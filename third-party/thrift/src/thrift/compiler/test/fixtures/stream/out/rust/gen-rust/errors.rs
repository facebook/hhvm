// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `PubSubStreamingService`.
pub mod pub_sub_streaming_service {

    pub trait AsFooEx {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx>;
    }

    impl AsFooEx for ::anyhow::Error {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(ServicethrowsError::e(e)) = cause.downcast_ref::<ServicethrowsError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(Servicethrows2Error::e1(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(BoththrowsError::e(e)) = cause.downcast_ref::<BoththrowsError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(ResponseandstreamservicethrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamservicethrowsError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(ResponseandstreamboththrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamboththrowsError>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub trait AsFooEx2 {
        fn as_foo_ex2(&self) -> ::std::option::Option<&crate::types::FooEx2>;
    }

    impl AsFooEx2 for ::anyhow::Error {
        fn as_foo_ex2(&self) -> ::std::option::Option<&crate::types::FooEx2> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(Servicethrows2Error::e2(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub trait AsFooStreamEx {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx>;
    }

    impl AsFooStreamEx for ::anyhow::Error {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(StreamthrowsStreamError::e(e)) = cause.downcast_ref::<StreamthrowsStreamError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(BoththrowsStreamError::e(e)) = cause.downcast_ref::<BoththrowsStreamError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(ResponseandstreamstreamthrowsStreamError::e(e)) = cause.downcast_ref::<ResponseandstreamstreamthrowsStreamError>() {
                    return ::std::option::Option::Some(e);
                }
                if let ::std::option::Option::Some(ResponseandstreamboththrowsStreamError::e(e)) = cause.downcast_ref::<ResponseandstreamboththrowsStreamError>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub type ReturnstreamError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum ReturnstreamReader {}

    impl ::fbthrift::help::DeserializeExn for ReturnstreamReader {
        type Success = ();
        type Error = ReturnstreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ReturnstreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type ReturnstreamStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum ReturnstreamStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ReturnstreamStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ReturnstreamStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ReturnstreamStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ReturnstreamStreamError"),
                )
                .into(),
            )
        }
    }

    pub type StreamthrowsError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum StreamthrowsReader {}

    impl ::fbthrift::help::DeserializeExn for StreamthrowsReader {
        type Success = ();
        type Error = StreamthrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamthrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    #[derive(Debug)]
    pub enum StreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for StreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::streamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::streamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for StreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for StreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooStreamEx for StreamthrowsStreamError {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for StreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for StreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsStreamExn> for StreamthrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::ApplicationException(aexn) =>
                    StreamthrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::e(exn) =>
                    StreamthrowsStreamError::e(exn),
            }
        }
    }

    pub(crate) enum StreamthrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for StreamthrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = StreamthrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "StreamthrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "StreamthrowsStreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for servicethrows (client side).
    #[derive(Debug)]
    pub enum ServicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ServicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ServicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ServicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ServicethrowsError {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ServicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ServicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsExn> for ServicethrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(aexn) =>
                    ServicethrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ServicethrowsExn::e(exn) =>
                    ServicethrowsError::e(exn),
            }
        }
    }

    impl ::std::convert::From<ServicethrowsError> for crate::services::pub_sub_streaming_service::ServicethrowsExn {
        fn from(err: ServicethrowsError) -> Self {
            match err {
                ServicethrowsError::e(err) => crate::services::pub_sub_streaming_service::ServicethrowsExn::e(err),
                ServicethrowsError::ApplicationException(aexn) => crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(aexn),
                ServicethrowsError::ThriftError(err) => crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum ServicethrowsReader {}

    impl ::fbthrift::help::DeserializeExn for ServicethrowsReader {
        type Success = ();
        type Error = ServicethrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ServicethrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type ServicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum ServicethrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ServicethrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ServicethrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ServicethrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ServicethrowsStreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for servicethrows2 (client side).
    #[derive(Debug)]
    pub enum Servicethrows2Error {
        e1(crate::types::FooEx),
        e2(crate::types::FooEx2),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for Servicethrows2Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e1(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e1`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e1(FooEx)")?;
                    }
                }
                Self::e2(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e2`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e2(FooEx2)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for Servicethrows2Error {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e1(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::e2(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for Servicethrows2Error {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e1(e)
        }
    }

    impl AsFooEx for Servicethrows2Error {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            match self {
                Self::e1(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx2> for Servicethrows2Error {
        fn from(e: crate::types::FooEx2) -> Self {
            Self::e2(e)
        }
    }

    impl AsFooEx2 for Servicethrows2Error {
        fn as_foo_ex2(&self) -> ::std::option::Option<&crate::types::FooEx2> {
            match self {
                Self::e2(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for Servicethrows2Error {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for Servicethrows2Error {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2Exn> for Servicethrows2Error {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2Exn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(aexn) =>
                    Servicethrows2Error::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e1(exn) =>
                    Servicethrows2Error::e1(exn),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e2(exn) =>
                    Servicethrows2Error::e2(exn),
            }
        }
    }

    impl ::std::convert::From<Servicethrows2Error> for crate::services::pub_sub_streaming_service::Servicethrows2Exn {
        fn from(err: Servicethrows2Error) -> Self {
            match err {
                Servicethrows2Error::e1(err) => crate::services::pub_sub_streaming_service::Servicethrows2Exn::e1(err),
                Servicethrows2Error::e2(err) => crate::services::pub_sub_streaming_service::Servicethrows2Exn::e2(err),
                Servicethrows2Error::ApplicationException(aexn) => crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(aexn),
                Servicethrows2Error::ThriftError(err) => crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum Servicethrows2Reader {}

    impl ::fbthrift::help::DeserializeExn for Servicethrows2Reader {
        type Success = ();
        type Error = Servicethrows2Error;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e1", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("e2", ::fbthrift::TType::Struct, 2),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::result::Result::Err(Self::Error::e1(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 2), false) => {
                        once = true;
                        alt = ::std::result::Result::Err(Self::Error::e2(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "Servicethrows2Error",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type Servicethrows2StreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum Servicethrows2StreamReader {}

    impl ::fbthrift::help::DeserializeExn for Servicethrows2StreamReader {
        type Success = ::std::primitive::i32;
        type Error = Servicethrows2StreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e1", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("e2", ::fbthrift::TType::Struct, 2),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "Servicethrows2StreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "Servicethrows2StreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for boththrows (client side).
    #[derive(Debug)]
    pub enum BoththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for BoththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for BoththrowsError {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsExn> for BoththrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(aexn) =>
                    BoththrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::BoththrowsExn::e(exn) =>
                    BoththrowsError::e(exn),
            }
        }
    }

    impl ::std::convert::From<BoththrowsError> for crate::services::pub_sub_streaming_service::BoththrowsExn {
        fn from(err: BoththrowsError) -> Self {
            match err {
                BoththrowsError::e(err) => crate::services::pub_sub_streaming_service::BoththrowsExn::e(err),
                BoththrowsError::ApplicationException(aexn) => crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(aexn),
                BoththrowsError::ThriftError(err) => crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum BoththrowsReader {}

    impl ::fbthrift::help::DeserializeExn for BoththrowsReader {
        type Success = ();
        type Error = BoththrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BoththrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    #[derive(Debug)]
    pub enum BoththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for BoththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooStreamEx for BoththrowsStreamError {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsStreamExn> for BoththrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::ApplicationException(aexn) =>
                    BoththrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::e(exn) =>
                    BoththrowsStreamError::e(exn),
            }
        }
    }

    pub(crate) enum BoththrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for BoththrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = BoththrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "BoththrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "BoththrowsStreamError"),
                )
                .into(),
            )
        }
    }

    pub type ResponseandstreamstreamthrowsError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum ResponseandstreamstreamthrowsReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamstreamthrowsReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamstreamthrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamstreamthrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamstreamthrowsError"),
                )
                .into(),
            )
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamstreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamstreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamstreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamstreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooStreamEx for ResponseandstreamstreamthrowsStreamError {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamstreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamstreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn> for ResponseandstreamstreamthrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::ApplicationException(aexn) =>
                    ResponseandstreamstreamthrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::e(exn) =>
                    ResponseandstreamstreamthrowsStreamError::e(exn),
            }
        }
    }

    pub(crate) enum ResponseandstreamstreamthrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamstreamthrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamstreamthrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamstreamthrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamstreamthrowsStreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for responseandstreamservicethrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamservicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamservicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamservicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamservicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamservicethrowsError {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamservicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamservicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> for ResponseandstreamservicethrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(aexn) =>
                    ResponseandstreamservicethrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::e(exn) =>
                    ResponseandstreamservicethrowsError::e(exn),
            }
        }
    }

    impl ::std::convert::From<ResponseandstreamservicethrowsError> for crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn {
        fn from(err: ResponseandstreamservicethrowsError) -> Self {
            match err {
                ResponseandstreamservicethrowsError::e(err) => crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::e(err),
                ResponseandstreamservicethrowsError::ApplicationException(aexn) => crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(aexn),
                ResponseandstreamservicethrowsError::ThriftError(err) => crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum ResponseandstreamservicethrowsReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamservicethrowsReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamservicethrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamservicethrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamservicethrowsError"),
                )
                .into(),
            )
        }
    }

    pub type ResponseandstreamservicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum ResponseandstreamservicethrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamservicethrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamservicethrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamservicethrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamservicethrowsStreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for responseandstreamboththrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamboththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamboththrowsError {
        fn as_foo_ex(&self) -> ::std::option::Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> for ResponseandstreamboththrowsError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(aexn) =>
                    ResponseandstreamboththrowsError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::e(exn) =>
                    ResponseandstreamboththrowsError::e(exn),
            }
        }
    }

    impl ::std::convert::From<ResponseandstreamboththrowsError> for crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn {
        fn from(err: ResponseandstreamboththrowsError) -> Self {
            match err {
                ResponseandstreamboththrowsError::e(err) => crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::e(err),
                ResponseandstreamboththrowsError::ApplicationException(aexn) => crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(aexn),
                ResponseandstreamboththrowsError::ThriftError(err) => crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum ResponseandstreamboththrowsReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamboththrowsReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamboththrowsError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamboththrowsError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamboththrowsError"),
                )
                .into(),
            )
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamboththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooStreamEx for ResponseandstreamboththrowsStreamError {
        fn as_foo_stream_ex(&self) -> ::std::option::Option<&crate::types::FooStreamEx> {
            match self {
                Self::e(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn> for ResponseandstreamboththrowsStreamError {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::ApplicationException(aexn) =>
                    ResponseandstreamboththrowsStreamError::ApplicationException(aexn),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::e(exn) =>
                    ResponseandstreamboththrowsStreamError::e(exn),
            }
        }
    }

    pub(crate) enum ResponseandstreamboththrowsStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseandstreamboththrowsStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ResponseandstreamboththrowsStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("e", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::e(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseandstreamboththrowsStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseandstreamboththrowsStreamError"),
                )
                .into(),
            )
        }
    }

    pub type ReturnstreamFastError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum ReturnstreamFastReader {}

    impl ::fbthrift::help::DeserializeExn for ReturnstreamFastReader {
        type Success = ();
        type Error = ReturnstreamFastError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?);
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ReturnstreamFastError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    pub type ReturnstreamFastStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum ReturnstreamFastStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ReturnstreamFastStreamReader {
        type Success = ::std::primitive::i32;
        type Error = ReturnstreamFastStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I32, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ReturnstreamFastStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ReturnstreamFastStreamError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::pub_sub_streaming_service::*;

