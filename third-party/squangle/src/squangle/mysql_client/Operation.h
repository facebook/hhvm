/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

//
// Operation objects are the handles users of AsyncMysqlClient use to
// interact with connections and queries.  Every action a user
// initiates returns an Operation to track the status of the action,
// report errors, etc.  Operations also offer a way to set callbacks
// for completion.
//
// In general, operations are held in shared_ptr's as ownership is
// unclear.  This allows the construction of Operations, callbacks to
// be set, and the Operation itself be cleaned up by AsyncMysqlClient.
// Conversely, if callbacks aren't being used, the Operation can
// simply be wait()'d upon for completion.
//
// See README for examples.
//
// Implementation detail; Operations straddle the caller's thread and
// the thread managed by the AsyncMysqlClient.  They also are
// responsible for execution of the actual libmysqlclient functions
// and most interactions with libevent.
//
// As mentioned above, an Operation's lifetime is determined by both
// AsyncMysqlClient and the calling point that created an Operation.
// It is permissible to immediately discard an Operation or to hold
// onto it (via a shared_ptr).  However, all calls to methods such as
// result() etc must occur either in the callback or after wait() has
// returned.

#pragma once

#include <folly/Function.h>
#include <folly/concurrency/AtomicSharedPtr.h>
#include <folly/futures/Future.h>
#include <folly/stop_watch.h>
#include <functional>
#include <memory>
#include <string>
#include <variant>

#include "squangle/logger/DBEventCounter.h"
#include "squangle/logger/DBEventLogger.h"
#include "squangle/mysql_client/DbResult.h"
#include "squangle/mysql_client/Flags.h"

namespace facebook::common::mysql_client {

class MysqlClientBase;
class ConnectOperation;
template <typename Client>
class ConnectionPool;
class QueryOperation;
class Operation;

enum class QueryCallbackReason;

// Simplify some std::chrono types.
using Clock = std::chrono::steady_clock;
using Timepoint = std::chrono::time_point<Clock>;

// Callbacks for connecting and querying, respectively.  A
// ConnectCallback is invoked when a connection succeeds or fails.  A
// QueryCallback is called for each row block (see Row.h) as well as
// when the query completes (either successfully or with an error).
using ConnectCallback = std::function<void(ConnectOperation&)>;
// Callback for observer. I will be called for a completed operation,
// after the callback for the specific operation is called, if one is defined.
using ObserverCallback = std::function<void(Operation&)>;
// Callback that is set on the ConnectOperation, and is then chained along all
// subsequent queries on that given connection.
using ChainedCallback = folly::Function<void(Operation&)>;
// Variant type allowing AsyncPostQueryCallback (below) to operate on either a
// Query or MultiQuery result.
using AsyncPostQueryResult = std::variant<DbQueryResult, DbMultiQueryResult>;
// Callbacks that are set on the ConnectOperation, and are then chained along
// all subsequent queries on that given connection. They execute asynchronously
// before/after query operations (if the async query APIs are used), and allow
// modification of the operation before or processing of results after a query.
using AsyncPreQueryCallback =
    std::function<folly::SemiFuture<folly::Unit>(FetchOperation&)>;
using AsyncPostQueryCallback =
    std::function<folly::SemiFuture<AsyncPostQueryResult>(
        AsyncPostQueryResult&&)>;

enum class SquangleErrno : uint16_t {
  SQ_ERRNO_CONN_TIMEOUT = 7000,
  SQ_ERRNO_CONN_TIMEOUT_LOOP_STALLED = 7001,
  SQ_ERRNO_QUERY_TIMEOUT = 7002,
  SQ_ERRNO_QUERY_TIMEOUT_LOOP_STALLED = 7003,
  SQ_ERRNO_POOL_CONN_TIMEOUT = 7004,
  SQ_ERRNO_FAILED_CONFIG_INIT = 7005,
  SQ_INVALID_API_USAGE = 7006,
  SQ_INITIALIZATION_FAILED = 7007,
  SQ_INVALID_CONN = 7008,
};

// prefix to use in mysql errors generated by the client
constexpr auto kErrorPrefix = "MySQL Client";

// The state of the Operation.  In general, callers will see Unstarted
// (i.e., haven't yet called run()) or Completed (which may mean
// success or error; see OperationResult below).  Pending and
// Cancelling are not visible at times an outside caller might see
// them (since, once run() has been called, wait() must be called
// before inspecting other Operation attributes).
enum class OperationState {
  Unstarted,
  Pending,
  Cancelling,
  Completed,
};

// overload of operator<< for OperationState
std::ostream& operator<<(std::ostream& os, OperationState state);

// Once an operation is Completed, it has a result type, indicating
// what ultimately occurred.  These are self-explanatory.
enum class OperationResult {
  Unknown,
  Succeeded,
  Failed,
  Cancelled,
  TimedOut,
};

// overload of operator<< for OperationResult
std::ostream& operator<<(std::ostream& os, OperationResult result);

db::FailureReason operationResultToFailureReason(OperationResult result);

enum class StreamState { InitQuery, RowsReady, QueryEnded, Failure, Success };

// overload of operator<< for StreamState
std::ostream& operator<<(std::ostream& os, StreamState state);

class OperationBase {
 public:
  virtual ~OperationBase() = default;

  // No default constructor or copy constructor/assignment operators
  OperationBase() = delete;
  explicit OperationBase(const Operation&) = delete;
  OperationBase& operator=(const Operation&) = delete;

  void run();

  // Try to cancel a pending operation.  This is inherently racey with
  // callbacks; it is possible the callback is being invoked *during*
  // the cancel attempt, so a cancelled operation may still succeed.
  virtual void cancel();

  // Did the operation succeed?
  bool ok() const {
    return done() && result() == OperationResult::Succeeded;
  }

  // Is the operation complete (success or failure)?
  bool done() const {
    return state() == OperationState::Completed;
  }

  // Information about why this operation failed.
  unsigned int mysql_errno() const;
  const std::string& mysql_error() const;

  OperationResult result() const {
    return result_;
  }

  OperationState state() const {
    return state_;
  }

  void setObserverCallback(ObserverCallback obs_cb);

  /**
   * Set callbacks that are invoked asynchronously before/after query operations
   * (if using asynchronous query APIs). They do not execute on operations that
   * have failed, and if they fail the operation will fail too.
   *
   * PreQueryCallbacks execute after a query operation is initialized and before
   * it has been run. They are allowed to modify the operation by reference.
   *
   * PostQueryCallbacks execute after a query operation returns results. They
   * are allowed to do post-processing on the results received and returned via
   * rvalue reference.
   */
  void setPreQueryCallback(AsyncPreQueryCallback&& callback);
  void setPostQueryCallback(AsyncPostQueryCallback&& callback);

  void setAttributes(const AttributeMap& attributes);
  void setAttributes(AttributeMap&& attributes);
  void setAttribute(const std::string& key, const std::string& value);

  const AttributeMap& getAttributes() const {
    return attributes_;
  }

  // Set a timeout; otherwise FLAGS_async_mysql_timeout_micros is
  // used.
  void setTimeout(Duration timeout);

  Duration getTimeout() const {
    return timeout_;
  }

  Millis getTimeoutMs() const {
    return std::chrono::duration_cast<Millis>(timeout_);
  }

  void setConnectionContext(
      std::shared_ptr<db::ConnectionContextBase> context) {
    CHECK_THROW(
        state_ == OperationState::Unstarted, db::OperationStateException);
    connection_context_ = std::move(context);
  }

  // Set's the connection context into the connection.  Needed here because
  // derived classes don't have access to the connection's
  // setConnectionContext()
  void setConnConnectionContext(
      std::shared_ptr<db::ConnectionContextBase> context);

  // Access to connection context
  std::shared_ptr<db::ConnectionContextBase> copyConnectionContextPtr() {
    return connection_context_;
  }
  db::ConnectionContextBase* getConnectionContext() const {
    return connection_context_.get();
  }
  void withOptionalConnectionContext(
      const std::function<void(db::ConnectionContextBase&)>& func) const {
    if (connection_context_) {
      func(*connection_context_);
    }
  }

  // Connections are transferred across operations.  At any one time,
  // there is one unique owner of the connection.
  std::unique_ptr<Connection> releaseConnection();
  const Connection* connection() const {
    return conn_proxy_->get();
  }
  Connection* connection() {
    return conn_proxy_->get();
  }

  /*
   * Various accessors for our Operation's start, end, and total elapsed time.
   */

  // Start time of the operation (doesn't need to have completed)
  Timepoint startTime() const {
    return stopwatch_->getCheckpoint();
  }
  // End time of the operation (must have completed)
  Timepoint endTime() const {
    CHECK_THROW(
        state() == OperationState::Completed, db::OperationStateException);
    return startTime() + duration_;
  }
  // Current stored time elapsed
  Duration elapsed() const {
    return duration_;
  }

  // Current time elapsed
  Duration opElapsed() const {
    return stopwatch_->elapsed();
  }
  // Current time elapsed in milliseconds
  Millis opElapsedMs() const {
    return std::chrono::duration_cast<Millis>(opElapsed());
  }
  // Has a particular time period elapsed
  bool hasOpElapsed(Duration timeperiod) const {
    return stopwatch_->elapsed(timeperiod);
  }

  /**
   * Set various callbacks that are invoked during the operation's lifetime
   * The pre and post operations are chained, in that they are propagated to
   * operations that are scheduled on the connection following the current
   * operation. A couple notes:
   *
   * The PreOperationCallback will be invoked on a cancelled operation before
   * the cancellation takes effect
   *
   * The PostOperationCallback will be invoked on operations that have failed
   */
  void setPreOperationCallback(ChainedCallback obs_cb);
  void setPostOperationCallback(ChainedCallback obs_cb);

  Operation& getOp() const {
    return *op_;
  }
  void setOperation(Operation& op) {
    op_ = &op;
  }

  class ConnectionProxy {
   public:
    virtual ~ConnectionProxy() = default;

    virtual Connection* get() = 0;
    virtual const Connection* get() const = 0;
    virtual std::unique_ptr<Connection> releaseConnection() {
      return nullptr;
    }
  };

 protected:
  friend class Operation;

  explicit OperationBase(std::unique_ptr<ConnectionProxy> safe_conn);

  // An owned connection is one where the operation fully owns the connection.
  // This occurs when a query is started via a semi-future and the connection is
  // moved in - for example:
  //   client->querySemiFuture(std::move(conn), "SELECT 1");
  // Since the connection is a unique_ptr, moving it in this way means that we
  // have full control over it.
  class OwnedConnection : public ConnectionProxy {
   public:
    explicit OwnedConnection(std::unique_ptr<Connection>&& conn);

    Connection* get() override;
    const Connection* get() const override;
    std::unique_ptr<Connection> releaseConnection() override;

   private:
    std::unique_ptr<Connection> conn_;
  };

  // A referenced connection is one where the operation can only have a
  // reference to the connection. This occurs when a query is started via the
  // connection itself and the query function doesn't return control back until
  // the query is complete - for example:
  //   conn->query("SELECT 1");
  // In this case the connection is still owned by the caller so the most we can
  // have is a reference to it.
  class ReferencedConnection : public ConnectionProxy {
   public:
    explicit ReferencedConnection(Connection& conn) : conn_(conn) {}

    Connection* get() override {
      return &conn_;
    }
    const Connection* get() const override {
      return &conn_;
    }

   private:
    Connection& conn_;
  };

  void setState(OperationState state) {
    state_ = state;
  }
  void setResult(OperationResult result) {
    result_ = result;
  }
  void setDuration() {
    duration_ = opElapsed();
  }

  void setTimeoutInternal(Duration timeout) {
    timeout_ = timeout;
  }

  folly::RequestContextScopeGuard makeRequestGuard() {
    return folly::RequestContextScopeGuard(
        request_context_.load(std::memory_order_relaxed));
  }

  // Helper function to set chained callbacks
  ChainedCallback setCallback(
      ChainedCallback orgCallback,
      ChainedCallback newCallback);

  MysqlClientBase& client_;

  // Our Connection object.  Created by ConnectOperation and moved
  // into QueryOperations.
  std::unique_ptr<ConnectionProxy> conn_proxy_;

  struct Callbacks {
    Callbacks()
        : pre_operation_callback_(nullptr),
          post_operation_callback_(nullptr),
          pre_query_callback_(nullptr),
          post_query_callback_(nullptr) {}

    ChainedCallback pre_operation_callback_;
    ChainedCallback post_operation_callback_;

    AsyncPreQueryCallback pre_query_callback_;
    AsyncPostQueryCallback post_query_callback_;
  };

  Callbacks callbacks_;

  std::optional<folly::SemiFuture<folly::Unit>> callPreQueryCallback(
      FetchOperation& op) const;
  DbQueryResult callPostQueryCallback(DbQueryResult result) const;
  DbMultiQueryResult callPostQueryCallback(DbMultiQueryResult result) const;
  AsyncPostQueryCallback stealPostQueryCallback();

  Operation* op_;

  virtual void specializedRun() = 0;
  virtual void protocolCompleteOperation(OperationResult result) = 0;

 protected:
  // Helper functions to set query callbacks
  static AsyncPreQueryCallback appendCallback(
      AsyncPreQueryCallback&& callback1,
      AsyncPreQueryCallback&& callback2);

  static AsyncPostQueryCallback appendCallback(
      AsyncPostQueryCallback&& callback1,
      AsyncPostQueryCallback&& callback2);

  Connection& conn() {
    auto* conn = connection();
    CHECK(conn);
    return *conn;
  }
  const Connection& conn() const {
    auto* conn = connection();
    CHECK(conn);
    return *conn;
  }

  [[nodiscard]] const InternalConnection& getInternalConnection() const;
  [[nodiscard]] InternalConnection& getInternalConnection();

  void deferRemoveOperation(Operation* op) const;

  virtual void timeoutTriggered() = 0;

  ObserverCallback observer_callback_;

  std::shared_ptr<db::ConnectionContextBase> connection_context_;

 private:
  friend class Connection;
  friend class SyncConnection;

  // Data members; subclasses freely interact with these.
  OperationState state_{OperationState::Unstarted};
  OperationResult result_{OperationResult::Unknown};

  // Connection or query attributes (depending on the Operation type)
  AttributeMap attributes_;

  // timeout specified for this operation
  Duration timeout_;

  using StopWatch = folly::stop_watch<Duration>;
  std::unique_ptr<StopWatch> stopwatch_;
  Duration duration_ = Duration();

  // The cancel() and run() commands both check the current value of state_ and
  // then change it.  The synchronized state on `cancel_on_run_` is used to
  // protect this check and then set code.  This is not an ideal solution, but
  // we don't really need to synchronize state_ anywhere else, so putting it in
  // a Synchronized<> object is overkill.
  folly::Synchronized<bool> cancel_on_run_{false};

  folly::atomic_shared_ptr<folly::RequestContext> request_context_;

  friend class MysqlClientBase;
};

//  Public facing Operation API
class Operation : public std::enable_shared_from_this<Operation> {
 public:
  virtual ~Operation() = default;

  // Wait for an operation to complete.  Throw a
  // RequiredOperationFailedException if it fails. Mainly for testing.
  virtual void mustSucceed() = 0;

  virtual db::OperationType getOperationType() const = 0;

  // Did the operation succeed?
  bool ok() const;

  // Is the operation complete (success or failure)?
  bool done() const;

  OperationResult result() const;

  OperationState state() const;

  Operation& run();
  void cancel() {
    impl()->cancel();
  }

  // Wait for the Operation to complete.
  void wait() const;

  Operation& setTimeout(Duration timeout);

  Operation& setAttributes(const AttributeMap& attributes);
  Operation& setAttributes(AttributeMap&& attributes);
  Operation& setAttribute(const std::string& key, const std::string& value);

  unsigned int mysql_errno() const {
    return mysql_errno_;
  }
  const std::string& mysql_error() const {
    return mysql_error_;
  }

  Duration elapsed() const {
    return impl()->elapsed();
  }

  // Current time elapsed
  Duration opElapsed() const {
    return impl()->opElapsed();
  }
  // Current time elapsed in milliseconds
  Millis opElapsedMs() const {
    return impl()->opElapsedMs();
  }
  // Has a particular time period elapsed
  bool hasOpElapsed(Duration timeperiod) const {
    return impl()->hasOpElapsed(timeperiod);
  }

  const Connection* connection() const {
    return impl()->connection();
  }
  Connection* connection() {
    return impl()->connection();
  }
  std::unique_ptr<Connection> releaseConnection();

  void setObserverCallback(ObserverCallback obs_cb) {
    impl()->setObserverCallback(std::move(obs_cb));
  }

  void setPreOperationCallback(ChainedCallback obs_cb) {
    impl()->setPreOperationCallback(std::move(obs_cb));
  }
  void setPostOperationCallback(ChainedCallback obs_cb) {
    impl()->setPostOperationCallback(std::move(obs_cb));
  }

  /**
   * Set callbacks that are invoked asynchronously before/after query operations
   * (if using asynchronous query APIs). They do not execute on operations that
   * have failed, and if they fail the operation will fail too.
   *
   * PreQueryCallbacks execute after a query operation is initialized and before
   * it has been run. They are allowed to modify the operation by reference.
   *
   * PostQueryCallbacks execute after a query operation returns results. They
   * are allowed to do post-processing on the results received and returned via
   * rvalue reference.
   */
  void setPreQueryCallback(AsyncPreQueryCallback&& callback) {
    impl()->setPreQueryCallback(std::move(callback));
  }
  void setPostQueryCallback(AsyncPostQueryCallback&& callback) {
    impl()->setPostQueryCallback(std::move(callback));
  }

  // Save any mysql errors that occurred (since we may hand off the
  // Connection before the user wants this information).
  void snapshotMysqlErrors(unsigned int errnum, std::string error);

  // Same as above, but specify the error code.
  void setAsyncClientError(unsigned int mysql_errno, folly::StringPiece msg);

  // Retrieve the shared pointer that holds this instance.
  std::shared_ptr<Operation> getSharedPointer();

  std::optional<folly::SemiFuture<folly::Unit>> callPreQueryCallback(
      FetchOperation& op) const {
    return impl()->callPreQueryCallback(op);
  }

  AsyncPostQueryCallback stealPostQueryCallback() {
    return impl()->stealPostQueryCallback();
  }

  folly::StringPiece resultString() const;
  folly::StringPiece stateString() const;

  const AttributeMap& getAttributes() const {
    return impl()->getAttributes();
  }

  void setConnectionContext(
      std::shared_ptr<db::ConnectionContextBase> context) {
    impl()->setConnectionContext(std::move(context));
  }

  std::shared_ptr<db::ConnectionContextBase> copyConnectionContextPtr() {
    return impl()->copyConnectionContextPtr();
  }

  db::ConnectionContextBase* getConnectionContext() const {
    return impl()->getConnectionContext();
  }

  Timepoint startTime() const {
    return impl()->startTime();
  }
  // End time of the operation (must have completed)
  Timepoint endTime() const {
    return impl()->endTime();
  }

  virtual void reportServerCertContent(
      const std::string& /*sslCertCn*/,
      const std::vector<std::string>& /*sslCertSan*/,
      const std::vector<std::string>& /*sslCertIdentities*/,
      bool /*isValidated*/) const {}

  static folly::StringPiece toString(OperationState state);
  static folly::StringPiece toString(OperationResult result);
  static folly::StringPiece toString(StreamState state);

 protected:
  Operation() : mysql_errno_(0) {}

  virtual OperationBase* impl() = 0;
  virtual const OperationBase* impl() const = 0;

  const Connection& conn() const {
    return impl()->conn();
  }
  Connection& conn() {
    return impl()->conn();
  }

  DbQueryResult callPostQueryCallback(DbQueryResult result) const {
    return impl()->callPostQueryCallback(std::move(result));
  }
  DbMultiQueryResult callPostQueryCallback(DbMultiQueryResult result) const {
    return impl()->callPostQueryCallback(std::move(result));
  }

  void timeoutTriggered() {
    impl()->timeoutTriggered();
  }

 private:
  // Errors that may have occurred.
  unsigned int mysql_errno_;
  std::string mysql_error_;

  friend class SyncConnectionPool;
};

// Helper function to build the result for a ConnectOperation in the sync
// mode. It will block the thread and return the acquired connection, in case
// of error, it will throw MysqlException as expected in the sync mode.
std::unique_ptr<Connection> blockingConnectHelper(ConnectOperation& conn_op);

} // namespace facebook::common::mysql_client
