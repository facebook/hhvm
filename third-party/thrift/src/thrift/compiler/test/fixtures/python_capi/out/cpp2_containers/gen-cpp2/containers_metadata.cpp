/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/python_capi/src/containers.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_metadata.h"
#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_data.h"

// some of these functions can be so large that the compiler gives up optimizing
// them - and issues a warning which may be treated as an error!
//
// these functions are so rarely called that it is probably okay for them not to
// be optimized in practice
FOLLY_CLANG_DISABLE_WARNING("-Wignored-optimization-argument")

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&, std::size_t);


const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateLists>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::TemplateLists>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateLists = res.metadata;
  DCHECK_EQ(*containers_TemplateLists.is_union(), false);
  static const auto* const
  containers_TemplateLists_fields = new std::array<EncodedThriftField, 5>{ {
    { 1, "std_string", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::vector") } }).cv_struct(), }},    { 2, "deque_string", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::deque") } }).cv_struct(), }},    { 3, "small_vector_iobuf", false, std::make_unique<Typedef>("containers.small_vector_iobuf", std::make_unique<List>(std::make_unique<Typedef>("containers.IOBuf", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"name", cvString("folly::IOBuf") } }).cv_struct(),  })), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"template", cvString("folly::small_vector") } }).cv_struct(),  }), std::vector<ThriftConstStruct>{ }},    { 4, "nested_small_vector", false, std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_string", std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct(),  })), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::small_vector") } }).cv_struct(), }},    { 5, "small_vector_tensor", false, std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_fbvector_string", std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_string", std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct(),  })), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct(),  })), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct(), }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_TemplateLists_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::TemplateLists>(containers_TemplateLists.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_TemplateLists.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::TemplateLists>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateSets>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::TemplateSets>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateSets = res.metadata;
  DCHECK_EQ(*containers_TemplateSets.is_union(), false);
  static const auto* const
  containers_TemplateSets_fields = new std::array<EncodedThriftField, 7>{ {
    { 1, "std_set", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::set") } }).cv_struct(), }},    { 2, "std_unordered", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::unordered_set") } }).cv_struct(), }},    { 3, "folly_fast", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14FastSet") } }).cv_struct(), }},    { 4, "folly_node", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14NodeSet") } }).cv_struct(), }},    { 5, "folly_value", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14ValueSet") } }).cv_struct(), }},    { 6, "folly_vector", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14VectorSet") } }).cv_struct(), }},    { 7, "folly_sorted_vector", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::sorted_vector_set") } }).cv_struct(), }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_TemplateSets_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::TemplateSets>(containers_TemplateSets.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_TemplateSets.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  containers_TemplateSets.structured_annotations()->push_back(*cvStruct("cpp.EnableCustomTypeOrdering", {  }).cv_struct());
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::TemplateSets>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateMaps>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::TemplateMaps>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateMaps = res.metadata;
  DCHECK_EQ(*containers_TemplateMaps.is_union(), false);
  static const auto* const
  containers_TemplateMaps_fields = new std::array<EncodedThriftField, 7>{ {
    { 1, "std_map", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::map") } }).cv_struct(), }},    { 2, "std_unordered", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::unordered_map") } }).cv_struct(), }},    { 3, "folly_fast", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14FastMap") } }).cv_struct(), }},    { 4, "folly_node", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14NodeMap") } }).cv_struct(), }},    { 5, "folly_value", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14ValueMap") } }).cv_struct(), }},    { 6, "folly_vector", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14VectorMap") } }).cv_struct(), }},    { 7, "folly_sorted_vector", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::sorted_vector_map") } }).cv_struct(), }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_TemplateMaps_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::TemplateMaps>(containers_TemplateMaps.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_TemplateMaps.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  containers_TemplateMaps.structured_annotations()->push_back(*cvStruct("cpp.EnableCustomTypeOrdering", {  }).cv_struct());
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::TemplateMaps>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TWrapped>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::TWrapped>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TWrapped = res.metadata;
  DCHECK_EQ(*containers_TWrapped.is_union(), false);
  static const auto* const
  containers_TWrapped_fields = new std::array<EncodedThriftField, 2>{ {
    { 1, "fieldA", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{ }},    { 2, "fieldB", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_TWrapped_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::TWrapped>(containers_TWrapped.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_TWrapped.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::TWrapped>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionA>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::IndirectionA>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionA = res.metadata;
  DCHECK_EQ(*containers_IndirectionA.is_union(), false);
  static const auto* const
  containers_IndirectionA_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.ListOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(),  }), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_IndirectionA_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::IndirectionA>(containers_IndirectionA.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_IndirectionA.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::IndirectionA>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionB>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::IndirectionB>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionB = res.metadata;
  DCHECK_EQ(*containers_IndirectionB.is_union(), false);
  static const auto* const
  containers_IndirectionB_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.VecOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(), *cvStruct("cpp.Type", { {"template", cvString("std::vector") } }).cv_struct(),  }), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_IndirectionB_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::IndirectionB>(containers_IndirectionB.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_IndirectionB.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::IndirectionB>()
  ));
  return res.metadata;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionC>::gen(ThriftMetadata& metadata) {
  auto res = genStructMetadata<::test::fixtures::python_capi::IndirectionC>(metadata, folly::kIsDebug);
  if (res.preExists) {
    return res.metadata;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionC = res.metadata;
  DCHECK_EQ(*containers_IndirectionC.is_union(), false);
  static const auto* const
  containers_IndirectionC_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.ListOfWrappedAlias", std::make_unique<Typedef>("containers.ListOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(),  }), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct(),  }), std::vector<ThriftConstStruct>{ }},  }};
  std::size_t i = 0;
  for (const auto& f : *containers_IndirectionC_fields) {
    genStructFieldMetadata<::test::fixtures::python_capi::IndirectionC>(containers_IndirectionC.fields()[i], f, i);

    // writeAndGenType will modify metadata, which might invalidate `field` reference
    // We need to store the result in a separate `type` variable.
    apache::thrift::metadata::ThriftType type;
    f.metadata_type_interface->writeAndGenType(type, metadata);
    containers_IndirectionC.fields()[i++].type() = std::move(type);
  }
  [[maybe_unused]] auto newAnnotations = std::move(*res.metadata.structured_annotations());
  res.metadata.structured_annotations()->clear();
  DCHECK(structuredAnnotationsEquality(
    *res.metadata.structured_annotations(),
    newAnnotations,
    getAnnotationTypes<::test::fixtures::python_capi::IndirectionC>()
  ));
  return res.metadata;
}

} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
