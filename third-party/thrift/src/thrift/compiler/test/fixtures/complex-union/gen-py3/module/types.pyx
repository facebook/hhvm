#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.optional cimport optional as __optional
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
from thrift.py3.types import _IsSet as _fbthrift_IsSet
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.std_libcpp cimport sv_to_str as __sv_to_str, string_view as __cstring_view
from thrift.py3.types cimport (
    cSetOp as __cSetOp,
    richcmp as __richcmp,
    set_op as __set_op,
    setcmp as __setcmp,
    list_index as __list_index,
    list_count as __list_count,
    list_slice as __list_slice,
    list_getitem as __list_getitem,
    set_iter as __set_iter,
    map_iter as __map_iter,
    map_contains as __map_contains,
    map_getitem as __map_getitem,
    reference_shared_ptr as __reference_shared_ptr,
    get_field_name_by_index as __get_field_name_by_index,
    reset_field as __reset_field,
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    const_pointer_cast,
    constant_shared_ptr,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.serializer as serializer
import folly.iobuf as _fbthrift_iobuf
from folly.optional cimport cOptional
from folly.memory cimport to_shared_ptr as __to_shared_ptr
from folly.range cimport Range as __cRange

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins

cimport module.types_reflection as _types_reflection



cdef __UnionTypeEnumData __ComplexUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cComplexUnion](),
    __ComplexUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ComplexUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __ComplexUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __ComplexUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __ComplexUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __ComplexUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __ComplexUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __ComplexUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __ComplexUnionType, <PyTypeObject*> __ComplexUnion_Union_TypeMeta)


cdef __UnionTypeEnumData __ListUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cListUnion](),
    __ListUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ListUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __ListUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __ListUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __ListUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __ListUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __ListUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __ListUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __ListUnionType, <PyTypeObject*> __ListUnion_Union_TypeMeta)


cdef __UnionTypeEnumData __DataUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cDataUnion](),
    __DataUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __DataUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __DataUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __DataUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __DataUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __DataUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __DataUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __DataUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __DataUnionType, <PyTypeObject*> __DataUnion_Union_TypeMeta)


cdef __UnionTypeEnumData __ValUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cValUnion](),
    __ValUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __ValUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __ValUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __ValUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __ValUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __ValUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __ValUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __ValUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __ValUnionType, <PyTypeObject*> __ValUnion_Union_TypeMeta)


cdef __UnionTypeEnumData __VirtualComplexUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cVirtualComplexUnion](),
    __VirtualComplexUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __VirtualComplexUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __VirtualComplexUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __VirtualComplexUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __VirtualComplexUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __VirtualComplexUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __VirtualComplexUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __VirtualComplexUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __VirtualComplexUnionType, <PyTypeObject*> __VirtualComplexUnion_Union_TypeMeta)


cdef __UnionTypeEnumData __NonCopyableUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cNonCopyableUnion](),
    __NonCopyableUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __NonCopyableUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __NonCopyableUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __NonCopyableUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __NonCopyableUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __NonCopyableUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __NonCopyableUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __NonCopyableUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __NonCopyableUnionType, <PyTypeObject*> __NonCopyableUnion_Union_TypeMeta)




@__cython.auto_pickle(False)
cdef class ComplexUnion(thrift.py3.types.Union):
    Type = __ComplexUnionType

    def __init__(
        self, *,
        intValue=None,
        str stringValue=None,
        intListValue=None,
        stringListValue=None,
        typedefValue=None,
        str stringRef=None
    ):
        if intValue is not None:
            if not isinstance(intValue, int):
                raise TypeError(f'intValue is not a { int !r}.')
            intValue = <cint64_t> intValue

        self._cpp_obj = __to_shared_ptr(cmove(ComplexUnion._make_instance(
          NULL,
          intValue,
          stringValue,
          intListValue,
          stringListValue,
          typedefValue,
          stringRef,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ComplexUnion()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <cint64_t> value
                    return ComplexUnion(intValue=value)
                except OverflowError:
                    pass
        if isinstance(value, str):
            return ComplexUnion(stringValue=value)
        if isinstance(value, List__i64):
            return ComplexUnion(intListValue=value)
        if isinstance(value, List__string):
            return ComplexUnion(stringListValue=value)
        if isinstance(value, Map__i16_string):
            return ComplexUnion(typedefValue=value)
        if isinstance(value, str):
            return ComplexUnion(stringRef=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cComplexUnion] _make_instance(
        cComplexUnion* base_instance,
        object intValue,
        str stringValue,
        object intListValue,
        object stringListValue,
        object typedefValue,
        str stringRef
    ) except *:
        cdef unique_ptr[cComplexUnion] c_inst = make_unique[cComplexUnion]()
        cdef bint any_set = False
        if intValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intValue(intValue)
            any_set = True
        if stringValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringValue(stringValue.encode('UTF-8'))
            any_set = True
        if intListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intListValue(<vector[cint64_t]>deref(List__i64(intListValue)._cpp_obj))
            any_set = True
        if stringListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringListValue(<vector[string]>deref(List__string(stringListValue)._cpp_obj))
            any_set = True
        if typedefValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_typedefValue(<cmap[cint16_t,string]>deref(Map__i16_string(typedefValue)._cpp_obj))
            any_set = True
        if stringRef is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringRef(string(deref((<str?>stringRef)._cpp_obj)))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cComplexUnion] cpp_obj):
        __fbthrift_inst = <ComplexUnion>ComplexUnion.__new__(ComplexUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def intValue(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not intValue')
        return self.value

    @property
    def stringValue(self):
        if self.type.value != 5:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not stringValue')
        return self.value

    @property
    def intListValue(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not intListValue')
        return self.value

    @property
    def stringListValue(self):
        if self.type.value != 3:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not stringListValue')
        return self.value

    @property
    def typedefValue(self):
        if self.type.value != 9:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not typedefValue')
        return self.value

    @property
    def stringRef(self):
        if self.type.value != 14:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not stringRef')
        return self.value


    def __hash__(ComplexUnion self):
        return  super().__hash__()

    cdef _load_cache(ComplexUnion self):
        self.type = ComplexUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = deref(self._cpp_obj).get_intValue()
        elif type == 5:
            self.value = bytes(deref(self._cpp_obj).get_stringValue()).decode('UTF-8')
        elif type == 2:
            self.value = List__i64._fbthrift_create(make_shared[vector[cint64_t]](deref(self._cpp_obj).get_intListValue()))
        elif type == 3:
            self.value = List__string._fbthrift_create(make_shared[vector[string]](deref(self._cpp_obj).get_stringListValue()))
        elif type == 9:
            self.value = Map__i16_string._fbthrift_create(make_shared[cmap[cint16_t,string]](deref(self._cpp_obj).get_typedefValue()))
        elif type == 14:
            if not deref(self._cpp_obj).get_stringRef():
                self.value = None
            else:
                self.value = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).get_stringRef()), self._cpp_obj))

    def __copy__(ComplexUnion self):
        cdef shared_ptr[cComplexUnion] cpp_obj = make_shared[cComplexUnion](
            deref(self._cpp_obj)
        )
        return ComplexUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cComplexUnion](
            self._cpp_obj,
            (<ComplexUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__ComplexUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cComplexUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.ComplexUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cComplexUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 6

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(ComplexUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cComplexUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(ComplexUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cComplexUnion]()
        with nogil:
            needed = serializer.cdeserialize[cComplexUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.ComplexUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.ComplexUnion, self)


@__cython.auto_pickle(False)
cdef class ListUnion(thrift.py3.types.Union):
    Type = __ListUnionType

    def __init__(
        self, *,
        intListValue=None,
        stringListValue=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(ListUnion._make_instance(
          NULL,
          intListValue,
          stringListValue,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ListUnion()
        if isinstance(value, List__i64):
            return ListUnion(intListValue=value)
        if isinstance(value, List__string):
            return ListUnion(stringListValue=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cListUnion] _make_instance(
        cListUnion* base_instance,
        object intListValue,
        object stringListValue
    ) except *:
        cdef unique_ptr[cListUnion] c_inst = make_unique[cListUnion]()
        cdef bint any_set = False
        if intListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_intListValue(<vector[cint64_t]>deref(List__i64(intListValue)._cpp_obj))
            any_set = True
        if stringListValue is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringListValue(<vector[string]>deref(List__string(stringListValue)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cListUnion] cpp_obj):
        __fbthrift_inst = <ListUnion>ListUnion.__new__(ListUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def intListValue(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not intListValue')
        return self.value

    @property
    def stringListValue(self):
        if self.type.value != 3:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not stringListValue')
        return self.value


    def __hash__(ListUnion self):
        return  super().__hash__()

    cdef _load_cache(ListUnion self):
        self.type = ListUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 2:
            self.value = List__i64._fbthrift_create(make_shared[vector[cint64_t]](deref(self._cpp_obj).get_intListValue()))
        elif type == 3:
            self.value = List__string._fbthrift_create(make_shared[vector[string]](deref(self._cpp_obj).get_stringListValue()))

    def __copy__(ListUnion self):
        cdef shared_ptr[cListUnion] cpp_obj = make_shared[cListUnion](
            deref(self._cpp_obj)
        )
        return ListUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cListUnion](
            self._cpp_obj,
            (<ListUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__ListUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cListUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.ListUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cListUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(ListUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cListUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(ListUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cListUnion]()
        with nogil:
            needed = serializer.cdeserialize[cListUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.ListUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.ListUnion, self)


@__cython.auto_pickle(False)
cdef class DataUnion(thrift.py3.types.Union):
    Type = __DataUnionType

    def __init__(
        self, *,
        bytes binaryData=None,
        str stringData=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(DataUnion._make_instance(
          NULL,
          binaryData,
          stringData,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return DataUnion()
        if isinstance(value, bytes):
            return DataUnion(binaryData=value)
        if isinstance(value, str):
            return DataUnion(stringData=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cDataUnion] _make_instance(
        cDataUnion* base_instance,
        bytes binaryData,
        str stringData
    ) except *:
        cdef unique_ptr[cDataUnion] c_inst = make_unique[cDataUnion]()
        cdef bint any_set = False
        if binaryData is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_binaryData(binaryData)
            any_set = True
        if stringData is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_stringData(stringData.encode('UTF-8'))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cDataUnion] cpp_obj):
        __fbthrift_inst = <DataUnion>DataUnion.__new__(DataUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def binaryData(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not binaryData')
        return self.value

    @property
    def stringData(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not stringData')
        return self.value


    def __hash__(DataUnion self):
        return  super().__hash__()

    cdef _load_cache(DataUnion self):
        self.type = DataUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = deref(self._cpp_obj).get_binaryData()
        elif type == 2:
            self.value = bytes(deref(self._cpp_obj).get_stringData()).decode('UTF-8')

    def __copy__(DataUnion self):
        cdef shared_ptr[cDataUnion] cpp_obj = make_shared[cDataUnion](
            deref(self._cpp_obj)
        )
        return DataUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cDataUnion](
            self._cpp_obj,
            (<DataUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__DataUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cDataUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.DataUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cDataUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(DataUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cDataUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(DataUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cDataUnion]()
        with nogil:
            needed = serializer.cdeserialize[cDataUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.DataUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.DataUnion, self)
@__cython.auto_pickle(False)
cdef class Val(thrift.py3.types.Struct):
    def __init__(Val self, **kwargs):
        self._cpp_obj = make_shared[cVal]()
        self._fields_setter = _fbthrift_types_fields.__Val_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(Val self, **kwargs):
        if not kwargs:
            return self
        cdef Val __fbthrift_inst = Val.__new__(Val)
        __fbthrift_inst._cpp_obj = make_shared[cVal](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__Val_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return _fbthrift_IsSet("Val", {
          "strVal": deref(self._cpp_obj).strVal_ref().has_value(),
          "intVal": deref(self._cpp_obj).intVal_ref().has_value(),
          "typedefValue": deref(self._cpp_obj).typedefValue_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cVal] cpp_obj):
        __fbthrift_inst = <Val>Val.__new__(Val)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline strVal_impl(self):

        return (<bytes>deref(self._cpp_obj).strVal_ref().value()).decode('UTF-8')

    @property
    def strVal(self):
        return self.strVal_impl()

    cdef inline intVal_impl(self):

        return deref(self._cpp_obj).intVal_ref().value()

    @property
    def intVal(self):
        return self.intVal_impl()

    cdef inline typedefValue_impl(self):

        if self.__fbthrift_cached_typedefValue is None:
            self.__fbthrift_cached_typedefValue = Map__i16_string._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).typedefValue_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_typedefValue

    @property
    def typedefValue(self):
        return self.typedefValue_impl()


    def __hash__(Val self):
        return super().__hash__()

    def __repr__(Val self):
        return super().__repr__()

    def __str__(Val self):
        return super().__str__()


    def __copy__(Val self):
        cdef shared_ptr[cVal] cpp_obj = make_shared[cVal](
            deref(self._cpp_obj)
        )
        return Val._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cVal](
            self._cpp_obj,
            (<Val>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Val()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cVal].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.Val"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cVal](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(Val self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cVal](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(Val self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cVal]()
        with nogil:
            needed = serializer.cdeserialize[cVal](buf, self._cpp_obj.get(), proto)
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.Val, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.Val, self)


@__cython.auto_pickle(False)
cdef class ValUnion(thrift.py3.types.Union):
    Type = __ValUnionType

    def __init__(
        self, *,
        Val v1=None,
        Val v2=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(ValUnion._make_instance(
          NULL,
          v1,
          v2,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return ValUnion()
        if isinstance(value, Val):
            return ValUnion(v1=value)
        if isinstance(value, Val):
            return ValUnion(v2=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cValUnion] _make_instance(
        cValUnion* base_instance,
        Val v1,
        Val v2
    ) except *:
        cdef unique_ptr[cValUnion] c_inst = make_unique[cValUnion]()
        cdef bint any_set = False
        if v1 is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_v1(deref((<Val?> v1)._cpp_obj))
            any_set = True
        if v2 is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_v2(deref((<Val?> v2)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cValUnion] cpp_obj):
        __fbthrift_inst = <ValUnion>ValUnion.__new__(ValUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def v1(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not v1')
        return self.value

    @property
    def v2(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not v2')
        return self.value


    def __hash__(ValUnion self):
        return  super().__hash__()

    cdef _load_cache(ValUnion self):
        self.type = ValUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = Val._fbthrift_create(make_shared[cVal](deref(self._cpp_obj).get_v1()))
        elif type == 2:
            self.value = Val._fbthrift_create(make_shared[cVal](deref(self._cpp_obj).get_v2()))

    def __copy__(ValUnion self):
        cdef shared_ptr[cValUnion] cpp_obj = make_shared[cValUnion](
            deref(self._cpp_obj)
        )
        return ValUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cValUnion](
            self._cpp_obj,
            (<ValUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__ValUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cValUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.ValUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cValUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(ValUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cValUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(ValUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cValUnion]()
        with nogil:
            needed = serializer.cdeserialize[cValUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.ValUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.ValUnion, self)


@__cython.auto_pickle(False)
cdef class VirtualComplexUnion(thrift.py3.types.Union):
    Type = __VirtualComplexUnionType

    def __init__(
        self, *,
        str thingOne=None,
        str thingTwo=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(VirtualComplexUnion._make_instance(
          NULL,
          thingOne,
          thingTwo,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return VirtualComplexUnion()
        if isinstance(value, str):
            return VirtualComplexUnion(thingOne=value)
        if isinstance(value, str):
            return VirtualComplexUnion(thingTwo=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cVirtualComplexUnion] _make_instance(
        cVirtualComplexUnion* base_instance,
        str thingOne,
        str thingTwo
    ) except *:
        cdef unique_ptr[cVirtualComplexUnion] c_inst = make_unique[cVirtualComplexUnion]()
        cdef bint any_set = False
        if thingOne is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_thingOne(thingOne.encode('UTF-8'))
            any_set = True
        if thingTwo is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_thingTwo(thingTwo.encode('UTF-8'))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cVirtualComplexUnion] cpp_obj):
        __fbthrift_inst = <VirtualComplexUnion>VirtualComplexUnion.__new__(VirtualComplexUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def thingOne(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not thingOne')
        return self.value

    @property
    def thingTwo(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not thingTwo')
        return self.value


    def __hash__(VirtualComplexUnion self):
        return  super().__hash__()

    cdef _load_cache(VirtualComplexUnion self):
        self.type = VirtualComplexUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = bytes(deref(self._cpp_obj).get_thingOne()).decode('UTF-8')
        elif type == 2:
            self.value = bytes(deref(self._cpp_obj).get_thingTwo()).decode('UTF-8')

    def __copy__(VirtualComplexUnion self):
        cdef shared_ptr[cVirtualComplexUnion] cpp_obj = make_shared[cVirtualComplexUnion](
            deref(self._cpp_obj)
        )
        return VirtualComplexUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cVirtualComplexUnion](
            self._cpp_obj,
            (<VirtualComplexUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__VirtualComplexUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cVirtualComplexUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.VirtualComplexUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cVirtualComplexUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(VirtualComplexUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cVirtualComplexUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(VirtualComplexUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cVirtualComplexUnion]()
        with nogil:
            needed = serializer.cdeserialize[cVirtualComplexUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.VirtualComplexUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.VirtualComplexUnion, self)
@__cython.auto_pickle(False)
cdef class NonCopyableStruct(thrift.py3.types.Struct):
    def __init__(NonCopyableStruct self, **kwargs):
        self._cpp_obj = make_shared[cNonCopyableStruct]()
        self._fields_setter = _fbthrift_types_fields.__NonCopyableStruct_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return _fbthrift_IsSet("NonCopyableStruct", {
          "num": deref(self._cpp_obj).num_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cNonCopyableStruct] cpp_obj):
        __fbthrift_inst = <NonCopyableStruct>NonCopyableStruct.__new__(NonCopyableStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline num_impl(self):

        return deref(self._cpp_obj).num_ref().value()

    @property
    def num(self):
        return self.num_impl()


    def __hash__(NonCopyableStruct self):
        return super().__hash__()

    def __repr__(NonCopyableStruct self):
        return super().__repr__()

    def __str__(NonCopyableStruct self):
        return super().__str__()


    def __copy__(NonCopyableStruct self):
        raise TypeError("NonCopyableStruct is noncopyable")

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cNonCopyableStruct](
            self._cpp_obj,
            (<NonCopyableStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__NonCopyableStruct()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cNonCopyableStruct].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.NonCopyableStruct"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cNonCopyableStruct](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 1

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(NonCopyableStruct self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cNonCopyableStruct](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(NonCopyableStruct self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cNonCopyableStruct]()
        with nogil:
            needed = serializer.cdeserialize[cNonCopyableStruct](buf, self._cpp_obj.get(), proto)
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.NonCopyableStruct, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.NonCopyableStruct, self)


@__cython.auto_pickle(False)
cdef class NonCopyableUnion(thrift.py3.types.Union):
    Type = __NonCopyableUnionType

    def __init__(
        self, *,
        NonCopyableStruct s=None
    ):
        self._cpp_obj = __to_shared_ptr(cmove(NonCopyableUnion._make_instance(
          NULL,
          s,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return NonCopyableUnion()
        if isinstance(value, NonCopyableStruct):
            return NonCopyableUnion(s=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cNonCopyableUnion] _make_instance(
        cNonCopyableUnion* base_instance,
        NonCopyableStruct s
    ) except *:
        cdef unique_ptr[cNonCopyableUnion] c_inst = make_unique[cNonCopyableUnion]()
        cdef bint any_set = False
        if s is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_s(deref((<NonCopyableStruct?> s)._cpp_obj))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cNonCopyableUnion] cpp_obj):
        __fbthrift_inst = <NonCopyableUnion>NonCopyableUnion.__new__(NonCopyableUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def s(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not s')
        return self.value


    def __hash__(NonCopyableUnion self):
        return  super().__hash__()

    cdef _load_cache(NonCopyableUnion self):
        self.type = NonCopyableUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            self.value = NonCopyableStruct._fbthrift_create(make_shared[cNonCopyableStruct](deref(self._cpp_obj).get_s()))

    def __copy__(NonCopyableUnion self):
        raise TypeError("NonCopyableUnion is noncopyable")

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cNonCopyableUnion](
            self._cpp_obj,
            (<NonCopyableUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__NonCopyableUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cNonCopyableUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.NonCopyableUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cNonCopyableUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 1

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(NonCopyableUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cNonCopyableUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(NonCopyableUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cNonCopyableUnion]()
        with nogil:
            needed = serializer.cdeserialize[cNonCopyableUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed


    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.NonCopyableUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.NonCopyableUnion, self)
@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[vector[cint64_t]] c_items):
        __fbthrift_inst = <List__i64>List__i64.__new__(List__i64)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i64._fbthrift_create(
            __list_slice[vector[cint64_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint64_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint64_t citem = item
        cdef __optional[size_t] found = __list_index[vector[cint64_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint64_t citem = item
        return __list_count[vector[cint64_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i64()


Sequence.register(List__i64)

@__cython.auto_pickle(False)
cdef class List__string(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__string):
            self._cpp_obj = (<List__string> items)._cpp_obj
        else:
            self._cpp_obj = List__string._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[vector[string]] c_items):
        __fbthrift_inst = <List__string>List__string.__new__(List__string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__string self):
        cdef shared_ptr[vector[string]] cpp_obj = make_shared[vector[string]](
            deref(self._cpp_obj)
        )
        return List__string._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[string]] _make_instance(object items) except *:
        cdef shared_ptr[vector[string]] c_inst = make_shared[vector[string]]()
        if items is not None:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            for item in items:
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")
                deref(c_inst).push_back(item.encode('UTF-8'))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__string._fbthrift_create(
            __list_slice[vector[string]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef string citem
        __list_getitem(self._cpp_obj, index, citem)
        return bytes(citem).decode('UTF-8')

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, str):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef string citem = item.encode('UTF-8')
        cdef __optional[size_t] found = __list_index[vector[string]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef string citem = item.encode('UTF-8')
        return __list_count[vector[string]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__string()


Sequence.register(List__string)

@__cython.auto_pickle(False)
cdef class Map__i16_string(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i16_string):
            self._cpp_obj = (<Map__i16_string> items)._cpp_obj
        else:
            self._cpp_obj = Map__i16_string._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cmap[cint16_t,string]] c_items):
        __fbthrift_inst = <Map__i16_string>Map__i16_string.__new__(Map__i16_string)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__i16_string self):
        cdef shared_ptr[cmap[cint16_t,string]] cpp_obj = make_shared[cmap[cint16_t,string]](
            deref(self._cpp_obj)
        )
        return Map__i16_string._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint16_t,string]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint16_t,string]] c_inst = make_shared[cmap[cint16_t,string]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint16_t> key
                if not isinstance(item, str):
                    raise TypeError(f"{item!r} is not of type str")

                deref(c_inst)[key] = item.encode('UTF-8')
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, int):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef cint16_t ckey = key
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef string citem
        __map_getitem(self._cpp_obj, ckey, citem)
        return bytes(citem).decode('UTF-8')

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[cint16_t,string]] itr = __map_iter[cmap[cint16_t,string]](self._cpp_obj)
        cdef cint16_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield citem

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef cint16_t ckey = key
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[cint16_t,string]] itr = __map_iter[cmap[cint16_t,string]](self._cpp_obj)
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[cint16_t,string]] itr = __map_iter[cmap[cint16_t,string]](self._cpp_obj)
        cdef cint16_t ckey = 0
        cdef string citem
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey, bytes(citem).decode('UTF-8'))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i16_string()

Mapping.register(Map__i16_string)

containerTypedef = Map__i16_string
