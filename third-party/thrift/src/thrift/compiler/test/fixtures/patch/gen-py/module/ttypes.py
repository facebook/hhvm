#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.lib.thrift.patch.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyData', 'InnerUnion', 'MyUnion', 'MyStruct', 'MyDataFieldPatch', 'MyDataPatch', 'InnerUnionFieldPatch', 'InnerUnionPatch', 'MyUnionFieldPatch', 'MyUnionPatch', 'MyStructFieldPatch', 'MyStructField21Patch', 'MyStructField22Patch', 'MyStructField23Patch', 'MyStructPatch']

class MyData:
  """
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyData')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyData, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyData, self)

  def _to_py_deprecated(self):
    return self

class InnerUnion(object):
  """
  Attributes:
   - innerOption
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INNEROPTION = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_innerOption(self):
    assert self.field == 1
    return self.value

  def set_innerOption(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('innerOption', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_innerOption = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_innerOption(_fbthrift_innerOption)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('InnerUnion')
    if self.field == 1:
      oprot.writeFieldBegin('innerOption', TType.STRING, 1)
      innerOption = self.value
      oprot.writeString(innerOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'innerOption' in obj:
      _fbthrift_innerOption = obj['innerOption']
      self.set_innerOption(_fbthrift_innerOption)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnion, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  """
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  OPTION1 = 1
  OPTION2 = 2
  OPTION3 = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_option1(self):
    assert self.field == 1
    return self.value

  def get_option2(self):
    assert self.field == 2
    return self.value

  def get_option3(self):
    assert self.field == 3
    return self.value

  def set_option1(self, value):
    self.field = 1
    self.value = value

  def set_option2(self, value):
    self.field = 2
    self.value = value

  def set_option3(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option1', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option2', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option3', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_option1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_option1(_fbthrift_option1)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_option2 = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_option2(_fbthrift_option2)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_option3 = InnerUnion()
          _fbthrift_option3.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_option3(_fbthrift_option3)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('option1', TType.STRING, 1)
      option1 = self.value
      oprot.writeString(option1.encode('utf-8')) if UTF8STRINGS and not isinstance(option1, bytes) else oprot.writeString(option1)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('option2', TType.I32, 2)
      option2 = self.value
      oprot.writeI32(option2)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      option3 = self.value
      option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'option1' in obj:
      _fbthrift_option1 = obj['option1']
      self.set_option1(_fbthrift_option1)
    if 'option2' in obj:
      _fbthrift_option2 = obj['option2']
      if _fbthrift_option2 > 0x7fffffff or _fbthrift_option2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_option2(_fbthrift_option2)
    if 'option3' in obj:
      _fbthrift_option3 = InnerUnion()
      _fbthrift_option3.readFromJson(obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_option3(_fbthrift_option3)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  """
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - structVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - unionVal
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.optListVal.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.optListVal.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, 1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, 2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, 3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, 4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, 5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, 6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, 7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, 8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, 9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, 10)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, 11)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, 12)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, 13)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, 14)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, 15)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, 16)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, 17)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, 18)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, 19)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, 20)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, 21)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter23 in self.optListVal:
        oprot.writeI16(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, 22)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter24 in self.optSetVal:
        oprot.writeString(iter24.encode('utf-8')) if UTF8STRINGS and not isinstance(iter24, bytes) else oprot.writeString(iter24)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, 23)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter25,viter26 in self.optMapVal.items():
        oprot.writeString(kiter25.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter25, bytes) else oprot.writeString(kiter25)
        oprot.writeString(viter26.encode('utf-8')) if UTF8STRINGS and not isinstance(viter26, bytes) else oprot.writeString(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, 30)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e27 in json_obj['optListVal']:
        if _tmp_e27 > 0x7fff or _tmp_e27 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e27)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e28 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e28)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k29, _tmp_v30 in json_obj['optMapVal'].items():
        _tmp_kp31 = _tmp_k29
        self.optMapVal[_tmp_kp31] = _tmp_v30
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'boolVal',
      'byteVal',
      'i16Val',
      'i32Val',
      'i64Val',
      'floatVal',
      'doubleVal',
      'stringVal',
      'binaryVal',
      'structVal',
      'optBoolVal',
      'optByteVal',
      'optI16Val',
      'optI32Val',
      'optI64Val',
      'optFloatVal',
      'optDoubleVal',
      'optStringVal',
      'optBinaryVal',
      'optStructVal',
      'optListVal',
      'optSetVal',
      'optMapVal',
      'unionVal',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataFieldPatch:
  """
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataPatch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyData()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyData()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyData()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyData()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionFieldPatch:
  """
  Attributes:
   - innerOption
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.innerOption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionFieldPatch')
    if self.innerOption != None:
      oprot.writeFieldBegin('innerOption', TType.STRUCT, 1)
      self.innerOption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'innerOption' in json_obj and json_obj['innerOption'] is not None:
      self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.innerOption.readFromJson(json_obj['innerOption'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.innerOption is not None:
      value = pprint.pformat(self.innerOption, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    innerOption=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'innerOption',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionPatch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = InnerUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = InnerUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = InnerUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = InnerUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = InnerUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = InnerUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = InnerUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = InnerUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionFieldPatch:
  """
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.option1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.option2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.option3 = InnerUnionPatch()
          self.option3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionFieldPatch')
    if self.option1 != None:
      oprot.writeFieldBegin('option1', TType.STRUCT, 1)
      self.option1.write(oprot)
      oprot.writeFieldEnd()
    if self.option2 != None:
      oprot.writeFieldBegin('option2', TType.STRUCT, 2)
      self.option2.write(oprot)
      oprot.writeFieldEnd()
    if self.option3 != None:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      self.option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'option1' in json_obj and json_obj['option1'] is not None:
      self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.option1.readFromJson(json_obj['option1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option2' in json_obj and json_obj['option2'] is not None:
      self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.option2.readFromJson(json_obj['option2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option3' in json_obj and json_obj['option3'] is not None:
      self.option3 = InnerUnionPatch()
      self.option3.readFromJson(json_obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.option1 is not None:
      value = pprint.pformat(self.option1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option1=%s' % (value))
    if self.option2 is not None:
      value = pprint.pformat(self.option2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option2=%s' % (value))
    if self.option3 is not None:
      value = pprint.pformat(self.option3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'option1',
      'option2',
      'option3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionPatch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = MyUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructFieldPatch:
  """
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - structVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - unionVal
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.boolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.byteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.i16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.i64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.floatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.doubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.stringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.binaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.structVal = MyDataPatch()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.optBoolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.optByteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.optI16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.optI32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.optI64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.optFloatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.optDoubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.optStringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.optBinaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.optStructVal = MyDataPatch()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.optListVal = MyStructField21Patch()
          self.optListVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRUCT:
          self.optSetVal = MyStructField22Patch()
          self.optSetVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.optMapVal = MyStructField23Patch()
          self.optMapVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnionPatch()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructFieldPatch')
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.STRUCT, 1)
      self.boolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.STRUCT, 2)
      self.byteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.STRUCT, 3)
      self.i16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.STRUCT, 4)
      self.i32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.STRUCT, 5)
      self.i64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.STRUCT, 6)
      self.floatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.STRUCT, 7)
      self.doubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRUCT, 8)
      self.stringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRUCT, 9)
      self.binaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, 10)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.STRUCT, 11)
      self.optBoolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.STRUCT, 12)
      self.optByteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.STRUCT, 13)
      self.optI16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.STRUCT, 14)
      self.optI32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.STRUCT, 15)
      self.optI64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.STRUCT, 16)
      self.optFloatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.STRUCT, 17)
      self.optDoubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRUCT, 18)
      self.optStringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRUCT, 19)
      self.optBinaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, 20)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.STRUCT, 21)
      self.optListVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.STRUCT, 22)
      self.optSetVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.STRUCT, 23)
      self.optMapVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, 30)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.boolVal.readFromJson(json_obj['boolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.byteVal.readFromJson(json_obj['byteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.i16Val.readFromJson(json_obj['i16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32Val.readFromJson(json_obj['i32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.i64Val.readFromJson(json_obj['i64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.floatVal.readFromJson(json_obj['floatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.doubleVal.readFromJson(json_obj['doubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.stringVal.readFromJson(json_obj['stringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.binaryVal.readFromJson(json_obj['binaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyDataPatch()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.optBoolVal.readFromJson(json_obj['optBoolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.optByteVal.readFromJson(json_obj['optByteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.optI16Val.readFromJson(json_obj['optI16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.optI32Val.readFromJson(json_obj['optI32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.optI64Val.readFromJson(json_obj['optI64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.optFloatVal.readFromJson(json_obj['optFloatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.optDoubleVal.readFromJson(json_obj['optDoubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.optStringVal.readFromJson(json_obj['optStringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.optBinaryVal.readFromJson(json_obj['optBinaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyDataPatch()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = MyStructField21Patch()
      self.optListVal.readFromJson(json_obj['optListVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = MyStructField22Patch()
      self.optSetVal.readFromJson(json_obj['optSetVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = MyStructField23Patch()
      self.optMapVal.readFromJson(json_obj['optMapVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnionPatch()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'boolVal',
      'byteVal',
      'i16Val',
      'i32Val',
      'i64Val',
      'floatVal',
      'doubleVal',
      'stringVal',
      'binaryVal',
      'structVal',
      'optBoolVal',
      'optByteVal',
      'optI16Val',
      'optI32Val',
      'optI64Val',
      'optFloatVal',
      'optDoubleVal',
      'optStringVal',
      'optBinaryVal',
      'optStructVal',
      'optListVal',
      'optSetVal',
      'optMapVal',
      'unionVal',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField21Patch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears a value. Applies first.
   - remove: Removes entries, if present. Applies third.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in range(_size32):
              _elem37 = iprot.readI16()
              self.assign.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = iprot.readI16()
              self.assign.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.remove = []
          (_etype42, _size39) = iprot.readListBegin()
          if _size39 >= 0:
            for _i43 in range(_size39):
              _elem44 = iprot.readI16()
              self.remove.append(_elem44)
          else: 
            while iprot.peekList():
              _elem45 = iprot.readI16()
              self.remove.append(_elem45)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype49, _size46) = iprot.readListBegin()
          if _size46 >= 0:
            for _i50 in range(_size46):
              _elem51 = iprot.readI16()
              self.prepend.append(_elem51)
          else: 
            while iprot.peekList():
              _elem52 = iprot.readI16()
              self.prepend.append(_elem52)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype56, _size53) = iprot.readListBegin()
          if _size53 >= 0:
            for _i57 in range(_size53):
              _elem58 = iprot.readI16()
              self.append.append(_elem58)
          else: 
            while iprot.peekList():
              _elem59 = iprot.readI16()
              self.append.append(_elem59)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField21Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.I16, len(self.assign))
      for iter60 in self.assign:
        oprot.writeI16(iter60)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.LIST, 7)
      oprot.writeListBegin(TType.I16, len(self.remove))
      for iter61 in self.remove:
        oprot.writeI16(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.I16, len(self.prepend))
      for iter62 in self.prepend:
        oprot.writeI16(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.I16, len(self.append))
      for iter63 in self.append:
        oprot.writeI16(iter63)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e64 in json_obj['assign']:
        if _tmp_e64 > 0x7fff or _tmp_e64 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign.append(_tmp_e64)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = []
      for _tmp_e65 in json_obj['remove']:
        if _tmp_e65 > 0x7fff or _tmp_e65 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.append(_tmp_e65)
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e66 in json_obj['prepend']:
        if _tmp_e66 > 0x7fff or _tmp_e66 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.prepend.append(_tmp_e66)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e67 in json_obj['append']:
        if _tmp_e67 > 0x7fff or _tmp_e67 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.append.append(_tmp_e67)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'remove',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField21Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField21Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField22Patch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears a value. Applies first.
   - remove: Removes entries, if present. Applies third.
   - add: Adds entries, if not already present. Applies fourth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.assign = set()
          (_etype71, _size68) = iprot.readSetBegin()
          if _size68 >= 0:
            for _i72 in range(_size68):
              _elem73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem73)
          else: 
            while iprot.peekSet():
              _elem74 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem74)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype78, _size75) = iprot.readSetBegin()
          if _size75 >= 0:
            for _i79 in range(_size75):
              _elem80 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem80)
          else: 
            while iprot.peekSet():
              _elem81 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem81)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.add = set()
          (_etype85, _size82) = iprot.readSetBegin()
          if _size82 >= 0:
            for _i86 in range(_size82):
              _elem87 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem87)
          else: 
            while iprot.peekSet():
              _elem88 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem88)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField22Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.assign))
      for iter89 in self.assign:
        oprot.writeString(iter89.encode('utf-8')) if UTF8STRINGS and not isinstance(iter89, bytes) else oprot.writeString(iter89)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter90 in self.remove:
        oprot.writeString(iter90.encode('utf-8')) if UTF8STRINGS and not isinstance(iter90, bytes) else oprot.writeString(iter90)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.SET, 8)
      oprot.writeSetBegin(TType.STRING, len(self.add))
      for iter91 in self.add:
        oprot.writeString(iter91.encode('utf-8')) if UTF8STRINGS and not isinstance(iter91, bytes) else oprot.writeString(iter91)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = set_cls()
      for _tmp_e92 in json_obj['assign']:
        self.assign.add(_tmp_e92)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e93 in json_obj['remove']:
        self.remove.add(_tmp_e93)
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = set_cls()
      for _tmp_e94 in json_obj['add']:
        self.add.add(_tmp_e94)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'remove',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField22Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField22Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField23Patch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears a value. Applies first.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype96, _vtype97, _size95 ) = iprot.readMapBegin() 
          if _size95 >= 0:
            for _i99 in range(_size95):
              _key100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key100] = _val101
          else: 
            while iprot.peekMap():
              _key102 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val103 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key102] = _val103
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype105, _vtype106, _size104 ) = iprot.readMapBegin() 
          if _size104 >= 0:
            for _i108 in range(_size104):
              _key109 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val110 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key109] = _val110
          else: 
            while iprot.peekMap():
              _key111 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val112 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key111] = _val112
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype116, _size113) = iprot.readSetBegin()
          if _size113 >= 0:
            for _i117 in range(_size113):
              _elem118 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem118)
          else: 
            while iprot.peekSet():
              _elem119 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem119)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype121, _vtype122, _size120 ) = iprot.readMapBegin() 
          if _size120 >= 0:
            for _i124 in range(_size120):
              _key125 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val126 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key125] = _val126
          else: 
            while iprot.peekMap():
              _key127 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val128 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key127] = _val128
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField23Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.assign))
      for kiter129,viter130 in self.assign.items():
        oprot.writeString(kiter129.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter129, bytes) else oprot.writeString(kiter129)
        oprot.writeString(viter130.encode('utf-8')) if UTF8STRINGS and not isinstance(viter130, bytes) else oprot.writeString(viter130)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.add))
      for kiter131,viter132 in self.add.items():
        oprot.writeString(kiter131.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter131, bytes) else oprot.writeString(kiter131)
        oprot.writeString(viter132.encode('utf-8')) if UTF8STRINGS and not isinstance(viter132, bytes) else oprot.writeString(viter132)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter133 in self.remove:
        oprot.writeString(iter133.encode('utf-8')) if UTF8STRINGS and not isinstance(iter133, bytes) else oprot.writeString(iter133)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.put))
      for kiter134,viter135 in self.put.items():
        oprot.writeString(kiter134.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter134, bytes) else oprot.writeString(kiter134)
        oprot.writeString(viter135.encode('utf-8')) if UTF8STRINGS and not isinstance(viter135, bytes) else oprot.writeString(viter135)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k136, _tmp_v137 in json_obj['assign'].items():
        _tmp_kp138 = _tmp_k136
        self.assign[_tmp_kp138] = _tmp_v137
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k139, _tmp_v140 in json_obj['add'].items():
        _tmp_kp141 = _tmp_k139
        self.add[_tmp_kp141] = _tmp_v140
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e142 in json_obj['remove']:
        self.remove.add(_tmp_e142)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k143, _tmp_v144 in json_obj['put'].items():
        _tmp_kp145 = _tmp_k143
        self.put[_tmp_kp145] = _tmp_v144

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField23Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField23Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructPatch:
  """
  Attributes:
   - assign: Assigns a value. If set, all other operations are ignored.
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructPatch, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(MyData)
MyData.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 3, ), # 1
  (2, TType.I32, 'data2', None, None, 3, ), # 2
)

MyData.thrift_struct_annotations = {
}
MyData.thrift_field_annotations = {
}

def MyData__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyData.__init__ = MyData__init__

def MyData__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyData.__getstate__ = lambda self: self.__dict__.copy()
MyData.__setstate__ = MyData__setstate__

all_structs.append(InnerUnion)
InnerUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'innerOption', False, None, 2, ), # 1
)

InnerUnion.thrift_struct_annotations = {
}
InnerUnion.thrift_field_annotations = {
}

def InnerUnion__init__(self, innerOption=None,):
  self.field = 0
  self.value = None
  if innerOption is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = innerOption

InnerUnion.__init__ = InnerUnion__init__

all_structs.append(MyUnion)
MyUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'option1', True, None, 2, ), # 1
  (2, TType.I32, 'option2', None, None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 3
)

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, option1=None, option2=None, option3=None,):
  self.field = 0
  self.value = None
  if option1 is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = option1
  if option2 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = option2
  if option3 is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = option3

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'boolVal', None, None, 3, ), # 1
  (2, TType.BYTE, 'byteVal', None, None, 3, ), # 2
  (3, TType.I16, 'i16Val', None, None, 3, ), # 3
  (4, TType.I32, 'i32Val', None, None, 3, ), # 4
  (5, TType.I64, 'i64Val', None, None, 3, ), # 5
  (6, TType.FLOAT, 'floatVal', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'doubleVal', None, None, 3, ), # 7
  (8, TType.STRING, 'stringVal', True, None, 3, ), # 8
  (9, TType.STRING, 'binaryVal', False, None, 3, ), # 9
  (10, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 3, ), # 10
  (11, TType.BOOL, 'optBoolVal', None, None, 1, ), # 11
  (12, TType.BYTE, 'optByteVal', None, None, 1, ), # 12
  (13, TType.I16, 'optI16Val', None, None, 1, ), # 13
  (14, TType.I32, 'optI32Val', None, None, 1, ), # 14
  (15, TType.I64, 'optI64Val', None, None, 1, ), # 15
  (16, TType.FLOAT, 'optFloatVal', None, None, 1, ), # 16
  (17, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # 17
  (18, TType.STRING, 'optStringVal', True, None, 1, ), # 18
  (19, TType.STRING, 'optBinaryVal', False, None, 1, ), # 19
  (20, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # 20
  (21, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # 21
  (22, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # 22
  (23, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # 23
  None, # 24
  None, # 25
  None, # 26
  None, # 27
  None, # 28
  None, # 29
  (30, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 30
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, structVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, unionVal=None,):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.structVal = structVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optStructVal = optStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.unionVal = unionVal

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('structVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('unionVal', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(MyDataFieldPatch)
MyDataFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 2, ), # 2
)

MyDataFieldPatch.thrift_struct_annotations = {
}
MyDataFieldPatch.thrift_field_annotations = {
}

def MyDataFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataFieldPatch.__init__ = MyDataFieldPatch__init__

def MyDataFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataFieldPatch.__setstate__ = MyDataFieldPatch__setstate__

all_structs.append(MyDataPatch)
MyDataPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 2, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyData, MyData.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 2, ), # 6
)

MyDataPatch.thrift_struct_annotations = {
}
MyDataPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyDataPatch.__init__ = MyDataPatch__init__

def MyDataPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyDataPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataPatch.__setstate__ = MyDataPatch__setstate__

all_structs.append(InnerUnionFieldPatch)
InnerUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'innerOption', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 2, ), # 1
)

InnerUnionFieldPatch.thrift_struct_annotations = {
}
InnerUnionFieldPatch.thrift_field_annotations = {
}

def InnerUnionFieldPatch__init__(self, innerOption=None,):
  self.innerOption = innerOption

InnerUnionFieldPatch.__init__ = InnerUnionFieldPatch__init__

def InnerUnionFieldPatch__setstate__(self, state):
  state.setdefault('innerOption', None)
  self.__dict__ = state

InnerUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionFieldPatch.__setstate__ = InnerUnionFieldPatch__setstate__

all_structs.append(InnerUnionPatch)
InnerUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [InnerUnion, InnerUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'ensure', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 2, ), # 6
)

InnerUnionPatch.thrift_struct_annotations = {
}
InnerUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def InnerUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

InnerUnionPatch.__init__ = InnerUnionPatch__init__

def InnerUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

InnerUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionPatch.__setstate__ = InnerUnionPatch__setstate__

all_structs.append(MyUnionFieldPatch)
MyUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'option1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'option2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnionPatch, InnerUnionPatch.thrift_spec, False], None, 2, ), # 3
)

MyUnionFieldPatch.thrift_struct_annotations = {
}
MyUnionFieldPatch.thrift_field_annotations = {
}

def MyUnionFieldPatch__init__(self, option1=None, option2=None, option3=None,):
  self.option1 = option1
  self.option2 = option2
  self.option3 = option3

MyUnionFieldPatch.__init__ = MyUnionFieldPatch__init__

def MyUnionFieldPatch__setstate__(self, state):
  state.setdefault('option1', None)
  state.setdefault('option2', None)
  state.setdefault('option3', None)
  self.__dict__ = state

MyUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionFieldPatch.__setstate__ = MyUnionFieldPatch__setstate__

all_structs.append(MyUnionPatch)
MyUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'ensure', [MyUnion, MyUnion.thrift_spec, True], None, 2, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 2, ), # 6
)

MyUnionPatch.thrift_struct_annotations = {
}
MyUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyUnionPatch.__init__ = MyUnionPatch__init__

def MyUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionPatch.__setstate__ = MyUnionPatch__setstate__

all_structs.append(MyStructFieldPatch)
MyStructFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'boolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'byteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'i16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'i32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'i64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'floatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 2, ), # 6
  (7, TType.STRUCT, 'doubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 2, ), # 7
  (8, TType.STRUCT, 'stringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 2, ), # 8
  (9, TType.STRUCT, 'binaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 2, ), # 9
  (10, TType.STRUCT, 'structVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 2, ), # 10
  (11, TType.STRUCT, 'optBoolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 2, ), # 11
  (12, TType.STRUCT, 'optByteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 2, ), # 12
  (13, TType.STRUCT, 'optI16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 2, ), # 13
  (14, TType.STRUCT, 'optI32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 2, ), # 14
  (15, TType.STRUCT, 'optI64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 2, ), # 15
  (16, TType.STRUCT, 'optFloatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 2, ), # 16
  (17, TType.STRUCT, 'optDoubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 2, ), # 17
  (18, TType.STRUCT, 'optStringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 2, ), # 18
  (19, TType.STRUCT, 'optBinaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 2, ), # 19
  (20, TType.STRUCT, 'optStructVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 2, ), # 20
  (21, TType.STRUCT, 'optListVal', [MyStructField21Patch, MyStructField21Patch.thrift_spec, False], None, 2, ), # 21
  (22, TType.STRUCT, 'optSetVal', [MyStructField22Patch, MyStructField22Patch.thrift_spec, False], None, 2, ), # 22
  (23, TType.STRUCT, 'optMapVal', [MyStructField23Patch, MyStructField23Patch.thrift_spec, False], None, 2, ), # 23
  None, # 24
  None, # 25
  None, # 26
  None, # 27
  None, # 28
  None, # 29
  (30, TType.STRUCT, 'unionVal', [MyUnionPatch, MyUnionPatch.thrift_spec, False], None, 2, ), # 30
)

MyStructFieldPatch.thrift_struct_annotations = {
}
MyStructFieldPatch.thrift_field_annotations = {
}

def MyStructFieldPatch__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, structVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, unionVal=None,):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.structVal = structVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optStructVal = optStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.unionVal = unionVal

MyStructFieldPatch.__init__ = MyStructFieldPatch__init__

def MyStructFieldPatch__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('structVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('unionVal', None)
  self.__dict__ = state

MyStructFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructFieldPatch.__setstate__ = MyStructFieldPatch__setstate__

all_structs.append(MyStructField21Patch)
MyStructField21Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.I16,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.LIST, 'remove', (TType.I16,None), None, 2, ), # 7
  (8, TType.LIST, 'prepend', (TType.I16,None), None, 2, ), # 8
  (9, TType.LIST, 'append', (TType.I16,None), None, 2, ), # 9
)

MyStructField21Patch.thrift_struct_annotations = {
}
MyStructField21Patch.thrift_field_annotations = {
}

def MyStructField21Patch__init__(self, assign=None, clear=None, remove=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.remove = remove
  self.prepend = prepend
  self.append = append

MyStructField21Patch.__init__ = MyStructField21Patch__init__

def MyStructField21Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('remove', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField21Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField21Patch.__setstate__ = MyStructField21Patch__setstate__

all_structs.append(MyStructField22Patch)
MyStructField22Patch.thrift_spec = (
  None, # 0
  (1, TType.SET, 'assign', (TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 2, ), # 7
  (8, TType.SET, 'add', (TType.STRING,True), None, 2, ), # 8
)

MyStructField22Patch.thrift_struct_annotations = {
}
MyStructField22Patch.thrift_field_annotations = {
}

def MyStructField22Patch__init__(self, assign=None, clear=None, remove=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.remove = remove
  self.add = add

MyStructField22Patch.__init__ = MyStructField22Patch__init__

def MyStructField22Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('remove', None)
  state.setdefault('add', None)
  self.__dict__ = state

MyStructField22Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField22Patch.__setstate__ = MyStructField22Patch__setstate__

all_structs.append(MyStructField23Patch)
MyStructField23Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  None, # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.STRING,True), None, 2, ), # 5
  None, # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 2, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.STRING,True), None, 2, ), # 9
)

MyStructField23Patch.thrift_struct_annotations = {
}
MyStructField23Patch.thrift_field_annotations = {
}

def MyStructField23Patch__init__(self, assign=None, clear=None, add=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.add = add
  self.remove = remove
  self.put = put

MyStructField23Patch.__init__ = MyStructField23Patch__init__

def MyStructField23Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField23Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField23Patch.__setstate__ = MyStructField23Patch__setstate__

all_structs.append(MyStructPatch)
MyStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyStruct, MyStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 2, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 2, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'patch', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 2, ), # 6
)

MyStructPatch.thrift_struct_annotations = {
}
MyStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyStructPatch.__init__ = MyStructPatch__init__

def MyStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyStructPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructPatch.__setstate__ = MyStructPatch__setstate__

fix_spec(all_structs)
del all_structs
