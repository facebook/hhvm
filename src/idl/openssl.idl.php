<?php
/**
 * Automatically generated by running "php schema.php openssl".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 *
 * @nolint
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )

DefineConstant(
  array(
    'name'   => "OPENSSL_RAW_DATA",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "OPENSSL_ZERO_PADDING",
    'type'   => Int64,
  ));


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "openssl_csr_export_to_file",
    'desc'   => "openssl_csr_export_to_file() takes the Certificate Signing Request represented by csr and saves it as ascii-armoured text into the file named by outfilename.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "csr",
        'type'   => Variant,
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
        'desc'   => "Path to the output file.",
      ),
      array(
        'name'   => "notext",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "The optional parameter notext affects the verbosity of the output; if it is FALSE, then additional human-readable information is included in the output. The default value of notext is TRUE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_csr_export",
    'desc'   => "openssl_csr_export() takes the Certificate Signing Request represented by csr and stores it as ascii-armoured text into out, which is passed by reference.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "csr",
        'type'   => Variant,
      ),
      array(
        'name'   => "out",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "notext",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "The optional parameter notext affects the verbosity of the output; if it is FALSE, then additional human-readable information is included in the output. The default value of notext is TRUE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_csr_get_public_key",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "csr",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_csr_get_subject",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "csr",
        'type'   => Variant,
      ),
      array(
        'name'   => "use_shortnames",
        'type'   => Boolean,
        'value'  => "true",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_csr_new",
    'desc'   => "openssl_csr_new() generates a new CSR (Certificate Signing Request) based on the information provided by dn, which represents the Distinguished Name to be used in the certificate. You need to have a valid openssl.cnf installed for this function to operate correctly. See the notes under the installation section for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the CSR.",
    ),
    'args'   => array(
      array(
        'name'   => "dn",
        'type'   => StringMap,
        'desc'   => "The Distinguished Name to be used in the certificate.",
      ),
      array(
        'name'   => "privkey",
        'type'   => Variant | Reference,
        'desc'   => "privkey should be set to a private key that was previously generated by openssl_pkey_new() (or otherwise obtained from the other openssl_pkey family of functions). The corresponding public portion of the key will be used to sign the CSR.",
      ),
      array(
        'name'   => "configargs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "By default, the information in your system openssl.conf is used to initialize the request; you can specify a configuration file section by setting the config_section_section key of configargs. You can also specify an alternative openssl configuration file by setting the value of the config key to the path of the file you want to use. The following keys, if present in configargs behave as their equivalents in the openssl.conf, as listed in the table below. Configuration overrides configargs key type openssl.conf equivalent description digest_alg string default_md Selects which digest method to use x509_extensions string x509_extensions Selects which extensions should be used when creating an x509 certificate req_extensions string req_extensions Selects which extensions should be used when creating a CSR private_key_bits integer default_bits Specifies how many bits should be used to generate a private key private_key_type integer none Specifies the type of private key to create. This can be one of OPENSSL_KEYTYPE_DSA, OPENSSL_KEYTYPE_DH or OPENSSL_KEYTYPE_RSA. The default value is OPENSSL_KEYTYPE_RSA which is currently the only supported key type. encrypt_key boolean encrypt_key Should an exported key (with passphrase) be encrypted?",
      ),
      array(
        'name'   => "extraattribs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "extraattribs is used to specify additional configuration options for the CSR. Both dn and extraattribs are associative arrays whose keys are converted to OIDs and applied to the relevant part of the request.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_csr_sign",
    'desc'   => "openssl_csr_sign() generates an x509 certificate resource from the given CSR. You need to have a valid openssl.cnf installed for this function to operate correctly. See the notes under the installation section for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an x509 certificate resource on success, FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "csr",
        'type'   => Variant,
        'desc'   => "A CSR previously generated by openssl_csr_new(). It can also be the path to a PEM encoded CSR when specified as file://path/to/csr or an exported string generated by openssl_csr_export().",
      ),
      array(
        'name'   => "cacert",
        'type'   => Variant,
        'desc'   => "The generated certificate will be signed by cacert. If cacert is NULL, the generated certificate will be a self-signed certificate.",
      ),
      array(
        'name'   => "priv_key",
        'type'   => Variant,
        'desc'   => "priv_key is the private key that corresponds to cacert.",
      ),
      array(
        'name'   => "days",
        'type'   => Int32,
        'desc'   => "days specifies the length of time for which the generated certificate will be valid, in days.",
      ),
      array(
        'name'   => "configargs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "You can finetune the CSR signing by configargs. See openssl_csr_new() for more information about configargs.",
      ),
      array(
        'name'   => "serial",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "An optional the serial number of issued certificate. If not specified it will default to 0.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_error_string",
    'desc'   => "openssl_error_string() returns the last error from the openSSL library. Error messages are stacked, so this function should be called multiple times to collect all of the information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an error message string, or FALSE if there are no more error messages to return.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_open",
    'desc'   => "openssl_open() opens (decrypts) sealed_data using the private key associated with the key identifier priv_key_id and the envelope key env_key, and fills open_data with the decrypted data. The envelope key is generated when the data are sealed and can only be used by one specific private key. See openssl_seal() for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "sealed_data",
        'type'   => String,
      ),
      array(
        'name'   => "open_data",
        'type'   => Variant | Reference,
        'desc'   => "If the call is successful the opened data is returned in this parameter.",
      ),
      array(
        'name'   => "env_key",
        'type'   => String,
      ),
      array(
        'name'   => "priv_key_id",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs12_export_to_file",
    'desc'   => "openssl_pkcs12_export_to_file() stores x509 into a file named by filename in a PKCS#12 file format.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "x509",
        'type'   => Variant,
        'desc'   => "See Key/Certificate parameters for a list of valid values.",
      ),
      array(
        'name'   => "filename",
        'type'   => String,
        'desc'   => "Path to the output file.",
      ),
      array(
        'name'   => "priv_key",
        'type'   => Variant,
        'desc'   => "Private key component of PKCS#12 file.",
      ),
      array(
        'name'   => "pass",
        'type'   => String,
        'desc'   => "Encryption password for unlocking the PKCS#12 file.",
      ),
      array(
        'name'   => "args",
        'type'   => Variant,
        'value'  => "null_variant",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs12_export",
    'desc'   => "openssl_pkcs12_export() stores x509 into a string named by out in a PKCS#12 file format.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "x509",
        'type'   => Variant,
        'desc'   => "See Key/Certificate parameters for a list of valid values.",
      ),
      array(
        'name'   => "out",
        'type'   => Variant | Reference,
        'desc'   => "On success, this will hold the PKCS#12.",
      ),
      array(
        'name'   => "priv_key",
        'type'   => Variant,
        'desc'   => "Private key component of PKCS#12 file.",
      ),
      array(
        'name'   => "pass",
        'type'   => String,
        'desc'   => "Encryption password for unlocking the PKCS#12 file.",
      ),
      array(
        'name'   => "args",
        'type'   => Variant,
        'value'  => "null_variant",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs12_read",
    'desc'   => "openssl_pkcs12_read() parses the PKCS#12 certificate store supplied by pkcs12 into a array named certs.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "pkcs12",
        'type'   => String,
      ),
      array(
        'name'   => "certs",
        'type'   => Variant | Reference,
        'desc'   => "On success, this will hold the Certificate Store Data.",
      ),
      array(
        'name'   => "pass",
        'type'   => String,
        'desc'   => "Encryption password for unlocking the PKCS#12 file.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs7_decrypt",
    'desc'   => "Decrypts the S/MIME encrypted message contained in the file specified by infilename using the certificate and its associated private key specified by recipcert and recipkey.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "infilename",
        'type'   => String,
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
        'desc'   => "The decrypted message is written to the file specified by outfilename.",
      ),
      array(
        'name'   => "recipcert",
        'type'   => Variant,
      ),
      array(
        'name'   => "recipkey",
        'type'   => Variant,
        'value'  => "null_variant",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs7_encrypt",
    'desc'   => "openssl_pkcs7_encrypt() takes the contents of the file named infile and encrypts them using an RC2 40-bit cipher so that they can only be read by the intended recipients specified by recipcerts.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "infilename",
        'type'   => String,
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
      ),
      array(
        'name'   => "recipcerts",
        'type'   => Variant,
        'desc'   => "Either a lone X.509 certificate, or an array of X.509 certificates.",
      ),
      array(
        'name'   => "headers",
        'type'   => StringVec,
        'desc'   => "headers is an array of headers that will be prepended to the data after it has been encrypted.\n\nheaders can be either an associative array keyed by header name, or an indexed array, where each element contains a single header line.",
      ),
      array(
        'name'   => "flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "flags can be used to specify options that affect the encoding process - see PKCS7 constants.",
      ),
      array(
        'name'   => "cipherid",
        'type'   => Int32,
        'value'  => "k_OPENSSL_CIPHER_RC2_40",
        'desc'   => "Cipher can be selected with cipherid.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs7_sign",
    'desc'   => "openssl_pkcs7_sign() takes the contents of the file named infilename and signs them using the certificate and its matching private key specified by signcert and privkey parameters.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "infilename",
        'type'   => String,
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
      ),
      array(
        'name'   => "signcert",
        'type'   => Variant,
      ),
      array(
        'name'   => "privkey",
        'type'   => Variant,
      ),
      array(
        'name'   => "headers",
        'type'   => Variant,
        'desc'   => "headers is an array of headers that will be prepended to the data after it has been signed (see openssl_pkcs7_encrypt() for more information about the format of this parameter).",
      ),
      array(
        'name'   => "flags",
        'type'   => Int32,
        'value'  => "k_PKCS7_DETACHED",
        'desc'   => "flags can be used to alter the output - see PKCS7 constants.",
      ),
      array(
        'name'   => "extracerts",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "extracerts specifies the name of a file containing a bunch of extra certificates to include in the signature which can for example be used to help the recipient to verify the certificate that you used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkcs7_verify",
    'desc'   => "openssl_pkcs7_verify() reads the S/MIME message contained in the given file and examines the digital signature.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE if the signature is verified, FALSE if it is not correct (the message has been tampered with, or the signing certificate is invalid), or -1 on error.",
    ),
    'args'   => array(
      array(
        'name'   => "filename",
        'type'   => String,
        'desc'   => "Path to the message.",
      ),
      array(
        'name'   => "flags",
        'type'   => Int32,
        'desc'   => "flags can be used to affect how the signature is verified - see PKCS7 constants for more information.",
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If the outfilename is specified, it should be a string holding the name of a file into which the certificates of the persons that signed the messages will be stored in PEM format.",
      ),
      array(
        'name'   => "cainfo",
        'type'   => StringVec,
        'value'  => "null_array",
        'desc'   => "If the cainfo is specified, it should hold information about the trusted CA certificates to use in the verification process - see certificate verification for more information about this parameter.",
      ),
      array(
        'name'   => "extracerts",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If the extracerts is specified, it is the filename of a file containing a bunch of certificates to use as untrusted CAs.",
      ),
      array(
        'name'   => "content",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "You can specify a filename with content that will be filled with the verified data, but with the signature information stripped.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_export_to_file",
    'desc'   => "openssl_pkey_export_to_file() saves an ascii-armoured (PEM encoded) rendition of key into the file named by outfilename. You need to have a valid openssl.cnf installed for this function to operate correctly. See the notes under the installation section for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
        'desc'   => "Path to the output file.",
      ),
      array(
        'name'   => "passphrase",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The key can be optionally protected by a passphrase.",
      ),
      array(
        'name'   => "configargs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "configargs can be used to fine-tune the export process by specifying and/or overriding options for the openssl configuration file. See openssl_csr_new() for more information about configargs.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_export",
    'desc'   => "openssl_pkey_export() exports key as a PEM encoded string and stores it into out (which is passed by reference). You need to have a valid openssl.cnf installed for this function to operate correctly. See the notes under the installation section for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
      ),
      array(
        'name'   => "out",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "passphrase",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The key is optionally protected by passphrase.",
      ),
      array(
        'name'   => "configargs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "configargs can be used to fine-tune the export process by specifying and/or overriding options for the openssl configuration file. See openssl_csr_new() for more information about configargs.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_free",
    'desc'   => "This function frees a private key created by openssl_pkey_new().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
      'desc'   => "No value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Object,
        'desc'   => "Resource holding the key.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_free_key",
    'desc'   => "openssl_free_key() frees the key associated with the specified key_identifier from memory.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
      'desc'   => "No value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Object,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_get_details",
    'desc'   => "This function returns the key details (bits, key, type).",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => VariantMap,
      'desc'   => "Returns an array with the key details in success or FALSE in failure. Returned array has indexes bits (number of bits), key (string representation of the public key) and type (type of the key which is one of OPENSSL_KEYTYPE_RSA, OPENSSL_KEYTYPE_DSA, OPENSSL_KEYTYPE_DH, OPENSSL_KEYTYPE_EC or -1 meaning unknown).",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Object,
        'desc'   => "Resource holding the key.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_get_private",
    'desc'   => "openssl_get_privatekey() parses key and prepares it for use by other functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a positive key resource identifier on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "key can be one of the following: a string having the format file://path/to/file.pem. The named file must contain a PEM encoded certificate/private key (it may contain both). A PEM formatted private key.",
      ),
      array(
        'name'   => "passphrase",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The optional parameter passphrase must be used if the specified key is encrypted (protected by a passphrase).",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_get_privatekey",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
      ),
      array(
        'name'   => "passphrase",
        'type'   => String,
        'value'  => "null_string",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_get_public",
    'desc'   => "openssl_get_publickey() extracts the public key from certificate and prepares it for use by other functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a positive key resource identifier on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "certificate",
        'type'   => Variant,
        'desc'   => "certificate can be one of the following: an X.509 certificate resource a string having the format file://path/to/file.pem. The named file must contain a PEM encoded certificate/private key (it may contain both). A PEM formatted private key.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_get_publickey",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "certificate",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_pkey_new",
    'desc'   => "openssl_pkey_new() generates a new private and public key pair. The public component of the key can be obtained using openssl_pkey_get_public(). You need to have a valid openssl.cnf installed for this function to operate correctly. See the notes under the installation section for more information.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Object,
      'desc'   => "Returns a resource identifier for the pkey on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "configargs",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "You can finetune the key generation (such as specifying the number of bits) using configargs. See openssl_csr_new() for more information about configargs.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_private_decrypt",
    'desc'   => "openssl_private_decrypt() decrypts data that was previous encrypted via openssl_public_encrypt() and stores the result into decrypted.\n\nYou can use this function e.g. to decrypt data which were supposed only to you.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "decrypted",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "key must be the private key corresponding that was used to encrypt the data.",
      ),
      array(
        'name'   => "padding",
        'type'   => Int32,
        'value'  => "k_OPENSSL_PKCS1_PADDING",
        'desc'   => "padding can be one of OPENSSL_PKCS1_PADDING, OPENSSL_SSLV23_PADDING, OPENSSL_PKCS1_OAEP_PADDING, OPENSSL_NO_PADDING.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_private_encrypt",
    'desc'   => "openssl_private_encrypt() encrypts data with private key and stores the result into crypted. Encrypted data can be decrypted via openssl_public_decrypt().\n\nThis function can be used e.g. to sign data (or its hash) to prove that it is not written by someone else.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "crypted",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "key",
        'type'   => Variant,
      ),
      array(
        'name'   => "padding",
        'type'   => Int32,
        'value'  => "k_OPENSSL_PKCS1_PADDING",
        'desc'   => "padding can be one of OPENSSL_PKCS1_PADDING, OPENSSL_NO_PADDING.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_public_decrypt",
    'desc'   => "openssl_public_decrypt() decrypts data that was previous encrypted via openssl_private_encrypt() and stores the result into decrypted.\n\nYou can use this function e.g. to check if the message was written by the owner of the private key.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "decrypted",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "key must be the public key corresponding that was used to encrypt the data.",
      ),
      array(
        'name'   => "padding",
        'type'   => Int32,
        'value'  => "k_OPENSSL_PKCS1_PADDING",
        'desc'   => "padding can be one of OPENSSL_PKCS1_PADDING, OPENSSL_NO_PADDING.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_public_encrypt",
    'desc'   => "openssl_public_encrypt() encrypts data with public key and stores the result into crypted. Encrypted data can be decrypted via openssl_private_decrypt().\n\nThis function can be used e.g. to encrypt message which can be then read only by owner of the private key. It can be also used to store secure data in database.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "crypted",
        'type'   => Variant | Reference,
        'desc'   => "This will hold the result of the encryption.",
      ),
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "The public key.",
      ),
      array(
        'name'   => "padding",
        'type'   => Int32,
        'value'  => "k_OPENSSL_PKCS1_PADDING",
        'desc'   => "padding can be one of OPENSSL_PKCS1_PADDING, OPENSSL_SSLV23_PADDING, OPENSSL_PKCS1_OAEP_PADDING, OPENSSL_NO_PADDING.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_seal",
    'desc'   => "openssl_seal() seals (encrypts) data by using RC4 with a randomly generated secret key. The key is encrypted with each of the public keys associated with the identifiers in pub_key_ids and each encrypted key is returned in env_keys. This means that one can send sealed data to multiple recipients (provided one has obtained their public keys). Each recipient must receive both the sealed data and the envelope key that was encrypted with the recipient's public key.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the length of the sealed data on success, or FALSE on error. If successful the sealed data is returned in sealed_data, and the envelope keys in env_keys.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "sealed_data",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "env_keys",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "pub_key_ids",
        'type'   => StringVec,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_sign",
    'desc'   => "openssl_sign() computes a signature for the specified data by using SHA1 for hashing followed by encryption using the private key associated with priv_key_id. Note that the data itself is not encrypted.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "signature",
        'type'   => Variant | Reference,
        'desc'   => "If the call was successful the signature is returned in signature.",
      ),
      array(
        'name'   => "priv_key_id",
        'type'   => Variant,
      ),
      array(
        'name'   => "signature_alg",
        'type'   => Int32,
        'value'  => "k_OPENSSL_ALGO_SHA1",
        'desc'   => "For more information see the list of Signature Algorithms.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_verify",
    'desc'   => "openssl_verify() verifies that the signature is correct for the specified data using the public key associated with pub_key_id. This must be the public key corresponding to the private key used for signing.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns 1 if the signature is correct, 0 if it is incorrect, and -1 on error.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "signature",
        'type'   => String,
      ),
      array(
        'name'   => "pub_key_id",
        'type'   => Variant,
      ),
      array(
        'name'   => "signature_alg",
        'type'   => Int32,
        'value'  => "k_OPENSSL_ALGO_SHA1",
        'desc'   => "For more information see the list of Signature Algorithms.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_check_private_key",
    'desc'   => "Checks whether the given key is the private key that corresponds to cert.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE if key is the private key that corresponds to cert, or FALSE otherwise.",
    ),
    'args'   => array(
      array(
        'name'   => "cert",
        'type'   => Variant,
        'desc'   => "The certificate.",
      ),
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "The private key.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_checkpurpose",
    'desc'   => "openssl_x509_checkpurpose() examines a certificate to see if it can be used for the specified purpose.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "Returns TRUE if the certificate can be used for the intended purpose, FALSE if it cannot, or -1 on error.",
    ),
    'args'   => array(
      array(
        'name'   => "x509cert",
        'type'   => Variant,
        'desc'   => "The examined certificate.",
      ),
      array(
        'name'   => "purpose",
        'type'   => Int32,
        'desc'   => "openssl_x509_checkpurpose() purposes Constant Description X509_PURPOSE_SSL_CLIENT Can the certificate be used for the client side of an SSL connection? X509_PURPOSE_SSL_SERVER Can the certificate be used for the server side of an SSL connection? X509_PURPOSE_NS_SSL_SERVER Can the cert be used for Netscape SSL server? X509_PURPOSE_SMIME_SIGN Can the cert be used to sign S/MIME email? X509_PURPOSE_SMIME_ENCRYPT Can the cert be used to encrypt S/MIME email? X509_PURPOSE_CRL_SIGN Can the cert be used to sign a certificate revocation list (CRL)? X509_PURPOSE_ANY Can the cert be used for Any/All purposes? These options are not bitfields - you may specify one only!",
      ),
      array(
        'name'   => "cainfo",
        'type'   => StringVec,
        'value'  => "null_array",
        'desc'   => "cainfo should be an array of trusted CA files/dirs as described in Certificate Verification.",
      ),
      array(
        'name'   => "untrustedfile",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If specified, this should be the name of a PEM encoded file holding certificates that can be used to help verify the certificate, although no trust is placed in the certificates that come from that file.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_export_to_file",
    'desc'   => "openssl_x509_export_to_file() stores x509 into a file named by outfilename in a PEM encoded format.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "x509",
        'type'   => Variant,
        'desc'   => "See Key/Certificate parameters for a list of valid values.",
      ),
      array(
        'name'   => "outfilename",
        'type'   => String,
        'desc'   => "Path to the output file.",
      ),
      array(
        'name'   => "notext",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "The optional parameter notext affects the verbosity of the output; if it is FALSE, then additional human-readable information is included in the output. The default value of notext is TRUE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_export",
    'desc'   => "openssl_x509_export() stores x509 into a string named by output in a PEM encoded format.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "x509",
        'type'   => Variant,
        'desc'   => "See Key/Certificate parameters for a list of valid values.",
      ),
      array(
        'name'   => "output",
        'type'   => Variant | Reference,
        'desc'   => "On success, this will hold the PEM.",
      ),
      array(
        'name'   => "notext",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "The optional parameter notext affects the verbosity of the output; if it is FALSE, then additional human-readable information is included in the output. The default value of notext is TRUE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_free",
    'desc'   => "openssl_x509_free() frees the certificate associated with the specified x509cert resource from memory.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
      'desc'   => "No value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "x509cert",
        'type'   => Object,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_parse",
    'desc'   => "openssl_x509_parse() returns information about the supplied x509cert, including fields such as subject name, issuer name, purposes, valid from and valid to dates etc.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The structure of the returned data is (deliberately) not yet documented, as it is still subject to change.",
    ),
    'args'   => array(
      array(
        'name'   => "x509cert",
        'type'   => Variant,
      ),
      array(
        'name'   => "shortnames",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "shortnames controls how the data is indexed in the array - if shortnames is TRUE (the default) then fields will be indexed with the short name form, otherwise, the long name form will be used - e.g.: CN is the shortname form of commonName.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_x509_read",
    'desc'   => "openssl_x509_read() parses the certificate supplied by x509certdata and returns a resource identifier for it.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a resource identifier on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "x509certdata",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_random_pseudo_bytes",
    'desc'   => "Generates a string of pseudo-random bytes, with the number of bytes determined by the length parameter.\n\nIt also indicates if a cryptographically strong algorithm was used to produce the pseudo-random bytes, and does this via the optional crypto_strong parameter. It's rare for this to be FALSE, but some systems may be broken or old.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the generated string of bytes on success, or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "length",
        'type'   => Int32,
        'desc'   => "The length of the desired string of bytes. Must be a positive integer. PHP will try to cast this parameter to a non-null integer to use it.",
      ),
      array(
        'name'   => "crypto_strong",
        'type'   => Variant | Reference,
        'value'  => "false",
        'desc'   => "If passed into the function, this will hold a boolean value that determines if the algorithm used was \"cryptographically strong\", e.g., safe for usage with GPG, passwords, etc. TRUE if it did, otherwise FALSE",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_cipher_iv_length",
    'desc'   => "Returns the required initialisation vector length for the cipher determined by the mode parameter.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the iv length of a cipher, or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "method",
        'type'   => String,
        'desc'   => "The cipher method.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_encrypt",
    'desc'   => "Encrypts given data with given method and key, returns a raw or base64 encoded string WarningThis function is currently not documented; only its argument list is available.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the encrypted string on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "The data.",
      ),
      array(
        'name'   => "method",
        'type'   => String,
        'desc'   => "The cipher method.",
      ),
      array(
        'name'   => "password",
        'type'   => String,
        'desc'   => "The password.",
      ),
      array(
        'name'   => "options",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "Setting to TRUE will return as raw output data, otherwise the return value is base64 encoded.",
      ),
      array(
        'name'   => "iv",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The initialisation vector.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_decrypt",
    'desc'   => "Takes a raw or base64 encoded string and decrypts it using a given method and key.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The decrypted string on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "The data.",
      ),
      array(
        'name'   => "method",
        'type'   => String,
        'desc'   => "The cipher method.",
      ),
      array(
        'name'   => "password",
        'type'   => String,
        'desc'   => "The password.",
      ),
      array(
        'name'   => "options",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "Setting to TRUE will take a raw encoded string, otherwise a base64 string is assumed for the data parameter.",
      ),
      array(
        'name'   => "iv",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The initialisation vector.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_digest",
    'desc'   => "Computes digest hash value for given data using given method, returns raw or binhex encoded string.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the digested hash value on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "The data.",
      ),
      array(
        'name'   => "method",
        'type'   => String,
        'desc'   => "The digest method.",
      ),
      array(
        'name'   => "raw_output",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Setting to TRUE will return as raw output data, otherwise the return value is binhex encoded.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_get_cipher_methods",
    'desc'   => "Gets a list of available cipher methods.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => StringVec,
      'desc'   => "An array of available cipher methods.",
    ),
    'args'   => array(
      array(
        'name'   => "aliases",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Set to TRUE if cipher aliases should be included within the returned array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "openssl_get_md_methods",
    'desc'   => "Gets a list of available digest methods.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => StringVec,
      'desc'   => "An array of available digest methods.",
    ),
    'args'   => array(
      array(
        'name'   => "aliases",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Set to TRUE if digest aliases should be included within the returned array.",
      ),
    ),
  ));

///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

