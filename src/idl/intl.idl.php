<?php
/**
 * Automatically generated by running "php schema.php intl".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "intl_get_error_code",
    'desc'   => "Useful to handle errors occurred in static methods when there's no object to get error code from.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int64,
      'desc'   => "Error code returned by the last API function call.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "intl_get_error_message",
    'desc'   => "Get error message from last internationalization function called.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Description of an error occurred in the last API function call.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "intl_error_name",
    'desc'   => "Return ICU error code name.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "The returned string will be the same as the name of the error code constant.",
    ),
    'args'   => array(
      array(
        'name'   => "error_code",
        'type'   => Int64,
        'desc'   => "ICU error code.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "intl_is_failure",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "TRUE if it the code indicates some failure, and FALSE in case of success or a warning.",
    ),
    'args'   => array(
      array(
        'name'   => "error_code",
        'type'   => Int64,
        'desc'   => "is a value that returned by functions: intl_get_error_code(), collator_get_error_code() .",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_asort",
    'desc'   => "Procedural style bool collator_asort ( Collator \$coll , array &\$arr [, int \$sort_flag ] ) This function sorts an array such that array indices maintain their correlation with the array elements they are associated with. This is used mainly when sorting associative arrays where the actual element order is significant. Array elements will have sort order according to current locale rules.\n\nEquivalent to standard PHP asort().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "sort_flag",
        'type'   => Int64,
        'value'  => "0",
        'desc'   => "Optional sorting type, one of the following:\n\nCollator::SORT_REGULAR - compare items normally (don't change types)\n\nCollator::SORT_NUMERIC - compare items numerically\n\nCollator::SORT_STRING - compare items as strings\n\nDefault \$sort_flag value is Collator::SORT_REGULAR. It is also used if an invalid \$sort_flag value has been specified.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_compare",
    'desc'   => "Procedural style int collator_compare ( Collator \$coll , string \$str1 , string \$str2 ) Compare two Unicode strings according to collation rules.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "1 if str1 is greater than str2 ;\n\n0 if str1 is equal to str2;\n\n-1 if str1 is less than str2 . On error boolean FALSE is returned. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "str1",
        'type'   => String,
        'desc'   => "The first string to compare.",
      ),
      array(
        'name'   => "str2",
        'type'   => String,
        'desc'   => "The second string to compare.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_create",
    'desc'   => "Procedural style Collator collator_create ( string \$locale ) The strings will be compared using the options already specified.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Return new instance of Collator object, or NULL on error.",
    ),
    'args'   => array(
      array(
        'name'   => "locale",
        'type'   => String,
        'desc'   => "The locale containing the required collation rules. Special values for locales can be passed in - if null is passed for the locale, the default locale collation rules will be used. If empty string (\"\") or \"root\" are passed, UCA rules will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_get_attribute",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
      array(
        'name'   => "attr",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_get_error_code",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_get_error_message",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_get_locale",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
      array(
        'name'   => "type",
        'type'   => Int64,
        'value'  => "0",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_get_strength",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_set_attribute",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
      array(
        'name'   => "attr",
        'type'   => Int64,
      ),
      array(
        'name'   => "val",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_set_strength",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
      array(
        'name'   => "strength",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_sort_with_sort_keys",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
      ),
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "collator_sort",
    'desc'   => "Procedural style bool collator_sort ( Collator \$coll , array &\$arr [, int \$sort_flag ] ) This function sorts an array according to current locale rules.\n\nEquivalent to standard PHP sort() .",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "obj",
        'type'   => Variant,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
        'desc'   => "Array of strings to sort.",
      ),
      array(
        'name'   => "sort_flag",
        'type'   => Int64,
        'value'  => "0",
        'desc'   => "Optional sorting type, one of the following:\n\n\n\nCollator::SORT_REGULAR - compare items normally (don't change types)\n\nCollator::SORT_NUMERIC - compare items numerically\n\nCollator::SORT_STRING - compare items as strings Default sorting type is Collator::SORT_REGULAR.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "idn_to_ascii",
    'desc'   => "This function converts Unicode domain name to IDNA ASCII-compatible format.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Domain name encoded in ASCII-compatible form.",
    ),
    'args'   => array(
      array(
        'name'   => "domain",
        'type'   => String,
        'desc'   => "Domain to convert. In PHP 5 must be UTF-8 encoded.",
      ),
      array(
        'name'   => "errorcode",
        'type'   => Variant | Reference,
        'value'  => "null",
        'desc'   => "Conversion options - combination of IDNA_* constants.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "idn_to_unicode",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "domain",
        'type'   => String,
      ),
      array(
        'name'   => "errorcode",
        'type'   => Variant | Reference,
        'value'  => "null",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "idn_to_utf8",
    'desc'   => "This function converts Unicode domain name from IDNA ASCII-compatible format to plain Unicode.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Domain name in Unicode. In PHP5, domain name will be in UTF-8.",
    ),
    'args'   => array(
      array(
        'name'   => "domain",
        'type'   => String,
        'desc'   => "Domain to convert in IDNA ASCII-compatible format.",
      ),
      array(
        'name'   => "errorcode",
        'type'   => Variant | Reference,
        'value'  => "null",
        'desc'   => "Conversion options - combination of IDNA_* constants.",
      ),
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

///////////////////////////////////////////////////////////////////////////////

BeginClass(
  array(
    'name'   => "Collator",
    'desc'   => "Provides string comparison capability with support for appropriate locale-sensitive sort orderings.",
    'flags'  =>  HasDocComment,
    'footer' => <<<EOT

 private:
  String     m_locale;
  UCollator *m_ucoll;
  intl_error m_errcode;
EOT
,
  ));

DefineConstant(
  array(
    'name'   => "SORT_REGULAR",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "SORT_NUMERIC",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "SORT_STRING",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "FRENCH_COLLATION",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "ALTERNATE_HANDLING",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "CASE_FIRST",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "CASE_LEVEL",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NORMALIZATION_MODE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "STRENGTH",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "HIRAGANA_QUATERNARY_MODE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NUMERIC_COLLATION",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "DEFAULT_VALUE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "PRIMARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "SECONDARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "TERTIARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "DEFAULT_STRENGTH",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "QUATERNARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "IDENTICAL",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "OFF",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "ON",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "SHIFTED",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NON_IGNORABLE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "LOWER_FIRST",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UPPER_FIRST",
    'type'   => Int64,
  ));

DefineFunction(
  array(
    'name'   => "__construct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
    ),
    'args'   => array(
      array(
        'name'   => "locale",
        'type'   => String,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "asort",
    'desc'   => "Procedural style bool collator_asort ( Collator \$coll , array &\$arr [, int \$sort_flag ] ) This function sorts an array such that array indices maintain their correlation with the array elements they are associated with. This is used mainly when sorting associative arrays where the actual element order is significant. Array elements will have sort order according to current locale rules.\n\nEquivalent to standard PHP asort().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "sort_flag",
        'type'   => Int64,
        'value'  => "0",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "compare",
    'desc'   => "Procedural style int collator_compare ( Collator \$coll , string \$str1 , string \$str2 ) Compare two Unicode strings according to collation rules.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "1 if str1 is greater than str2 ;\n\n0 if str1 is equal to str2;\n\n-1 if str1 is less than str2 . On error boolean FALSE is returned. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "str1",
        'type'   => String,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "str2",
        'type'   => String,
        'desc'   => "The first string to compare.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "create",
    'desc'   => "Procedural style Collator collator_create ( string \$locale ) The strings will be compared using the options already specified.",
    'flags'  =>  IsStatic | HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Return new instance of Collator object, or NULL on error.",
    ),
    'args'   => array(
      array(
        'name'   => "locale",
        'type'   => String,
        'desc'   => "The locale containing the required collation rules. Special values for locales can be passed in - if null is passed for the locale, the default locale collation rules will be used. If empty string (\"\") or \"root\" are passed, UCA rules will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "getattribute",
    'desc'   => "Procedural style int collator_get_attribute ( Collator \$coll , int \$attr ) Get a value of an integer collator attribute.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int64,
      'desc'   => "Attribute value, or boolean FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "attr",
        'type'   => Int64,
        'desc'   => "Collator object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "geterrorcode",
    'desc'   => "Procedural style int collator_get_error_code ( Collator \$coll )",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int64,
      'desc'   => "Error code returned by the last Collator API function call.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "geterrormessage",
    'desc'   => "Procedural style string collator_get_error_message ( Collator \$coll ) Retrieves the message for the last error.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Description of an error occurred in the last Collator API function call.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "getlocale",
    'desc'   => "Procedural style string collator_get_locale ( Collator \$coll , int \$type ) Get collector locale name.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Real locale name from which the collation data comes. If the collator was instantiated from rules or an error occurred, returns boolean FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "type",
        'type'   => Int64,
        'value'  => "0",
        'desc'   => "Collator object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "getstrength",
    'desc'   => "Procedural style int collator_get_strength ( Collator \$coll )",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int64,
      'desc'   => "Returns current collation strength, or boolean FALSE on error.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "setattribute",
    'desc'   => "Procedural style bool collator_set_attribute ( Collator \$coll , int \$attr , int \$val )",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "attr",
        'type'   => Int64,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "val",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "setstrength",
    'desc'   => "Procedural style bool collator_set_strength ( Collator \$coll , int \$strength ) The » ICU Collation Service supports many levels of comparison (named \"Levels\", but also known as \"Strengths\"). Having these categories enables ICU to sort strings precisely according to local conventions. However, by allowing the levels to be selectively employed, searching for a string in text can be performed with various matching conditions.\n\n\n\nPrimary Level: Typically, this is used to denote differences between base characters (for example, \"a\" < \"b\"). It is the strongest difference. For example, dictionaries are divided into different sections by base character. This is also called the level1 strength.\n\nSecondary Level: Accents in the characters are considered secondary differences (for example, \"as\" < \"Ã s\" < \"at\"). Other differences between letters can also be considered secondary differences, depending on the language. A secondary difference is ignored when there is a primary difference anywhere in the strings. This is also called the level2 strength.\n\nNote: In some languages (such as Danish), certain accented letters are considered to be separate base characters. In most languages, however, an accented letter only has a secondary difference from the unaccented version of that letter.\n\nTertiary Level: Upper and lower case differences in characters are distinguished at the tertiary level (for example, \"ao\" < \"Ao\" < \"aÃ²\"). In addition, a variant of a letter differs from the base form on the tertiary level (such as \"A\" and \" \"). Another example is the difference between large and small Kana. A tertiary difference is ignored when there is a primary or secondary difference anywhere in the strings. This is also called the level3 strength.\n\nQuaternary Level: When punctuation is ignored (see Ignoring Punctuations ) at level 13, an additional level can be used to distinguish words with and without punctuation (for example, \"ab\" < \"a-b\" < \"aB\"). This difference is ignored when there is a primary, secondary or tertiary difference. This is also known as the level4 strength. The quaternary level should only be used if ignoring punctuation is required or when processing Japanese text (see Hiragana processing).\n\nIdentical Level: When all other levels are equal, the identical level is used as a tiebreaker. The Unicode code point values of the NFD form of each string are compared at this level, just in case there is no difference at levels 14. For example, Hebrew cantillation marks are only distinguished at this level. This level should be used sparingly, as only code point values differences between two strings is an extremely rare occurrence. Using this level substantially decreases the performance for both incremental comparison and sort key generation (as well as increasing the sort key length). It is also known as level 5 strength.\n\nFor example, people may choose to ignore accents or ignore accents and case when searching for text. Almost all characters are distinguished by the first three levels, and in most locales the default value is thus Tertiary. However, if Alternate is set to be Shifted, then the Quaternary strength can be used to break ties among whitespace, punctuation, and symbols that would otherwise be ignored. If very fine distinctions among characters are required, then the Identical strength can be used (for example, Identical Strength distinguishes between the Mathematical Bold Small A and the Mathematical Italic Small A.). However, using levels higher than Tertiary the Identical strength result in significantly longer sort keys, and slower string comparison performance for equal strings.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "strength",
        'type'   => Int64,
        'desc'   => "Collator object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "sortwithsortkeys",
    'desc'   => "Procedural style bool collator_sort_with_sort_keys ( Collator \$coll , array &\$arr ) Similar to collator_sort() but uses ICU sorting keys produced by ucol_getSortKey() to gain more speed on large arrays.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
        'desc'   => "Collator object.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "sort",
    'desc'   => "Procedural style bool collator_sort ( Collator \$coll , array &\$arr [, int \$sort_flag ] ) This function sorts an array according to current locale rules.\n\nEquivalent to standard PHP sort() .",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "arr",
        'type'   => Variant | Reference,
        'desc'   => "Collator object.",
      ),
      array(
        'name'   => "sort_flag",
        'type'   => Int64,
        'value'  => "0",
        'desc'   => "Array of strings to sort.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "__destruct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
  ));

EndClass(
);

///////////////////////////////////////////////////////////////////////////////

BeginClass(
  array(
    'name'   => "Locale",
    'desc'   => "A \"Locale\" is an identifier used to get language, culture, or regionally-specific behavior from an API. PHP locales are organized and identified the same way that the CLDR locales used by ICU (and many vendors of Unix-like operating systems, the Mac, Java, and so forth) use. Locales are identified using RFC 4646 language tags (which use hyphen, not underscore) in addition to the more traditional underscore-using identifiers. Unless otherwise noted the functions in this class are tolerant of both formats.\n\nExamples of identifiers include: en-US (English, United States) zh-Hant-TW (Chinese, Traditional Script, Taiwan) fr-CA, fr-FR (French for Canada and France respectively) The Locale class (and related procedural functions) are used to interact with locale identifiers--to verify that an ID is well-formed, valid, etc. The extensions used by CLDR in UAX #35 (and inherited by ICU) are valid and used wherever they would be in ICU normally. Locales cannot be instantiated as objects. All of the functions/methods provided are static. The null or empty string obtains the \"root\" locale. The \"root\" locale is equivalent to \"en_US_POSIX\" in CLDR. Language tags (and thus locale identifiers) are case insensitive. There exists a canonicalization function to make case match the specification.",
    'flags'  =>  HasDocComment,
  ));

DefineConstant(
  array(
    'name'   => "ACTUAL_LOCALE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "VALID_LOCALE",
    'type'   => Int64,
  ));

DefineFunction(
  array(
    'name'   => "__construct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
    ),
  ));

DefineFunction(
  array(
    'name'   => "__destruct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
  ));

EndClass(
);

///////////////////////////////////////////////////////////////////////////////

BeginClass(
  array(
    'name'   => "Normalizer",
    'desc'   => "Normalization is a process that involves transforming characters and sequences of characters into a formally-defined underlying representation. This process is most important when text needs to be compared for sorting and searching, but it is also used when storing text to ensure that the text is stored in a consistent representation.\n\nThe Unicode Consortium has defined a number of normalization forms reflecting the various needs of applications: Normalization Form D (NFD) - Canonical Decomposition Normalization Form C (NFC) - Canonical Decomposition followed by Canonical Composition Normalization Form KD (NFKD) - Compatibility Decomposition Normalization Form KC (NFKC) - Compatibility Decomposition followed by Canonical Composition The different forms are defined in terms of a set of transformations on the text, transformations that are expressed by both an algorithm and a set of data files.",
    'flags'  =>  HasDocComment,
  ));

DefineConstant(
  array(
    'name'   => "NONE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "FORM_D",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NFD",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "FORM_KD",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NFKD",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "FORM_C",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NFC",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "FORM_KC",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "NFKC",
    'type'   => Int64,
  ));

DefineFunction(
  array(
    'name'   => "__construct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => null,
    ),
  ));

DefineFunction(
  array(
    'name'   => "isnormalized",
    'desc'   => "Procedural style bool normalizer_is_normalized ( string \$input [, string \$form = Normalizer::FORM_C ] ) Checks if the provided string is already in the specified normalization form.",
    'flags'  =>  IsStatic | HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "TRUE if normalized, FALSE otherwise or if there an error",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => String,
      ),
      array(
        'name'   => "form",
        'type'   => Int64,
        'value'  => "q_normalizer_FORM_C",
        'desc'   => "One of the normalization forms.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "normalize",
    'desc'   => "Procedural style string normalizer_normalize ( string \$input [, string \$form = Normalizer::FORM_C ] ) Normalizes the input provided and returns the normalized string",
    'flags'  =>  IsStatic | HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "NULL if an error occurred.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => String,
      ),
      array(
        'name'   => "form",
        'type'   => Int64,
        'value'  => "q_normalizer_FORM_C",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "__destruct",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
  ));

EndClass(
);

