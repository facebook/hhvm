#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

# pyre-unsafe

import typing as __T  # sometimes `t` is used as a field name

from thrift import Thrift
from thrift.protocol.TProtocol import TProtocolBase

__property__ = property  # sometimes `property` is used as a field name

import thrift.annotation.cpp.ttypes
import thrift.annotation.python.ttypes
import thrift.annotation.thrift.ttypes
import thrift.annotation.scope.ttypes
import thrift.annotation.hack.ttypes
import thrift.annotation.rust.ttypes
import ::my
import my

UTF8STRINGS: bool


class Color(int):
    UNKNOWN: __T.ClassVar[Color]
    RED: __T.ClassVar[Color]
    GREEN: __T.ClassVar[Color]
    BLUE: __T.ClassVar[Color]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[Color, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, Color]]


class ThriftAdaptedEnum(int):
    Zero: __T.ClassVar[ThriftAdaptedEnum]
    One: __T.ClassVar[ThriftAdaptedEnum]

    _VALUES_TO_NAMES: __T.ClassVar[__T.Dict[ThriftAdaptedEnum, str]]
    _NAMES_TO_VALUES: __T.ClassVar[__T.Dict[str, ThriftAdaptedEnum]]


class MyAnnotation:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        signature: __T.Optional[str] = ...,
        color: Color = ...
    ) -> None:
        ...

    @__property__
    def signature(self) -> str: ...
    @signature.setter
    def signature(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def color(self) -> Color: ...
    @color.setter
    def color(self, value: Color) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.MyAnnotation": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.MyAnnotation": ...   # type: ignore
    def _to_py_deprecated(self) -> MyAnnotation: ...


class Foo:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        intField: __T.Optional[int] = ...,
        optionalIntField: __T.Optional[int] = ...,
        intFieldWithDefault: int = ...,
        setField: __T.Optional[__T.Set[str]] = ...,
        optionalSetField: __T.Optional[__T.Set[str]] = ...,
        mapField: __T.Optional[__T.Dict[str, __T.List[str]]] = ...,
        optionalMapField: __T.Optional[__T.Dict[str, __T.List[str]]] = ...,
        binaryField: __T.Optional[bytes] = ...,
        longField: __T.Optional[int] = ...,
        adaptedLongField: __T.Optional[int] = ...,
        doubleAdaptedField: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def intField(self) -> int: ...
    @intField.setter
    def intField(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def optionalIntField(self) -> __T.Optional[int]: ...
    @optionalIntField.setter
    def optionalIntField(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def intFieldWithDefault(self) -> int: ...
    @intFieldWithDefault.setter
    def intFieldWithDefault(self, value: int) -> None: ...
    @__property__
    def setField(self) -> __T.Set[str]: ...
    @setField.setter
    def setField(self, value: __T.Optional[__T.Set[str]]) -> None: ...
    @__property__
    def optionalSetField(self) -> __T.Optional[__T.Set[str]]: ...
    @optionalSetField.setter
    def optionalSetField(self, value: __T.Optional[__T.Set[str]]) -> None: ...
    @__property__
    def mapField(self) -> __T.Dict[str, __T.List[str]]: ...
    @mapField.setter
    def mapField(self, value: __T.Optional[__T.Dict[str, __T.List[str]]]) -> None: ...
    @__property__
    def optionalMapField(self) -> __T.Optional[__T.Dict[str, __T.List[str]]]: ...
    @optionalMapField.setter
    def optionalMapField(self, value: __T.Optional[__T.Dict[str, __T.List[str]]]) -> None: ...
    @__property__
    def binaryField(self) -> bytes: ...
    @binaryField.setter
    def binaryField(self, value: __T.Optional[bytes]) -> None: ...
    @__property__
    def longField(self) -> int: ...
    @longField.setter
    def longField(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def adaptedLongField(self) -> int: ...
    @adaptedLongField.setter
    def adaptedLongField(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def doubleAdaptedField(self) -> int: ...
    @doubleAdaptedField.setter
    def doubleAdaptedField(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Foo": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Foo": ...   # type: ignore
    def _to_py_deprecated(self) -> Foo: ...


class Baz:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        intField: __T.Optional[int] = ...,
        setField: __T.Optional[__T.Set[str]] = ...,
        mapField: __T.Optional[__T.Dict[str, __T.List[str]]] = ...,
        binaryField: __T.Optional[bytes] = ...,
        longField: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def intField(self) -> int: ...
    @intField.setter
    def intField(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def setField(self) -> __T.Set[str]: ...
    @setField.setter
    def setField(self, value: __T.Optional[__T.Set[str]]) -> None: ...
    @__property__
    def mapField(self) -> __T.Dict[str, __T.List[str]]: ...
    @mapField.setter
    def mapField(self, value: __T.Optional[__T.Dict[str, __T.List[str]]]) -> None: ...
    @__property__
    def binaryField(self) -> bytes: ...
    @binaryField.setter
    def binaryField(self, value: __T.Optional[bytes]) -> None: ...
    @__property__
    def longField(self) -> int: ...
    @longField.setter
    def longField(self, value: __T.Optional[int]) -> None: ...

    def getType(self) -> int: ...

    def get_intField(self) -> int: ...
    def set_intField(self, value: int) -> None: ...
    def get_setField(self) -> __T.Set[str]: ...
    def set_setField(self, value: __T.Set[str]) -> None: ...
    def get_mapField(self) -> __T.Dict[str, __T.List[str]]: ...
    def set_mapField(self, value: __T.Dict[str, __T.List[str]]) -> None: ...
    def get_binaryField(self) -> bytes: ...
    def set_binaryField(self, value: bytes) -> None: ...
    def get_longField(self) -> int: ...
    def set_longField(self, value: int) -> None: ...

    __EMPTY__: int = ...
    INTFIELD: int = ...
    SETFIELD: int = ...
    MAPFIELD: int = ...
    BINARYFIELD: int = ...
    LONGFIELD: int = ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Baz": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Baz": ...   # type: ignore
    def _to_py_deprecated(self) -> Baz: ...


class Bar:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        structField: __T.Optional[::my.Adapter1.Type] = ...,
        optionalStructField: __T.Optional[my.Adapter1.Type] = ...,
        structListField: __T.Optional[__T.List[my.Adapter1.Type]] = ...,
        optionalStructListField: __T.Optional[__T.List[my.Adapter1.Type]] = ...,
        unionField: __T.Optional[my.Adapter1.Type] = ...,
        optionalUnionField: __T.Optional[my.Adapter1.Type] = ...,
        adaptedStructField: __T.Optional[DirectlyAdapted] = ...
    ) -> None:
        ...

    @__property__
    def structField(self) -> ::my.Adapter1.Type: ...
    @structField.setter
    def structField(self, value: __T.Optional[::my.Adapter1.Type]) -> None: ...
    @__property__
    def optionalStructField(self) -> __T.Optional[my.Adapter1.Type]: ...
    @optionalStructField.setter
    def optionalStructField(self, value: __T.Optional[my.Adapter1.Type]) -> None: ...
    @__property__
    def structListField(self) -> __T.List[my.Adapter1.Type]: ...
    @structListField.setter
    def structListField(self, value: __T.Optional[__T.List[my.Adapter1.Type]]) -> None: ...
    @__property__
    def optionalStructListField(self) -> __T.Optional[__T.List[my.Adapter1.Type]]: ...
    @optionalStructListField.setter
    def optionalStructListField(self, value: __T.Optional[__T.List[my.Adapter1.Type]]) -> None: ...
    @__property__
    def unionField(self) -> my.Adapter1.Type: ...
    @unionField.setter
    def unionField(self, value: __T.Optional[my.Adapter1.Type]) -> None: ...
    @__property__
    def optionalUnionField(self) -> __T.Optional[my.Adapter1.Type]: ...
    @optionalUnionField.setter
    def optionalUnionField(self, value: __T.Optional[my.Adapter1.Type]) -> None: ...
    @__property__
    def adaptedStructField(self) -> DirectlyAdapted: ...
    @adaptedStructField.setter
    def adaptedStructField(self, value: __T.Optional[DirectlyAdapted]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Bar": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Bar": ...   # type: ignore
    def _to_py_deprecated(self) -> Bar: ...


class DirectlyAdapted:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> int: ...
    @field.setter
    def field(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.DirectlyAdapted": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.DirectlyAdapted": ...   # type: ignore
    def _to_py_deprecated(self) -> DirectlyAdapted: ...


class IndependentDirectlyAdapted:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> int: ...
    @field.setter
    def field(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.IndependentDirectlyAdapted": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.IndependentDirectlyAdapted": ...   # type: ignore
    def _to_py_deprecated(self) -> IndependentDirectlyAdapted: ...


class StructWithFieldAdapter:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[int] = ...,
        shared_field: __T.Optional[int] = ...,
        opt_shared_field: __T.Optional[int] = ...,
        opt_boxed_field: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> int: ...
    @field.setter
    def field(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def shared_field(self) -> int: ...
    @shared_field.setter
    def shared_field(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def opt_shared_field(self) -> __T.Optional[int]: ...
    @opt_shared_field.setter
    def opt_shared_field(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def opt_boxed_field(self) -> __T.Optional[int]: ...
    @opt_boxed_field.setter
    def opt_boxed_field(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.StructWithFieldAdapter": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.StructWithFieldAdapter": ...   # type: ignore
    def _to_py_deprecated(self) -> StructWithFieldAdapter: ...


class TerseAdaptedFields:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        int_field: __T.Optional[int] = ...,
        string_field: __T.Optional[str] = ...,
        set_field: __T.Optional[__T.Set[int]] = ...
    ) -> None:
        ...

    @__property__
    def int_field(self) -> int: ...
    @int_field.setter
    def int_field(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def string_field(self) -> str: ...
    @string_field.setter
    def string_field(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def set_field(self) -> __T.Set[int]: ...
    @set_field.setter
    def set_field(self, value: __T.Optional[__T.Set[int]]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.TerseAdaptedFields": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.TerseAdaptedFields": ...   # type: ignore
    def _to_py_deprecated(self) -> TerseAdaptedFields: ...


class B:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        a: __T.Optional[A] = ...
    ) -> None:
        ...

    @__property__
    def a(self) -> A: ...
    @a.setter
    def a(self, value: __T.Optional[A]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.B": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.B": ...   # type: ignore
    def _to_py_deprecated(self) -> B: ...


class A:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...



    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.A": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.A": ...   # type: ignore
    def _to_py_deprecated(self) -> A: ...


class Config:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        path: __T.Optional[str] = ...
    ) -> None:
        ...

    @__property__
    def path(self) -> str: ...
    @path.setter
    def path(self, value: __T.Optional[str]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Config": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Config": ...   # type: ignore
    def _to_py_deprecated(self) -> Config: ...


class MyStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[int] = ...,
        set_string: __T.Optional[__T.Set[str]] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> int: ...
    @field.setter
    def field(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def set_string(self) -> __T.Set[str]: ...
    @set_string.setter
    def set_string(self, value: __T.Optional[__T.Set[str]]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.MyStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.MyStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> MyStruct: ...


class AdaptTestStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        delay: __T.Optional[int] = ...,
        custom: __T.Optional[bytes] = ...,
        timeout: __T.Optional[int] = ...,
        data: __T.Optional[int] = ...,
        meta: __T.Optional[str] = ...,
        indirectionString: __T.Optional[str] = ...,
        string_data: __T.Optional[str] = ...,
        double_wrapped_bool: __T.Optional[bool] = ...,
        double_wrapped_integer: __T.Optional[int] = ...,
        binary_data: __T.Optional[bytes] = ...
    ) -> None:
        ...

    @__property__
    def delay(self) -> int: ...
    @delay.setter
    def delay(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def custom(self) -> bytes: ...
    @custom.setter
    def custom(self, value: __T.Optional[bytes]) -> None: ...
    @__property__
    def timeout(self) -> int: ...
    @timeout.setter
    def timeout(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def data(self) -> int: ...
    @data.setter
    def data(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def meta(self) -> str: ...
    @meta.setter
    def meta(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def indirectionString(self) -> str: ...
    @indirectionString.setter
    def indirectionString(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def string_data(self) -> str: ...
    @string_data.setter
    def string_data(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def double_wrapped_bool(self) -> bool: ...
    @double_wrapped_bool.setter
    def double_wrapped_bool(self, value: __T.Optional[bool]) -> None: ...
    @__property__
    def double_wrapped_integer(self) -> int: ...
    @double_wrapped_integer.setter
    def double_wrapped_integer(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def binary_data(self) -> bytes: ...
    @binary_data.setter
    def binary_data(self, value: __T.Optional[bytes]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AdaptTestStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AdaptTestStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> AdaptTestStruct: ...


class AdaptTemplatedTestStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        adaptedBool: __T.Optional[bool] = ...,
        adaptedByte: __T.Optional[int] = ...,
        adaptedShort: __T.Optional[int] = ...,
        adaptedInteger: __T.Optional[int] = ...,
        adaptedLong: __T.Optional[int] = ...,
        adaptedDouble: __T.Optional[float] = ...,
        adaptedString: __T.Optional[str] = ...,
        adaptedList: __T.Optional[__T.List[int]] = ...,
        adaptedSet: __T.Optional[__T.Set[int]] = ...,
        adaptedMap: __T.Optional[__T.Dict[int, int]] = ...,
        adaptedBoolDefault: bool = ...,
        adaptedByteDefault: int = ...,
        adaptedShortDefault: int = ...,
        adaptedIntegerDefault: int = ...,
        adaptedLongDefault: int = ...,
        adaptedDoubleDefault: float = ...,
        adaptedStringDefault: str = ...,
        adaptedEnum: ThriftAdaptedEnum = ...,
        adaptedListDefault: __T.List[int] = ...,
        adaptedSetDefault: __T.Set[int] = ...,
        adaptedMapDefault: __T.Dict[int, int] = ...,
        doubleTypedefBool: __T.Optional[bool] = ...
    ) -> None:
        ...

    @__property__
    def adaptedBool(self) -> bool: ...
    @adaptedBool.setter
    def adaptedBool(self, value: __T.Optional[bool]) -> None: ...
    @__property__
    def adaptedByte(self) -> int: ...
    @adaptedByte.setter
    def adaptedByte(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def adaptedShort(self) -> int: ...
    @adaptedShort.setter
    def adaptedShort(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def adaptedInteger(self) -> int: ...
    @adaptedInteger.setter
    def adaptedInteger(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def adaptedLong(self) -> int: ...
    @adaptedLong.setter
    def adaptedLong(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def adaptedDouble(self) -> float: ...
    @adaptedDouble.setter
    def adaptedDouble(self, value: __T.Optional[float]) -> None: ...
    @__property__
    def adaptedString(self) -> str: ...
    @adaptedString.setter
    def adaptedString(self, value: __T.Optional[str]) -> None: ...
    @__property__
    def adaptedList(self) -> __T.List[int]: ...
    @adaptedList.setter
    def adaptedList(self, value: __T.Optional[__T.List[int]]) -> None: ...
    @__property__
    def adaptedSet(self) -> __T.Set[int]: ...
    @adaptedSet.setter
    def adaptedSet(self, value: __T.Optional[__T.Set[int]]) -> None: ...
    @__property__
    def adaptedMap(self) -> __T.Dict[int, int]: ...
    @adaptedMap.setter
    def adaptedMap(self, value: __T.Optional[__T.Dict[int, int]]) -> None: ...
    @__property__
    def adaptedBoolDefault(self) -> bool: ...
    @adaptedBoolDefault.setter
    def adaptedBoolDefault(self, value: bool) -> None: ...
    @__property__
    def adaptedByteDefault(self) -> int: ...
    @adaptedByteDefault.setter
    def adaptedByteDefault(self, value: int) -> None: ...
    @__property__
    def adaptedShortDefault(self) -> int: ...
    @adaptedShortDefault.setter
    def adaptedShortDefault(self, value: int) -> None: ...
    @__property__
    def adaptedIntegerDefault(self) -> int: ...
    @adaptedIntegerDefault.setter
    def adaptedIntegerDefault(self, value: int) -> None: ...
    @__property__
    def adaptedLongDefault(self) -> int: ...
    @adaptedLongDefault.setter
    def adaptedLongDefault(self, value: int) -> None: ...
    @__property__
    def adaptedDoubleDefault(self) -> float: ...
    @adaptedDoubleDefault.setter
    def adaptedDoubleDefault(self, value: float) -> None: ...
    @__property__
    def adaptedStringDefault(self) -> str: ...
    @adaptedStringDefault.setter
    def adaptedStringDefault(self, value: str) -> None: ...
    @__property__
    def adaptedEnum(self) -> ThriftAdaptedEnum: ...
    @adaptedEnum.setter
    def adaptedEnum(self, value: ThriftAdaptedEnum) -> None: ...
    @__property__
    def adaptedListDefault(self) -> __T.List[int]: ...
    @adaptedListDefault.setter
    def adaptedListDefault(self, value: __T.List[int]) -> None: ...
    @__property__
    def adaptedSetDefault(self) -> __T.Set[int]: ...
    @adaptedSetDefault.setter
    def adaptedSetDefault(self, value: __T.Set[int]) -> None: ...
    @__property__
    def adaptedMapDefault(self) -> __T.Dict[int, int]: ...
    @adaptedMapDefault.setter
    def adaptedMapDefault(self, value: __T.Dict[int, int]) -> None: ...
    @__property__
    def doubleTypedefBool(self) -> bool: ...
    @doubleTypedefBool.setter
    def doubleTypedefBool(self, value: __T.Optional[bool]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AdaptTemplatedTestStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AdaptTemplatedTestStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> AdaptTemplatedTestStruct: ...


class AdaptTemplatedNestedTestStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        adaptedStruct: __T.Optional[AdaptTemplatedTestStruct] = ...
    ) -> None:
        ...

    @__property__
    def adaptedStruct(self) -> AdaptTemplatedTestStruct: ...
    @adaptedStruct.setter
    def adaptedStruct(self, value: __T.Optional[AdaptTemplatedTestStruct]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AdaptTemplatedNestedTestStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AdaptTemplatedNestedTestStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> AdaptTemplatedNestedTestStruct: ...


class AdaptTestUnion:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        delay: __T.Optional[int] = ...,
        custom: __T.Optional[bytes] = ...
    ) -> None:
        ...

    @__property__
    def delay(self) -> int: ...
    @delay.setter
    def delay(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def custom(self) -> bytes: ...
    @custom.setter
    def custom(self, value: __T.Optional[bytes]) -> None: ...

    def getType(self) -> int: ...

    def get_delay(self) -> int: ...
    def set_delay(self, value: int) -> None: ...
    def get_custom(self) -> bytes: ...
    def set_custom(self, value: bytes) -> None: ...

    __EMPTY__: int = ...
    DELAY: int = ...
    CUSTOM: int = ...

    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AdaptTestUnion": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AdaptTestUnion": ...   # type: ignore
    def _to_py_deprecated(self) -> AdaptTestUnion: ...


class AdaptedStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        data: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def data(self) -> int: ...
    @data.setter
    def data(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AdaptedStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AdaptedStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> AdaptedStruct: ...


class DirectlyAdaptedStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        data: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def data(self) -> int: ...
    @data.setter
    def data(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.DirectlyAdaptedStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.DirectlyAdaptedStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> DirectlyAdaptedStruct: ...


class StructFieldAdaptedStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        adaptedStruct: __T.Optional[AdaptedStruct] = ...,
        adaptedTypedef: __T.Optional[AdaptedStruct] = ...,
        directlyAdapted: __T.Optional[DirectlyAdaptedStruct] = ...,
        typedefOfAdapted: __T.Optional[DirectlyAdaptedStruct] = ...
    ) -> None:
        ...

    @__property__
    def adaptedStruct(self) -> AdaptedStruct: ...
    @adaptedStruct.setter
    def adaptedStruct(self, value: __T.Optional[AdaptedStruct]) -> None: ...
    @__property__
    def adaptedTypedef(self) -> AdaptedStruct: ...
    @adaptedTypedef.setter
    def adaptedTypedef(self, value: __T.Optional[AdaptedStruct]) -> None: ...
    @__property__
    def directlyAdapted(self) -> DirectlyAdaptedStruct: ...
    @directlyAdapted.setter
    def directlyAdapted(self, value: __T.Optional[DirectlyAdaptedStruct]) -> None: ...
    @__property__
    def typedefOfAdapted(self) -> DirectlyAdaptedStruct: ...
    @typedefOfAdapted.setter
    def typedefOfAdapted(self, value: __T.Optional[DirectlyAdaptedStruct]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.StructFieldAdaptedStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.StructFieldAdaptedStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> StructFieldAdaptedStruct: ...


class CircularAdaptee:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[CircularStruct] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> CircularStruct: ...
    @field.setter
    def field(self, value: __T.Optional[CircularStruct]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.CircularAdaptee": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.CircularAdaptee": ...   # type: ignore
    def _to_py_deprecated(self) -> CircularAdaptee: ...


class CircularStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        field: __T.Optional[CircularAdaptee] = ...
    ) -> None:
        ...

    @__property__
    def field(self) -> __T.Optional[CircularAdaptee]: ...
    @field.setter
    def field(self, value: __T.Optional[CircularAdaptee]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.CircularStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.CircularStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> CircularStruct: ...


class ReorderedStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        reordered_dependent_adapted: __T.Optional[DeclaredAfterStruct] = ...
    ) -> None:
        ...

    @__property__
    def reordered_dependent_adapted(self) -> DeclaredAfterStruct: ...
    @reordered_dependent_adapted.setter
    def reordered_dependent_adapted(self, value: __T.Optional[DeclaredAfterStruct]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.ReorderedStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.ReorderedStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> ReorderedStruct: ...


class DeclaredAfterStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...



    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.DeclaredAfterStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.DeclaredAfterStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> DeclaredAfterStruct: ...


class RenamedStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        data: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def data(self) -> int: ...
    @data.setter
    def data(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.RenamedStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.RenamedStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> RenamedStruct: ...


class SameNamespaceStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        data: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def data(self) -> int: ...
    @data.setter
    def data(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.SameNamespaceStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.SameNamespaceStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> SameNamespaceStruct: ...


class HeapAllocated:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...



    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.HeapAllocated": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.HeapAllocated": ...   # type: ignore
    def _to_py_deprecated(self) -> HeapAllocated: ...


class MoveOnly:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        ptr: __T.Optional[HeapAllocated] = ...
    ) -> None:
        ...

    @__property__
    def ptr(self) -> HeapAllocated: ...
    @ptr.setter
    def ptr(self, value: __T.Optional[HeapAllocated]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.MoveOnly": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.MoveOnly": ...   # type: ignore
    def _to_py_deprecated(self) -> MoveOnly: ...


class AlsoMoveOnly:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        ptr: __T.Optional[int] = ...
    ) -> None:
        ...

    @__property__
    def ptr(self) -> int: ...
    @ptr.setter
    def ptr(self, value: __T.Optional[int]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.AlsoMoveOnly": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.AlsoMoveOnly": ...   # type: ignore
    def _to_py_deprecated(self) -> AlsoMoveOnly: ...


class ApplyAdapter:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...



    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.ApplyAdapter": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.ApplyAdapter": ...   # type: ignore
    def _to_py_deprecated(self) -> ApplyAdapter: ...


class TransitiveAdapted:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self
    ) -> None:
        ...



    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.TransitiveAdapted": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.TransitiveAdapted": ...   # type: ignore
    def _to_py_deprecated(self) -> TransitiveAdapted: ...


class CountingStruct:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        regularInt: __T.Optional[int] = ...,
        countingInt: __T.Optional[int] = ...,
        regularString: __T.Optional[str] = ...
    ) -> None:
        ...

    @__property__
    def regularInt(self) -> __T.Optional[int]: ...
    @regularInt.setter
    def regularInt(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def countingInt(self) -> __T.Optional[int]: ...
    @countingInt.setter
    def countingInt(self, value: __T.Optional[int]) -> None: ...
    @__property__
    def regularString(self) -> __T.Optional[str]: ...
    @regularString.setter
    def regularString(self, value: __T.Optional[str]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.CountingStruct": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.CountingStruct": ...   # type: ignore
    def _to_py_deprecated(self) -> CountingStruct: ...


class Person:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        name: __T.Optional[str] = ...
    ) -> None:
        ...

    @__property__
    def name(self) -> str: ...
    @name.setter
    def name(self, value: __T.Optional[str]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Person": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Person": ...   # type: ignore
    def _to_py_deprecated(self) -> Person: ...


class Person2:
    thrift_spec: __T.Tuple[__T.Optional[__T.Tuple[int, int, str, __T.Any, __T.Optional[int], int]]]
    thrift_field_annotations: __T.Dict[int, __T.Dict[str, str]]
    thrift_struct_annotations: __T.Dict[str, str]

    def __init__(
        self,
        name: __T.Optional[str] = ...
    ) -> None:
        ...

    @__property__
    def name(self) -> str: ...
    @name.setter
    def name(self, value: __T.Optional[str]) -> None: ...


    def isUnion(self) -> bool: ...
    def checkRequired(self) -> None: ...
    def read(self, iprot: TProtocolBase) -> None: ...
    @__T.overload
    def readFromJson(self, json: __T.Dict[str, __T.Any], is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    @__T.overload
    def readFromJson(self, json: str, is_text: bool = ..., **kwargs: __T.Any) -> None: ...
    def write(self, oprot: TProtocolBase) -> None: ...
    def __eq__(self, other: __T.Any) -> bool: ...
    def __ne__(self, other: __T.Any) -> bool: ...
    def __dir__(self) -> __T.Sequence[str]: ...
    def _to_python(self) -> "facebook.thrift.test.module.thrift_types.Person2": ...   # type: ignore
    def _to_py3(self) -> "facebook.thrift.test.module.types.Person2": ...   # type: ignore
    def _to_py_deprecated(self) -> Person2: ...


SetWithAdapter = __T.Set[str]
StringWithAdapter = str
ListWithElemAdapter = __T.List[str]
ListWithElemAdapter_withAdapter = __T.List[str]
MyI64 = int
DoubleTypedefI64 = int
MyI32 = int
FooWithAdapter = Foo
StructWithAdapter = my.Adapter2.Type
UnionWithAdapter = my.Adapter2.Type
AdaptedA = A
DurationMs = int
AdaptedBool = bool
AdaptedByte = int
AdaptedShort = int
AdaptedInteger = int
AdaptedLong = int
AdaptedDouble = float
AdaptedString = str
DoubleTypedefBool = bool
CustomProtocolType = bytes
IndirectionString = str
AdaptedEnum = ThriftAdaptedEnum
AdaptedTypedef = AdaptedStruct
TypedefOfDirect = DirectlyAdaptedStruct
AdaptedCircularAdaptee = CircularAdaptee
CountingInt = int
