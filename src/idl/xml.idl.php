<?php
/**
 * Automatically generated by running "php schema.php xml".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "xml_parser_create",
    'desc'   => "xml_parser_create() creates a new XML parser and returns a resource handle referencing it to be used by the other XML functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Resource,
      'desc'   => "Returns a resource handle for the new XML parser.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The optional encoding specifies the character encoding for the input/output in PHP 4. Starting from PHP 5, the input encoding is automatically detected, so that the encoding parameter specifies only the output encoding. In PHP 4, the default output encoding is the same as the input charset. If empty string is passed, the parser attempts to identify which encoding the document is encoded in by looking at the heading 3 or 4 bytes. In PHP 5.0.0 and 5.0.1, the default output charset is ISO-8859-1, while in PHP 5.0.2 and upper is UTF-8. The supported encodings are ISO-8859-1, UTF-8 and US-ASCII.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parser_free",
    'desc'   => "Frees the given XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or else it frees the parser and returns TRUE. xml_parser_get_option xml_parser_create Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to free.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parse",
    'desc'   => "xml_parse() parses an XML document. The handlers for the configured events are called as many times as necessary.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "Returns 1 on success or 0 on failure.\n\nFor unsuccessful parses, error information can be retrieved with xml_get_error_code(), xml_error_string(), xml_get_current_line_number(), xml_get_current_column_number() and xml_get_current_byte_index().\n\nEntity errors are reported at the end of the data thus only if is_final is set and TRUE. xml_parser_create_ns xml_parse_into_struct Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to use.",
      ),
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "Chunk of data to parse. A document may be parsed piece-wise by calling xml_parse() several times with new data, as long as the is_final parameter is set and TRUE when the last data is parsed.",
      ),
      array(
        'name'   => "is_final",
        'type'   => Boolean,
        'value'  => "true",
        'desc'   => "If set and TRUE, data is the last piece of data sent in this parse.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parse_into_struct",
    'desc'   => "This function parses an XML file into 2 parallel array structures, one (index) containing pointers to the location of the appropriate values in the values array. These last two parameters must be passed by reference.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "xml_parse_into_struct() returns 0 for failure and 1 for success. This is not the same as FALSE and TRUE, be careful with operators such as ===.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "data",
        'type'   => String,
      ),
      array(
        'name'   => "values",
        'type'   => Variant | Reference,
      ),
      array(
        'name'   => "index",
        'type'   => Variant | Reference,
        'value'  => "null",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parser_create_ns",
    'desc'   => "xml_parser_create_ns() creates a new XML parser with XML namespace support and returns a resource handle referencing it to be used by the other XML functions.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Resource,
      'desc'   => "Returns a resource handle for the new XML parser.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The optional encoding specifies the character encoding for the input/output in PHP 4. Starting from PHP 5, the input encoding is automatically detected, so that the encoding parameter specifies only the output encoding. In PHP 4, the default output encoding is the same as the input charset. In PHP 5.0.0 and 5.0.1, the default output charset is ISO-8859-1, while in PHP 5.0.2 and upper is UTF-8. The supported encodings are ISO-8859-1, UTF-8 and US-ASCII.",
      ),
      array(
        'name'   => "separator",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "With a namespace aware parser tag parameters passed to the various handler functions will consist of namespace and tag name separated by the string specified in seperator.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parser_get_option",
    'desc'   => "Gets an option value from an XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser or if option isn't valid (generates also a E_WARNING). Else the option's value is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to get an option from.",
      ),
      array(
        'name'   => "option",
        'type'   => Int32,
        'desc'   => "Which option to fetch. XML_OPTION_CASE_FOLDING and XML_OPTION_TARGET_ENCODING are available. See xml_parser_set_option() for their description.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_parser_set_option",
    'desc'   => "Sets an option in an XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or if the option could not be set. Else the option is set and TRUE is returned. xml_set_character_data_handler xml_parser_get_option Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to set an option in.",
      ),
      array(
        'name'   => "option",
        'type'   => Int32,
        'desc'   => "Which option to set. See below.\n\nThe following options are available: XML parser options Option constant Data type Description XML_OPTION_CASE_FOLDING integer Controls whether case-folding is enabled for this XML parser. Enabled by default. XML_OPTION_SKIP_TAGSTART integer Specify how many characters should be skipped in the beginning of a tag name. XML_OPTION_SKIP_WHITE integer Whether to skip values consisting of whitespace characters. XML_OPTION_TARGET_ENCODING string Sets which target encoding to use in this XML parser.By default, it is set to the same as the source encoding used by xml_parser_create(). Supported target encodings are ISO-8859-1, US-ASCII and UTF-8.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "The option's new value.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_character_data_handler",
    'desc'   => "Sets the character data handler function for the XML parser parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. xml_set_default_handler xml_parser_set_option Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept two parameters: handler ( resource \$parser , string \$data ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_default_handler",
    'desc'   => "Sets the default handler function for the XML parser parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept two parameters: handler ( resource \$parser , string \$data ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_element_handler",
    'desc'   => "Sets the element handler functions for the XML parser. start_element_handler and end_element_handler are strings containing the names of functions that must exist when xml_parse() is called for parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure. xml_set_end_namespace_decl_handler xml_set_default_handler Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "start_element_handler",
        'type'   => Variant,
        'desc'   => "The function named by start_element_handler must accept three parameters: start_element_handler ( resource \$parser , string \$name , array \$attribs ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
      array(
        'name'   => "end_element_handler",
        'type'   => Variant,
        'desc'   => "The second parameter, name, contains the name of the element for which this handler is called.If case-folding is in effect for this parser, the element name will be in uppercase letters.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_processing_instruction_handler",
    'desc'   => "Sets the processing instruction (PI) handler function for the XML parser parser.\n\nA processing instruction has the following format: target data?> You can put PHP code into such a tag, but be aware of one limitation: in an XML PI, the PI end tag (?>) can not be quoted, so this character sequence should not appear in the PHP code you embed with PIs in XML documents.If it does, the rest of the PHP code, as well as the \"real\" PI end tag, will be treated as character data.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept three parameters: handler ( resource \$parser , string \$target , string \$data ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_start_namespace_decl_handler",
    'desc'   => "Set a handler to be called when a namespace is declared. Namespace declarations occur inside start tags. But the namespace declaration start handler is called before the start tag handler for each namespace declared in that start tag.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser.",
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept four parameters, and should return an integer value. If the value returned from the handler is FALSE (which it will be if no value is returned), the XML parser will stop parsing and xml_get_error_code() will return XML_ERROR_EXTERNAL_ENTITY_HANDLING. handler ( resource \$parser , string \$user_data , string \$prefix , string \$uri ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_end_namespace_decl_handler",
    'desc'   => "Set a handler to be called when leaving the scope of a namespace declaration. This will be called, for each namespace declaration, after the handler for the end tag of the element in which the namespace was declared.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser.",
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept three parameters, and should return an integer value. If the value returned from the handler is FALSE (which it will be if no value is returned), the XML parser will stop parsing and xml_get_error_code() will return XML_ERROR_EXTERNAL_ENTITY_HANDLING. handler ( resource \$parser , string \$user_data , string \$prefix ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_unparsed_entity_decl_handler",
    'desc'   => "Sets the unparsed entity declaration handler function for the XML parser parser.\n\nThe handler will be called if the XML parser encounters an external entity declaration with an NDATA declaration, like the following:\n\n\n\nSee » section 4.2.2 of the XML 1.0 spec for the definition of notation declared external entities.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept six parameters: handler ( resource \$parser , string \$entity_name , string \$base , string \$system_id , string \$public_id , string \$notation_name ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_external_entity_ref_handler",
    'desc'   => "Sets the external entity reference handler function for the XML parser parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept five parameters, and should return an integer value.If the value returned from the handler is FALSE (which it will be if no value is returned), the XML parser will stop parsing and xml_get_error_code() will return XML_ERROR_EXTERNAL_ENTITY_HANDLING. handler ( resource \$parser , string \$open_entity_names , string \$base , string \$system_id , string \$public_id ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_notation_decl_handler",
    'desc'   => "Sets the notation declaration handler function for the XML parser parser.\n\nA notation declaration is part of the document's DTD and has the following format:\n\nSee » section 4.7 of the XML 1.0 spec for the definition of notation declarations.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "handler",
        'type'   => Variant,
        'desc'   => "handler is a string containing the name of a function that must exist when xml_parse() is called for parser.\n\nThe function named by handler must accept five parameters: handler ( resource \$parser , string \$notation_name , string \$base , string \$system_id , string \$public_id ) parser The first parameter, parser, is a reference to the XML parser calling the handler.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_set_object",
    'desc'   => "This function allows to use parser inside object. All callback functions could be set with xml_set_element_handler() etc and assumed to be methods of object.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
      ),
      array(
        'name'   => "object",
        'type'   => Variant | Reference,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_get_current_byte_index",
    'desc'   => "Gets the current byte index of the given XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or else it returns which byte index the parser is currently at in its data buffer (starting at 0).",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to get byte index from.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_get_current_column_number",
    'desc'   => "Gets the current column number of the given XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or else it returns which column on the current line (as given by xml_get_current_line_number()) the parser is currently at.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to get column number from.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_get_current_line_number",
    'desc'   => "Gets the current line number for the given XML parser.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or else it returns which line the parser is currently at in its data buffer.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to get line number from.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_get_error_code",
    'desc'   => "Gets the XML parser error code.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int32,
      'desc'   => "This function returns FALSE if parser does not refer to a valid parser, or else it returns one of the error codes listed in the error codes section.",
    ),
    'args'   => array(
      array(
        'name'   => "parser",
        'type'   => Resource,
        'desc'   => "A reference to the XML parser to get error code from.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "xml_error_string",
    'desc'   => "Gets the XML parser error string associated with the given code.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Returns a string with a textual description of the error code, or FALSE if no description was found.",
    ),
    'args'   => array(
      array(
        'name'   => "code",
        'type'   => Int32,
        'desc'   => "An error code from xml_get_error_code().",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "utf8_decode",
    'desc'   => "This function decodes data, assumed to be UTF-8 encoded, to ISO-8859-1.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Returns the ISO-8859-1 translation of data.",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "An UTF-8 encoded string.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "utf8_encode",
    'desc'   => "This function encodes the string data to UTF-8, and returns the encoded version. UTF-8 is a standard mechanism used by Unicode for encoding wide character values into a byte stream. UTF-8 is transparent to plain ASCII characters, is self-synchronized (meaning it is possible for a program to figure out where in the bytestream characters start) and can be used with normal string comparison functions for sorting and such. PHP encodes UTF-8 characters in up to four bytes, like this: UTF-8 encoding bytes bits representation 1 7 0bbbbbbb 2 11 110bbbbb 10bbbbbb 3 16 1110bbbb 10bbbbbb 10bbbbbb 4 21 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb Each b represents a bit that can be used to store character data.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "Returns the UTF-8 translation of data. xml_error_string utf8_decode Last updated: Fri, 03 Sep 2010  ",
    ),
    'args'   => array(
      array(
        'name'   => "data",
        'type'   => String,
        'desc'   => "An ISO-8859-1 string.",
      ),
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

