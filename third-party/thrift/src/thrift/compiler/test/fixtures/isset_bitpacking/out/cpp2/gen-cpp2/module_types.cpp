/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/isset_bitpacking/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/isset_bitpacking/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/isset_bitpacking/gen-cpp2/module_types_custom_protocol.h"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/isset_bitpacking/gen-cpp2/module_data.h"
[[maybe_unused]] static constexpr std::string_view kModuleName = "module";


#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::Default>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::Default>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace cpp2 {

std::string_view Default::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<Default>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view Default::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<Default>::name;
}

Default::Default(const Default&) = default;
Default& Default::operator=(const Default&) = default;
Default::Default() :
    __fbthrift_field_field1(),
    __fbthrift_field_field2(),
    __fbthrift_field_field4() {
}


Default::~Default() {}

Default::Default([[maybe_unused]] Default&& other) noexcept :
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

Default& Default::operator=([[maybe_unused]] Default&& other) noexcept {
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


Default::Default(apache::thrift::FragileConstructor, ::std::int32_t field1__arg, ::std::int32_t field2__arg, ::std::string field3__arg, double field4__arg) :
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void Default::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field1 = ::std::int32_t();
  this->__fbthrift_field_field2 = ::std::int32_t();
  this->__fbthrift_field_field3 = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_field4 = double();
  __isset = {};
}

void Default::__fbthrift_clear_terse_fields() {
}

bool Default::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__isset.get(1)) &&
 !(this->__isset.get(2)) &&
 !(this->__isset.get(3));
}

bool Default::operator==([[maybe_unused]] const Default& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool Default::operator<([[maybe_unused]] const Default& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::int32_t* Default::get_field1() const& {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t* Default::get_field1() & {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t& Default::set_field1(::std::int32_t field1_) {
  field1_ref() = field1_;
  return __fbthrift_field_field1;
}

const ::std::int32_t* Default::get_field2() const& {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t* Default::get_field2() & {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t& Default::set_field2(::std::int32_t field2_) {
  field2_ref() = field2_;
  return __fbthrift_field_field2;
}

const ::std::string* Default::get_field3() const& {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

::std::string* Default::get_field3() & {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

const double* Default::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double* Default::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double& Default::set_field4(double field4_) {
  field4_ref() = field4_;
  return __fbthrift_field_field4;
}

void swap([[maybe_unused]] Default& a, [[maybe_unused]] Default& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}



} // namespace cpp2

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::NonAtomic>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::NonAtomic>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace cpp2 {

std::string_view NonAtomic::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<NonAtomic>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view NonAtomic::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<NonAtomic>::name;
}

NonAtomic::NonAtomic(const NonAtomic&) = default;
NonAtomic& NonAtomic::operator=(const NonAtomic&) = default;
NonAtomic::NonAtomic() :
    __fbthrift_field_field1(),
    __fbthrift_field_field2(),
    __fbthrift_field_field4() {
}


NonAtomic::~NonAtomic() {}

NonAtomic::NonAtomic([[maybe_unused]] NonAtomic&& other) noexcept :
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

NonAtomic& NonAtomic::operator=([[maybe_unused]] NonAtomic&& other) noexcept {
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


NonAtomic::NonAtomic(apache::thrift::FragileConstructor, ::std::int32_t field1__arg, ::std::int32_t field2__arg, ::std::string field3__arg, double field4__arg) :
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void NonAtomic::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field1 = ::std::int32_t();
  this->__fbthrift_field_field2 = ::std::int32_t();
  this->__fbthrift_field_field3 = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_field4 = double();
  __isset = {};
}

void NonAtomic::__fbthrift_clear_terse_fields() {
}

bool NonAtomic::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__isset.get(1)) &&
 !(this->__isset.get(2)) &&
 !(this->__isset.get(3));
}

bool NonAtomic::operator==([[maybe_unused]] const NonAtomic& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool NonAtomic::operator<([[maybe_unused]] const NonAtomic& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::int32_t* NonAtomic::get_field1() const& {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t* NonAtomic::get_field1() & {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t& NonAtomic::set_field1(::std::int32_t field1_) {
  field1_ref() = field1_;
  return __fbthrift_field_field1;
}

const ::std::int32_t* NonAtomic::get_field2() const& {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t* NonAtomic::get_field2() & {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t& NonAtomic::set_field2(::std::int32_t field2_) {
  field2_ref() = field2_;
  return __fbthrift_field_field2;
}

const ::std::string* NonAtomic::get_field3() const& {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

::std::string* NonAtomic::get_field3() & {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

const double* NonAtomic::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double* NonAtomic::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double& NonAtomic::set_field4(double field4_) {
  field4_ref() = field4_;
  return __fbthrift_field_field4;
}

void swap([[maybe_unused]] NonAtomic& a, [[maybe_unused]] NonAtomic& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}



} // namespace cpp2

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::Atomic>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::Atomic>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace cpp2 {

std::string_view Atomic::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<Atomic>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view Atomic::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<Atomic>::name;
}

Atomic::Atomic(const Atomic&) = default;
Atomic& Atomic::operator=(const Atomic&) = default;
Atomic::Atomic() :
    __fbthrift_field_field1(),
    __fbthrift_field_field2(),
    __fbthrift_field_field4() {
}


Atomic::~Atomic() {}

Atomic::Atomic([[maybe_unused]] Atomic&& other) noexcept :
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

Atomic& Atomic::operator=([[maybe_unused]] Atomic&& other) noexcept {
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


Atomic::Atomic(apache::thrift::FragileConstructor, ::std::int32_t field1__arg, ::std::int32_t field2__arg, ::std::string field3__arg, double field4__arg) :
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void Atomic::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field1 = ::std::int32_t();
  this->__fbthrift_field_field2 = ::std::int32_t();
  this->__fbthrift_field_field3 = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_field4 = double();
  __isset = {};
}

void Atomic::__fbthrift_clear_terse_fields() {
}

bool Atomic::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__isset.get(1)) &&
 !(this->__isset.get(2)) &&
 !(this->__isset.get(3));
}

bool Atomic::operator==([[maybe_unused]] const Atomic& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool Atomic::operator<([[maybe_unused]] const Atomic& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::int32_t* Atomic::get_field1() const& {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t* Atomic::get_field1() & {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t& Atomic::set_field1(::std::int32_t field1_) {
  field1_ref() = field1_;
  return __fbthrift_field_field1;
}

const ::std::int32_t* Atomic::get_field2() const& {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t* Atomic::get_field2() & {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t& Atomic::set_field2(::std::int32_t field2_) {
  field2_ref() = field2_;
  return __fbthrift_field_field2;
}

const ::std::string* Atomic::get_field3() const& {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

::std::string* Atomic::get_field3() & {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

const double* Atomic::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double* Atomic::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double& Atomic::set_field4(double field4_) {
  field4_ref() = field4_;
  return __fbthrift_field_field4;
}

void swap([[maybe_unused]] Atomic& a, [[maybe_unused]] Atomic& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}



} // namespace cpp2

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::cpp2::AtomicFoo>::translateFieldName(
    std::string_view _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::cpp2::AtomicFoo>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache
#endif


namespace cpp2 {

std::string_view AtomicFoo::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AtomicFoo>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AtomicFoo::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AtomicFoo>::name;
}

AtomicFoo::AtomicFoo(const AtomicFoo&) = default;
AtomicFoo& AtomicFoo::operator=(const AtomicFoo&) = default;
AtomicFoo::AtomicFoo() :
    __fbthrift_field_field1(),
    __fbthrift_field_field2(),
    __fbthrift_field_field4() {
}


AtomicFoo::~AtomicFoo() {}

AtomicFoo::AtomicFoo([[maybe_unused]] AtomicFoo&& other) noexcept :
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

AtomicFoo& AtomicFoo::operator=([[maybe_unused]] AtomicFoo&& other) noexcept {
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


AtomicFoo::AtomicFoo(apache::thrift::FragileConstructor, ::std::int32_t field1__arg, ::std::int32_t field2__arg, ::std::string field3__arg, double field4__arg) :
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}

#ifndef __FBTHRIFT_SEPARATE_SERIALIZATION
#endif

void AtomicFoo::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field1 = ::std::int32_t();
  this->__fbthrift_field_field2 = ::std::int32_t();
  this->__fbthrift_field_field3 = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_field4 = double();
  __isset = {};
}

void AtomicFoo::__fbthrift_clear_terse_fields() {
}

bool AtomicFoo::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__isset.get(1)) &&
 !(this->__isset.get(2)) &&
 !(this->__isset.get(3));
}

bool AtomicFoo::operator==([[maybe_unused]] const AtomicFoo& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AtomicFoo::operator<([[maybe_unused]] const AtomicFoo& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::int32_t* AtomicFoo::get_field1() const& {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t* AtomicFoo::get_field1() & {
  return field1_ref().has_value() ? std::addressof(__fbthrift_field_field1) : nullptr;
}

::std::int32_t& AtomicFoo::set_field1(::std::int32_t field1_) {
  field1_ref() = field1_;
  return __fbthrift_field_field1;
}

const ::std::int32_t* AtomicFoo::get_field2() const& {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t* AtomicFoo::get_field2() & {
  return field2_ref().has_value() ? std::addressof(__fbthrift_field_field2) : nullptr;
}

::std::int32_t& AtomicFoo::set_field2(::std::int32_t field2_) {
  field2_ref() = field2_;
  return __fbthrift_field_field2;
}

const ::std::string* AtomicFoo::get_field3() const& {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

::std::string* AtomicFoo::get_field3() & {
  return field3_ref().has_value() ? std::addressof(__fbthrift_field_field3) : nullptr;
}

const double* AtomicFoo::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double* AtomicFoo::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

double& AtomicFoo::set_field4(double field4_) {
  field4_ref() = field4_;
  return __fbthrift_field_field4;
}

void swap([[maybe_unused]] AtomicFoo& a, [[maybe_unused]] AtomicFoo& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}



} // namespace cpp2

namespace cpp2 { namespace {
[[maybe_unused]] FOLLY_ERASE void validateAdapters() {
}
}} // namespace cpp2
namespace apache::thrift::detail::annotation {
}
