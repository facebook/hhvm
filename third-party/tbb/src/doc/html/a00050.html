<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00249.html">tbb</a></li><li class="navelem"><b>interface5</b></li><li class="navelem"><a class="el" href="a00050.html">concurrent_hash_map</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00376.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00272.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Unordered map from Key to T.  
 <a href="a00050.html#details">More...</a></p>

<p><code>#include &lt;concurrent_hash_map.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="a00050.png" usemap="#tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;_map" alt=""/>
  <map id="tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;_map" name="tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows write access to elements and combines data access, locking, and garbage collection.  <a href="a00017.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">accessor_not_used</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">bucket_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bucket accessor is to find, rehash, acquire a lock, and access a bucket  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">call_clear_on_leave</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">const_accessor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines data access, locking, and garbage collection.  <a href="a00061.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a73476eabf0605a4a17e33eca379b567c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73476eabf0605a4a17e33eca379b567c"></a>
typedef Key&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr class="separator:a73476eabf0605a4a17e33eca379b567c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f82b7e1255cd4a7ab13f694f04e0a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f82b7e1255cd4a7ab13f694f04e0a2"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><b>mapped_type</b></td></tr>
<tr class="separator:a09f82b7e1255cd4a7ab13f694f04e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10da770ec791fd8f3bddbf19d852b2f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10da770ec791fd8f3bddbf19d852b2f6"></a>
typedef std::pair&lt; const Key, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:a10da770ec791fd8f3bddbf19d852b2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4346b898af1007960c70b1d5a12b3dda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4346b898af1007960c70b1d5a12b3dda"></a>
typedef hash_map_base::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr class="separator:a4346b898af1007960c70b1d5a12b3dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6344f41fc1b2aae8b310442f609db0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae6344f41fc1b2aae8b310442f609db0"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr class="separator:aae6344f41fc1b2aae8b310442f609db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fca882f67e98d54a675c9b75db3cc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8fca882f67e98d54a675c9b75db3cc0"></a>
typedef value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr class="separator:af8fca882f67e98d54a675c9b75db3cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf14214618545aa7e0aa59a3af4a6bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf14214618545aa7e0aa59a3af4a6bd"></a>
typedef const value_type *&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr class="separator:acaf14214618545aa7e0aa59a3af4a6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5064777ff7c17e294d74ca60f96f28db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5064777ff7c17e294d74ca60f96f28db"></a>
typedef value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr class="separator:a5064777ff7c17e294d74ca60f96f28db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6291ee6059597aac8f59dc8fd5558036"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6291ee6059597aac8f59dc8fd5558036"></a>
typedef const value_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr class="separator:a6291ee6059597aac8f59dc8fd5558036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af7bf91f1cbd859aef1ffc6197b41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6af7bf91f1cbd859aef1ffc6197b41a"></a>
typedef <br class="typebreak"/>
internal::hash_map_iterator<br class="typebreak"/>
&lt; <a class="el" href="a00050.html">concurrent_hash_map</a>, <br class="typebreak"/>
value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:ae6af7bf91f1cbd859aef1ffc6197b41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af416067eaf691c88e6b73bf3b3323f66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af416067eaf691c88e6b73bf3b3323f66"></a>
typedef <br class="typebreak"/>
internal::hash_map_iterator<br class="typebreak"/>
&lt; <a class="el" href="a00050.html">concurrent_hash_map</a>, const <br class="typebreak"/>
value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:af416067eaf691c88e6b73bf3b3323f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69508e67134dd5282b89e1847e71c31b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69508e67134dd5282b89e1847e71c31b"></a>
typedef <br class="typebreak"/>
internal::hash_map_range<br class="typebreak"/>
&lt; iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>range_type</b></td></tr>
<tr class="separator:a69508e67134dd5282b89e1847e71c31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9d06751969eacda84b01582e4aa1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b9d06751969eacda84b01582e4aa1d2"></a>
typedef <br class="typebreak"/>
internal::hash_map_range<br class="typebreak"/>
&lt; const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_range_type</b></td></tr>
<tr class="separator:a0b9d06751969eacda84b01582e4aa1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c266c1560f7faa64772d349d0280a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85c266c1560f7faa64772d349d0280a4"></a>
typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b></td></tr>
<tr class="separator:a85c266c1560f7faa64772d349d0280a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa3a9767b525144a2afb69ed125714c53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3a9767b525144a2afb69ed125714c53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aa3a9767b525144a2afb69ed125714c53">concurrent_hash_map</a> (const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:aa3a9767b525144a2afb69ed125714c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty table. <br/></td></tr>
<tr class="separator:aa3a9767b525144a2afb69ed125714c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae76e1252b56b107685f8746e0f6a1f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae76e1252b56b107685f8746e0f6a1f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aae76e1252b56b107685f8746e0f6a1f4">concurrent_hash_map</a> (size_type n, const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:aae76e1252b56b107685f8746e0f6a1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty table with n preallocated buckets. This number serves also as initial concurrency level. <br/></td></tr>
<tr class="separator:aae76e1252b56b107685f8746e0f6a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a73b86f9a5e9836b38713e56c546654"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a73b86f9a5e9836b38713e56c546654"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8a73b86f9a5e9836b38713e56c546654">concurrent_hash_map</a> (const <a class="el" href="a00050.html">concurrent_hash_map</a> &amp;table, const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a8a73b86f9a5e9836b38713e56c546654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a8a73b86f9a5e9836b38713e56c546654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd04845683b15a590913a72a19fa3dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd04845683b15a590913a72a19fa3dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2bd04845683b15a590913a72a19fa3dc">concurrent_hash_map</a> (<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&amp;table)</td></tr>
<tr class="memdesc:a2bd04845683b15a590913a72a19fa3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:a2bd04845683b15a590913a72a19fa3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad642e497153df5669e6454acef095675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad642e497153df5669e6454acef095675"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ad642e497153df5669e6454acef095675">concurrent_hash_map</a> (<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&amp;table, const allocator_type &amp;a)</td></tr>
<tr class="memdesc:ad642e497153df5669e6454acef095675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br/></td></tr>
<tr class="separator:ad642e497153df5669e6454acef095675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56fc19d656099d49051f3c363cefc89"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad56fc19d656099d49051f3c363cefc89"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ad56fc19d656099d49051f3c363cefc89"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#ad56fc19d656099d49051f3c363cefc89">concurrent_hash_map</a> (I first, I last, const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:ad56fc19d656099d49051f3c363cefc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction with copying iteration range and given allocator instance. <br/></td></tr>
<tr class="separator:ad56fc19d656099d49051f3c363cefc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57149f90060b033b1f2493f2a88ef291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57149f90060b033b1f2493f2a88ef291"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a57149f90060b033b1f2493f2a88ef291">concurrent_hash_map</a> (std::initializer_list&lt; value_type &gt; il, const allocator_type &amp;a=allocator_type())</td></tr>
<tr class="memdesc:a57149f90060b033b1f2493f2a88ef291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct empty table with n preallocated buckets. This number serves also as initial concurrency level. <br/></td></tr>
<tr class="separator:a57149f90060b033b1f2493f2a88ef291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e01b1f79c287ae0257ccfd483fd90a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e01b1f79c287ae0257ccfd483fd90a"></a>
<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a63e01b1f79c287ae0257ccfd483fd90a">operator=</a> (const <a class="el" href="a00050.html">concurrent_hash_map</a> &amp;table)</td></tr>
<tr class="memdesc:a63e01b1f79c287ae0257ccfd483fd90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr class="separator:a63e01b1f79c287ae0257ccfd483fd90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b506ceed93d1c25979948961054380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92b506ceed93d1c25979948961054380"></a>
<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a92b506ceed93d1c25979948961054380">operator=</a> (<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&amp;table)</td></tr>
<tr class="memdesc:a92b506ceed93d1c25979948961054380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Assignment. <br/></td></tr>
<tr class="separator:a92b506ceed93d1c25979948961054380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac73665b1a55e3de7332f36598488252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac73665b1a55e3de7332f36598488252"></a>
<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aac73665b1a55e3de7332f36598488252">operator=</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:aac73665b1a55e3de7332f36598488252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr class="separator:aac73665b1a55e3de7332f36598488252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1fa9470c605731063e5949f0418eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#adf1fa9470c605731063e5949f0418eb7">rehash</a> (size_type n=0)</td></tr>
<tr class="memdesc:adf1fa9470c605731063e5949f0418eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rehashes and optionally resizes the whole table.  <a href="#adf1fa9470c605731063e5949f0418eb7">More...</a><br/></td></tr>
<tr class="separator:adf1fa9470c605731063e5949f0418eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8295bc260b5e4df883fef11574b84c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8295bc260b5e4df883fef11574b84c6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ab8295bc260b5e4df883fef11574b84c6">clear</a> ()</td></tr>
<tr class="memdesc:ab8295bc260b5e4df883fef11574b84c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear table. <br/></td></tr>
<tr class="separator:ab8295bc260b5e4df883fef11574b84c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce9ab8c954bf6979c2c57d10fd8a8ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ce9ab8c954bf6979c2c57d10fd8a8ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a9ce9ab8c954bf6979c2c57d10fd8a8ed">~concurrent_hash_map</a> ()</td></tr>
<tr class="memdesc:a9ce9ab8c954bf6979c2c57d10fd8a8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear table and destroy it. <br/></td></tr>
<tr class="separator:a9ce9ab8c954bf6979c2c57d10fd8a8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dc8d8b91878b211c12a3e6b1bb38bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10dc8d8b91878b211c12a3e6b1bb38bb"></a>
range_type&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1)</td></tr>
<tr class="separator:a10dc8d8b91878b211c12a3e6b1bb38bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8698274a4ffb94bb0468c387ffdc2e56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8698274a4ffb94bb0468c387ffdc2e56"></a>
const_range_type&#160;</td><td class="memItemRight" valign="bottom"><b>range</b> (size_type grainsize=1) const </td></tr>
<tr class="separator:a8698274a4ffb94bb0468c387ffdc2e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7d6443502ee9f4c2374d34ea8d742"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38b7d6443502ee9f4c2374d34ea8d742"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="separator:a38b7d6443502ee9f4c2374d34ea8d742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa85633d3fc7494f49728b4064db59f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa85633d3fc7494f49728b4064db59f6"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> ()</td></tr>
<tr class="separator:afa85633d3fc7494f49728b4064db59f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aa6dc98653a88d410d0cfddd514f0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46aa6dc98653a88d410d0cfddd514f0d"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const </td></tr>
<tr class="separator:a46aa6dc98653a88d410d0cfddd514f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8cd11a3a5c400d9bc11492d136dfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed8cd11a3a5c400d9bc11492d136dfd"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const </td></tr>
<tr class="separator:a0ed8cd11a3a5c400d9bc11492d136dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a1c3032bb193a5c4f37425adbe306c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01a1c3032bb193a5c4f37425adbe306c"></a>
std::pair&lt; iterator, iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key)</td></tr>
<tr class="separator:a01a1c3032bb193a5c4f37425adbe306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af368c8d8f49a9a74706c9ed11f8fd7e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af368c8d8f49a9a74706c9ed11f8fd7e4"></a>
std::pair&lt; const_iterator, <br class="typebreak"/>
const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>equal_range</b> (const Key &amp;key) const </td></tr>
<tr class="separator:af368c8d8f49a9a74706c9ed11f8fd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce6da7cd62bc7425f0a29498332ab4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2ce6da7cd62bc7425f0a29498332ab4"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ad2ce6da7cd62bc7425f0a29498332ab4">size</a> () const </td></tr>
<tr class="memdesc:ad2ce6da7cd62bc7425f0a29498332ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of items in table. <br/></td></tr>
<tr class="separator:ad2ce6da7cd62bc7425f0a29498332ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e05f2a1ca3accfb4252d7ee82d1e990"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e05f2a1ca3accfb4252d7ee82d1e990"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a5e05f2a1ca3accfb4252d7ee82d1e990">empty</a> () const </td></tr>
<tr class="memdesc:a5e05f2a1ca3accfb4252d7ee82d1e990"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <a class="el" href="a00050.html#ad2ce6da7cd62bc7425f0a29498332ab4" title="Number of items in table. ">size()</a>==0. <br/></td></tr>
<tr class="separator:a5e05f2a1ca3accfb4252d7ee82d1e990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0a0e5220a0dcb67da57d0280d36005"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea0a0e5220a0dcb67da57d0280d36005"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aea0a0e5220a0dcb67da57d0280d36005">max_size</a> () const </td></tr>
<tr class="memdesc:aea0a0e5220a0dcb67da57d0280d36005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upper bound on size. <br/></td></tr>
<tr class="separator:aea0a0e5220a0dcb67da57d0280d36005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa067a2a4db1d96f38555369a89deee64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa067a2a4db1d96f38555369a89deee64"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aa067a2a4db1d96f38555369a89deee64">bucket_count</a> () const </td></tr>
<tr class="memdesc:aa067a2a4db1d96f38555369a89deee64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of buckets. <br/></td></tr>
<tr class="separator:aa067a2a4db1d96f38555369a89deee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121865c574f8ae5cae69ed3d6b7e0511"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121865c574f8ae5cae69ed3d6b7e0511"></a>
allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a121865c574f8ae5cae69ed3d6b7e0511">get_allocator</a> () const </td></tr>
<tr class="memdesc:a121865c574f8ae5cae69ed3d6b7e0511"><td class="mdescLeft">&#160;</td><td class="mdescRight">return allocator object <br/></td></tr>
<tr class="separator:a121865c574f8ae5cae69ed3d6b7e0511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8edf603bc776a6c84c007702c1808e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c8edf603bc776a6c84c007702c1808e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a4c8edf603bc776a6c84c007702c1808e">swap</a> (<a class="el" href="a00050.html">concurrent_hash_map</a> &amp;table)</td></tr>
<tr class="memdesc:a4c8edf603bc776a6c84c007702c1808e"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap two instances. Iterators are invalidated <br/></td></tr>
<tr class="separator:a4c8edf603bc776a6c84c007702c1808e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac375d3884bf9c80efe56117757c822e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac375d3884bf9c80efe56117757c822e7"></a>
size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ac375d3884bf9c80efe56117757c822e7">count</a> (const Key &amp;key) const </td></tr>
<tr class="memdesc:ac375d3884bf9c80efe56117757c822e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return count of items (0 or 1) <br/></td></tr>
<tr class="separator:ac375d3884bf9c80efe56117757c822e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a3f296dc170ae25f8e3fd9efa93cff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a27a3f296dc170ae25f8e3fd9efa93cff">find</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;result, const Key &amp;key) const </td></tr>
<tr class="memdesc:a27a3f296dc170ae25f8e3fd9efa93cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a read lock on the item.  <a href="#a27a3f296dc170ae25f8e3fd9efa93cff">More...</a><br/></td></tr>
<tr class="separator:a27a3f296dc170ae25f8e3fd9efa93cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b61799e2018381b5ee4b78752a41483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6b61799e2018381b5ee4b78752a41483">find</a> (<a class="el" href="a00017.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:a6b61799e2018381b5ee4b78752a41483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find item and acquire a write lock on the item.  <a href="#a6b61799e2018381b5ee4b78752a41483">More...</a><br/></td></tr>
<tr class="separator:a6b61799e2018381b5ee4b78752a41483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebb10a9e9dcb24e63860caa745a281d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#aaebb10a9e9dcb24e63860caa745a281d">insert</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:aaebb10a9e9dcb24e63860caa745a281d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item (if not already present) and acquire a read lock on the item.  <a href="#aaebb10a9e9dcb24e63860caa745a281d">More...</a><br/></td></tr>
<tr class="separator:aaebb10a9e9dcb24e63860caa745a281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766c6033c203e8f342501d85a7cf3405"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a766c6033c203e8f342501d85a7cf3405">insert</a> (<a class="el" href="a00017.html">accessor</a> &amp;result, const Key &amp;key)</td></tr>
<tr class="memdesc:a766c6033c203e8f342501d85a7cf3405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item (if not already present) and acquire a write lock on the item.  <a href="#a766c6033c203e8f342501d85a7cf3405">More...</a><br/></td></tr>
<tr class="separator:a766c6033c203e8f342501d85a7cf3405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b420cdb752e749790c8a7daa15c3c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#ae0b420cdb752e749790c8a7daa15c3c2">insert</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;result, const value_type &amp;value)</td></tr>
<tr class="memdesc:ae0b420cdb752e749790c8a7daa15c3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#ae0b420cdb752e749790c8a7daa15c3c2">More...</a><br/></td></tr>
<tr class="separator:ae0b420cdb752e749790c8a7daa15c3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2047214e041b7674c3b83e204d0d6c6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2047214e041b7674c3b83e204d0d6c6a">insert</a> (<a class="el" href="a00017.html">accessor</a> &amp;result, const value_type &amp;value)</td></tr>
<tr class="memdesc:a2047214e041b7674c3b83e204d0d6c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#a2047214e041b7674c3b83e204d0d6c6a">More...</a><br/></td></tr>
<tr class="separator:a2047214e041b7674c3b83e204d0d6c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e39501f9edb3210504c9c4ca05384b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a8e39501f9edb3210504c9c4ca05384b7">insert</a> (const value_type &amp;value)</td></tr>
<tr class="memdesc:a8e39501f9edb3210504c9c4ca05384b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#a8e39501f9edb3210504c9c4ca05384b7">More...</a><br/></td></tr>
<tr class="separator:a8e39501f9edb3210504c9c4ca05384b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446910c1ca4818bdb00f4ffa91b9108a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a446910c1ca4818bdb00f4ffa91b9108a">insert</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;result, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a446910c1ca4818bdb00f4ffa91b9108a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#a446910c1ca4818bdb00f4ffa91b9108a">More...</a><br/></td></tr>
<tr class="separator:a446910c1ca4818bdb00f4ffa91b9108a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c929e78ecfa36986c8821287665a70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a50c929e78ecfa36986c8821287665a70">insert</a> (<a class="el" href="a00017.html">accessor</a> &amp;result, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a50c929e78ecfa36986c8821287665a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#a50c929e78ecfa36986c8821287665a70">More...</a><br/></td></tr>
<tr class="separator:a50c929e78ecfa36986c8821287665a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3da283d2e74c7ff0ecb0dfd4d371fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a5d3da283d2e74c7ff0ecb0dfd4d371fd">insert</a> (value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a5d3da283d2e74c7ff0ecb0dfd4d371fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#a5d3da283d2e74c7ff0ecb0dfd4d371fd">More...</a><br/></td></tr>
<tr class="separator:a5d3da283d2e74c7ff0ecb0dfd4d371fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382178ea2f00f69096c91bcf76ae7913"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a382178ea2f00f69096c91bcf76ae7913"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#a382178ea2f00f69096c91bcf76ae7913">emplace</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;result, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a382178ea2f00f69096c91bcf76ae7913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a read lock on the item.  <a href="#a382178ea2f00f69096c91bcf76ae7913">More...</a><br/></td></tr>
<tr class="separator:a382178ea2f00f69096c91bcf76ae7913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e51c8864282c35aa4d23f22909cc4a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a17e51c8864282c35aa4d23f22909cc4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#a17e51c8864282c35aa4d23f22909cc4a">emplace</a> (<a class="el" href="a00017.html">accessor</a> &amp;result, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a17e51c8864282c35aa4d23f22909cc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already and acquire a write lock on the item.  <a href="#a17e51c8864282c35aa4d23f22909cc4a">More...</a><br/></td></tr>
<tr class="separator:a17e51c8864282c35aa4d23f22909cc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe1d0f3a87786a83a7021af2ef52ee0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:acbe1d0f3a87786a83a7021af2ef52ee0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#acbe1d0f3a87786a83a7021af2ef52ee0">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:acbe1d0f3a87786a83a7021af2ef52ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert item by copying if there is no such key present already.  <a href="#acbe1d0f3a87786a83a7021af2ef52ee0">More...</a><br/></td></tr>
<tr class="separator:acbe1d0f3a87786a83a7021af2ef52ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84dfd77316252cbf39c7ae89e365a00"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab84dfd77316252cbf39c7ae89e365a00"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ab84dfd77316252cbf39c7ae89e365a00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#ab84dfd77316252cbf39c7ae89e365a00">insert</a> (I first, I last)</td></tr>
<tr class="memdesc:ab84dfd77316252cbf39c7ae89e365a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert range [first, last) <br/></td></tr>
<tr class="separator:ab84dfd77316252cbf39c7ae89e365a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580fdba266e87106ad41470479f641d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a580fdba266e87106ad41470479f641d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a580fdba266e87106ad41470479f641d6">insert</a> (std::initializer_list&lt; value_type &gt; il)</td></tr>
<tr class="memdesc:a580fdba266e87106ad41470479f641d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert initializer list. <br/></td></tr>
<tr class="separator:a580fdba266e87106ad41470479f641d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5144122dbb946d933b94a92117543b33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a5144122dbb946d933b94a92117543b33">erase</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:a5144122dbb946d933b94a92117543b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase item.  <a href="#a5144122dbb946d933b94a92117543b33">More...</a><br/></td></tr>
<tr class="separator:a5144122dbb946d933b94a92117543b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6f95ed9beda9d32df56cdd45c1842"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2ec6f95ed9beda9d32df56cdd45c1842">erase</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;item_accessor)</td></tr>
<tr class="memdesc:a2ec6f95ed9beda9d32df56cdd45c1842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase item by <a class="el" href="a00061.html" title="Combines data access, locking, and garbage collection. ">const_accessor</a>.  <a href="#a2ec6f95ed9beda9d32df56cdd45c1842">More...</a><br/></td></tr>
<tr class="separator:a2ec6f95ed9beda9d32df56cdd45c1842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0fbcc6cfd4db8242e100355ac1fa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a3ed0fbcc6cfd4db8242e100355ac1fa5">erase</a> (<a class="el" href="a00017.html">accessor</a> &amp;item_accessor)</td></tr>
<tr class="memdesc:a3ed0fbcc6cfd4db8242e100355ac1fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase item by accessor.  <a href="#a3ed0fbcc6cfd4db8242e100355ac1fa5">More...</a><br/></td></tr>
<tr class="separator:a3ed0fbcc6cfd4db8242e100355ac1fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a81dddc5d509f7f074d84d9c38e83efb9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81dddc5d509f7f074d84d9c38e83efb9"></a>
typedef Allocator::template <br class="typebreak"/>
rebind&lt; <a class="el" href="a00098.html">node</a> &gt;::other&#160;</td><td class="memItemRight" valign="bottom"><b>node_allocator_type</b></td></tr>
<tr class="separator:a81dddc5d509f7f074d84d9c38e83efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed0e0def29516d9ee7aab2192727b69b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed0e0def29516d9ee7aab2192727b69b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>delete_node</b> (node_base *n)</td></tr>
<tr class="separator:aed0e0def29516d9ee7aab2192727b69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a70417f9674a2169f9a1fd437a3bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae44a70417f9674a2169f9a1fd437a3bd"></a>
<a class="el" href="a00098.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>search_bucket</b> (const key_type &amp;key, bucket *b) const </td></tr>
<tr class="separator:ae44a70417f9674a2169f9a1fd437a3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b57e036f82bc2b1ef1ede41b02d46b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b57e036f82bc2b1ef1ede41b02d46b5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rehash_bucket</b> (bucket *b_new, const hashcode_t h)</td></tr>
<tr class="separator:a1b57e036f82bc2b1ef1ede41b02d46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a319cf46fb9cf9a88aab6c0a20c98b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a319cf46fb9cf9a88aab6c0a20c98b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a2a319cf46fb9cf9a88aab6c0a20c98b3">lookup</a> (bool op_insert, const Key &amp;key, const T *t, <a class="el" href="a00061.html">const_accessor</a> *result, bool write, <a class="el" href="a00098.html">node</a> *(*allocate_node)(node_allocator_type &amp;, const Key &amp;, const T *), <a class="el" href="a00098.html">node</a> *tmp_n=0)</td></tr>
<tr class="memdesc:a2a319cf46fb9cf9a88aab6c0a20c98b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert or find item and optionally acquire a lock on the item. <br/></td></tr>
<tr class="separator:a2a319cf46fb9cf9a88aab6c0a20c98b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6204ad5c57618556931e4c90e1938d1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6204ad5c57618556931e4c90e1938d1e"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a6204ad5c57618556931e4c90e1938d1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generic_move_insert</b> (Accessor &amp;&amp;result, value_type &amp;&amp;value)</td></tr>
<tr class="separator:a6204ad5c57618556931e4c90e1938d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c0a242bf8d4a210d74d551dbc61c18"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81c0a242bf8d4a210d74d551dbc61c18"></a>
template&lt;typename Accessor , typename... Args&gt; </td></tr>
<tr class="memitem:a81c0a242bf8d4a210d74d551dbc61c18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generic_emplace</b> (Accessor &amp;&amp;result, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a81c0a242bf8d4a210d74d551dbc61c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fec452b31b8f0e185dc2de64b7128b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fec452b31b8f0e185dc2de64b7128b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a6fec452b31b8f0e185dc2de64b7128b2">exclude</a> (<a class="el" href="a00061.html">const_accessor</a> &amp;item_accessor)</td></tr>
<tr class="memdesc:a6fec452b31b8f0e185dc2de64b7128b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete item by accessor <br/></td></tr>
<tr class="separator:a6fec452b31b8f0e185dc2de64b7128b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8603f5288db63ec35a16844427e97e42"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8603f5288db63ec35a16844427e97e42"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:a8603f5288db63ec35a16844427e97e42"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; I, I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00050.html#a8603f5288db63ec35a16844427e97e42">internal_equal_range</a> (const Key &amp;key, I end) const </td></tr>
<tr class="memdesc:a8603f5288db63ec35a16844427e97e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator for an item defined by the key, or for the next item after it (if upper==true) <br/></td></tr>
<tr class="separator:a8603f5288db63ec35a16844427e97e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc3593f82b3b4f9839fc051780212ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bc3593f82b3b4f9839fc051780212ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#a0bc3593f82b3b4f9839fc051780212ab">internal_copy</a> (const <a class="el" href="a00050.html">concurrent_hash_map</a> &amp;source)</td></tr>
<tr class="memdesc:a0bc3593f82b3b4f9839fc051780212ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy "source" to *this, where *this must start out empty. <br/></td></tr>
<tr class="separator:a0bc3593f82b3b4f9839fc051780212ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76750c61ad670e130850148543f67147"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76750c61ad670e130850148543f67147"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:a76750c61ad670e130850148543f67147"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal_copy</b> (I first, I last, size_type reserve_size)</td></tr>
<tr class="separator:a76750c61ad670e130850148543f67147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb5b18c097fb32f264b7b5fe8d9fdd4"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html#acbb5b18c097fb32f264b7b5fe8d9fdd4">internal_fast_find</a> (const Key &amp;key) const </td></tr>
<tr class="memdesc:acbb5b18c097fb32f264b7b5fe8d9fdd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast find when no concurrent erasure is used. For internal use inside TBB only!  <a href="#acbb5b18c097fb32f264b7b5fe8d9fdd4">More...</a><br/></td></tr>
<tr class="separator:acbb5b18c097fb32f264b7b5fe8d9fdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aa220373171ca2feccb74c23823c6329f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa220373171ca2feccb74c23823c6329f"></a>
static <a class="el" href="a00098.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_node_copy_construct</b> (node_allocator_type &amp;allocator, const Key &amp;key, const T *t)</td></tr>
<tr class="separator:aa220373171ca2feccb74c23823c6329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59416689b95d20f4d69e43a23aa4f300"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59416689b95d20f4d69e43a23aa4f300"></a>
static <a class="el" href="a00098.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_node_move_construct</b> (node_allocator_type &amp;allocator, const Key &amp;key, const T *t)</td></tr>
<tr class="separator:a59416689b95d20f4d69e43a23aa4f300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8388c1d433042b67d3cc12181189c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e8388c1d433042b67d3cc12181189c3"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8e8388c1d433042b67d3cc12181189c3"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00098.html">node</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>allocate_node_emplace_construct</b> (node_allocator_type &amp;allocator, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a8e8388c1d433042b67d3cc12181189c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f92f68816357df14d30650b29ab94cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f92f68816357df14d30650b29ab94cb"></a>
static <a class="el" href="a00098.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocate_node_default_construct</b> (node_allocator_type &amp;allocator, const Key &amp;key, const T *)</td></tr>
<tr class="separator:a1f92f68816357df14d30650b29ab94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684cc0d3eb4b6ba8b88a14189c40bb20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684cc0d3eb4b6ba8b88a14189c40bb20"></a>
static <a class="el" href="a00098.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>do_not_allocate_node</b> (node_allocator_type &amp;, const Key &amp;, const T *)</td></tr>
<tr class="separator:a684cc0d3eb4b6ba8b88a14189c40bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2f3f082b2719a9e3c3c15a51a9564202"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f3f082b2719a9e3c3c15a51a9564202"></a>
node_allocator_type&#160;</td><td class="memItemRight" valign="bottom"><b>my_allocator</b></td></tr>
<tr class="separator:a2f3f082b2719a9e3c3c15a51a9564202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c3c723768e7e396104f84577f7240"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67c3c723768e7e396104f84577f7240"></a>
HashCompare&#160;</td><td class="memItemRight" valign="bottom"><b>my_hash_compare</b></td></tr>
<tr class="separator:ae67c3c723768e7e396104f84577f7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0ecadabdc31088d7bace5a0b6e5ee3f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ecadabdc31088d7bace5a0b6e5ee3f9"></a>
template&lt;typename Container , typename Value &gt; </td></tr>
<tr class="memitem:a0ecadabdc31088d7bace5a0b6e5ee3f9"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal::hash_map_iterator</b></td></tr>
<tr class="separator:a0ecadabdc31088d7bace5a0b6e5ee3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49112156111ee1b85be9f4b89e410ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad49112156111ee1b85be9f4b89e410ca"></a>
template&lt;typename I &gt; </td></tr>
<tr class="memitem:ad49112156111ee1b85be9f4b89e410ca"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal::hash_map_range</b></td></tr>
<tr class="separator:ad49112156111ee1b85be9f4b89e410ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584bf754a8408612d4bfd33a3eafd80d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a584bf754a8408612d4bfd33a3eafd80d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>const_accessor</b></td></tr>
<tr class="separator:a584bf754a8408612d4bfd33a3eafd80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e234c756e22e65a3c99771fdeb67d7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e234c756e22e65a3c99771fdeb67d7a"></a>
<a class="el" href="a00061.html">const_accessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>accessor_location</b> (<a class="el" href="a00018.html">accessor_not_used</a> const &amp;)</td></tr>
<tr class="separator:a6e234c756e22e65a3c99771fdeb67d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0216633e60539f42cf9d645d3f3b7117"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0216633e60539f42cf9d645d3f3b7117"></a>
<a class="el" href="a00061.html">const_accessor</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>accessor_location</b> (<a class="el" href="a00061.html">const_accessor</a> &amp;a)</td></tr>
<tr class="separator:a0216633e60539f42cf9d645d3f3b7117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa491682f70c12a8c7f783a427791ce4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa491682f70c12a8c7f783a427791ce4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_write_access_needed</b> (<a class="el" href="a00017.html">accessor</a> const &amp;)</td></tr>
<tr class="separator:afa491682f70c12a8c7f783a427791ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c835f5e1b689d1fbbff61519c0ef5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34c835f5e1b689d1fbbff61519c0ef5f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_write_access_needed</b> (<a class="el" href="a00061.html">const_accessor</a> const &amp;)</td></tr>
<tr class="separator:a34c835f5e1b689d1fbbff61519c0ef5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bdfdc062d155dc1ace8cc18acc8d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4bdfdc062d155dc1ace8cc18acc8d6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_write_access_needed</b> (<a class="el" href="a00018.html">accessor_not_used</a> const &amp;)</td></tr>
<tr class="separator:a7b4bdfdc062d155dc1ace8cc18acc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename T, typename HashCompare = tbb_hash_compare&lt;Key&gt;, typename A = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt;<br/>
class tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;</h3>

<p>Unordered map from Key to T. </p>
<pre class="fragment">concurrent_hash_map is associative container with concurrent access.
</pre><dl class="section user"><dt>Compatibility</dt><dd>The class meets all Container Requirements from C++ Standard (See ISO/IEC 14882:2003(E), clause 23.1).</dd></dl>
<dl class="section user"><dt>Exception Safety</dt><dd><ul>
<li>Hash function is not permitted to throw an exception. User-defined types Key and T are forbidden from throwing an exception in destructors.</li>
<li>If exception happens during <a class="el" href="a00050.html#aaebb10a9e9dcb24e63860caa745a281d" title="Insert item (if not already present) and acquire a read lock on the item. ">insert()</a> operations, it has no effect (unless exception raised by HashCompare::hash() function during grow_segment).</li>
<li>If exception happens during <a class="el" href="a00050.html#a63e01b1f79c287ae0257ccfd483fd90a" title="Assignment. ">operator=()</a> operation, the container can have a part of source items, and methods <a class="el" href="a00050.html#ad2ce6da7cd62bc7425f0a29498332ab4" title="Number of items in table. ">size()</a> and <a class="el" href="a00050.html#a5e05f2a1ca3accfb4252d7ee82d1e990" title="True if size()==0. ">empty()</a> can return wrong results.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Changes since TBB 2.1</dt><dd><ul>
<li>Replaced internal algorithm and data structure. Patent is pending.</li>
<li>Added buckets number argument for constructor</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Changes since TBB 2.0</dt><dd><ul>
<li>Fixed exception-safety</li>
<li>Added template argument for allocator</li>
<li>Added allocator argument in constructors</li>
<li>Added constructor from a range of iterators</li>
<li>Added several new overloaded <a class="el" href="a00050.html#aaebb10a9e9dcb24e63860caa745a281d" title="Insert item (if not already present) and acquire a read lock on the item. ">insert()</a> methods</li>
<li>Added <a class="el" href="a00050.html#a121865c574f8ae5cae69ed3d6b7e0511" title="return allocator object ">get_allocator()</a></li>
<li>Added <a class="el" href="a00050.html#a4c8edf603bc776a6c84c007702c1808e" title="swap two instances. Iterators are invalidated ">swap()</a></li>
<li>Added <a class="el" href="a00050.html#ac375d3884bf9c80efe56117757c822e7" title="Return count of items (0 or 1) ">count()</a></li>
<li>Added overloaded <a class="el" href="a00050.html#a3ed0fbcc6cfd4db8242e100355ac1fa5" title="Erase item by accessor. ">erase(accessor &amp;)</a> and <a class="el" href="a00050.html#a2ec6f95ed9beda9d32df56cdd45c1842" title="Erase item by const_accessor. ">erase(const_accessor&amp;)</a></li>
<li>Added equal_range() [const]</li>
<li>Added [const_]pointer, [const_]reference, and allocator_type types</li>
<li>Added global functions: operator==(), operator!=(), and <a class="el" href="a00050.html#a4c8edf603bc776a6c84c007702c1808e" title="swap two instances. Iterators are invalidated ">swap()</a> </li>
</ul>
</dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a382178ea2f00f69096c91bcf76ae7913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a read lock on the item. </p>
<p>Returns true if item is new. </p>

</div>
</div>
<a class="anchor" id="a17e51c8864282c35aa4d23f22909cc4a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a write lock on the item. </p>
<p>Returns true if item is new. </p>

</div>
</div>
<a class="anchor" id="acbe1d0f3a87786a83a7021af2ef52ee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already. </p>
<p>Returns true if item is inserted. </p>

</div>
</div>
<a class="anchor" id="a5144122dbb946d933b94a92117543b33"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase item. </p>
<p>Return true if item was erased by particularly this call. </p>

<p>References <a class="el" href="a00040.html#aaa8167e2961330435fd23eb92127805c">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::bucket_accessor::is_writer()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ec6f95ed9beda9d32df56cdd45c1842"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>item_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase item by <a class="el" href="a00061.html" title="Combines data access, locking, and garbage collection. ">const_accessor</a>. </p>
<p>Return true if item was erased by particularly this call. </p>

</div>
</div>
<a class="anchor" id="a3ed0fbcc6cfd4db8242e100355ac1fa5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>item_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase item by accessor. </p>
<p>Return true if item was erased by particularly this call. </p>

</div>
</div>
<a class="anchor" id="a27a3f296dc170ae25f8e3fd9efa93cff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a read lock on the item. </p>
<p>Return true if item is found, false otherwise. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="a6b61799e2018381b5ee4b78752a41483"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find item and acquire a write lock on the item. </p>
<p>Return true if item is found, false otherwise. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="aaebb10a9e9dcb24e63860caa745a281d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item (if not already present) and acquire a read lock on the item. </p>
<p>Returns true if item is new. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="a766c6033c203e8f342501d85a7cf3405"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item (if not already present) and acquire a write lock on the item. </p>
<p>Returns true if item is new. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="ae0b420cdb752e749790c8a7daa15c3c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a read lock on the item. </p>
<p>Returns true if item is new. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="a2047214e041b7674c3b83e204d0d6c6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a write lock on the item. </p>
<p>Returns true if item is new. </p>

<p>References <a class="el" href="a00061.html#a18390cb369369d72bdf7c867755b5190">tbb::interface5::concurrent_hash_map&lt; Key, T, HashCompare, A &gt;::const_accessor::release()</a>.</p>

</div>
</div>
<a class="anchor" id="a8e39501f9edb3210504c9c4ca05384b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already. </p>
<p>Returns true if item is inserted. </p>

</div>
</div>
<a class="anchor" id="a446910c1ca4818bdb00f4ffa91b9108a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">const_accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a read lock on the item. </p>
<p>Returns true if item is new. </p>

</div>
</div>
<a class="anchor" id="a50c929e78ecfa36986c8821287665a70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00017.html">accessor</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already and acquire a write lock on the item. </p>
<p>Returns true if item is new. </p>

</div>
</div>
<a class="anchor" id="a5d3da283d2e74c7ff0ecb0dfd4d371fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert item by copying if there is no such key present already. </p>
<p>Returns true if item is inserted. </p>

</div>
</div>
<a class="anchor" id="acbb5b18c097fb32f264b7b5fe8d9fdd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare  = tbb_hash_compare&lt;Key&gt;, typename A  = tbb_allocator&lt;std::pair&lt;Key, T&gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::internal_fast_find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast find when no concurrent erasure is used. For internal use inside TBB only! </p>
<p>Return pointer to item with given key, or NULL if no such item exists. Must not be called concurrently with erasure operations. </p>

</div>
</div>
<a class="anchor" id="adf1fa9470c605731063e5949f0418eb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T , typename HashCompare , typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00050.html">tbb::interface5::concurrent_hash_map</a>&lt; Key, T, HashCompare, A &gt;::rehash </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rehashes and optionally resizes the whole table. </p>
<p>Useful to optimize performance before or after concurrent operations. Also enables using of <a class="el" href="a00050.html#a27a3f296dc170ae25f8e3fd9efa93cff" title="Find item and acquire a read lock on the item. ">find()</a> and <a class="el" href="a00050.html#ac375d3884bf9c80efe56117757c822e7" title="Return count of items (0 or 1) ">count()</a> concurrent methods in serial context. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>concurrent_hash_map.h</li>
</ul>
</div><!-- contents -->
<hr>
<p></p>
Copyright &copy; 2005-2018 Intel Corporation.  All Rights Reserved.
<p></p>
Intel, Pentium, Intel Xeon, Itanium, Intel XScale and VTune are
registered trademarks or trademarks of Intel Corporation or its
subsidiaries in the United States and other countries.
<p></p>
* Other names and brands may be claimed as the property of others.
