/**
 * Autogenerated by Thrift for Memcache.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "mcrouter/lib/network/gen/gen-cpp2/Memcache_types.h"
#include "mcrouter/lib/network/gen/gen-cpp2/Memcache_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "mcrouter/lib/network/gen/gen-cpp2/Memcache_data.h"


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGetRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "flags",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetRequest::McGetRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, uint64_t flags__arg) :
    key(std::move(key__arg)),
    flags(std::move(flags__arg)) {
  __isset.key = true;
  __isset.flags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGetRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  flags = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGetRequest::operator==(const McGetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  return true;
}

bool McGetRequest::operator<(const McGetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  return false;
}


void swap(McGetRequest& a, McGetRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGetReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "value",
    "flags",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetReply::McGetReply() :
      result( ::carbon::Result::UNKNOWN),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McGetReply::~McGetReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetReply::McGetReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, folly::IOBuf value__arg, uint64_t flags__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    value(std::move(value__arg)),
    flags(std::move(flags__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.value = true;
  __isset.flags = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGetReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  flags = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGetReply::operator==(const McGetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return false;
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return false;
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McGetReply::operator<(const McGetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return lhs.value_ref().has_value() < rhs.value_ref().has_value();
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McGetReply& a, McGetReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.value_ref().value_unchecked(), b.value_ref().value_unchecked());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGetReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGetReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGetReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGetReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGetReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGetReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGetReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGetReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McSetRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McSetRequest::McSetRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McSetRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McSetRequest::operator==(const McSetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool McSetRequest::operator<(const McSetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(McSetRequest& a, McSetRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McSetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McSetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McSetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McSetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McSetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McSetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McSetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McSetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McSetReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "flags",
    "value",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McSetReply::McSetReply() :
      result( ::carbon::Result::UNKNOWN),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McSetReply::~McSetReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McSetReply::McSetReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, uint64_t flags__arg, folly::IOBuf value__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.flags = true;
  __isset.value = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McSetReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McSetReply::operator==(const McSetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McSetReply::operator<(const McSetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McSetReply& a, McSetReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McSetReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McSetReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McSetReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McSetReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McSetReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McSetReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McSetReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McSetReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McDeleteRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "flags",
    "exptime",
    "value",
    "attributes",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
    TType::T_I32,
    TType::T_STRING,
    TType::T_MAP,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDeleteRequest::McDeleteRequest() :
      flags(0),
      exptime(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McDeleteRequest::~McDeleteRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDeleteRequest::McDeleteRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, uint64_t flags__arg, int32_t exptime__arg, folly::IOBuf value__arg, std::unordered_map<std::string, uint64_t> attributes__arg) :
    key(std::move(key__arg)),
    flags(std::move(flags__arg)),
    exptime(std::move(exptime__arg)),
    value(std::move(value__arg)),
    attributes(std::move(attributes__arg)) {
  __isset.key = true;
  __isset.flags = true;
  __isset.exptime = true;
  __isset.value = true;
  __isset.attributes = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McDeleteRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  flags = 0;
  exptime = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  attributes.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McDeleteRequest::operator==(const McDeleteRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (!(lhs.attributes == rhs.attributes)) {
    return false;
  }
  return true;
}

const std::unordered_map<std::string, uint64_t>& McDeleteRequest::get_attributes() const& {
  return attributes;
}

std::unordered_map<std::string, uint64_t> McDeleteRequest::get_attributes() && {
  return std::move(attributes);
}


void swap(McDeleteRequest& a, McDeleteRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.attributes_ref().value(), b.attributes_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McDeleteRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McDeleteRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McDeleteRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McDeleteRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McDeleteRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McDeleteRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McDeleteRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McDeleteRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McDeleteReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "flags",
    "value",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDeleteReply::McDeleteReply() :
      result( ::carbon::Result::UNKNOWN),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McDeleteReply::~McDeleteReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDeleteReply::McDeleteReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, uint64_t flags__arg, folly::IOBuf value__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.flags = true;
  __isset.value = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McDeleteReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McDeleteReply::operator==(const McDeleteReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McDeleteReply::operator<(const McDeleteReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McDeleteReply& a, McDeleteReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McDeleteReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McDeleteReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McDeleteReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McDeleteReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McDeleteReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McDeleteReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McDeleteReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McDeleteReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McLeaseGetRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "flags",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseGetRequest::McLeaseGetRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, uint64_t flags__arg) :
    key(std::move(key__arg)),
    flags(std::move(flags__arg)) {
  __isset.key = true;
  __isset.flags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McLeaseGetRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  flags = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McLeaseGetRequest::operator==(const McLeaseGetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  return true;
}

bool McLeaseGetRequest::operator<(const McLeaseGetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  return false;
}


void swap(McLeaseGetRequest& a, McLeaseGetRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McLeaseGetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McLeaseGetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McLeaseGetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McLeaseGetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McLeaseGetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McLeaseGetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McLeaseGetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McLeaseGetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McLeaseGetReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "leaseToken",
    "value",
    "flags",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseGetReply::McLeaseGetReply() :
      result( ::carbon::Result::UNKNOWN),
      leaseToken(0),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McLeaseGetReply::~McLeaseGetReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseGetReply::McLeaseGetReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, int64_t leaseToken__arg, folly::IOBuf value__arg, uint64_t flags__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    leaseToken(std::move(leaseToken__arg)),
    value(std::move(value__arg)),
    flags(std::move(flags__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.leaseToken = true;
  __isset.value = true;
  __isset.flags = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McLeaseGetReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  leaseToken = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  flags = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McLeaseGetReply::operator==(const McLeaseGetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.leaseToken == rhs.leaseToken)) {
    return false;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return false;
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return false;
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McLeaseGetReply::operator<(const McLeaseGetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.leaseToken == rhs.leaseToken)) {
    return lhs.leaseToken < rhs.leaseToken;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return lhs.value_ref().has_value() < rhs.value_ref().has_value();
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McLeaseGetReply& a, McLeaseGetReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.leaseToken_ref().value(), b.leaseToken_ref().value());
  swap(a.value_ref().value_unchecked(), b.value_ref().value_unchecked());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McLeaseGetReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McLeaseGetReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McLeaseGetReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McLeaseGetReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McLeaseGetReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McLeaseGetReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McLeaseGetReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McLeaseGetReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McLeaseSetRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
    "leaseToken",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseSetRequest::McLeaseSetRequest() :
      exptime(0),
      flags(0),
      leaseToken(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McLeaseSetRequest::~McLeaseSetRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseSetRequest::McLeaseSetRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg, int64_t leaseToken__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)),
    leaseToken(std::move(leaseToken__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
  __isset.leaseToken = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McLeaseSetRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  leaseToken = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McLeaseSetRequest::operator==(const McLeaseSetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (!(lhs.leaseToken == rhs.leaseToken)) {
    return false;
  }
  return true;
}

bool McLeaseSetRequest::operator<(const McLeaseSetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  if (!(lhs.leaseToken == rhs.leaseToken)) {
    return lhs.leaseToken < rhs.leaseToken;
  }
  return false;
}


void swap(McLeaseSetRequest& a, McLeaseSetRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.leaseToken_ref().value(), b.leaseToken_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McLeaseSetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McLeaseSetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McLeaseSetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McLeaseSetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McLeaseSetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McLeaseSetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McLeaseSetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McLeaseSetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McLeaseSetReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McLeaseSetReply::McLeaseSetReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McLeaseSetReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McLeaseSetReply::operator==(const McLeaseSetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McLeaseSetReply::operator<(const McLeaseSetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McLeaseSetReply& a, McLeaseSetReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McLeaseSetReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McLeaseSetReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McLeaseSetReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McLeaseSetReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McLeaseSetReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McLeaseSetReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McLeaseSetReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McLeaseSetReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McAddRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McAddRequest::McAddRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McAddRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McAddRequest::operator==(const McAddRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool McAddRequest::operator<(const McAddRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(McAddRequest& a, McAddRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McAddRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McAddRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McAddRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McAddRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McAddRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McAddRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McAddRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McAddRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McAddReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McAddReply::McAddReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McAddReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McAddReply::operator==(const McAddReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McAddReply::operator<(const McAddReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McAddReply& a, McAddReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McAddReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McAddReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McAddReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McAddReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McAddReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McAddReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McAddReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McAddReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McReplaceRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McReplaceRequest::McReplaceRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McReplaceRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McReplaceRequest::operator==(const McReplaceRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool McReplaceRequest::operator<(const McReplaceRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(McReplaceRequest& a, McReplaceRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McReplaceRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McReplaceRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McReplaceRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McReplaceRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McReplaceRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McReplaceRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McReplaceRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McReplaceRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McReplaceReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McReplaceReply::McReplaceReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McReplaceReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McReplaceReply::operator==(const McReplaceReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McReplaceReply::operator<(const McReplaceReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McReplaceReply& a, McReplaceReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McReplaceReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McReplaceReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McReplaceReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McReplaceReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McReplaceReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McReplaceReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McReplaceReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McReplaceReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGetsRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "flags",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetsRequest::McGetsRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, uint64_t flags__arg) :
    key(std::move(key__arg)),
    flags(std::move(flags__arg)) {
  __isset.key = true;
  __isset.flags = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGetsRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  flags = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGetsRequest::operator==(const McGetsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  return true;
}

bool McGetsRequest::operator<(const McGetsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  return false;
}


void swap(McGetsRequest& a, McGetsRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGetsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGetsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGetsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGetsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGetsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGetsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGetsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGetsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGetsReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "casToken",
    "value",
    "flags",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetsReply::McGetsReply() :
      result( ::carbon::Result::UNKNOWN),
      casToken(0),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McGetsReply::~McGetsReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGetsReply::McGetsReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, uint64_t casToken__arg, folly::IOBuf value__arg, uint64_t flags__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    casToken(std::move(casToken__arg)),
    value(std::move(value__arg)),
    flags(std::move(flags__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.casToken = true;
  __isset.value = true;
  __isset.flags = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGetsReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  casToken = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  flags = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGetsReply::operator==(const McGetsReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return false;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return false;
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return false;
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McGetsReply::operator<(const McGetsReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return lhs.casToken < rhs.casToken;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return lhs.value_ref().has_value() < rhs.value_ref().has_value();
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McGetsReply& a, McGetsReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.casToken_ref().value(), b.casToken_ref().value());
  swap(a.value_ref().value_unchecked(), b.value_ref().value_unchecked());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGetsReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGetsReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGetsReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGetsReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGetsReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGetsReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGetsReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGetsReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McCasRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
    "casToken",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McCasRequest::McCasRequest() :
      exptime(0),
      flags(0),
      casToken(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McCasRequest::~McCasRequest() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McCasRequest::McCasRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg, uint64_t casToken__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)),
    casToken(std::move(casToken__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
  __isset.casToken = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McCasRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  casToken = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McCasRequest::operator==(const McCasRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return false;
  }
  return true;
}

bool McCasRequest::operator<(const McCasRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return lhs.casToken < rhs.casToken;
  }
  return false;
}


void swap(McCasRequest& a, McCasRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
  swap(a.casToken_ref().value(), b.casToken_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McCasRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McCasRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McCasRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McCasRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McCasRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McCasRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McCasRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McCasRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McCasReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McCasReply::McCasReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McCasReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McCasReply::operator==(const McCasReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McCasReply::operator<(const McCasReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McCasReply& a, McCasReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McCasReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McCasReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McCasReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McCasReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McCasReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McCasReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McCasReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McCasReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McIncrRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "delta",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McIncrRequest::McIncrRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int64_t delta__arg) :
    key(std::move(key__arg)),
    delta(std::move(delta__arg)) {
  __isset.key = true;
  __isset.delta = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McIncrRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  delta = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McIncrRequest::operator==(const McIncrRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.delta == rhs.delta)) {
    return false;
  }
  return true;
}

bool McIncrRequest::operator<(const McIncrRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.delta == rhs.delta)) {
    return lhs.delta < rhs.delta;
  }
  return false;
}


void swap(McIncrRequest& a, McIncrRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.delta_ref().value(), b.delta_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McIncrRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McIncrRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McIncrRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McIncrRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McIncrRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McIncrRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McIncrRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McIncrRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McIncrReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "delta",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McIncrReply::McIncrReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, int64_t delta__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    delta(std::move(delta__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.delta = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McIncrReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  delta = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McIncrReply::operator==(const McIncrReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.delta == rhs.delta)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McIncrReply::operator<(const McIncrReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.delta == rhs.delta)) {
    return lhs.delta < rhs.delta;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McIncrReply& a, McIncrReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.delta_ref().value(), b.delta_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McIncrReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McIncrReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McIncrReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McIncrReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McIncrReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McIncrReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McIncrReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McIncrReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McDecrRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "delta",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I64,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDecrRequest::McDecrRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int64_t delta__arg) :
    key(std::move(key__arg)),
    delta(std::move(delta__arg)) {
  __isset.key = true;
  __isset.delta = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McDecrRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  delta = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McDecrRequest::operator==(const McDecrRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.delta == rhs.delta)) {
    return false;
  }
  return true;
}

bool McDecrRequest::operator<(const McDecrRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.delta == rhs.delta)) {
    return lhs.delta < rhs.delta;
  }
  return false;
}


void swap(McDecrRequest& a, McDecrRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.delta_ref().value(), b.delta_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McDecrRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McDecrRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McDecrRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McDecrRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McDecrRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McDecrRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McDecrRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McDecrRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McDecrReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "delta",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McDecrReply::McDecrReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, int64_t delta__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    delta(std::move(delta__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.delta = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McDecrReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  delta = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McDecrReply::operator==(const McDecrReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.delta == rhs.delta)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McDecrReply::operator<(const McDecrReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.delta == rhs.delta)) {
    return lhs.delta < rhs.delta;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McDecrReply& a, McDecrReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.delta_ref().value(), b.delta_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McDecrReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McDecrReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McDecrReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McDecrReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McDecrReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McDecrReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McDecrReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McDecrReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McMetagetRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "key",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McMetagetRequest::McMetagetRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg) :
    key(std::move(key__arg)) {
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McMetagetRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McMetagetRequest::operator==(const McMetagetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  return true;
}

bool McMetagetRequest::operator<(const McMetagetRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  return false;
}


void swap(McMetagetRequest& a, McMetagetRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McMetagetRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McMetagetRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McMetagetRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McMetagetRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McMetagetRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McMetagetRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McMetagetRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McMetagetRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McMetagetReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 7;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "age",
    "exptime",
    "ipv",
    "ipAddress",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
    7,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I32,
    TType::T_I32,
    TType::T_I16,
    TType::T_STRING,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McMetagetReply::McMetagetReply() :
      result( ::carbon::Result::UNKNOWN),
      age(0),
      exptime(0),
      ipv(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McMetagetReply::~McMetagetReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McMetagetReply::McMetagetReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, int32_t age__arg, int32_t exptime__arg, int16_t ipv__arg, ::std::string ipAddress__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    age(std::move(age__arg)),
    exptime(std::move(exptime__arg)),
    ipv(std::move(ipv__arg)),
    ipAddress(std::move(ipAddress__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.age = true;
  __isset.exptime = true;
  __isset.ipv = true;
  __isset.ipAddress = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McMetagetReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  age = 0;
  exptime = 0;
  ipv = 0;
  ipAddress = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McMetagetReply::operator==(const McMetagetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.age == rhs.age)) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.ipv == rhs.ipv)) {
    return false;
  }
  if (!(lhs.ipAddress == rhs.ipAddress)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McMetagetReply::operator<(const McMetagetReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.age == rhs.age)) {
    return lhs.age < rhs.age;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.ipv == rhs.ipv)) {
    return lhs.ipv < rhs.ipv;
  }
  if (!(lhs.ipAddress == rhs.ipAddress)) {
    return lhs.ipAddress < rhs.ipAddress;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McMetagetReply& a, McMetagetReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.age_ref().value(), b.age_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.ipv_ref().value(), b.ipv_ref().value());
  swap(a.ipAddress_ref().value(), b.ipAddress_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McMetagetReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McMetagetReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McMetagetReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McMetagetReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McMetagetReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McMetagetReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McMetagetReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McMetagetReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McAppendRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McAppendRequest::McAppendRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McAppendRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McAppendRequest::operator==(const McAppendRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool McAppendRequest::operator<(const McAppendRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(McAppendRequest& a, McAppendRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McAppendRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McAppendRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McAppendRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McAppendRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McAppendRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McAppendRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McAppendRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McAppendRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McAppendReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McAppendReply::McAppendReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McAppendReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McAppendReply::operator==(const McAppendReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McAppendReply::operator<(const McAppendReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McAppendReply& a, McAppendReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McAppendReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McAppendReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McAppendReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McAppendReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McAppendReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McAppendReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McAppendReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McAppendReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McPrependRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 4;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
    "flags",
    "value",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McPrependRequest::McPrependRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg, uint64_t flags__arg, folly::IOBuf value__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)),
    flags(std::move(flags__arg)),
    value(std::move(value__arg)) {
  __isset.key = true;
  __isset.exptime = true;
  __isset.flags = true;
  __isset.value = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McPrependRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
  flags = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McPrependRequest::operator==(const McPrependRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return false;
  }
  return true;
}

bool McPrependRequest::operator<(const McPrependRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
    return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
  }
  return false;
}


void swap(McPrependRequest& a, McPrependRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.value_ref().value(), b.value_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McPrependRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McPrependRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McPrependRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McPrependRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McPrependRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McPrependRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McPrependRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McPrependRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McPrependReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McPrependReply::McPrependReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McPrependReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McPrependReply::operator==(const McPrependReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McPrependReply::operator<(const McPrependReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McPrependReply& a, McPrependReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McPrependReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McPrependReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McPrependReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McPrependReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McPrependReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McPrependReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McPrependReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McPrependReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McTouchRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "exptime",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McTouchRequest::McTouchRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t exptime__arg) :
    key(std::move(key__arg)),
    exptime(std::move(exptime__arg)) {
  __isset.key = true;
  __isset.exptime = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McTouchRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  exptime = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McTouchRequest::operator==(const McTouchRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  return true;
}

bool McTouchRequest::operator<(const McTouchRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  return false;
}


void swap(McTouchRequest& a, McTouchRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.exptime_ref().value(), b.exptime_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McTouchRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McTouchRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McTouchRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McTouchRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McTouchRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McTouchRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McTouchRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McTouchRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McTouchReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McTouchReply::McTouchReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McTouchReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McTouchReply::operator==(const McTouchReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McTouchReply::operator<(const McTouchReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McTouchReply& a, McTouchReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McTouchReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McTouchReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McTouchReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McTouchReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McTouchReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McTouchReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McTouchReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McTouchReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McFlushReRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 1;
  static constexpr folly::StringPiece _names[] = {
    "key",
  };
  static constexpr int16_t _ids[] = {
    1,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McFlushReRequest::McFlushReRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg) :
    key(std::move(key__arg)) {
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McFlushReRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McFlushReRequest::operator==(const McFlushReRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  return true;
}

bool McFlushReRequest::operator<(const McFlushReRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  return false;
}


void swap(McFlushReRequest& a, McFlushReRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McFlushReRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McFlushReRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McFlushReRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McFlushReRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McFlushReRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McFlushReRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McFlushReRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McFlushReRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McFlushReReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McFlushReReply::McFlushReReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McFlushReReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McFlushReReply::operator==(const McFlushReReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McFlushReReply::operator<(const McFlushReReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McFlushReReply& a, McFlushReReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McFlushReReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McFlushReReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McFlushReReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McFlushReReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McFlushReReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McFlushReReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McFlushReReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McFlushReReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McFlushAllRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "key",
    "delay",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_STRING,
    TType::T_I32,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McFlushAllRequest::McFlushAllRequest(apache::thrift::FragileConstructor,  ::carbon::thrift::IOBufKey key__arg, int32_t delay__arg) :
    key(std::move(key__arg)),
    delay(std::move(delay__arg)) {
  __isset.key = true;
  __isset.delay = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McFlushAllRequest::__clear() {
  // clear all fields
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
  delay = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McFlushAllRequest::operator==(const McFlushAllRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  if (!(lhs.delay == rhs.delay)) {
    return false;
  }
  return true;
}

bool McFlushAllRequest::operator<(const McFlushAllRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  if (!(lhs.delay == rhs.delay)) {
    return lhs.delay < rhs.delay;
  }
  return false;
}


void swap(McFlushAllRequest& a, McFlushAllRequest& b) {
  using ::std::swap;
  swap(a.key_ref().value(), b.key_ref().value());
  swap(a.delay_ref().value(), b.delay_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McFlushAllRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McFlushAllRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McFlushAllRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McFlushAllRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McFlushAllRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McFlushAllRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McFlushAllRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McFlushAllRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McFlushAllReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 3;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McFlushAllReply::McFlushAllReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McFlushAllReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McFlushAllReply::operator==(const McFlushAllReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McFlushAllReply::operator<(const McFlushAllReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McFlushAllReply& a, McFlushAllReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McFlushAllReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McFlushAllReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McFlushAllReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McFlushAllReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McFlushAllReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McFlushAllReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McFlushAllReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McFlushAllReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGatRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "exptime",
    "key",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatRequest::McGatRequest(apache::thrift::FragileConstructor, int32_t exptime__arg,  ::carbon::thrift::IOBufKey key__arg) :
    exptime(std::move(exptime__arg)),
    key(std::move(key__arg)) {
  __isset.exptime = true;
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGatRequest::__clear() {
  // clear all fields
  exptime = 0;
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGatRequest::operator==(const McGatRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  return true;
}

bool McGatRequest::operator<(const McGatRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  return false;
}


void swap(McGatRequest& a, McGatRequest& b) {
  using ::std::swap;
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGatRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGatRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGatRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGatRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGatRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGatRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGatRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGatRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGatReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 5;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "value",
    "flags",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatReply::McGatReply() :
      result( ::carbon::Result::UNKNOWN),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McGatReply::~McGatReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatReply::McGatReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, folly::IOBuf value__arg, uint64_t flags__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    value(std::move(value__arg)),
    flags(std::move(flags__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.value = true;
  __isset.flags = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGatReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  flags = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGatReply::operator==(const McGatReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return false;
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return false;
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McGatReply::operator<(const McGatReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return lhs.value_ref().has_value() < rhs.value_ref().has_value();
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McGatReply& a, McGatReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.value_ref().value_unchecked(), b.value_ref().value_unchecked());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGatReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGatReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGatReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGatReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGatReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGatReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGatReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGatReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGatsRequest>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 2;
  static constexpr folly::StringPiece _names[] = {
    "exptime",
    "key",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_STRING,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatsRequest::McGatsRequest(apache::thrift::FragileConstructor, int32_t exptime__arg,  ::carbon::thrift::IOBufKey key__arg) :
    exptime(std::move(exptime__arg)),
    key(std::move(key__arg)) {
  __isset.exptime = true;
  __isset.key = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGatsRequest::__clear() {
  // clear all fields
  exptime = 0;
  key.rawUnsafe() = apache::thrift::StringTraits< folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGatsRequest::operator==(const McGatsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.exptime == rhs.exptime)) {
    return false;
  }
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return false;
  }
  return true;
}

bool McGatsRequest::operator<(const McGatsRequest& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.exptime == rhs.exptime)) {
    return lhs.exptime < rhs.exptime;
  }
  if (!apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isEqual(lhs.key.rawUnsafe(), rhs.key.rawUnsafe())) {
    return apache::thrift::StringTraits<folly::remove_cvref_t<decltype(std::declval<carbon::Keys<folly::IOBuf>>().rawUnsafe())>>::isLess(lhs.key.rawUnsafe(), rhs.key.rawUnsafe());
  }
  return false;
}


void swap(McGatsRequest& a, McGatsRequest& b) {
  using ::std::swap;
  swap(a.exptime_ref().value(), b.exptime_ref().value());
  swap(a.key_ref().value(), b.key_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGatsRequest::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGatsRequest::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGatsRequest::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGatsRequest::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGatsRequest::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGatsRequest::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGatsRequest::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGatsRequest::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::facebook::memcache::thrift::McGatsReply>::translateFieldName(
    FOLLY_MAYBE_UNUSED folly::StringPiece _fname,
    FOLLY_MAYBE_UNUSED int16_t& fid,
    FOLLY_MAYBE_UNUSED apache::thrift::protocol::TType& _ftype) noexcept {
  using TType = apache::thrift::protocol::TType;
  constexpr size_t _size = 6;
  static constexpr folly::StringPiece _names[] = {
    "result",
    "casToken",
    "value",
    "flags",
    "message",
    "appSpecificErrorCode",
  };
  static constexpr int16_t _ids[] = {
    1,
    2,
    3,
    4,
    5,
    6,
  };
  static constexpr TType _types[] = {
    TType::T_I32,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I64,
    TType::T_STRING,
    TType::T_I16,
  };
  static constexpr st::translate_field_name_table
      table{_size, _names, _ids, _types};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace facebook { namespace memcache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatsReply::McGatsReply() :
      result( ::carbon::Result::UNKNOWN),
      casToken(0),
      flags(0),
      appSpecificErrorCode(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


McGatsReply::~McGatsReply() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
McGatsReply::McGatsReply(apache::thrift::FragileConstructor,  ::carbon::Result result__arg, uint64_t casToken__arg, folly::IOBuf value__arg, uint64_t flags__arg, ::std::string message__arg, int16_t appSpecificErrorCode__arg) :
    result(std::move(result__arg)),
    casToken(std::move(casToken__arg)),
    value(std::move(value__arg)),
    flags(std::move(flags__arg)),
    message(std::move(message__arg)),
    appSpecificErrorCode(std::move(appSpecificErrorCode__arg)) {
  __isset.result = true;
  __isset.casToken = true;
  __isset.value = true;
  __isset.flags = true;
  __isset.message = true;
  __isset.appSpecificErrorCode = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void McGatsReply::__clear() {
  // clear all fields
  result =  ::carbon::Result::UNKNOWN;
  casToken = 0;
  value = apache::thrift::StringTraits< folly::IOBuf>::fromStringLiteral("");
  flags = 0;
  message = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  appSpecificErrorCode = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool McGatsReply::operator==(const McGatsReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return false;
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return false;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return false;
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return false;
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return false;
  }
  if (!(lhs.message == rhs.message)) {
    return false;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return false;
  }
  return true;
}

bool McGatsReply::operator<(const McGatsReply& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.result == rhs.result)) {
    return lhs.result < rhs.result;
  }
  if (!(lhs.casToken == rhs.casToken)) {
    return lhs.casToken < rhs.casToken;
  }
  if (lhs.value_ref().has_value() != rhs.value_ref().has_value()) {
    return lhs.value_ref().has_value() < rhs.value_ref().has_value();
  }
  if (lhs.value_ref().has_value()) {
    if (!apache::thrift::StringTraits<folly::IOBuf>::isEqual(lhs.value, rhs.value)) {
      return apache::thrift::StringTraits<folly::IOBuf>::isLess(lhs.value, rhs.value);
    }
  }
  if (!(lhs.flags == rhs.flags)) {
    return lhs.flags < rhs.flags;
  }
  if (!(lhs.message == rhs.message)) {
    return lhs.message < rhs.message;
  }
  if (!(lhs.appSpecificErrorCode == rhs.appSpecificErrorCode)) {
    return lhs.appSpecificErrorCode < rhs.appSpecificErrorCode;
  }
  return false;
}


void swap(McGatsReply& a, McGatsReply& b) {
  using ::std::swap;
  swap(a.result_ref().value(), b.result_ref().value());
  swap(a.casToken_ref().value(), b.casToken_ref().value());
  swap(a.value_ref().value_unchecked(), b.value_ref().value_unchecked());
  swap(a.flags_ref().value(), b.flags_ref().value());
  swap(a.message_ref().value(), b.message_ref().value());
  swap(a.appSpecificErrorCode_ref().value(), b.appSpecificErrorCode_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void McGatsReply::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t McGatsReply::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t McGatsReply::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t McGatsReply::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void McGatsReply::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t McGatsReply::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t McGatsReply::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t McGatsReply::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}}} // facebook::memcache::thrift
