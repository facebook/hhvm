#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/constants/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib
from builtins import property as _python__property

import typing as _typing
import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
from thrift.py3.types import (
    _fbthrift__is_float32,
    _fbthrift__filter_kwargs,
)
import thrift.py3.exceptions
import thrift.python.exceptions
import thrift.python.types
import module.thrift_types as _fbthrift_python_types
import module.thrift_enums as _fbthrift_python_enums



def get_types_reflection():
    return importlib.import_module(
        "module.types_reflection"
    )

def _get_py_deprecated_module():
    import thrift.util.converter # needed by _to_py_deprecated() call
    return importlib.import_module("module.ttypes")

_fbthrift__module_name__ = "module.types"

__all__ = []

### Enums ###

EmptyEnum = _fbthrift_python_enums.EmptyEnum

__all__.append("EmptyEnum")


City = _fbthrift_python_enums.City

__all__.append("City")


Company = _fbthrift_python_enums.Company

__all__.append("Company")


### Union Enums ###

class __union1Type(enum.Enum):
    i = 1
    d = 2
    EMPTY = 0

    __module__ = _fbthrift__module_name__
    __slots__ = ()

_fbthrift__union1Type = __union1Type

__all__.append("__union1Type")


class __union2Type(enum.Enum):
    i = 1
    d = 2
    s = 3
    u = 4
    EMPTY = 0

    __module__ = _fbthrift__module_name__
    __slots__ = ()

_fbthrift__union2Type = __union2Type

__all__.append("__union2Type")


### Containers ###
class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i32:
        _items = list(python_list)
        return List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i32)


__all__.append("List__i32")

class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_i32)

__all__.append("Map__string_i32")

class List__Map__string_i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__string_i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__string_i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__string_i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, int]")
        if not isinstance(item, Map__string_i32):
            item = Map__string_i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Map__string_i32):
            return item
        try:
            return Map__string_i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__string_i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Map__string_i32:
        _items = [
            Map__string_i32.from_python(item)
            for item in python_list
        ]
        return List__Map__string_i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Map__string_i32)


__all__.append("List__Map__string_i32")

class Map__string_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_string._check_key_type_or_raise
            check_val = Map__string_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_string)

__all__.append("Map__string_string")

class List__Company(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Company):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Company._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Company)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, Company) or
            isinstance(item, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{item!r} is not of type Company")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Company):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Company()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Company:
        _items = list(python_list)
        return List__Company(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Company)


__all__.append("List__Company")

class List__City(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__City):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__City._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__City)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, City) or
            isinstance(item, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{item!r} is not of type City")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, City):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__City()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__City:
        _items = list(python_list)
        return List__City(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__City)


__all__.append("List__City")

class Map__Company_List__City(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__Company_List__City):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__Company_List__City._check_key_type_or_raise
            check_val = Map__Company_List__City._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__Company_List__City)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, Company) or
            isinstance(key, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{key!r} is not of type Company")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, Company):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[City]")
        if not isinstance(item, List__City):
            item = List__City(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__Company_List__City()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__Company_List__City:
        _keys = python_map.keys()
        _values = (
            List__City.from_python(item)
            for item in python_map.values()
        )
        return Map__Company_List__City(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__Company_List__City)

__all__.append("Map__Company_List__City")

class List__Range(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Range):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Range._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Range)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, Range)
        ):
            raise TypeError(f"{item!r} is not of type Range")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Range):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Range()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Range:
        _items = [
            Range.from_python(item)
            for item in python_list
        ]
        return List__Range(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Range)


__all__.append("List__Range")

class List__Internship(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Internship):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Internship._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Internship)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, Internship)
        ):
            raise TypeError(f"{item!r} is not of type Internship")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Internship):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Internship()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Internship:
        _items = [
            Internship.from_python(item)
            for item in python_list
        ]
        return List__Internship(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Internship)


__all__.append("List__Internship")

class List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            check_method = List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__string:
        _items = list(python_list)
        return List__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__string)


__all__.append("List__string")

class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__i32:
        _items = frozenset(python_set)
        return Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__i32)


__all__.append("Set__i32")

class Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__string()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__string:
        _items = frozenset(python_set)
        return Set__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__string)


__all__.append("Set__string")

class Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_i32._check_key_type_or_raise
            check_val = Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_i32)

__all__.append("Map__i32_i32")

class Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_string._check_key_type_or_raise
            check_val = Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_string)

__all__.append("Map__i32_string")

class Map__i32_bool(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_bool):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_bool._check_key_type_or_raise
            check_val = Map__i32_bool._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_bool)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, bool)
        ):
            raise TypeError(f"{item!r} is not of type bool")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_bool()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_bool:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_bool(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_bool)

__all__.append("Map__i32_bool")


### Structured Types ###
class Internship(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.Internship
    _FBTHRIFT__FIELD_NAMES = (
        "weeks",
        "title",
        "employer",
        "compensation",
        "school",
    )
    _fbthrift__inner : _fbthrift_python_types.Internship


    def __init__(self, *args, **kwargs) -> None:
        _fbthrift__maybe_str_enum = kwargs.get("title", None)
        if isinstance(_fbthrift__maybe_str_enum, enum.Enum):
            kwargs["title"] = _fbthrift__maybe_str_enum.value
        _fbthrift__maybe_str_enum = kwargs.get("school", None)
        if isinstance(_fbthrift__maybe_str_enum, enum.Enum):
            kwargs["school"] = _fbthrift__maybe_str_enum.value
        try:
            self._fbthrift__inner = _fbthrift_python_types.Internship(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.Internship(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> Internship:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> Internship:
        return Internship.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.Internship) -> Internship:
        inst = Internship.__new__(Internship)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> Internship:
        return self

    def _to_python(self) -> _fbthrift_python_types.Internship:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.Internship, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Internship()

    @staticmethod
    def __get_metadata__():
        return Internship._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.Internship"

    @_python__property
    def weeks(self) -> int:
        return self._fbthrift__inner.weeks

    @_python__property
    def title(self) -> str:
        return self._fbthrift__inner.title

    @_python__property
    def employer(self) -> _typing.Optional[Company]:
        return self._fbthrift__inner.employer

    @_python__property
    def compensation(self) -> _typing.Optional[float]:
        return self._fbthrift__inner.compensation

    @_python__property
    def school(self) -> _typing.Optional[str]:
        return self._fbthrift__inner.school


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 5

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, Internship):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, Internship):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("Internship")

class Range(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.Range
    _FBTHRIFT__FIELD_NAMES = (
        "min",
        "max",
    )
    _fbthrift__inner : _fbthrift_python_types.Range


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.Range(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.Range(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> Range:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> Range:
        return Range.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.Range) -> Range:
        inst = Range.__new__(Range)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> Range:
        return self

    def _to_python(self) -> _fbthrift_python_types.Range:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.Range, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Range()

    @staticmethod
    def __get_metadata__():
        return Range._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.Range"

    @_python__property
    def min(self) -> int:
        return self._fbthrift__inner.min

    @_python__property
    def max(self) -> int:
        return self._fbthrift__inner.max


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, Range):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, Range):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("Range")

class struct1(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.struct1
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
    )
    _fbthrift__inner : _fbthrift_python_types.struct1


    def __init__(self, *args, **kwargs) -> None:
        _fbthrift__maybe_str_enum = kwargs.get("b", None)
        if isinstance(_fbthrift__maybe_str_enum, enum.Enum):
            kwargs["b"] = _fbthrift__maybe_str_enum.value
        try:
            self._fbthrift__inner = _fbthrift_python_types.struct1(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.struct1(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> struct1:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> struct1:
        return struct1.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.struct1) -> struct1:
        inst = struct1.__new__(struct1)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> struct1:
        return self

    def _to_python(self) -> _fbthrift_python_types.struct1:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.struct1, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__struct1()

    @staticmethod
    def __get_metadata__():
        return struct1._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.struct1"

    @_python__property
    def a(self) -> int:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> str:
        return self._fbthrift__inner.b


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, struct1):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, struct1):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("struct1")

class struct2(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__c",
        "_fbthrift_inner__d",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.struct2
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
        "c",
        "d",
    )
    _fbthrift__inner : _fbthrift_python_types.struct2
    _fbthrift_inner__c : struct1 | None
    _fbthrift_inner__d : _typing.Sequence[int] | None


    def __init__(self, *args, **kwargs) -> None:
        _fbthrift__maybe_str_enum = kwargs.get("b", None)
        if isinstance(_fbthrift__maybe_str_enum, enum.Enum):
            kwargs["b"] = _fbthrift__maybe_str_enum.value
        try:
            self._fbthrift__inner = _fbthrift_python_types.struct2(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.struct2(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> struct2:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__c = None
        instance._fbthrift_inner__d = None
        return instance

    def __call__(self, **kwargs) -> struct2:
        return struct2.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.struct2) -> struct2:
        inst = struct2.__new__(struct2)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> struct2:
        return self

    def _to_python(self) -> _fbthrift_python_types.struct2:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.struct2, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__struct2()

    @staticmethod
    def __get_metadata__():
        return struct2._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.struct2"

    @_python__property
    def a(self) -> int:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> str:
        return self._fbthrift__inner.b

    @_python__property
    def c(self) -> struct1:
        if self._fbthrift_inner__c is None:
            __python_val = self._fbthrift__inner.c
            self._fbthrift_inner__c = struct1.from_python(__python_val)

        return self._fbthrift_inner__c

    @_python__property
    def d(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__d is None:
            __python_val = self._fbthrift__inner.d
            self._fbthrift_inner__d = List__i32.from_python(__python_val)

        return self._fbthrift_inner__d


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 4

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, struct2):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, struct2):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("struct2")

class struct3(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__c",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.struct3
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
        "c",
    )
    _fbthrift__inner : _fbthrift_python_types.struct3
    _fbthrift_inner__c : struct2 | None


    def __init__(self, *args, **kwargs) -> None:
        _fbthrift__maybe_str_enum = kwargs.get("a", None)
        if isinstance(_fbthrift__maybe_str_enum, enum.Enum):
            kwargs["a"] = _fbthrift__maybe_str_enum.value
        try:
            self._fbthrift__inner = _fbthrift_python_types.struct3(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.struct3(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> struct3:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__c = None
        return instance

    def __call__(self, **kwargs) -> struct3:
        return struct3.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.struct3) -> struct3:
        inst = struct3.__new__(struct3)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> struct3:
        return self

    def _to_python(self) -> _fbthrift_python_types.struct3:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.struct3, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__struct3()

    @staticmethod
    def __get_metadata__():
        return struct3._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.struct3"

    @_python__property
    def a(self) -> str:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> int:
        return self._fbthrift__inner.b

    @_python__property
    def c(self) -> struct2:
        if self._fbthrift_inner__c is None:
            __python_val = self._fbthrift__inner.c
            self._fbthrift_inner__c = struct2.from_python(__python_val)

        return self._fbthrift_inner__c


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 3

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, struct3):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, struct3):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("struct3")

class struct4(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.struct4
    _FBTHRIFT__FIELD_NAMES = (
        "a",
        "b",
        "c",
    )
    _fbthrift__inner : _fbthrift_python_types.struct4


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.struct4(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.struct4(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> struct4:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> struct4:
        return struct4.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.struct4) -> struct4:
        inst = struct4.__new__(struct4)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> struct4:
        return self

    def _to_python(self) -> _fbthrift_python_types.struct4:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.struct4, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__struct4()

    @staticmethod
    def __get_metadata__():
        return struct4._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.struct4"

    @_python__property
    def a(self) -> int:
        return self._fbthrift__inner.a

    @_python__property
    def b(self) -> _typing.Optional[float]:
        return self._fbthrift__inner.b

    @_python__property
    def c(self) -> _typing.Optional[int]:
        return self._fbthrift__inner.c


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 3

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, struct4):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, struct4):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("struct4")

class union1(thrift.py3.types.Union):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__type",
        "_fbthrift_inner__value",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.union1
    _FBTHRIFT__FIELD_NAMES = (
        "i",
        "d",
    )
    Type = _fbthrift__union1Type
    _fbthrift__inner : _fbthrift_python_types.union1
    _fbthrift_inner__type: Type
    _fbthrift_inner__value: int | float | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.union1(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.union1(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> union1:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__type = None
        instance._fbthrift_inner__value = None
        return instance

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.union1) -> union1:
        inst = union1.__new__(union1)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> union1:
        return self

    def _to_python(self) -> _fbthrift_python_types.union1:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.union1, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__union1()

    @staticmethod
    def __get_metadata__():
        return union1._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.union1"

    @_python__property
    def i(self) -> int:
        return self._fbthrift__inner.i

    @_python__property
    def d(self) -> float:
        return self._fbthrift__inner.d

    @_python__property
    def type(self) -> _fbthrift_python_types.union1.Type:
        if self._fbthrift_inner__type is None:
            self._fbthrift_inner__type = self.Type(self._fbthrift__inner.type.value)
        return self._fbthrift_inner__type

    @_python__property
    def value(self) -> int | float | None:
        match self._fbthrift__inner.type:
            case _:
                return self._fbthrift__inner.value


    @staticmethod
    def fromValue(value) -> union1:
        if value is None:
            return union1()
        if isinstance(value, int):
            if not isinstance(value, bool):
                try:
                    return union1(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, bool):
                try:
                    return union1(d=value)
                except OverflowError:
                    pass
        if isinstance(value, (float, int)):
            try:
                return union1(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 2

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, union1):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, union1):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("union1")

class union2(thrift.py3.types.Union):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__s",
        "_fbthrift_inner__u",
        "_fbthrift_inner__type",
        "_fbthrift_inner__value",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.union2
    _FBTHRIFT__FIELD_NAMES = (
        "i",
        "d",
        "s",
        "u",
    )
    Type = _fbthrift__union2Type
    _fbthrift__inner : _fbthrift_python_types.union2
    _fbthrift_inner__s : struct1 | None
    _fbthrift_inner__u : union1 | None
    _fbthrift_inner__type: Type
    _fbthrift_inner__value: int | float | struct1 | union1 | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.union2(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.union2(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> union2:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__s = None
        instance._fbthrift_inner__u = None
        instance._fbthrift_inner__type = None
        instance._fbthrift_inner__value = None
        return instance

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.union2) -> union2:
        inst = union2.__new__(union2)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> union2:
        return self

    def _to_python(self) -> _fbthrift_python_types.union2:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.union2, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__union2()

    @staticmethod
    def __get_metadata__():
        return union2._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.union2"

    @_python__property
    def i(self) -> int:
        return self._fbthrift__inner.i

    @_python__property
    def d(self) -> float:
        return self._fbthrift__inner.d

    @_python__property
    def s(self) -> struct1:
        if self._fbthrift_inner__s is None:
            __python_val = self._fbthrift__inner.s
            if __python_val is None:
                return None
            self._fbthrift_inner__s = struct1.from_python(__python_val)

        return self._fbthrift_inner__s

    @_python__property
    def u(self) -> union1:
        if self._fbthrift_inner__u is None:
            __python_val = self._fbthrift__inner.u
            if __python_val is None:
                return None
            self._fbthrift_inner__u = union1.from_python(__python_val)

        return self._fbthrift_inner__u

    @_python__property
    def type(self) -> _fbthrift_python_types.union2.Type:
        if self._fbthrift_inner__type is None:
            self._fbthrift_inner__type = self.Type(self._fbthrift__inner.type.value)
        return self._fbthrift_inner__type

    @_python__property
    def value(self) -> int | float | struct1 | union1 | None:
        match self._fbthrift__inner.type:
            case _fbthrift_python_types.union2.Type.s:
                return self.s
            case _fbthrift_python_types.union2.Type.u:
                return self.u
            case _:
                return self._fbthrift__inner.value


    @staticmethod
    def fromValue(value) -> union2:
        if value is None:
            return union2()
        if isinstance(value, int):
            if not isinstance(value, bool):
                try:
                    return union2(i=value)
                except OverflowError:
                    pass
        if isinstance(value, float):
            if not isinstance(value, bool):
                try:
                    return union2(d=value)
                except OverflowError:
                    pass
        if isinstance(value, struct1):
            return union2(s=value)
        if isinstance(value, union1):
            return union2(u=value)
        if isinstance(value, (float, int)):
            try:
                return union2(d=value)
            except OverflowError:
                pass
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 4

    def __eq__(self, other):
        if type(self) == type(other):
            return self._fbthrift__inner == other._fbthrift__inner

        if type(other) is self._FBTHRIFT__PYTHON_CLASS:
            return self._fbthrift__inner == other

        return False


    def __lt__(self, other):
        if not isinstance(other, union2):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, union2):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("union2")


### Constants
myInt = 1337
name = "Mark Zuckerberg"
multi_line_string = "This\nis a\nmulti line string.\n"
states = List__Map__string_i32((Map__string_i32( { "San Diego": 3211000, "Sacramento": 479600, "SF": 837400 }), Map__string_i32( { "New York": 8406000, "Albany": 98400 }), ))
x = 1
y = 1000000.0
z = 1000000000
zeroDoubleValue = 0
longDoubleValue = 2.59961000990301e-05
bin = b"a\000z"
my_company = Company.FACEBOOK
foo = "foo"
bar = 42
mymap = Map__string_string( { "keys": "values" })
my_apps = List__Company((Company.FACEBOOK, Company._Company__FRIEND__FEED, ))
instagram = Internship(weeks=12, title="Software Engineer", employer=Company.INSTAGRAM, compensation=1200, school="Monters University")
partial_const = Internship(weeks=8, title="Some Job")
cities = List__City((City.NYC, City.MPK, City.SEA, City.LON, ))
company_locations = Map__Company_List__City( { Company.FACEBOOK: List__City((City.NYC, City.MPK, City.SEA, City.LON, )) })
kRanges = List__Range((Range(min=1, max=2), Range(min=5, max=6), ))
internList = List__Internship((Internship(weeks=12, title="Software Engineer", employer=Company.INSTAGRAM, compensation=1200, school="Monters University"), Internship(weeks=10, title="Sales Intern", employer=Company.FACEBOOK, compensation=1000), ))
pod_0 = struct1()
pod_s_0 = struct1()
pod_1 = struct1(a=10, b="foo")
pod_s_1 = struct1(a=10, b="foo")
pod_2 = struct2(a=98, b="gaz", c=struct1(a=12, b="bar"), d=List__i32((11, 22, 33, )))
pod_trailing_commas = struct2(a=98, b="gaz", c=struct1(a=12, b="bar"), d=List__i32((11, 22, 33, )))
pod_s_2 = struct2(a=98, b="gaz", c=struct1(a=12, b="bar"), d=List__i32((11, 22, 33, )))
pod_3 = struct3(a="abc", b=456, c=struct2(a=888, c=struct1(b="gaz"), d=List__i32((1, 2, 3, ))))
pod_s_3 = struct3(a="abc", b=456, c=struct2(a=888, c=struct1(b="gaz"), d=List__i32((1, 2, 3, ))))
pod_4 = struct4(a=1234, b=0.333, c=25)
u_1_1 = union1(i=97)
u_1_2 = union1(d=5.6)
u_1_3 = union1()
u_2_1 = union2(i=51)
u_2_2 = union2(d=6.7)
u_2_3 = union2(s=struct1(a=8, b="abacabb"))
u_2_4 = union2(u=union1(i=43))
u_2_5 = union2(u=union1(d=9.8))
u_2_6 = union2(u=union1())
apostrophe = "'"
tripleApostrophe = "'''"
quotationMark = "\""
backslash = "\\"
escaped_a = "a"
char2ascii = Map__string_i32( { "'": 39, "\"": 34, "\\": 92, "a": 97 })
escaped_strings = List__string(("\001", "\037", " ", "'", "\"", "\n", "\r", "\011", "a", "", "j", "", "ayyy", "yyy", "jyyy", "yyy", "zzza", "zzz", "zzzj", "zzz", "zzzayyy", "zzzyyy", "zzzjyyy", "zzzyyy", ))
unicode_list = List__string(("Bulgaria", "Benin", "Saint Barthlemy", ))
false_c = False
true_c = True
zero_byte = 0
zero16 = 0
zero32 = 0
zero64 = 0
zero_dot_zero = 0
empty_string = ""
empty_int_list = List__i32(())
empty_string_list = List__string(())
empty_int_set = Set__i32(())
empty_string_set = Set__string(())
empty_int_int_map = Map__i32_i32( {  })
empty_int_string_map = Map__i32_string( {  })
empty_string_int_map = Map__string_i32( {  })
empty_string_string_map = Map__string_string( {  })
unicode_map = Map__string_string( { "BG": "Bulgaria", "BH": "Bahrain", "B": "Saint Barthlemy" })
maxIntDec = 9223372036854775807
maxIntOct = 9223372036854775807
maxIntHex = 9223372036854775807
maxIntBin = 9223372036854775807
maxDub = 1.7976931348623157e+308
minDub = 2.2250738585072014e-308
minSDub = 5e-324
maxPIntDec = 9223372036854775807
maxPIntOct = 9223372036854775807
maxPIntHex = 9223372036854775807
maxPIntBin = 9223372036854775807
maxPDub = 1.7976931348623157e+308
minPDub = 2.2250738585072014e-308
minPSDub = 5e-324
minIntDec = -9223372036854775808
minIntOct = -9223372036854775808
minIntHex = -9223372036854775808
minIntBin = -9223372036854775808
maxNDub = -1.7976931348623157e+308
minNDub = -2.2250738585072014e-308
minNSDub = -5e-324
I2B = Map__i32_bool( { 0: False, 1: True, 2: True, 3: False })
I2B_REF = Map__i32_bool( { 0: False, 1: True, 2: True, 3: False })
map_list_initializer = Map__i32_i32( {  })
list_map_initializer = List__i32(())
set_map_initializer = Set__i32(())
