// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package patch // [[[ program thrift source path ]]]

import (
    "fmt"
    "strings"

    standard "thrift/lib/thrift/standard"
    id "thrift/lib/thrift/id"
    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

var _ = standard.GoUnusedProtection__
var _ = id.GoUnusedProtection__

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = thrift.ZERO
var _ = strings.Split


type FieldId = id.FieldId

func NewFieldId() FieldId {
  return id.NewFieldId()
}

func WriteFieldId(item FieldId, p thrift.Protocol) error {
  err := id.WriteFieldId(item, p)
if err != nil {
    return err
}
  return nil
}

func ReadFieldId(p thrift.Protocol) (FieldId, error) {
  var decodeResult FieldId
  decodeErr := func() error {
    result, err := id.ReadFieldId(p)
if err != nil {
    return err
}
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type FieldIdList = []int16

func NewFieldIdList() FieldIdList {
  return nil
}

func WriteFieldIdList(item FieldIdList, p thrift.Protocol) error {
  if err := p.WriteListBegin(thrift.I16, len(item)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
}
for _, v := range item {
    {
        item := v
        if err := p.WriteI16(item); err != nil {
    return err
}
    }
}
if err := p.WriteListEnd(); err != nil {
    return thrift.PrependError("error writing list end: ", err)
}
  return nil
}

func ReadFieldIdList(p thrift.Protocol) (FieldIdList, error) {
  var decodeResult FieldIdList
  decodeErr := func() error {
    _ /* elemType */, size, err := p.ReadListBegin()
if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
}

listResult := make([]int16, 0, size)
for i := 0; i < size; i++ {
    var elem int16
    {
        result, err := p.ReadI16()
if err != nil {
    return err
}
        elem = result
    }
    listResult = append(listResult, elem)
}

if err := p.ReadListEnd(); err != nil {
    return thrift.PrependError("error reading list end: ", err)
}
result := listResult
    decodeResult = result
    return nil
  }()
  return decodeResult, decodeErr
}

type PatchOp int32

const (
    PatchOp_Unspecified PatchOp = 0
    PatchOp_Assign PatchOp = 1
    PatchOp_Clear PatchOp = 2
    PatchOp_PatchPrior PatchOp = 3
    PatchOp_EnsureUnion PatchOp = 4
    PatchOp_EnsureStruct PatchOp = 5
    PatchOp_PatchAfter PatchOp = 6
    PatchOp_Remove PatchOp = 7
    PatchOp_Add PatchOp = 8
    PatchOp_Put PatchOp = 9
)

// Enum value maps for PatchOp
var (
    PatchOpToName = map[PatchOp]string {
        PatchOp_Unspecified: "Unspecified",
        PatchOp_Assign: "Assign",
        PatchOp_Clear: "Clear",
        PatchOp_PatchPrior: "PatchPrior",
        PatchOp_EnsureUnion: "EnsureUnion",
        PatchOp_EnsureStruct: "EnsureStruct",
        PatchOp_PatchAfter: "PatchAfter",
        PatchOp_Remove: "Remove",
        PatchOp_Add: "Add",
        PatchOp_Put: "Put",
    }

    PatchOpToValue = map[string]PatchOp {
        "Unspecified": PatchOp_Unspecified,
        "Assign": PatchOp_Assign,
        "Clear": PatchOp_Clear,
        "PatchPrior": PatchOp_PatchPrior,
        "EnsureUnion": PatchOp_EnsureUnion,
        "EnsureStruct": PatchOp_EnsureStruct,
        "PatchAfter": PatchOp_PatchAfter,
        "Remove": PatchOp_Remove,
        "Add": PatchOp_Add,
        "Put": PatchOp_Put,
    }

    PatchOpNames = []string{
        "Unspecified",
        "Assign",
        "Clear",
        "PatchPrior",
        "EnsureUnion",
        "EnsureStruct",
        "PatchAfter",
        "Remove",
        "Add",
        "Put",
    }

    PatchOpValues = []PatchOp{
        PatchOp_Unspecified,
        PatchOp_Assign,
        PatchOp_Clear,
        PatchOp_PatchPrior,
        PatchOp_EnsureUnion,
        PatchOp_EnsureStruct,
        PatchOp_PatchAfter,
        PatchOp_Remove,
        PatchOp_Add,
        PatchOp_Put,
    }
)

func (x PatchOp) String() string {
    if v, ok := PatchOpToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x PatchOp) Ptr() *PatchOp {
    return &x
}

// Deprecated: Use PatchOpToValue instead (e.g. `x, ok := PatchOpToValue["name"]`).
func PatchOpFromString(s string) (PatchOp, error) {
    if v, ok := PatchOpToValue[s]; ok {
        return v, nil
    }
    return PatchOp(0), fmt.Errorf("not a valid PatchOp string")
}

// Deprecated: Use PatchOp.Ptr() instead.
func PatchOpPtr(v PatchOp) *PatchOp {
    return &v
}


type GeneratePatch struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &GeneratePatch{}

func NewGeneratePatch() *GeneratePatch {
    return (&GeneratePatch{})
}


// Deprecated: Use GeneratePatch.Set* methods instead or set the fields directly.
type GeneratePatchBuilder struct {
    obj *GeneratePatch
}

func NewGeneratePatchBuilder() *GeneratePatchBuilder {
    return &GeneratePatchBuilder{
        obj: NewGeneratePatch(),
    }
}

func (x *GeneratePatchBuilder) Emit() *GeneratePatch {
    var objCopy GeneratePatch = *x.obj
    return &objCopy
}

func (x *GeneratePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("GeneratePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *GeneratePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *GeneratePatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("GeneratePatch({")
    sb.WriteString("})")

    return sb.String()
}

type AssignOnlyPatch struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &AssignOnlyPatch{}

func NewAssignOnlyPatch() *AssignOnlyPatch {
    return (&AssignOnlyPatch{})
}


// Deprecated: Use AssignOnlyPatch.Set* methods instead or set the fields directly.
type AssignOnlyPatchBuilder struct {
    obj *AssignOnlyPatch
}

func NewAssignOnlyPatchBuilder() *AssignOnlyPatchBuilder {
    return &AssignOnlyPatchBuilder{
        obj: NewAssignOnlyPatch(),
    }
}

func (x *AssignOnlyPatchBuilder) Emit() *AssignOnlyPatch {
    var objCopy AssignOnlyPatch = *x.obj
    return &objCopy
}

func (x *AssignOnlyPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("AssignOnlyPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *AssignOnlyPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *AssignOnlyPatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("AssignOnlyPatch({")
    sb.WriteString("})")

    return sb.String()
}

type BoolPatch struct {
    Assign *bool `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Invert bool `thrift:"invert,9" json:"invert" db:"invert"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BoolPatch{}

func NewBoolPatch() *BoolPatch {
    return (&BoolPatch{}).
        SetClearNonCompat(false).
        SetInvertNonCompat(false)
}

func (x *BoolPatch) GetAssignNonCompat() *bool {
    return x.Assign
}

func (x *BoolPatch) GetAssign() bool {
    if !x.IsSetAssign() {
        return false
    }

    return *x.Assign
}

func (x *BoolPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BoolPatch) GetClear() bool {
    return x.Clear
}

func (x *BoolPatch) GetInvertNonCompat() bool {
    return x.Invert
}

func (x *BoolPatch) GetInvert() bool {
    return x.Invert
}

func (x *BoolPatch) SetAssignNonCompat(value bool) *BoolPatch {
    x.Assign = &value
    return x
}

func (x *BoolPatch) SetAssign(value *bool) *BoolPatch {
    x.Assign = value
    return x
}

func (x *BoolPatch) SetClearNonCompat(value bool) *BoolPatch {
    x.Clear = value
    return x
}

func (x *BoolPatch) SetClear(value bool) *BoolPatch {
    x.Clear = value
    return x
}

func (x *BoolPatch) SetInvertNonCompat(value bool) *BoolPatch {
    x.Invert = value
    return x
}

func (x *BoolPatch) SetInvert(value bool) *BoolPatch {
    x.Invert = value
    return x
}

func (x *BoolPatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *BoolPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) writeField9(p thrift.Protocol) error {  // Invert
    if err := p.WriteFieldBegin("invert", thrift.BOOL, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetInvertNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *BoolPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *BoolPatch) readField9(p thrift.Protocol) error {  // Invert
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetInvertNonCompat(result)
    return nil
}

func (x *BoolPatch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *BoolPatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *BoolPatch) toString9() string {  // Invert
    return fmt.Sprintf("%v", x.GetInvertNonCompat())
}

// Deprecated: Use NewBoolPatch().GetAssign() instead.
var BoolPatch_Assign_DEFAULT = NewBoolPatch().GetAssign()


// Deprecated: Use BoolPatch.Set* methods instead or set the fields directly.
type BoolPatchBuilder struct {
    obj *BoolPatch
}

func NewBoolPatchBuilder() *BoolPatchBuilder {
    return &BoolPatchBuilder{
        obj: NewBoolPatch(),
    }
}

func (x *BoolPatchBuilder) Assign(value *bool) *BoolPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BoolPatchBuilder) Clear(value bool) *BoolPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BoolPatchBuilder) Invert(value bool) *BoolPatchBuilder {
    x.obj.Invert = value
    return x
}

func (x *BoolPatchBuilder) Emit() *BoolPatch {
    var objCopy BoolPatch = *x.obj
    return &objCopy
}

func (x *BoolPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BoolPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BoolPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 9:  // invert
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *BoolPatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("BoolPatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Invert:%s", x.toString9()))
    sb.WriteString("})")

    return sb.String()
}

type BytePatch struct {
    Assign *int8 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int8 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BytePatch{}

func NewBytePatch() *BytePatch {
    return (&BytePatch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0)
}

func (x *BytePatch) GetAssignNonCompat() *int8 {
    return x.Assign
}

func (x *BytePatch) GetAssign() int8 {
    if !x.IsSetAssign() {
        return 0
    }

    return *x.Assign
}

func (x *BytePatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BytePatch) GetClear() bool {
    return x.Clear
}

func (x *BytePatch) GetAddNonCompat() int8 {
    return x.Add
}

func (x *BytePatch) GetAdd() int8 {
    return x.Add
}

func (x *BytePatch) SetAssignNonCompat(value int8) *BytePatch {
    x.Assign = &value
    return x
}

func (x *BytePatch) SetAssign(value *int8) *BytePatch {
    x.Assign = value
    return x
}

func (x *BytePatch) SetClearNonCompat(value bool) *BytePatch {
    x.Clear = value
    return x
}

func (x *BytePatch) SetClear(value bool) *BytePatch {
    x.Clear = value
    return x
}

func (x *BytePatch) SetAddNonCompat(value int8) *BytePatch {
    x.Add = value
    return x
}

func (x *BytePatch) SetAdd(value int8) *BytePatch {
    x.Add = value
    return x
}

func (x *BytePatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *BytePatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.BYTE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.BYTE, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteByte(byte(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) readField1(p thrift.Protocol) error {  // Assign
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *BytePatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *BytePatch) readField8(p thrift.Protocol) error {  // Add
    resultByte, err := p.ReadByte()
result := int8(resultByte)
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *BytePatch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *BytePatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *BytePatch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewBytePatch().GetAssign() instead.
var BytePatch_Assign_DEFAULT = NewBytePatch().GetAssign()


// Deprecated: Use BytePatch.Set* methods instead or set the fields directly.
type BytePatchBuilder struct {
    obj *BytePatch
}

func NewBytePatchBuilder() *BytePatchBuilder {
    return &BytePatchBuilder{
        obj: NewBytePatch(),
    }
}

func (x *BytePatchBuilder) Assign(value *int8) *BytePatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BytePatchBuilder) Clear(value bool) *BytePatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BytePatchBuilder) Add(value int8) *BytePatchBuilder {
    x.obj.Add = value
    return x
}

func (x *BytePatchBuilder) Emit() *BytePatch {
    var objCopy BytePatch = *x.obj
    return &objCopy
}

func (x *BytePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BytePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BytePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *BytePatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("BytePatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type I16Patch struct {
    Assign *int16 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int16 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I16Patch{}

func NewI16Patch() *I16Patch {
    return (&I16Patch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0)
}

func (x *I16Patch) GetAssignNonCompat() *int16 {
    return x.Assign
}

func (x *I16Patch) GetAssign() int16 {
    if !x.IsSetAssign() {
        return 0
    }

    return *x.Assign
}

func (x *I16Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I16Patch) GetClear() bool {
    return x.Clear
}

func (x *I16Patch) GetAddNonCompat() int16 {
    return x.Add
}

func (x *I16Patch) GetAdd() int16 {
    return x.Add
}

func (x *I16Patch) SetAssignNonCompat(value int16) *I16Patch {
    x.Assign = &value
    return x
}

func (x *I16Patch) SetAssign(value *int16) *I16Patch {
    x.Assign = value
    return x
}

func (x *I16Patch) SetClearNonCompat(value bool) *I16Patch {
    x.Clear = value
    return x
}

func (x *I16Patch) SetClear(value bool) *I16Patch {
    x.Clear = value
    return x
}

func (x *I16Patch) SetAddNonCompat(value int16) *I16Patch {
    x.Add = value
    return x
}

func (x *I16Patch) SetAdd(value int16) *I16Patch {
    x.Add = value
    return x
}

func (x *I16Patch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *I16Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I16, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I16, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI16(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *I16Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *I16Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI16()
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *I16Patch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *I16Patch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *I16Patch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewI16Patch().GetAssign() instead.
var I16Patch_Assign_DEFAULT = NewI16Patch().GetAssign()


// Deprecated: Use I16Patch.Set* methods instead or set the fields directly.
type I16PatchBuilder struct {
    obj *I16Patch
}

func NewI16PatchBuilder() *I16PatchBuilder {
    return &I16PatchBuilder{
        obj: NewI16Patch(),
    }
}

func (x *I16PatchBuilder) Assign(value *int16) *I16PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I16PatchBuilder) Clear(value bool) *I16PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I16PatchBuilder) Add(value int16) *I16PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I16PatchBuilder) Emit() *I16Patch {
    var objCopy I16Patch = *x.obj
    return &objCopy
}

func (x *I16Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I16Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I16Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *I16Patch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("I16Patch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type I32Patch struct {
    Assign *int32 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int32 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I32Patch{}

func NewI32Patch() *I32Patch {
    return (&I32Patch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0)
}

func (x *I32Patch) GetAssignNonCompat() *int32 {
    return x.Assign
}

func (x *I32Patch) GetAssign() int32 {
    if !x.IsSetAssign() {
        return 0
    }

    return *x.Assign
}

func (x *I32Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I32Patch) GetClear() bool {
    return x.Clear
}

func (x *I32Patch) GetAddNonCompat() int32 {
    return x.Add
}

func (x *I32Patch) GetAdd() int32 {
    return x.Add
}

func (x *I32Patch) SetAssignNonCompat(value int32) *I32Patch {
    x.Assign = &value
    return x
}

func (x *I32Patch) SetAssign(value *int32) *I32Patch {
    x.Assign = value
    return x
}

func (x *I32Patch) SetClearNonCompat(value bool) *I32Patch {
    x.Clear = value
    return x
}

func (x *I32Patch) SetClear(value bool) *I32Patch {
    x.Clear = value
    return x
}

func (x *I32Patch) SetAddNonCompat(value int32) *I32Patch {
    x.Add = value
    return x
}

func (x *I32Patch) SetAdd(value int32) *I32Patch {
    x.Add = value
    return x
}

func (x *I32Patch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *I32Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I32, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI32(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *I32Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *I32Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI32()
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *I32Patch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *I32Patch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *I32Patch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewI32Patch().GetAssign() instead.
var I32Patch_Assign_DEFAULT = NewI32Patch().GetAssign()


// Deprecated: Use I32Patch.Set* methods instead or set the fields directly.
type I32PatchBuilder struct {
    obj *I32Patch
}

func NewI32PatchBuilder() *I32PatchBuilder {
    return &I32PatchBuilder{
        obj: NewI32Patch(),
    }
}

func (x *I32PatchBuilder) Assign(value *int32) *I32PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I32PatchBuilder) Clear(value bool) *I32PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I32PatchBuilder) Add(value int32) *I32PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I32PatchBuilder) Emit() *I32Patch {
    var objCopy I32Patch = *x.obj
    return &objCopy
}

func (x *I32Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I32Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I32Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *I32Patch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("I32Patch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type I64Patch struct {
    Assign *int64 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add int64 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &I64Patch{}

func NewI64Patch() *I64Patch {
    return (&I64Patch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0)
}

func (x *I64Patch) GetAssignNonCompat() *int64 {
    return x.Assign
}

func (x *I64Patch) GetAssign() int64 {
    if !x.IsSetAssign() {
        return 0
    }

    return *x.Assign
}

func (x *I64Patch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *I64Patch) GetClear() bool {
    return x.Clear
}

func (x *I64Patch) GetAddNonCompat() int64 {
    return x.Add
}

func (x *I64Patch) GetAdd() int64 {
    return x.Add
}

func (x *I64Patch) SetAssignNonCompat(value int64) *I64Patch {
    x.Assign = &value
    return x
}

func (x *I64Patch) SetAssign(value *int64) *I64Patch {
    x.Assign = value
    return x
}

func (x *I64Patch) SetClearNonCompat(value bool) *I64Patch {
    x.Clear = value
    return x
}

func (x *I64Patch) SetClear(value bool) *I64Patch {
    x.Clear = value
    return x
}

func (x *I64Patch) SetAddNonCompat(value int64) *I64Patch {
    x.Add = value
    return x
}

func (x *I64Patch) SetAdd(value int64) *I64Patch {
    x.Add = value
    return x
}

func (x *I64Patch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *I64Patch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.I64, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.I64, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteI64(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *I64Patch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *I64Patch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadI64()
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *I64Patch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *I64Patch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *I64Patch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewI64Patch().GetAssign() instead.
var I64Patch_Assign_DEFAULT = NewI64Patch().GetAssign()


// Deprecated: Use I64Patch.Set* methods instead or set the fields directly.
type I64PatchBuilder struct {
    obj *I64Patch
}

func NewI64PatchBuilder() *I64PatchBuilder {
    return &I64PatchBuilder{
        obj: NewI64Patch(),
    }
}

func (x *I64PatchBuilder) Assign(value *int64) *I64PatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *I64PatchBuilder) Clear(value bool) *I64PatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *I64PatchBuilder) Add(value int64) *I64PatchBuilder {
    x.obj.Add = value
    return x
}

func (x *I64PatchBuilder) Emit() *I64Patch {
    var objCopy I64Patch = *x.obj
    return &objCopy
}

func (x *I64Patch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("I64Patch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *I64Patch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *I64Patch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("I64Patch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type FloatPatch struct {
    Assign *float32 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add float32 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &FloatPatch{}

func NewFloatPatch() *FloatPatch {
    return (&FloatPatch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0.0)
}

func (x *FloatPatch) GetAssignNonCompat() *float32 {
    return x.Assign
}

func (x *FloatPatch) GetAssign() float32 {
    if !x.IsSetAssign() {
        return 0.0
    }

    return *x.Assign
}

func (x *FloatPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *FloatPatch) GetClear() bool {
    return x.Clear
}

func (x *FloatPatch) GetAddNonCompat() float32 {
    return x.Add
}

func (x *FloatPatch) GetAdd() float32 {
    return x.Add
}

func (x *FloatPatch) SetAssignNonCompat(value float32) *FloatPatch {
    x.Assign = &value
    return x
}

func (x *FloatPatch) SetAssign(value *float32) *FloatPatch {
    x.Assign = value
    return x
}

func (x *FloatPatch) SetClearNonCompat(value bool) *FloatPatch {
    x.Clear = value
    return x
}

func (x *FloatPatch) SetClear(value bool) *FloatPatch {
    x.Clear = value
    return x
}

func (x *FloatPatch) SetAddNonCompat(value float32) *FloatPatch {
    x.Add = value
    return x
}

func (x *FloatPatch) SetAdd(value float32) *FloatPatch {
    x.Add = value
    return x
}

func (x *FloatPatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *FloatPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.FLOAT, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteFloat(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.FLOAT, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteFloat(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadFloat()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *FloatPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *FloatPatch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadFloat()
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *FloatPatch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *FloatPatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *FloatPatch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewFloatPatch().GetAssign() instead.
var FloatPatch_Assign_DEFAULT = NewFloatPatch().GetAssign()


// Deprecated: Use FloatPatch.Set* methods instead or set the fields directly.
type FloatPatchBuilder struct {
    obj *FloatPatch
}

func NewFloatPatchBuilder() *FloatPatchBuilder {
    return &FloatPatchBuilder{
        obj: NewFloatPatch(),
    }
}

func (x *FloatPatchBuilder) Assign(value *float32) *FloatPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *FloatPatchBuilder) Clear(value bool) *FloatPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *FloatPatchBuilder) Add(value float32) *FloatPatchBuilder {
    x.obj.Add = value
    return x
}

func (x *FloatPatchBuilder) Emit() *FloatPatch {
    var objCopy FloatPatch = *x.obj
    return &objCopy
}

func (x *FloatPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("FloatPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FloatPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *FloatPatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("FloatPatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type DoublePatch struct {
    Assign *float64 `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Add float64 `thrift:"add,8" json:"add" db:"add"`
}
// Compile time interface enforcer
var _ thrift.Struct = &DoublePatch{}

func NewDoublePatch() *DoublePatch {
    return (&DoublePatch{}).
        SetClearNonCompat(false).
        SetAddNonCompat(0.0)
}

func (x *DoublePatch) GetAssignNonCompat() *float64 {
    return x.Assign
}

func (x *DoublePatch) GetAssign() float64 {
    if !x.IsSetAssign() {
        return 0.0
    }

    return *x.Assign
}

func (x *DoublePatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *DoublePatch) GetClear() bool {
    return x.Clear
}

func (x *DoublePatch) GetAddNonCompat() float64 {
    return x.Add
}

func (x *DoublePatch) GetAdd() float64 {
    return x.Add
}

func (x *DoublePatch) SetAssignNonCompat(value float64) *DoublePatch {
    x.Assign = &value
    return x
}

func (x *DoublePatch) SetAssign(value *float64) *DoublePatch {
    x.Assign = value
    return x
}

func (x *DoublePatch) SetClearNonCompat(value bool) *DoublePatch {
    x.Clear = value
    return x
}

func (x *DoublePatch) SetClear(value bool) *DoublePatch {
    x.Clear = value
    return x
}

func (x *DoublePatch) SetAddNonCompat(value float64) *DoublePatch {
    x.Add = value
    return x
}

func (x *DoublePatch) SetAdd(value float64) *DoublePatch {
    x.Add = value
    return x
}

func (x *DoublePatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *DoublePatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.DOUBLE, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteDouble(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) writeField8(p thrift.Protocol) error {  // Add
    if err := p.WriteFieldBegin("add", thrift.DOUBLE, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAddNonCompat()
    if err := p.WriteDouble(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadDouble()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *DoublePatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *DoublePatch) readField8(p thrift.Protocol) error {  // Add
    result, err := p.ReadDouble()
if err != nil {
    return err
}

    x.SetAddNonCompat(result)
    return nil
}

func (x *DoublePatch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *DoublePatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *DoublePatch) toString8() string {  // Add
    return fmt.Sprintf("%v", x.GetAddNonCompat())
}

// Deprecated: Use NewDoublePatch().GetAssign() instead.
var DoublePatch_Assign_DEFAULT = NewDoublePatch().GetAssign()


// Deprecated: Use DoublePatch.Set* methods instead or set the fields directly.
type DoublePatchBuilder struct {
    obj *DoublePatch
}

func NewDoublePatchBuilder() *DoublePatchBuilder {
    return &DoublePatchBuilder{
        obj: NewDoublePatch(),
    }
}

func (x *DoublePatchBuilder) Assign(value *float64) *DoublePatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *DoublePatchBuilder) Clear(value bool) *DoublePatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *DoublePatchBuilder) Add(value float64) *DoublePatchBuilder {
    x.obj.Add = value
    return x
}

func (x *DoublePatchBuilder) Emit() *DoublePatch {
    var objCopy DoublePatch = *x.obj
    return &objCopy
}

func (x *DoublePatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("DoublePatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DoublePatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // add
            if err := x.readField8(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DoublePatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DoublePatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Add:%s", x.toString8()))
    sb.WriteString("})")

    return sb.String()
}

type StringPatch struct {
    Assign *string `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Prepend string `thrift:"prepend,8" json:"prepend" db:"prepend"`
    Append string `thrift:"append,9" json:"append" db:"append"`
}
// Compile time interface enforcer
var _ thrift.Struct = &StringPatch{}

func NewStringPatch() *StringPatch {
    return (&StringPatch{}).
        SetClearNonCompat(false).
        SetPrependNonCompat("").
        SetAppendNonCompat("")
}

func (x *StringPatch) GetAssignNonCompat() *string {
    return x.Assign
}

func (x *StringPatch) GetAssign() string {
    if !x.IsSetAssign() {
        return ""
    }

    return *x.Assign
}

func (x *StringPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *StringPatch) GetClear() bool {
    return x.Clear
}

func (x *StringPatch) GetPrependNonCompat() string {
    return x.Prepend
}

func (x *StringPatch) GetPrepend() string {
    return x.Prepend
}

func (x *StringPatch) GetAppendNonCompat() string {
    return x.Append
}

func (x *StringPatch) GetAppend() string {
    return x.Append
}

func (x *StringPatch) SetAssignNonCompat(value string) *StringPatch {
    x.Assign = &value
    return x
}

func (x *StringPatch) SetAssign(value *string) *StringPatch {
    x.Assign = value
    return x
}

func (x *StringPatch) SetClearNonCompat(value bool) *StringPatch {
    x.Clear = value
    return x
}

func (x *StringPatch) SetClear(value bool) *StringPatch {
    x.Clear = value
    return x
}

func (x *StringPatch) SetPrependNonCompat(value string) *StringPatch {
    x.Prepend = value
    return x
}

func (x *StringPatch) SetPrepend(value string) *StringPatch {
    x.Prepend = value
    return x
}

func (x *StringPatch) SetAppendNonCompat(value string) *StringPatch {
    x.Append = value
    return x
}

func (x *StringPatch) SetAppend(value string) *StringPatch {
    x.Append = value
    return x
}

func (x *StringPatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *StringPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := *x.GetAssignNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField8(p thrift.Protocol) error {  // Prepend
    if err := p.WriteFieldBegin("prepend", thrift.STRING, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetPrependNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) writeField9(p thrift.Protocol) error {  // Append
    if err := p.WriteFieldBegin("append", thrift.STRING, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAppendNonCompat()
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *StringPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *StringPatch) readField8(p thrift.Protocol) error {  // Prepend
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetPrependNonCompat(result)
    return nil
}

func (x *StringPatch) readField9(p thrift.Protocol) error {  // Append
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.SetAppendNonCompat(result)
    return nil
}

func (x *StringPatch) toString1() string {  // Assign
    if x.IsSetAssign() {
        return fmt.Sprintf("%v", *x.GetAssignNonCompat())
    }
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *StringPatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *StringPatch) toString8() string {  // Prepend
    return fmt.Sprintf("%v", x.GetPrependNonCompat())
}

func (x *StringPatch) toString9() string {  // Append
    return fmt.Sprintf("%v", x.GetAppendNonCompat())
}

// Deprecated: Use NewStringPatch().GetAssign() instead.
var StringPatch_Assign_DEFAULT = NewStringPatch().GetAssign()


// Deprecated: Use StringPatch.Set* methods instead or set the fields directly.
type StringPatchBuilder struct {
    obj *StringPatch
}

func NewStringPatchBuilder() *StringPatchBuilder {
    return &StringPatchBuilder{
        obj: NewStringPatch(),
    }
}

func (x *StringPatchBuilder) Assign(value *string) *StringPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *StringPatchBuilder) Clear(value bool) *StringPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *StringPatchBuilder) Prepend(value string) *StringPatchBuilder {
    x.obj.Prepend = value
    return x
}

func (x *StringPatchBuilder) Append(value string) *StringPatchBuilder {
    x.obj.Append = value
    return x
}

func (x *StringPatchBuilder) Emit() *StringPatch {
    var objCopy StringPatch = *x.obj
    return &objCopy
}

func (x *StringPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("StringPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *StringPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // prepend
            if err := x.readField8(p); err != nil {
                return err
            }
        case 9:  // append
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *StringPatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("StringPatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Prepend:%s ", x.toString8()))
    sb.WriteString(fmt.Sprintf("Append:%s", x.toString9()))
    sb.WriteString("})")

    return sb.String()
}

type BinaryPatch struct {
    Assign standard.ByteBuffer `thrift:"assign,1,optional" json:"assign,omitempty" db:"assign"`
    Clear bool `thrift:"clear,2" json:"clear" db:"clear"`
    Prepend standard.ByteBuffer `thrift:"prepend,8" json:"prepend" db:"prepend"`
    Append standard.ByteBuffer `thrift:"append,9" json:"append" db:"append"`
}
// Compile time interface enforcer
var _ thrift.Struct = &BinaryPatch{}

func NewBinaryPatch() *BinaryPatch {
    return (&BinaryPatch{}).
        SetClearNonCompat(false).
        SetPrependNonCompat(standard.NewByteBuffer()).
        SetAppendNonCompat(standard.NewByteBuffer())
}

func (x *BinaryPatch) GetAssignNonCompat() standard.ByteBuffer {
    return x.Assign
}

func (x *BinaryPatch) GetAssign() standard.ByteBuffer {
    if !x.IsSetAssign() {
        return standard.NewByteBuffer()
    }

    return x.Assign
}

func (x *BinaryPatch) GetClearNonCompat() bool {
    return x.Clear
}

func (x *BinaryPatch) GetClear() bool {
    return x.Clear
}

func (x *BinaryPatch) GetPrependNonCompat() standard.ByteBuffer {
    return x.Prepend
}

func (x *BinaryPatch) GetPrepend() standard.ByteBuffer {
    if !x.IsSetPrepend() {
        return standard.NewByteBuffer()
    }

    return x.Prepend
}

func (x *BinaryPatch) GetAppendNonCompat() standard.ByteBuffer {
    return x.Append
}

func (x *BinaryPatch) GetAppend() standard.ByteBuffer {
    if !x.IsSetAppend() {
        return standard.NewByteBuffer()
    }

    return x.Append
}

func (x *BinaryPatch) SetAssignNonCompat(value standard.ByteBuffer) *BinaryPatch {
    x.Assign = value
    return x
}

func (x *BinaryPatch) SetAssign(value standard.ByteBuffer) *BinaryPatch {
    x.Assign = value
    return x
}

func (x *BinaryPatch) SetClearNonCompat(value bool) *BinaryPatch {
    x.Clear = value
    return x
}

func (x *BinaryPatch) SetClear(value bool) *BinaryPatch {
    x.Clear = value
    return x
}

func (x *BinaryPatch) SetPrependNonCompat(value standard.ByteBuffer) *BinaryPatch {
    x.Prepend = value
    return x
}

func (x *BinaryPatch) SetPrepend(value standard.ByteBuffer) *BinaryPatch {
    x.Prepend = value
    return x
}

func (x *BinaryPatch) SetAppendNonCompat(value standard.ByteBuffer) *BinaryPatch {
    x.Append = value
    return x
}

func (x *BinaryPatch) SetAppend(value standard.ByteBuffer) *BinaryPatch {
    x.Append = value
    return x
}

func (x *BinaryPatch) IsSetAssign() bool {
    return x.Assign != nil
}

func (x *BinaryPatch) IsSetPrepend() bool {
    return x.Prepend != nil
}

func (x *BinaryPatch) IsSetAppend() bool {
    return x.Append != nil
}

func (x *BinaryPatch) writeField1(p thrift.Protocol) error {  // Assign
    if !x.IsSetAssign() {
        return nil
    }

    if err := p.WriteFieldBegin("assign", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAssignNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField2(p thrift.Protocol) error {  // Clear
    if err := p.WriteFieldBegin("clear", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetClearNonCompat()
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField8(p thrift.Protocol) error {  // Prepend
    if !x.IsSetPrepend() {
        return nil
    }

    if err := p.WriteFieldBegin("prepend", thrift.STRING, 8); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetPrependNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) writeField9(p thrift.Protocol) error {  // Append
    if !x.IsSetAppend() {
        return nil
    }

    if err := p.WriteFieldBegin("append", thrift.STRING, 9); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetAppendNonCompat()
    err := standard.WriteByteBuffer(item, p)
if err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) readField1(p thrift.Protocol) error {  // Assign
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetAssignNonCompat(result)
    return nil
}

func (x *BinaryPatch) readField2(p thrift.Protocol) error {  // Clear
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.SetClearNonCompat(result)
    return nil
}

func (x *BinaryPatch) readField8(p thrift.Protocol) error {  // Prepend
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetPrependNonCompat(result)
    return nil
}

func (x *BinaryPatch) readField9(p thrift.Protocol) error {  // Append
    result, err := standard.ReadByteBuffer(p)
if err != nil {
    return err
}

    x.SetAppendNonCompat(result)
    return nil
}

func (x *BinaryPatch) toString1() string {  // Assign
    return fmt.Sprintf("%v", x.GetAssignNonCompat())
}

func (x *BinaryPatch) toString2() string {  // Clear
    return fmt.Sprintf("%v", x.GetClearNonCompat())
}

func (x *BinaryPatch) toString8() string {  // Prepend
    return fmt.Sprintf("%v", x.GetPrependNonCompat())
}

func (x *BinaryPatch) toString9() string {  // Append
    return fmt.Sprintf("%v", x.GetAppendNonCompat())
}


// Deprecated: Use BinaryPatch.Set* methods instead or set the fields directly.
type BinaryPatchBuilder struct {
    obj *BinaryPatch
}

func NewBinaryPatchBuilder() *BinaryPatchBuilder {
    return &BinaryPatchBuilder{
        obj: NewBinaryPatch(),
    }
}

func (x *BinaryPatchBuilder) Assign(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Assign = value
    return x
}

func (x *BinaryPatchBuilder) Clear(value bool) *BinaryPatchBuilder {
    x.obj.Clear = value
    return x
}

func (x *BinaryPatchBuilder) Prepend(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Prepend = value
    return x
}

func (x *BinaryPatchBuilder) Append(value standard.ByteBuffer) *BinaryPatchBuilder {
    x.obj.Append = value
    return x
}

func (x *BinaryPatchBuilder) Emit() *BinaryPatch {
    var objCopy BinaryPatch = *x.obj
    return &objCopy
}

func (x *BinaryPatch) Write(p thrift.Protocol) error {
    if err := p.WriteStructBegin("BinaryPatch"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField8(p); err != nil {
        return err
    }

    if err := x.writeField9(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *BinaryPatch) Read(p thrift.Protocol) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, typ, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if typ == thrift.STOP {
            break;
        }

        switch id {
        case 1:  // assign
            if err := x.readField1(p); err != nil {
                return err
            }
        case 2:  // clear
            if err := x.readField2(p); err != nil {
                return err
            }
        case 8:  // prepend
            if err := x.readField8(p); err != nil {
                return err
            }
        case 9:  // append
            if err := x.readField9(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(typ); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *BinaryPatch) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("BinaryPatch({")
    sb.WriteString(fmt.Sprintf("Assign:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Clear:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("Prepend:%s ", x.toString8()))
    sb.WriteString(fmt.Sprintf("Append:%s", x.toString9()))
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
	  RegisterType(name string, obj any)
}) {
    registry.RegisterType("facebook.com/thrift/op/GeneratePatch", &GeneratePatch{})
    registry.RegisterType("facebook.com/thrift/op/AssignOnlyPatch", &AssignOnlyPatch{})
    registry.RegisterType("facebook.com/thrift/op/BoolPatch", &BoolPatch{})
    registry.RegisterType("facebook.com/thrift/op/BytePatch", &BytePatch{})
    registry.RegisterType("facebook.com/thrift/op/I16Patch", &I16Patch{})
    registry.RegisterType("facebook.com/thrift/op/I32Patch", &I32Patch{})
    registry.RegisterType("facebook.com/thrift/op/I64Patch", &I64Patch{})
    registry.RegisterType("facebook.com/thrift/op/FloatPatch", &FloatPatch{})
    registry.RegisterType("facebook.com/thrift/op/DoublePatch", &DoublePatch{})
    registry.RegisterType("facebook.com/thrift/op/StringPatch", &StringPatch{})
    registry.RegisterType("facebook.com/thrift/op/BinaryPatch", &BinaryPatch{})

    registry.RegisterType("facebook.com/thrift/op/PatchOp", PatchOp(0))
}
