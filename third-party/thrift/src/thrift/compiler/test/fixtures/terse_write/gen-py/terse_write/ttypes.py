#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
from thrift.Thrift import expand_thrift_spec as __EXPAND_THRIFT_SPEC
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyStruct', 'MyUnion', 'MyStructWithCustomDefault', 'StructLevelTerseStruct', 'FieldLevelTerseStruct', 'TerseStructWithCustomDefault', 'AdaptedFields', 'WrappedFields', 'TerseException', 'MyInteger']

class MyEnum:
  ME0 = 0
  ME1 = 1

  _VALUES_TO_NAMES = {
    0: "ME0",
    1: "ME1",
  }

  _NAMES_TO_VALUES = {
    "ME0": 0,
    "ME1": 1,
  }

class MyStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  BOOL_FIELD = 1
  BYTE_FIELD = 2
  SHORT_FIELD = 3
  INT_FIELD = 4
  LONG_FIELD = 5
  FLOAT_FIELD = 6
  DOUBLE_FIELD = 7
  STRING_FIELD = 8
  BINARY_FIELD = 9
  ENUM_FIELD = 10
  LIST_FIELD = 11
  SET_FIELD = 12
  MAP_FIELD = 13
  STRUCT_FIELD = 14
  
  @staticmethod
  def isUnion():
    return True

  def get_bool_field(self):
    assert self.field == 1
    return self.value

  def get_byte_field(self):
    assert self.field == 2
    return self.value

  def get_short_field(self):
    assert self.field == 3
    return self.value

  def get_int_field(self):
    assert self.field == 4
    return self.value

  def get_long_field(self):
    assert self.field == 5
    return self.value

  def get_float_field(self):
    assert self.field == 6
    return self.value

  def get_double_field(self):
    assert self.field == 7
    return self.value

  def get_string_field(self):
    assert self.field == 8
    return self.value

  def get_binary_field(self):
    assert self.field == 9
    return self.value

  def get_enum_field(self):
    assert self.field == 10
    return self.value

  def get_list_field(self):
    assert self.field == 11
    return self.value

  def get_set_field(self):
    assert self.field == 12
    return self.value

  def get_map_field(self):
    assert self.field == 13
    return self.value

  def get_struct_field(self):
    assert self.field == 14
    return self.value

  def set_bool_field(self, value):
    self.field = 1
    self.value = value

  def set_byte_field(self, value):
    self.field = 2
    self.value = value

  def set_short_field(self, value):
    self.field = 3
    self.value = value

  def set_int_field(self, value):
    self.field = 4
    self.value = value

  def set_long_field(self, value):
    self.field = 5
    self.value = value

  def set_float_field(self, value):
    self.field = 6
    self.value = value

  def set_double_field(self, value):
    self.field = 7
    self.value = value

  def set_string_field(self, value):
    self.field = 8
    self.value = value

  def set_binary_field(self, value):
    self.field = 9
    self.value = value

  def set_enum_field(self, value):
    self.field = 10
    self.value = value

  def set_list_field(self, value):
    self.field = 11
    self.value = value

  def set_set_field(self, value):
    self.field = 12
    self.value = value

  def set_map_field(self, value):
    self.field = 13
    self.value = value

  def set_struct_field(self, value):
    self.field = 14
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('bool_field', value)
    if self.field == 2:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('byte_field', value)
    if self.field == 3:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('short_field', value)
    if self.field == 4:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('int_field', value)
    if self.field == 5:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('long_field', value)
    if self.field == 6:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('float_field', value)
    if self.field == 7:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('double_field', value)
    if self.field == 8:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('string_field', value)
    if self.field == 9:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binary_field', value)
    if self.field == 10:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('enum_field', value)
    if self.field == 11:
      padding = ' ' * 11
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('list_field', value)
    if self.field == 12:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('set_field', value)
    if self.field == 13:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('map_field', value)
    if self.field == 14:
      padding = ' ' * 13
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('struct_field', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.BOOL:
          _fbthrift_bool_field = iprot.readBool()
          assert self.field == 0 and self.value is None
          self.set_bool_field(_fbthrift_bool_field)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          _fbthrift_byte_field = iprot.readByte()
          assert self.field == 0 and self.value is None
          self.set_byte_field(_fbthrift_byte_field)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          _fbthrift_short_field = iprot.readI16()
          assert self.field == 0 and self.value is None
          self.set_short_field(_fbthrift_short_field)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          _fbthrift_int_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_int_field(_fbthrift_int_field)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          _fbthrift_long_field = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_long_field(_fbthrift_long_field)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          _fbthrift_float_field = iprot.readFloat()
          assert self.field == 0 and self.value is None
          self.set_float_field(_fbthrift_float_field)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          _fbthrift_double_field = iprot.readDouble()
          assert self.field == 0 and self.value is None
          self.set_double_field(_fbthrift_double_field)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          _fbthrift_string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_string_field(_fbthrift_string_field)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          _fbthrift_binary_field = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binary_field(_fbthrift_binary_field)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          _fbthrift_enum_field = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_enum_field(_fbthrift_enum_field)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          _fbthrift_list_field = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              _fbthrift_list_field.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              _fbthrift_list_field.append(_elem6)
          iprot.readListEnd()
          assert self.field == 0 and self.value is None
          self.set_list_field(_fbthrift_list_field)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          _fbthrift_set_field = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readI16()
              _fbthrift_set_field.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readI16()
              _fbthrift_set_field.add(_elem13)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_set_field(_fbthrift_set_field)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          _fbthrift_map_field = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readI16()
              _val20 = iprot.readI16()
              _fbthrift_map_field[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readI16()
              _val22 = iprot.readI16()
              _fbthrift_map_field[_key21] = _val22
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_map_field(_fbthrift_map_field)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          _fbthrift_struct_field = MyStruct()
          _fbthrift_struct_field.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_struct_field(_fbthrift_struct_field)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      bool_field = self.value
      oprot.writeBool(bool_field)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      byte_field = self.value
      oprot.writeByte(byte_field)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      short_field = self.value
      oprot.writeI16(short_field)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      int_field = self.value
      oprot.writeI32(int_field)
      oprot.writeFieldEnd()
    if self.field == 5:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      long_field = self.value
      oprot.writeI64(long_field)
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      float_field = self.value
      oprot.writeFloat(float_field)
      oprot.writeFieldEnd()
    if self.field == 7:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      double_field = self.value
      oprot.writeDouble(double_field)
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      string_field = self.value
      oprot.writeString(string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(string_field, bytes) else oprot.writeString(string_field)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      binary_field = self.value
      oprot.writeString(binary_field)
      oprot.writeFieldEnd()
    if self.field == 10:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      enum_field = self.value
      oprot.writeI32(enum_field)
      oprot.writeFieldEnd()
    if self.field == 11:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      list_field = self.value
      oprot.writeListBegin(TType.I16, len(list_field))
      for iter23 in list_field:
        oprot.writeI16(iter23)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.field == 12:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      set_field = self.value
      oprot.writeSetBegin(TType.I16, len(set_field))
      for iter24 in set_field:
        oprot.writeI16(iter24)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 13:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      map_field = self.value
      oprot.writeMapBegin(TType.I16, TType.I16, len(map_field))
      for kiter25,viter26 in map_field.items():
        oprot.writeI16(kiter25)
        oprot.writeI16(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 14:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      struct_field = self.value
      struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'bool_field' in obj:
      _fbthrift_bool_field = obj['bool_field']
      self.set_bool_field(_fbthrift_bool_field)
    if 'byte_field' in obj:
      _fbthrift_byte_field = obj['byte_field']
      if _fbthrift_byte_field > 0x7f or _fbthrift_byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_byte_field(_fbthrift_byte_field)
    if 'short_field' in obj:
      _fbthrift_short_field = obj['short_field']
      if _fbthrift_short_field > 0x7fff or _fbthrift_short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_short_field(_fbthrift_short_field)
    if 'int_field' in obj:
      _fbthrift_int_field = obj['int_field']
      if _fbthrift_int_field > 0x7fffffff or _fbthrift_int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_int_field(_fbthrift_int_field)
    if 'long_field' in obj:
      _fbthrift_long_field = long(obj['long_field'])
      self.set_long_field(_fbthrift_long_field)
    if 'float_field' in obj:
      _fbthrift_float_field = float(obj['float_field'])
      self.set_float_field(_fbthrift_float_field)
    if 'double_field' in obj:
      _fbthrift_double_field = float(obj['double_field'])
      self.set_double_field(_fbthrift_double_field)
    if 'string_field' in obj:
      _fbthrift_string_field = obj['string_field']
      self.set_string_field(_fbthrift_string_field)
    if 'binary_field' in obj:
      _fbthrift_binary_field = obj['binary_field']
      self.set_binary_field(_fbthrift_binary_field)
    if 'enum_field' in obj:
      _fbthrift_enum_field = obj['enum_field']
      if not _fbthrift_enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % _fbthrift_enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
      self.set_enum_field(_fbthrift_enum_field)
    if 'list_field' in obj:
      _fbthrift_list_field = []
      for _tmp_e27 in obj['list_field']:
        if _tmp_e27 > 0x7fff or _tmp_e27 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_list_field.append(_tmp_e27)
      self.set_list_field(_fbthrift_list_field)
    if 'set_field' in obj:
      _fbthrift_set_field = set_cls()
      for _tmp_e28 in obj['set_field']:
        if _tmp_e28 > 0x7fff or _tmp_e28 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_set_field.add(_tmp_e28)
      self.set_set_field(_fbthrift_set_field)
    if 'map_field' in obj:
      _fbthrift_map_field = dict_cls()
      for _tmp_k29, _tmp_v30 in obj['map_field'].items():
        _tmp_kp31 = int(_tmp_k29)
        if _tmp_kp31 > 0x7fff or _tmp_kp31 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k29)
        if _tmp_v30 > 0x7fff or _tmp_v30 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        _fbthrift_map_field[_tmp_kp31] = _tmp_v30
      self.set_map_field(_fbthrift_map_field)
    if 'struct_field' in obj:
      _fbthrift_struct_field = MyStruct()
      _fbthrift_struct_field.readFromJson(obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_struct_field(_fbthrift_struct_field)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStructWithCustomDefault:
  r"""
  Attributes:
   - field1
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.field1 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructWithCustomDefault')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I64, 1)
      oprot.writeI64(self.field1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = long(json_obj['field1'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class StructLevelTerseStruct:
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
   - union_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in range(_size32):
              _elem37 = iprot.readI16()
              self.list_field.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = iprot.readI16()
              self.list_field.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype42, _size39) = iprot.readSetBegin()
          if _size39 >= 0:
            for _i43 in range(_size39):
              _elem44 = iprot.readI16()
              self.set_field.add(_elem44)
          else: 
            while iprot.peekSet():
              _elem45 = iprot.readI16()
              self.set_field.add(_elem45)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype47, _vtype48, _size46 ) = iprot.readMapBegin() 
          if _size46 >= 0:
            for _i50 in range(_size46):
              _key51 = iprot.readI16()
              _val52 = iprot.readI16()
              self.map_field[_key51] = _val52
          else: 
            while iprot.peekMap():
              _key53 = iprot.readI16()
              _val54 = iprot.readI16()
              self.map_field[_key53] = _val54
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.union_field = MyUnion()
          self.union_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructLevelTerseStruct')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter55 in self.list_field:
        oprot.writeI16(iter55)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter56 in self.set_field:
        oprot.writeI16(iter56)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter57,viter58 in self.map_field.items():
        oprot.writeI16(kiter57)
        oprot.writeI16(viter58)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.union_field != None:
      oprot.writeFieldBegin('union_field', TType.STRUCT, 15)
      self.union_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e59 in json_obj['list_field']:
        if _tmp_e59 > 0x7fff or _tmp_e59 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e59)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e60 in json_obj['set_field']:
        if _tmp_e60 > 0x7fff or _tmp_e60 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e60)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k61, _tmp_v62 in json_obj['map_field'].items():
        _tmp_kp63 = int(_tmp_k61)
        if _tmp_kp63 > 0x7fff or _tmp_kp63 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k61)
        if _tmp_v62 > 0x7fff or _tmp_v62 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp63] = _tmp_v62
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'union_field' in json_obj and json_obj['union_field'] is not None:
      self.union_field = MyUnion()
      self.union_field.readFromJson(json_obj['union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    if self.union_field is not None:
      value = pprint.pformat(self.union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    union_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
      'union_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class FieldLevelTerseStruct:
  r"""
  Attributes:
   - terse_bool_field
   - terse_byte_field
   - terse_short_field
   - terse_int_field
   - terse_long_field
   - terse_float_field
   - terse_double_field
   - terse_string_field
   - terse_binary_field
   - terse_enum_field
   - terse_list_field
   - terse_set_field
   - terse_map_field
   - terse_struct_field
   - terse_union_field
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
   - union_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.terse_bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.terse_byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.terse_short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.terse_int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.terse_long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.terse_float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.terse_double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.terse_string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.terse_binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.terse_enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.terse_list_field = []
          (_etype67, _size64) = iprot.readListBegin()
          if _size64 >= 0:
            for _i68 in range(_size64):
              _elem69 = iprot.readI16()
              self.terse_list_field.append(_elem69)
          else: 
            while iprot.peekList():
              _elem70 = iprot.readI16()
              self.terse_list_field.append(_elem70)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.terse_set_field = set()
          (_etype74, _size71) = iprot.readSetBegin()
          if _size71 >= 0:
            for _i75 in range(_size71):
              _elem76 = iprot.readI16()
              self.terse_set_field.add(_elem76)
          else: 
            while iprot.peekSet():
              _elem77 = iprot.readI16()
              self.terse_set_field.add(_elem77)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.terse_map_field = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          if _size78 >= 0:
            for _i82 in range(_size78):
              _key83 = iprot.readI16()
              _val84 = iprot.readI16()
              self.terse_map_field[_key83] = _val84
          else: 
            while iprot.peekMap():
              _key85 = iprot.readI16()
              _val86 = iprot.readI16()
              self.terse_map_field[_key85] = _val86
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.terse_struct_field = MyStruct()
          self.terse_struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.terse_union_field = MyUnion()
          self.terse_union_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype90, _size87) = iprot.readListBegin()
          if _size87 >= 0:
            for _i91 in range(_size87):
              _elem92 = iprot.readI16()
              self.list_field.append(_elem92)
          else: 
            while iprot.peekList():
              _elem93 = iprot.readI16()
              self.list_field.append(_elem93)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype97, _size94) = iprot.readSetBegin()
          if _size94 >= 0:
            for _i98 in range(_size94):
              _elem99 = iprot.readI16()
              self.set_field.add(_elem99)
          else: 
            while iprot.peekSet():
              _elem100 = iprot.readI16()
              self.set_field.add(_elem100)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
          if _size101 >= 0:
            for _i105 in range(_size101):
              _key106 = iprot.readI16()
              _val107 = iprot.readI16()
              self.map_field[_key106] = _val107
          else: 
            while iprot.peekMap():
              _key108 = iprot.readI16()
              _val109 = iprot.readI16()
              self.map_field[_key108] = _val109
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRUCT:
          self.struct_field = MyStruct()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.union_field = MyUnion()
          self.union_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FieldLevelTerseStruct')
    if self.terse_bool_field != None:
      oprot.writeFieldBegin('terse_bool_field', TType.BOOL, 1)
      oprot.writeBool(self.terse_bool_field)
      oprot.writeFieldEnd()
    if self.terse_byte_field != None:
      oprot.writeFieldBegin('terse_byte_field', TType.BYTE, 2)
      oprot.writeByte(self.terse_byte_field)
      oprot.writeFieldEnd()
    if self.terse_short_field != None:
      oprot.writeFieldBegin('terse_short_field', TType.I16, 3)
      oprot.writeI16(self.terse_short_field)
      oprot.writeFieldEnd()
    if self.terse_int_field != None:
      oprot.writeFieldBegin('terse_int_field', TType.I32, 4)
      oprot.writeI32(self.terse_int_field)
      oprot.writeFieldEnd()
    if self.terse_long_field != None:
      oprot.writeFieldBegin('terse_long_field', TType.I64, 5)
      oprot.writeI64(self.terse_long_field)
      oprot.writeFieldEnd()
    if self.terse_float_field != None:
      oprot.writeFieldBegin('terse_float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.terse_float_field)
      oprot.writeFieldEnd()
    if self.terse_double_field != None:
      oprot.writeFieldBegin('terse_double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.terse_double_field)
      oprot.writeFieldEnd()
    if self.terse_string_field != None:
      oprot.writeFieldBegin('terse_string_field', TType.STRING, 8)
      oprot.writeString(self.terse_string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.terse_string_field, bytes) else oprot.writeString(self.terse_string_field)
      oprot.writeFieldEnd()
    if self.terse_binary_field != None:
      oprot.writeFieldBegin('terse_binary_field', TType.STRING, 9)
      oprot.writeString(self.terse_binary_field)
      oprot.writeFieldEnd()
    if self.terse_enum_field != None:
      oprot.writeFieldBegin('terse_enum_field', TType.I32, 10)
      oprot.writeI32(self.terse_enum_field)
      oprot.writeFieldEnd()
    if self.terse_list_field != None:
      oprot.writeFieldBegin('terse_list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.terse_list_field))
      for iter110 in self.terse_list_field:
        oprot.writeI16(iter110)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.terse_set_field != None:
      oprot.writeFieldBegin('terse_set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.terse_set_field))
      for iter111 in self.terse_set_field:
        oprot.writeI16(iter111)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.terse_map_field != None:
      oprot.writeFieldBegin('terse_map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.terse_map_field))
      for kiter112,viter113 in self.terse_map_field.items():
        oprot.writeI16(kiter112)
        oprot.writeI16(viter113)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.terse_struct_field != None:
      oprot.writeFieldBegin('terse_struct_field', TType.STRUCT, 14)
      self.terse_struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 15)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 16)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 17)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 18)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 19)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 20)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 21)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 22)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 23)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 24)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 25)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter114 in self.list_field:
        oprot.writeI16(iter114)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 26)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter115 in self.set_field:
        oprot.writeI16(iter115)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 27)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter116,viter117 in self.map_field.items():
        oprot.writeI16(kiter116)
        oprot.writeI16(viter117)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 28)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    if self.terse_union_field != None:
      oprot.writeFieldBegin('terse_union_field', TType.STRUCT, 29)
      self.terse_union_field.write(oprot)
      oprot.writeFieldEnd()
    if self.union_field != None:
      oprot.writeFieldBegin('union_field', TType.STRUCT, 30)
      self.union_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'terse_bool_field' in json_obj and json_obj['terse_bool_field'] is not None:
      self.terse_bool_field = json_obj['terse_bool_field']
    if 'terse_byte_field' in json_obj and json_obj['terse_byte_field'] is not None:
      self.terse_byte_field = json_obj['terse_byte_field']
      if self.terse_byte_field > 0x7f or self.terse_byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_short_field' in json_obj and json_obj['terse_short_field'] is not None:
      self.terse_short_field = json_obj['terse_short_field']
      if self.terse_short_field > 0x7fff or self.terse_short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_int_field' in json_obj and json_obj['terse_int_field'] is not None:
      self.terse_int_field = json_obj['terse_int_field']
      if self.terse_int_field > 0x7fffffff or self.terse_int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'terse_long_field' in json_obj and json_obj['terse_long_field'] is not None:
      self.terse_long_field = long(json_obj['terse_long_field'])
    if 'terse_float_field' in json_obj and json_obj['terse_float_field'] is not None:
      self.terse_float_field = float(json_obj['terse_float_field'])
    if 'terse_double_field' in json_obj and json_obj['terse_double_field'] is not None:
      self.terse_double_field = float(json_obj['terse_double_field'])
    if 'terse_string_field' in json_obj and json_obj['terse_string_field'] is not None:
      self.terse_string_field = json_obj['terse_string_field']
    if 'terse_binary_field' in json_obj and json_obj['terse_binary_field'] is not None:
      self.terse_binary_field = json_obj['terse_binary_field']
    if 'terse_enum_field' in json_obj and json_obj['terse_enum_field'] is not None:
      self.terse_enum_field = json_obj['terse_enum_field']
      if not self.terse_enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.terse_enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'terse_list_field' in json_obj and json_obj['terse_list_field'] is not None:
      self.terse_list_field = []
      for _tmp_e118 in json_obj['terse_list_field']:
        if _tmp_e118 > 0x7fff or _tmp_e118 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_list_field.append(_tmp_e118)
    if 'terse_set_field' in json_obj and json_obj['terse_set_field'] is not None:
      self.terse_set_field = set_cls()
      for _tmp_e119 in json_obj['terse_set_field']:
        if _tmp_e119 > 0x7fff or _tmp_e119 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_set_field.add(_tmp_e119)
    if 'terse_map_field' in json_obj and json_obj['terse_map_field'] is not None:
      self.terse_map_field = dict_cls()
      for _tmp_k120, _tmp_v121 in json_obj['terse_map_field'].items():
        _tmp_kp122 = int(_tmp_k120)
        if _tmp_kp122 > 0x7fff or _tmp_kp122 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k120)
        if _tmp_v121 > 0x7fff or _tmp_v121 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.terse_map_field[_tmp_kp122] = _tmp_v121
    if 'terse_struct_field' in json_obj and json_obj['terse_struct_field'] is not None:
      self.terse_struct_field = MyStruct()
      self.terse_struct_field.readFromJson(json_obj['terse_struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'terse_union_field' in json_obj and json_obj['terse_union_field'] is not None:
      self.terse_union_field = MyUnion()
      self.terse_union_field.readFromJson(json_obj['terse_union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e123 in json_obj['list_field']:
        if _tmp_e123 > 0x7fff or _tmp_e123 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e123)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e124 in json_obj['set_field']:
        if _tmp_e124 > 0x7fff or _tmp_e124 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e124)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k125, _tmp_v126 in json_obj['map_field'].items():
        _tmp_kp127 = int(_tmp_k125)
        if _tmp_kp127 > 0x7fff or _tmp_kp127 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k125)
        if _tmp_v126 > 0x7fff or _tmp_v126 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp127] = _tmp_v126
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStruct()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'union_field' in json_obj and json_obj['union_field'] is not None:
      self.union_field = MyUnion()
      self.union_field.readFromJson(json_obj['union_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.terse_bool_field is not None:
      value = pprint.pformat(self.terse_bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_bool_field=%s' % (value))
    if self.terse_byte_field is not None:
      value = pprint.pformat(self.terse_byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_byte_field=%s' % (value))
    if self.terse_short_field is not None:
      value = pprint.pformat(self.terse_short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_short_field=%s' % (value))
    if self.terse_int_field is not None:
      value = pprint.pformat(self.terse_int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_int_field=%s' % (value))
    if self.terse_long_field is not None:
      value = pprint.pformat(self.terse_long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_long_field=%s' % (value))
    if self.terse_float_field is not None:
      value = pprint.pformat(self.terse_float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_float_field=%s' % (value))
    if self.terse_double_field is not None:
      value = pprint.pformat(self.terse_double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_double_field=%s' % (value))
    if self.terse_string_field is not None:
      value = pprint.pformat(self.terse_string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_string_field=%s' % (value))
    if self.terse_binary_field is not None:
      value = pprint.pformat(self.terse_binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_binary_field=%s' % (value))
    if self.terse_enum_field is not None:
      value = pprint.pformat(self.terse_enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_enum_field=%s' % (value))
    if self.terse_list_field is not None:
      value = pprint.pformat(self.terse_list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_list_field=%s' % (value))
    if self.terse_set_field is not None:
      value = pprint.pformat(self.terse_set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_set_field=%s' % (value))
    if self.terse_map_field is not None:
      value = pprint.pformat(self.terse_map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_map_field=%s' % (value))
    if self.terse_struct_field is not None:
      value = pprint.pformat(self.terse_struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_struct_field=%s' % (value))
    if self.terse_union_field is not None:
      value = pprint.pformat(self.terse_union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    terse_union_field=%s' % (value))
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    if self.union_field is not None:
      value = pprint.pformat(self.union_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    union_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'terse_bool_field',
      'terse_byte_field',
      'terse_short_field',
      'terse_int_field',
      'terse_long_field',
      'terse_float_field',
      'terse_double_field',
      'terse_string_field',
      'terse_binary_field',
      'terse_enum_field',
      'terse_list_field',
      'terse_set_field',
      'terse_map_field',
      'terse_struct_field',
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
      'terse_union_field',
      'union_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FieldLevelTerseStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FieldLevelTerseStruct, self)

  def _to_py_deprecated(self):
    return self

class TerseStructWithCustomDefault:
  r"""
  Attributes:
   - bool_field
   - byte_field
   - short_field
   - int_field
   - long_field
   - float_field
   - double_field
   - string_field
   - binary_field
   - enum_field
   - list_field
   - set_field
   - map_field
   - struct_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_field = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_field = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.short_field = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.long_field = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.FLOAT:
          self.float_field = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.DOUBLE:
          self.double_field = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.enum_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype131, _size128) = iprot.readListBegin()
          if _size128 >= 0:
            for _i132 in range(_size128):
              _elem133 = iprot.readI16()
              self.list_field.append(_elem133)
          else: 
            while iprot.peekList():
              _elem134 = iprot.readI16()
              self.list_field.append(_elem134)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype138, _size135) = iprot.readSetBegin()
          if _size135 >= 0:
            for _i139 in range(_size135):
              _elem140 = iprot.readI16()
              self.set_field.add(_elem140)
          else: 
            while iprot.peekSet():
              _elem141 = iprot.readI16()
              self.set_field.add(_elem141)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.map_field = {}
          (_ktype143, _vtype144, _size142 ) = iprot.readMapBegin() 
          if _size142 >= 0:
            for _i146 in range(_size142):
              _key147 = iprot.readI16()
              _val148 = iprot.readI16()
              self.map_field[_key147] = _val148
          else: 
            while iprot.peekMap():
              _key149 = iprot.readI16()
              _val150 = iprot.readI16()
              self.map_field[_key149] = _val150
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.struct_field = MyStructWithCustomDefault()
          self.struct_field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseStructWithCustomDefault')
    if self.bool_field != None:
      oprot.writeFieldBegin('bool_field', TType.BOOL, 1)
      oprot.writeBool(self.bool_field)
      oprot.writeFieldEnd()
    if self.byte_field != None:
      oprot.writeFieldBegin('byte_field', TType.BYTE, 2)
      oprot.writeByte(self.byte_field)
      oprot.writeFieldEnd()
    if self.short_field != None:
      oprot.writeFieldBegin('short_field', TType.I16, 3)
      oprot.writeI16(self.short_field)
      oprot.writeFieldEnd()
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 4)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.long_field != None:
      oprot.writeFieldBegin('long_field', TType.I64, 5)
      oprot.writeI64(self.long_field)
      oprot.writeFieldEnd()
    if self.float_field != None:
      oprot.writeFieldBegin('float_field', TType.FLOAT, 6)
      oprot.writeFloat(self.float_field)
      oprot.writeFieldEnd()
    if self.double_field != None:
      oprot.writeFieldBegin('double_field', TType.DOUBLE, 7)
      oprot.writeDouble(self.double_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 8)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 9)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.enum_field != None:
      oprot.writeFieldBegin('enum_field', TType.I32, 10)
      oprot.writeI32(self.enum_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 11)
      oprot.writeListBegin(TType.I16, len(self.list_field))
      for iter151 in self.list_field:
        oprot.writeI16(iter151)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 12)
      oprot.writeSetBegin(TType.I16, len(self.set_field))
      for iter152 in self.set_field:
        oprot.writeI16(iter152)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_field != None:
      oprot.writeFieldBegin('map_field', TType.MAP, 13)
      oprot.writeMapBegin(TType.I16, TType.I16, len(self.map_field))
      for kiter153,viter154 in self.map_field.items():
        oprot.writeI16(kiter153)
        oprot.writeI16(viter154)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.struct_field != None:
      oprot.writeFieldBegin('struct_field', TType.STRUCT, 14)
      self.struct_field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bool_field' in json_obj and json_obj['bool_field'] is not None:
      self.bool_field = json_obj['bool_field']
    if 'byte_field' in json_obj and json_obj['byte_field'] is not None:
      self.byte_field = json_obj['byte_field']
      if self.byte_field > 0x7f or self.byte_field < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'short_field' in json_obj and json_obj['short_field'] is not None:
      self.short_field = json_obj['short_field']
      if self.short_field > 0x7fff or self.short_field < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'long_field' in json_obj and json_obj['long_field'] is not None:
      self.long_field = long(json_obj['long_field'])
    if 'float_field' in json_obj and json_obj['float_field'] is not None:
      self.float_field = float(json_obj['float_field'])
    if 'double_field' in json_obj and json_obj['double_field'] is not None:
      self.double_field = float(json_obj['double_field'])
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'binary_field' in json_obj and json_obj['binary_field'] is not None:
      self.binary_field = json_obj['binary_field']
    if 'enum_field' in json_obj and json_obj['enum_field'] is not None:
      self.enum_field = json_obj['enum_field']
      if not self.enum_field in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enum_field
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'list_field' in json_obj and json_obj['list_field'] is not None:
      self.list_field = []
      for _tmp_e155 in json_obj['list_field']:
        if _tmp_e155 > 0x7fff or _tmp_e155 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.list_field.append(_tmp_e155)
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e156 in json_obj['set_field']:
        if _tmp_e156 > 0x7fff or _tmp_e156 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e156)
    if 'map_field' in json_obj and json_obj['map_field'] is not None:
      self.map_field = dict_cls()
      for _tmp_k157, _tmp_v158 in json_obj['map_field'].items():
        _tmp_kp159 = int(_tmp_k157)
        if _tmp_kp159 > 0x7fff or _tmp_kp159 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k157)
        if _tmp_v158 > 0x7fff or _tmp_v158 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.map_field[_tmp_kp159] = _tmp_v158
    if 'struct_field' in json_obj and json_obj['struct_field'] is not None:
      self.struct_field = MyStructWithCustomDefault()
      self.struct_field.readFromJson(json_obj['struct_field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bool_field is not None:
      value = pprint.pformat(self.bool_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bool_field=%s' % (value))
    if self.byte_field is not None:
      value = pprint.pformat(self.byte_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byte_field=%s' % (value))
    if self.short_field is not None:
      value = pprint.pformat(self.short_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    short_field=%s' % (value))
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.long_field is not None:
      value = pprint.pformat(self.long_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    long_field=%s' % (value))
    if self.float_field is not None:
      value = pprint.pformat(self.float_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    float_field=%s' % (value))
    if self.double_field is not None:
      value = pprint.pformat(self.double_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.enum_field is not None:
      value = pprint.pformat(self.enum_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enum_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    if self.map_field is not None:
      value = pprint.pformat(self.map_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    map_field=%s' % (value))
    if self.struct_field is not None:
      value = pprint.pformat(self.struct_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    struct_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bool_field',
      'byte_field',
      'short_field',
      'int_field',
      'long_field',
      'float_field',
      'double_field',
      'string_field',
      'binary_field',
      'enum_field',
      'list_field',
      'set_field',
      'map_field',
      'struct_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseStructWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseStructWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class AdaptedFields:
  r"""
  Attributes:
   - field1
   - field2
   - field3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.field2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.field3 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedFields')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I32, 1)
      oprot.writeI32(self.field1)
      oprot.writeFieldEnd()
    if self.field2 != None:
      oprot.writeFieldBegin('field2', TType.I32, 2)
      oprot.writeI32(self.field2)
      oprot.writeFieldEnd()
    if self.field3 != None:
      oprot.writeFieldBegin('field3', TType.I32, 3)
      oprot.writeI32(self.field3)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = json_obj['field1']
      if self.field1 > 0x7fffffff or self.field1 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field2' in json_obj and json_obj['field2'] is not None:
      self.field2 = json_obj['field2']
      if self.field2 > 0x7fffffff or self.field2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'field3' in json_obj and json_obj['field3'] is not None:
      self.field3 = json_obj['field3']
      if self.field3 > 0x7fffffff or self.field3 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    if self.field2 is not None:
      value = pprint.pformat(self.field2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field2=%s' % (value))
    if self.field3 is not None:
      value = pprint.pformat(self.field3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
      'field2',
      'field3',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class WrappedFields:
  r"""
  Attributes:
   - field1
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('WrappedFields')
    if self.field1 != None:
      oprot.writeFieldBegin('field1', TType.I32, 1)
      oprot.writeI32(self.field1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field1' in json_obj and json_obj['field1'] is not None:
      self.field1 = json_obj['field1']
      if self.field1 > 0x7fffffff or self.field1 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field1 is not None:
      value = pprint.pformat(self.field1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field1=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field1',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.WrappedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.WrappedFields, self)

  def _to_py_deprecated(self):
    return self

class TerseException(TException):
  r"""
  Attributes:
   - msg
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.msg = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseException')
    if self.msg != None:
      oprot.writeFieldBegin('msg', TType.STRING, 1)
      oprot.writeString(self.msg.encode('utf-8')) if UTF8STRINGS and not isinstance(self.msg, bytes) else oprot.writeString(self.msg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'msg' in json_obj and json_obj['msg'] is not None:
      self.msg = json_obj['msg']

  def __str__(self):
    if self.msg:
      return self.msg
    else:
      return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.msg is not None:
      value = pprint.pformat(self.msg, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    msg=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'msg',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.terse_write.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseException, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.terse_write.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseException, self)

  def _to_py_deprecated(self):
    return self

MyInteger = UnimplementedTypedef()
all_structs.append(MyStruct)
MyStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

all_structs.append(MyUnion)
MyUnion.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'bool_field', None, None, 2, ), # 1
  (2, TType.BYTE, 'byte_field', None, None, 2, ), # 2
  (3, TType.I16, 'short_field', None, None, 2, ), # 3
  (4, TType.I32, 'int_field', None, None, 2, ), # 4
  (5, TType.I64, 'long_field', None, None, 2, ), # 5
  (6, TType.FLOAT, 'float_field', None, None, 2, ), # 6
  (7, TType.DOUBLE, 'double_field', None, None, 2, ), # 7
  (8, TType.STRING, 'string_field', True, None, 2, ), # 8
  (9, TType.STRING, 'binary_field', False, None, 2, ), # 9
  (10, TType.I32, 'enum_field', MyEnum, None, 2, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), None, 2, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), None, 2, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 2, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 14
)))

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None,):
  self.field = 0
  self.value = None
  if bool_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = bool_field
  if byte_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = byte_field
  if short_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = short_field
  if int_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = int_field
  if long_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 5
    self.value = long_field
  if float_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = float_field
  if double_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 7
    self.value = double_field
  if string_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = string_field
  if binary_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = binary_field
  if enum_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 10
    self.value = enum_field
  if list_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 11
    self.value = list_field
  if set_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 12
    self.value = set_field
  if map_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 13
    self.value = map_field
  if struct_field is not None:
    assert self.field == 0 and self.value is None
    self.field = 14
    self.value = struct_field

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStructWithCustomDefault)
MyStructWithCustomDefault.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'field1', None, 1, 2, ), # 1
)))

MyStructWithCustomDefault.thrift_struct_annotations = {
}
MyStructWithCustomDefault.thrift_field_annotations = {
}

def MyStructWithCustomDefault__init__(self, field1=MyStructWithCustomDefault.thrift_spec[1][4],):
  self.field1 = field1

MyStructWithCustomDefault.__init__ = MyStructWithCustomDefault__init__

def MyStructWithCustomDefault__setstate__(self, state):
  state.setdefault('field1', 1)
  self.__dict__ = state

MyStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyStructWithCustomDefault.__setstate__ = MyStructWithCustomDefault__setstate__

all_structs.append(StructLevelTerseStruct)
StructLevelTerseStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'short_field', None, None, 3, ), # 3
  (4, TType.I32, 'int_field', None, None, 3, ), # 4
  (5, TType.I64, 'long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
  (15, TType.STRUCT, 'union_field', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 15
)))

StructLevelTerseStruct.thrift_struct_annotations = {
}
StructLevelTerseStruct.thrift_field_annotations = {
}

def StructLevelTerseStruct__init__(self, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None, union_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field
  self.union_field = union_field

StructLevelTerseStruct.__init__ = StructLevelTerseStruct__init__

def StructLevelTerseStruct__setstate__(self, state):
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  state.setdefault('union_field', None)
  self.__dict__ = state

StructLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
StructLevelTerseStruct.__setstate__ = StructLevelTerseStruct__setstate__

all_structs.append(FieldLevelTerseStruct)
FieldLevelTerseStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'terse_bool_field', None, None, 3, ), # 1
  (2, TType.BYTE, 'terse_byte_field', None, None, 3, ), # 2
  (3, TType.I16, 'terse_short_field', None, None, 3, ), # 3
  (4, TType.I32, 'terse_int_field', None, None, 3, ), # 4
  (5, TType.I64, 'terse_long_field', None, None, 3, ), # 5
  (6, TType.FLOAT, 'terse_float_field', None, None, 3, ), # 6
  (7, TType.DOUBLE, 'terse_double_field', None, None, 3, ), # 7
  (8, TType.STRING, 'terse_string_field', True, None, 3, ), # 8
  (9, TType.STRING, 'terse_binary_field', False, None, 3, ), # 9
  (10, TType.I32, 'terse_enum_field', MyEnum, None, 3, ), # 10
  (11, TType.LIST, 'terse_list_field', (TType.I16,None), None, 3, ), # 11
  (12, TType.SET, 'terse_set_field', (TType.I16,None), None, 3, ), # 12
  (13, TType.MAP, 'terse_map_field', (TType.I16,None,TType.I16,None), None, 3, ), # 13
  (14, TType.STRUCT, 'terse_struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 3, ), # 14
  (15, TType.BOOL, 'bool_field', None, None, 2, ), # 15
  (16, TType.BYTE, 'byte_field', None, None, 2, ), # 16
  (17, TType.I16, 'short_field', None, None, 2, ), # 17
  (18, TType.I32, 'int_field', None, None, 2, ), # 18
  (19, TType.I64, 'long_field', None, None, 2, ), # 19
  (20, TType.FLOAT, 'float_field', None, None, 2, ), # 20
  (21, TType.DOUBLE, 'double_field', None, None, 2, ), # 21
  (22, TType.STRING, 'string_field', True, None, 2, ), # 22
  (23, TType.STRING, 'binary_field', False, None, 2, ), # 23
  (24, TType.I32, 'enum_field', MyEnum, None, 2, ), # 24
  (25, TType.LIST, 'list_field', (TType.I16,None), None, 2, ), # 25
  (26, TType.SET, 'set_field', (TType.I16,None), None, 2, ), # 26
  (27, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), None, 2, ), # 27
  (28, TType.STRUCT, 'struct_field', [MyStruct, MyStruct.thrift_spec, False], None, 2, ), # 28
  (29, TType.STRUCT, 'terse_union_field', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 29
  (30, TType.STRUCT, 'union_field', [MyUnion, MyUnion.thrift_spec, True], None, 2, ), # 30
)))

FieldLevelTerseStruct.thrift_struct_annotations = {
}
FieldLevelTerseStruct.thrift_field_annotations = {
}

def FieldLevelTerseStruct__init__(self, terse_bool_field=None, terse_byte_field=None, terse_short_field=None, terse_int_field=None, terse_long_field=None, terse_float_field=None, terse_double_field=None, terse_string_field=None, terse_binary_field=None, terse_enum_field=None, terse_list_field=None, terse_set_field=None, terse_map_field=None, terse_struct_field=None, terse_union_field=None, bool_field=None, byte_field=None, short_field=None, int_field=None, long_field=None, float_field=None, double_field=None, string_field=None, binary_field=None, enum_field=None, list_field=None, set_field=None, map_field=None, struct_field=None, union_field=None,):
  self.terse_bool_field = terse_bool_field
  self.terse_byte_field = terse_byte_field
  self.terse_short_field = terse_short_field
  self.terse_int_field = terse_int_field
  self.terse_long_field = terse_long_field
  self.terse_float_field = terse_float_field
  self.terse_double_field = terse_double_field
  self.terse_string_field = terse_string_field
  self.terse_binary_field = terse_binary_field
  self.terse_enum_field = terse_enum_field
  self.terse_list_field = terse_list_field
  self.terse_set_field = terse_set_field
  self.terse_map_field = terse_map_field
  self.terse_struct_field = terse_struct_field
  self.terse_union_field = terse_union_field
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  self.list_field = list_field
  self.set_field = set_field
  self.map_field = map_field
  self.struct_field = struct_field
  self.union_field = union_field

FieldLevelTerseStruct.__init__ = FieldLevelTerseStruct__init__

def FieldLevelTerseStruct__setstate__(self, state):
  state.setdefault('terse_bool_field', None)
  state.setdefault('terse_byte_field', None)
  state.setdefault('terse_short_field', None)
  state.setdefault('terse_int_field', None)
  state.setdefault('terse_long_field', None)
  state.setdefault('terse_float_field', None)
  state.setdefault('terse_double_field', None)
  state.setdefault('terse_string_field', None)
  state.setdefault('terse_binary_field', None)
  state.setdefault('terse_enum_field', None)
  state.setdefault('terse_list_field', None)
  state.setdefault('terse_set_field', None)
  state.setdefault('terse_map_field', None)
  state.setdefault('terse_struct_field', None)
  state.setdefault('terse_union_field', None)
  state.setdefault('bool_field', None)
  state.setdefault('byte_field', None)
  state.setdefault('short_field', None)
  state.setdefault('int_field', None)
  state.setdefault('long_field', None)
  state.setdefault('float_field', None)
  state.setdefault('double_field', None)
  state.setdefault('string_field', None)
  state.setdefault('binary_field', None)
  state.setdefault('enum_field', None)
  state.setdefault('list_field', None)
  state.setdefault('set_field', None)
  state.setdefault('map_field', None)
  state.setdefault('struct_field', None)
  state.setdefault('union_field', None)
  self.__dict__ = state

FieldLevelTerseStruct.__getstate__ = lambda self: self.__dict__.copy()
FieldLevelTerseStruct.__setstate__ = FieldLevelTerseStruct__setstate__

all_structs.append(TerseStructWithCustomDefault)
TerseStructWithCustomDefault.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'bool_field', None, True, 3, ), # 1
  (2, TType.BYTE, 'byte_field', None, 1, 3, ), # 2
  (3, TType.I16, 'short_field', None, 2, 3, ), # 3
  (4, TType.I32, 'int_field', None, 3, 3, ), # 4
  (5, TType.I64, 'long_field', None, 4, 3, ), # 5
  (6, TType.FLOAT, 'float_field', None, 5.00000, 3, ), # 6
  (7, TType.DOUBLE, 'double_field', None, 6.00000, 3, ), # 7
  (8, TType.STRING, 'string_field', True, "7", 3, ), # 8
  (9, TType.STRING, 'binary_field', False, "8", 3, ), # 9
  (10, TType.I32, 'enum_field', MyEnum,   1, 3, ), # 10
  (11, TType.LIST, 'list_field', (TType.I16,None), [
    1,
  ], 3, ), # 11
  (12, TType.SET, 'set_field', (TType.I16,None), set([
    1,
  ]), 3, ), # 12
  (13, TType.MAP, 'map_field', (TType.I16,None,TType.I16,None), {
    1 : 1,
  }, 3, ), # 13
  (14, TType.STRUCT, 'struct_field', [MyStructWithCustomDefault, MyStructWithCustomDefault.thrift_spec, False], None, 3, ), # 14
)))

TerseStructWithCustomDefault.thrift_struct_annotations = {
}
TerseStructWithCustomDefault.thrift_field_annotations = {
}

def TerseStructWithCustomDefault__init__(self, bool_field=TerseStructWithCustomDefault.thrift_spec[1][4], byte_field=TerseStructWithCustomDefault.thrift_spec[2][4], short_field=TerseStructWithCustomDefault.thrift_spec[3][4], int_field=TerseStructWithCustomDefault.thrift_spec[4][4], long_field=TerseStructWithCustomDefault.thrift_spec[5][4], float_field=TerseStructWithCustomDefault.thrift_spec[6][4], double_field=TerseStructWithCustomDefault.thrift_spec[7][4], string_field=TerseStructWithCustomDefault.thrift_spec[8][4], binary_field=TerseStructWithCustomDefault.thrift_spec[9][4], enum_field=TerseStructWithCustomDefault.thrift_spec[10][4], list_field=TerseStructWithCustomDefault.thrift_spec[11][4], set_field=TerseStructWithCustomDefault.thrift_spec[12][4], map_field=TerseStructWithCustomDefault.thrift_spec[13][4], struct_field=None,):
  self.bool_field = bool_field
  self.byte_field = byte_field
  self.short_field = short_field
  self.int_field = int_field
  self.long_field = long_field
  self.float_field = float_field
  self.double_field = double_field
  self.string_field = string_field
  self.binary_field = binary_field
  self.enum_field = enum_field
  if list_field is self.thrift_spec[11][4]:
    list_field = [
    1,
  ]
  self.list_field = list_field
  if set_field is self.thrift_spec[12][4]:
    set_field = set([
    1,
  ])
  self.set_field = set_field
  if map_field is self.thrift_spec[13][4]:
    map_field = {
    1 : 1,
  }
  self.map_field = map_field
  self.struct_field = struct_field

TerseStructWithCustomDefault.__init__ = TerseStructWithCustomDefault__init__

def TerseStructWithCustomDefault__setstate__(self, state):
  state.setdefault('bool_field', True)
  state.setdefault('byte_field', 1)
  state.setdefault('short_field', 2)
  state.setdefault('int_field', 3)
  state.setdefault('long_field', 4)
  state.setdefault('float_field', 5.00000)
  state.setdefault('double_field', 6.00000)
  state.setdefault('string_field', "7")
  state.setdefault('binary_field', "8")
  state.setdefault('enum_field',   1)
  state.setdefault('list_field', [
    1,
  ])
  state.setdefault('set_field', set([
    1,
  ]))
  state.setdefault('map_field', {
    1 : 1,
  })
  state.setdefault('struct_field', None)
  self.__dict__ = state

TerseStructWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
TerseStructWithCustomDefault.__setstate__ = TerseStructWithCustomDefault__setstate__

all_structs.append(AdaptedFields)
AdaptedFields.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field1', None, None, 3, ), # 1
  (2, TType.I32, 'field2', None, None, 3, ), # 2
  (3, TType.I32, 'field3', None, None, 3, ), # 3
)))

AdaptedFields.thrift_struct_annotations = {
}
AdaptedFields.thrift_field_annotations = {
}

def AdaptedFields__init__(self, field1=None, field2=None, field3=None,):
  self.field1 = field1
  self.field2 = field2
  self.field3 = field3

AdaptedFields.__init__ = AdaptedFields__init__

def AdaptedFields__setstate__(self, state):
  state.setdefault('field1', None)
  state.setdefault('field2', None)
  state.setdefault('field3', None)
  self.__dict__ = state

AdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
AdaptedFields.__setstate__ = AdaptedFields__setstate__

all_structs.append(WrappedFields)
WrappedFields.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field1', None, 7, 3, ), # 1
)))

WrappedFields.thrift_struct_annotations = {
}
WrappedFields.thrift_field_annotations = {
}

def WrappedFields__init__(self, field1=WrappedFields.thrift_spec[1][4],):
  self.field1 = field1

WrappedFields.__init__ = WrappedFields__init__

def WrappedFields__setstate__(self, state):
  state.setdefault('field1', 7)
  self.__dict__ = state

WrappedFields.__getstate__ = lambda self: self.__dict__.copy()
WrappedFields.__setstate__ = WrappedFields__setstate__

all_structs.append(TerseException)
TerseException.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'msg', True, None, 3, ), # 1
)))

TerseException.thrift_struct_annotations = {
  "message": "msg",
}
TerseException.thrift_field_annotations = {
}

def TerseException__init__(self, msg=None,):
  self.msg = msg

TerseException.__init__ = TerseException__init__

def TerseException__setstate__(self, state):
  state.setdefault('msg', None)
  self.__dict__ = state

TerseException.__getstate__ = lambda self: self.__dict__.copy()
TerseException.__setstate__ = TerseException__setstate__

fix_spec(all_structs)
del all_structs
