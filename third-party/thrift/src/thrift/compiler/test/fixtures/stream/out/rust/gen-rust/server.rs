// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Server definitions for `module`.

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]


#[doc(inline)]
pub use :: as types;

pub mod errors {
    #[doc(inline)]
    pub use ::::services::pub_sub_streaming_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::pub_sub_streaming_service::*;
}

pub(crate) use crate as server;
pub(crate) use ::::services;



#[::async_trait::async_trait]
pub trait PubSubStreamingService: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn returnstream(
        &self,
        _i32_from: ::std::primitive::i32,
        _i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "returnstream",
            ),
        ))
    }
    async fn streamthrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>>
, crate::services::pub_sub_streaming_service::StreamthrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::StreamthrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "streamthrows",
            ),
        ))
    }
    async fn servicethrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ServicethrowsStreamExn>>
, crate::services::pub_sub_streaming_service::ServicethrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "servicethrows",
            ),
        ))
    }
    async fn servicethrows2(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::Servicethrows2StreamExn>>
, crate::services::pub_sub_streaming_service::Servicethrows2Exn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "servicethrows2",
            ),
        ))
    }
    async fn boththrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>>
, crate::services::pub_sub_streaming_service::BoththrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "boththrows",
            ),
        ))
    }
    async fn responseandstreamstreamthrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "responseandstreamstreamthrows",
            ),
        ))
    }
    async fn responseandstreamservicethrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "responseandstreamservicethrows",
            ),
        ))
    }
    async fn responseandstreamboththrows(
        &self,
        _foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "responseandstreamboththrows",
            ),
        ))
    }
    async fn returnstreamFast(
        &self,
        _i32_from: ::std::primitive::i32,
        _i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamFastExn> {
        ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamFastExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "PubSubStreamingService",
                "returnstreamFast",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> PubSubStreamingService for ::std::boxed::Box<T>
where
    T: PubSubStreamingService + Send + Sync + ?Sized,
{
    async fn returnstream(
        &self,
        i32_from: ::std::primitive::i32,
        i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamExn> {
        (**self).returnstream(
            i32_from,
            i32_to,
        ).await
    }
    async fn streamthrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>>
, crate::services::pub_sub_streaming_service::StreamthrowsExn> {
        (**self).streamthrows(
            foo,
        ).await
    }
    async fn servicethrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ServicethrowsStreamExn>>
, crate::services::pub_sub_streaming_service::ServicethrowsExn> {
        (**self).servicethrows(
            foo,
        ).await
    }
    async fn servicethrows2(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::Servicethrows2StreamExn>>
, crate::services::pub_sub_streaming_service::Servicethrows2Exn> {
        (**self).servicethrows2(
            foo,
        ).await
    }
    async fn boththrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>>
, crate::services::pub_sub_streaming_service::BoththrowsExn> {
        (**self).boththrows(
            foo,
        ).await
    }
    async fn responseandstreamstreamthrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn> {
        (**self).responseandstreamstreamthrows(
            foo,
        ).await
    }
    async fn responseandstreamservicethrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> {
        (**self).responseandstreamservicethrows(
            foo,
        ).await
    }
    async fn responseandstreamboththrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> {
        (**self).responseandstreamboththrows(
            foo,
        ).await
    }
    async fn returnstreamFast(
        &self,
        i32_from: ::std::primitive::i32,
        i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamFastExn> {
        (**self).returnstreamFast(
            i32_from,
            i32_to,
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> PubSubStreamingService for ::std::sync::Arc<T>
where
    T: PubSubStreamingService + Send + Sync + ?Sized,
{
    async fn returnstream(
        &self,
        i32_from: ::std::primitive::i32,
        i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamExn> {
        (**self).returnstream(
            i32_from,
            i32_to,
        ).await
    }
    async fn streamthrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>>
, crate::services::pub_sub_streaming_service::StreamthrowsExn> {
        (**self).streamthrows(
            foo,
        ).await
    }
    async fn servicethrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ServicethrowsStreamExn>>
, crate::services::pub_sub_streaming_service::ServicethrowsExn> {
        (**self).servicethrows(
            foo,
        ).await
    }
    async fn servicethrows2(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::Servicethrows2StreamExn>>
, crate::services::pub_sub_streaming_service::Servicethrows2Exn> {
        (**self).servicethrows2(
            foo,
        ).await
    }
    async fn boththrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>>
, crate::services::pub_sub_streaming_service::BoththrowsExn> {
        (**self).boththrows(
            foo,
        ).await
    }
    async fn responseandstreamstreamthrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn> {
        (**self).responseandstreamstreamthrows(
            foo,
        ).await
    }
    async fn responseandstreamservicethrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> {
        (**self).responseandstreamservicethrows(
            foo,
        ).await
    }
    async fn responseandstreamboththrows(
        &self,
        foo: ::std::primitive::i32,
    ) -> ::std::result::Result<
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>>
)
, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> {
        (**self).responseandstreamboththrows(
            foo,
        ).await
    }
    async fn returnstreamFast(
        &self,
        i32_from: ::std::primitive::i32,
        i32_to: ::std::primitive::i32,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn>>
, crate::services::pub_sub_streaming_service::ReturnstreamFastExn> {
        (**self).returnstreamFast(
            i32_from,
            i32_to,
        ).await
    }
}
/// Processor for PubSubStreamingService's methods.
#[derive(Clone, Debug)]
pub struct PubSubStreamingServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_PubSubStreamingService_returnstream {
    i32_from: ::std::primitive::i32,
    i32_to: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_returnstream {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.returnstream"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("i32_from", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("i32_to", ::fbthrift::TType::I32, 2),
        ];
        let mut field_i32_from = ::std::option::Option::None;
        let mut field_i32_to = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_i32_from = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "i32_from", function: "returnstream"})?),
                (::fbthrift::TType::I32, 2) => field_i32_to = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "i32_to", function: "returnstream"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            i32_from: field_i32_from.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.returnstream", "i32_from"))?,
            i32_to: field_i32_to.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.returnstream", "i32_to"))?,
        })
    }
}


struct Args_PubSubStreamingService_streamthrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_streamthrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.streamthrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "streamthrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.streamthrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_servicethrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_servicethrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.servicethrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "servicethrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.servicethrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_servicethrows2 {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_servicethrows2 {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.servicethrows2"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "servicethrows2"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.servicethrows2", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_boththrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_boththrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.boththrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "boththrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.boththrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_responseandstreamstreamthrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_responseandstreamstreamthrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.responseandstreamstreamthrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "responseandstreamstreamthrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.responseandstreamstreamthrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_responseandstreamservicethrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_responseandstreamservicethrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.responseandstreamservicethrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "responseandstreamservicethrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.responseandstreamservicethrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_responseandstreamboththrows {
    foo: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_responseandstreamboththrows {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.responseandstreamboththrows"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("foo", ::fbthrift::TType::I32, 1),
        ];
        let mut field_foo = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_foo = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "foo", function: "responseandstreamboththrows"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            foo: field_foo.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.responseandstreamboththrows", "foo"))?,
        })
    }
}


struct Args_PubSubStreamingService_returnstreamFast {
    i32_from: ::std::primitive::i32,
    i32_to: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_PubSubStreamingService_returnstreamFast {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "PubSubStreamingService.returnstreamFast"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("i32_from", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("i32_to", ::fbthrift::TType::I32, 2),
        ];
        let mut field_i32_from = ::std::option::Option::None;
        let mut field_i32_to = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_i32_from = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "i32_from", function: "returnstreamFast"})?),
                (::fbthrift::TType::I32, 2) => field_i32_to = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "i32_to", function: "returnstreamFast"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            i32_from: field_i32_from.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.returnstreamFast", "i32_from"))?,
            i32_to: field_i32_to.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "PubSubStreamingService.returnstreamFast", "i32_to"))?,
        })
    }
}

impl<P, H, R, RS> PubSubStreamingServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: PubSubStreamingService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.returnstream"))]
    async fn handle_returnstream<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"returnstream";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.returnstream";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_returnstream = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.returnstream(
                _args.i32_from,
                _args.i32_to,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.returnstream", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.returnstream", exn);
                ::tracing::error!(method = "PubSubStreamingService.returnstream", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ReturnstreamStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "returnstream",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.returnstream", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.returnstream", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.returnstream", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ReturnstreamExn>(
            "returnstream",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.streamthrows"))]
    async fn handle_streamthrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"streamthrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.streamthrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_streamthrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.streamthrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.streamthrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.streamthrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.streamthrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::StreamthrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "streamthrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.streamthrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                                tracing::debug!(?exn, method="PubSubStreamingService.streamthrows", "Streaming declared exception");
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::StreamthrowsStreamExn>(
                                    ::std::result::Result::Err(exn),
                                    "streamthrows",
                                );
                                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.streamthrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.streamthrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::StreamthrowsExn>(
            "streamthrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.servicethrows"))]
    async fn handle_servicethrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"servicethrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.servicethrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_servicethrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.servicethrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.servicethrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.servicethrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.servicethrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ServicethrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "servicethrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ServicethrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.servicethrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.servicethrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.servicethrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ServicethrowsExn>(
            "servicethrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.servicethrows2"))]
    async fn handle_servicethrows2<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"servicethrows2";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.servicethrows2";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_servicethrows2 = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.servicethrows2(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.servicethrows2", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.servicethrows2", exn);
                ::tracing::error!(method = "PubSubStreamingService.servicethrows2", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::Servicethrows2StreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "servicethrows2",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::Servicethrows2StreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.servicethrows2", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.servicethrows2", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.servicethrows2", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::Servicethrows2Exn>(
            "servicethrows2",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.boththrows"))]
    async fn handle_boththrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"boththrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.boththrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_boththrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.boththrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.boththrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.boththrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.boththrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "boththrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::BoththrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.boththrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                                tracing::debug!(?exn, method="PubSubStreamingService.boththrows", "Streaming declared exception");
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::BoththrowsStreamExn>(
                                    ::std::result::Result::Err(exn),
                                    "boththrows",
                                );
                                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.boththrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.boththrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::BoththrowsExn>(
            "boththrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.responseandstreamstreamthrows"))]
    async fn handle_responseandstreamstreamthrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"responseandstreamstreamthrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.responseandstreamstreamthrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_responseandstreamstreamthrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.responseandstreamstreamthrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.responseandstreamstreamthrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamstreamthrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.responseandstreamstreamthrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let (response, stream) = res;
                let response = ::std::result::Result::Ok(response);

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "responseandstreamstreamthrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.responseandstreamstreamthrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                                tracing::debug!(?exn, method="PubSubStreamingService.responseandstreamstreamthrows", "Streaming declared exception");
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn>(
                                    ::std::result::Result::Err(exn),
                                    "responseandstreamstreamthrows",
                                );
                                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.responseandstreamstreamthrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamstreamthrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn>(
            "responseandstreamstreamthrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.responseandstreamservicethrows"))]
    async fn handle_responseandstreamservicethrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"responseandstreamservicethrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.responseandstreamservicethrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_responseandstreamservicethrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.responseandstreamservicethrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.responseandstreamservicethrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamservicethrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.responseandstreamservicethrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let (response, stream) = res;
                let response = ::std::result::Result::Ok(response);

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "responseandstreamservicethrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.responseandstreamservicethrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.responseandstreamservicethrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamservicethrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn>(
            "responseandstreamservicethrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.responseandstreamboththrows"))]
    async fn handle_responseandstreamboththrows<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"responseandstreamboththrows";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.responseandstreamboththrows";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_responseandstreamboththrows = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.responseandstreamboththrows(
                _args.foo,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.responseandstreamboththrows", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamboththrows", exn);
                ::tracing::error!(method = "PubSubStreamingService.responseandstreamboththrows", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let (response, stream) = res;
                let response = ::std::result::Result::Ok(response);

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "responseandstreamboththrows",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.responseandstreamboththrows", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                                tracing::debug!(?exn, method="PubSubStreamingService.responseandstreamboththrows", "Streaming declared exception");
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn>(
                                    ::std::result::Result::Err(exn),
                                    "responseandstreamboththrows",
                                );
                                ::fbthrift::SerializedStreamElement::DeclaredException(payload)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.responseandstreamboththrows", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.responseandstreamboththrows", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn>(
            "responseandstreamboththrows",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "PubSubStreamingService.returnstreamFast"))]
    async fn handle_returnstreamFast<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"PubSubStreamingService";
        const METHOD_NAME: &::std::ffi::CStr = c"returnstreamFast";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"PubSubStreamingService.returnstreamFast";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_PubSubStreamingService_returnstreamFast = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.returnstreamFast(
                _args.i32_from,
                _args.i32_to,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "PubSubStreamingService.returnstreamFast", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.returnstreamFast", exn);
                ::tracing::error!(method = "PubSubStreamingService.returnstreamFast", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamFastExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let response = ::std::result::Result::Ok(());
                let stream = res;

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "returnstreamFast",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="PubSubStreamingService.returnstreamFast", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="PubSubStreamingService.returnstreamFast", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("PubSubStreamingService.returnstreamFast", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::pub_sub_streaming_service::ReturnstreamFastExn>(
            "returnstreamFast",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for PubSubStreamingServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: PubSubStreamingService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"returnstream" => ::std::result::Result::Ok(0usize),
            b"streamthrows" => ::std::result::Result::Ok(1usize),
            b"servicethrows" => ::std::result::Result::Ok(2usize),
            b"servicethrows2" => ::std::result::Result::Ok(3usize),
            b"boththrows" => ::std::result::Result::Ok(4usize),
            b"responseandstreamstreamthrows" => ::std::result::Result::Ok(5usize),
            b"responseandstreamservicethrows" => ::std::result::Result::Ok(6usize),
            b"responseandstreamboththrows" => ::std::result::Result::Ok(7usize),
            b"returnstreamFast" => ::std::result::Result::Ok(8usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_returnstream(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_streamthrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            2usize => {
                self.handle_servicethrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            3usize => {
                self.handle_servicethrows2(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            4usize => {
                self.handle_boththrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            5usize => {
                self.handle_responseandstreamstreamthrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            6usize => {
                self.handle_responseandstreamservicethrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            7usize => {
                self.handle_responseandstreamboththrows(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            8usize => {
                self.handle_returnstreamFast(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "PubSubStreamingServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "PubSubStreamingServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for PubSubStreamingServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: PubSubStreamingService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "PubSubStreamingService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.PubSubStreamingService:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "returnstream",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "streamthrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "servicethrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "servicethrows2",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "boththrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "responseandstreamstreamthrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "responseandstreamservicethrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "responseandstreamboththrows",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "returnstreamFast",
              starts_interaction: false,
              interaction_name: None,
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a PubSubStreamingService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_PubSubStreamingService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: PubSubStreamingService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(PubSubStreamingServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(PubSubStreamingServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "PubSubStreamingService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

