{{!

  Copyright (c) Meta Platforms, Inc. and affiliates.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}// @{{!}}generated by Thrift for {{program:autogen_path}}
// This file is probably not the place you want to edit!

{{#if (not (string.empty? program:include_docs))}}
#![doc = include_str!("{{program:include_docs}}")]
{{/if (not (string.empty? program:include_docs))}}
{{#if program:services?}}
//! Mock definitions for `{{program:name}}`.
//!
//! Client mocks. For every service, a struct TheService that implements
//! client::TheService.
//!
//! As an example of the generated API, for the following thrift service in
//! example.thrift:
//!
//! ```thrift
//! service MyService {
//!     FunctionResponse myFunction(
//!         1: FunctionRequest request,
//!     ) throws {
//!         1: StorageException s,
//!         2: NotFoundException n,
//!     ),
//!
//!     // other functions
//! }
//! ```
//!
//! we would end up with this mock object in an `example_mocks` crate:
//!
//! ```
//! # const _: &str = stringify! {
//! impl example_clients::MyService for MyService<'mock> {...}
//!
//! pub struct MyService<'mock> {
//!     pub myFunction: myFunction<'mock>,
//!     // ...
//! }
//!
//! impl myFunction<'mock> {
//!     // directly return the given success response
//!     pub fn ret(&self, value: FunctionResponse);
//!
//!     // invoke closure to compute success response
//!     pub fn mock(
//!         &self,
//!         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
//!     );
//!
//!     // invoke closure to compute response
//!     pub fn mock_result(
//!         &self,
//!         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, example_services::errors::MyFunctionExn> + Send + Sync + 'mock,
//!     );
//!
//!     // return one of the function's declared exceptions
//!     pub fn throw<E>(&self, exception: E)
//!     where
//!         E: Clone + Into<example_services::errors::MyFunctionExn> + Send + Sync + 'mock;
//! }
//! # };
//! ```
//!
//! The intended usage from a test would be:
//!
//! ```
//! # const _: &str = stringify! {
//! use std::sync::Arc;
//! use example_clients::MyService;
//!
//! #[tokio::test]
//! async fn test_my_client() {
//!     let mock = Arc::new(example_mocks::new::<dyn MyService>());
//!
//!     // directly return a success response
//!     let resp = FunctionResponse {...};
//!     mock.myFunction.ret(resp);
//!
//!     // or give a closure to compute the success response
//!     mock.myFunction.mock(|request| FunctionResponse {...});
//!
//!     // or throw one of the function's exceptions
//!     mock.myFunction.throw(StorageException::ItFailed);
//!
//!     // or compute a Result (useful if your exceptions aren't Clone)
//!     mock.myFunction.mock_result(|request| Err(...));
//!
//!     let out = do_the_thing(mock).await.unwrap();
//!     assert!(out.what_i_expected());
//! }
//!
//! async fn do_the_thing(
//!     client: Arc<dyn MyService + Send + Sync + 'static>,
//! ) -> Out {...}
//! # };
//! ```

{{#if (not program:multifile?)}}
#![recursion_limit = "100000000"]
{{/if (not program:multifile?)}}
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals{{!
}}{{#if (not program:multifile?)}}, unused_crate_dependencies{{/if (not program:multifile?)}}{{!
}}, unused_imports, clippy::all)]

pub(crate) use {{program:types}} as types;
pub(crate) use {{program:clients}} as client;
pub(crate) use {{program:clients}}::errors;

{{#if (not program:multifile?)}}
pub fn new<'mock, Client>() -> Client::Mock<'mock>
where
    Client: ?::std::marker::Sized + DynClient,
{
    Client::mock()
}

pub trait DynClient {
    type Mock<'mock>;
    fn mock<'mock>() -> Self::Mock<'mock>;
}
{{/if (not program:multifile?)}}

{{#program:services}}
pub struct {{service:rust_name}}<'mock> {{> lib/block}}
    {{#service:extends}}
    pub parent: {{service:mock_package}}::{{service:rust_name}}<'mock>,
    {{/service:extends}}
    {{#service:rustFunctions}}
    {{#if (not function:starts_interaction?)}}
    pub {{function:rust_name}}: r#impl::{{service:snake}}::{{function:rust_name}}<'mock>,
    {{/if (not function:starts_interaction?)}}
    {{/service:rustFunctions}}
    _marker: ::std::marker::PhantomData<&'mock ()>,
}

impl crate::DynClient for dyn {{program:clients}}::{{service:rust_name}} {
    type Mock<'mock> = {{service:rust_name}}<'mock>;
    fn mock<'mock>() -> Self::Mock<'mock> {
        {{service:rust_name}} {
            {{#service:extends}}
            parent: {{service:mock_crate}}::new::<dyn {{service:client_package}}::{{service:rust_name}}>(),
            {{/service:extends}}
            {{#service:rustFunctions}}
            {{#if (not function:starts_interaction?)}}
            {{function:rust_name}}: {{!
                }}r#impl::{{service:snake}}::{{function:rust_name}}::unimplemented(),
            {{/if (not function:starts_interaction?)}}
            {{/service:rustFunctions}}
            _marker: ::std::marker::PhantomData,
        }
    }
}

impl<'mock> {{program:clients}}::{{service:rust_name}} for {{service:rust_name}}<'mock> {{> lib/block}}{{!
    }}{{#service:rustFunctions}}
    {{#if (not function:starts_interaction?)}}{{#if (not function:creates_interaction?)}}
    fn {{function:rust_name}}(
        &self,{{!
        }}{{#function:args}}
        arg_{{field:name}}: {{> lib/arg}},{{!
        }}{{/function:args}}
    ) -> {{> lib/client_return_type}} {
        let mut closure = self.{{function:rust_name}}.closure.lock().unwrap();
        let closure: &mut dyn ::std::ops::FnMut({{!
            }}{{#function:args}}{{!
            }}{{#field:type}}{{> lib/type}}{{/field:type}}{{!
            }}{{#if (not last?)}}, {{/if (not last?)}}{{!
            }}{{/function:args}}{{!
        }}) -> _ = &mut **closure;
        ::std::boxed::Box::pin(::futures::future::ready(closure({{!
            }}{{#function:args}}{{!
            }}arg_{{field:name}}{{#field:type}}{{!
                }}{{#if type:string?}}.to_owned(){{/if type:string?}}{{!
                }}{{#if type:list?}}.to_owned(){{/if type:list?}}{{!
                }}{{#if (not type:string?)}}{{#if (not type:list?)}}{{!
                    }}.clone(){{!
                }}{{/if (not type:list?)}}{{/if (not type:string?)}}{{!
            }}{{/field:type}}{{!
            }}{{#if (not last?)}}, {{/if (not last?)}}{{!
            }}{{/function:args}}{{!
        }})))
    }{{!
    }}{{#else}}
    fn {{function:rust_name}}(
        &self,{{!
        }}{{#function:args}}
        _arg_{{field:name}}: {{> lib/arg}},{{!
        }}{{/function:args}}
    ) -> {{> lib/client_return_type}} {
        unimplemented!("Mocking interactions is not yet implemented");
    }{{!
    }}{{/if (not function:creates_interaction?)}}{{#else}}
    fn {{function:rust_name}}(
        &self,
    ) -> ::std::result::Result<{{!
    }}{{service:client_package}}::{{function:interaction_name}}Client, {{!
    }}::anyhow::Error> {
        unimplemented!("Mocking interactions is not yet implemented");
    }{{!
    }}{{/if (not function:starts_interaction?)}}{{/service:rustFunctions}}
}

impl<'mock, T> {{program:clients}}::{{service:rust_name}}Ext<T> for {{service:rust_name}}<'mock>
where
    T: ::fbthrift::Transport,
{{> lib/block}}{{!
    }}{{#service:rustFunctions}}
    {{#if (not function:starts_interaction?)}}
    fn {{function:rust_name}}_with_rpc_opts(
        &self,{{!
        }}{{#function:args}}
        arg_{{field:name}}: {{> lib/arg}},{{!
        }}{{/function:args}}
        _rpc_options: T::RpcOptions,
    ) -> {{> lib/client_return_type}} {
        <Self as {{program:clients}}::{{service:rust_name}}>::{{function:rust_name}}(
            self,
            {{#function:args}}
            arg_{{field:name}},
            {{/function:args}}
        )
    }
    {{/if (not function:starts_interaction?)}}
    {{/service:rustFunctions}}
    {{#if (not service:extendedClients)}}

    fn transport(&self) -> &T {
        ::fbthrift::help::GetTransport::transport(self)
    }
    {{/if (not service:extendedClients)}}
}

impl<'mock, T> ::fbthrift::help::GetTransport<T> for {{service:rust_name}}<'mock>
where
    T: ::fbthrift::Transport,
{
    fn transport(&self) -> &T {
        unimplemented!("{{service:rust_name}}Ext::transport is not implemented for mock client")
    }
}

{{#service:extendedClients}}
#[allow(deprecated)]{{! `dependencies` modules are deprecated other than for packagePrefix to use }}
impl<'mock> {{!
    }}{{#extendedService:service}}{{!
    }}::std::convert::AsRef<dyn {{extendedService:packagePrefix}}::{{service:rust_name}} + 'mock> {{!
    }}{{/extendedService:service}}{{!
    }}for {{service:rust_name}}<'mock>
{
    {{#extendedService:service}}
    fn as_ref(&self) -> &(dyn {{extendedService:packagePrefix}}::{{service:rust_name}} + 'mock) {
        &self.parent
    }
    {{/extendedService:service}}
}

#[allow(deprecated)]{{! `dependencies` modules are deprecated other than for packagePrefix to use }}
impl<'mock, T> {{!
    }}{{#extendedService:service}}{{!
    }}::std::convert::AsRef<dyn {{extendedService:packagePrefix}}::{{service:rust_name}}Ext<T> + 'mock> {{!
    }}{{/extendedService:service}}{{!
    }}for {{service:rust_name}}<'mock>
where
    T: ::fbthrift::Transport,
{
    {{#extendedService:service}}
    fn as_ref(&self) -> &(dyn {{extendedService:packagePrefix}}::{{service:rust_name}}Ext<T> + 'mock) {
        &self.parent
    }
    {{/extendedService:service}}
}

{{/service:extendedClients}}{{!
}}{{/program:services}}
pub mod r#impl {{> lib/block}}{{!
}}{{#program:services}}
    pub mod {{service:snake}} {{> lib/block}}{{!

        }}{{#service:rustFunctions}}
        {{#if (not function:starts_interaction?)}}

        pub struct {{function:rust_name}}<'mock> {
            pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                dyn ::std::ops::FnMut({{!
                    }}{{#function:args}}{{!
                    }}{{#field:type}}{{> lib/type}}{{/field:type}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}) -> ::std::result::Result<
                    {{#function:return_type}}{{> lib/return_type}}{{/function:return_type}},
                    {{program:clients}}::errors::{{service:snake}}::{{function:upcamel}}Error,
                > + ::std::marker::Send + ::std::marker::Sync + 'mock,
            >>,
        }

        #[allow(clippy::redundant_closure)]
        impl<'mock> {{function:rust_name}}<'mock> {
            pub(crate) fn unimplemented() -> Self {
                Self {
                    closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|{{!
                        }}{{#function:args}}{{!
                        }}_: {{#field:type}}{{> lib/type}}{{/field:type}}{{!
                        }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                        }}{{/function:args}}{{!
                    }}| panic!(
                        "{}::{} is not mocked",
                        "{{service:rust_name}}",
                        "{{function:name}}",
                    ))),
                }
            }

            pub fn ret({{!
                }}&self, {{!
                }}{{#if function:stream?}}_{{/if function:stream?}}{{#if function:sink?}}_{{/if function:sink?}}value: {{#function:return_type}}{{> lib/return_type}}{{/function:return_type}}{{!
            }}) {
                {{#if function:bidirectional_stream?}}
                unimplemented!("Mocking bidirectional streams is not yet implemented, as value isn't cloneable");
                {{#else}}{{#if function:stream?}}
                unimplemented!("Mocking streams is not yet implemented, as value isn't cloneable");
                {{#else}}{{#if function:sink?}}
                unimplemented!("Mocking sinks is not yet implemented, as value isn't cloneable");
                {{#else}}
                self.mock(move |{{!
                    }}{{#function:args}}{{!
                    }}_: {{#field:type}}{{> lib/type}}{{/field:type}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}| value.clone());
                {{/if function:sink?}}{{/if function:stream?}}{{/if function:bidirectional_stream?}}
            }

            pub fn mock(&self, mut mock: impl ::std::ops::FnMut({{!
                }}{{#function:args}}{{!
                }}{{#field:type}}{{> lib/type}}{{/field:type}}{{!
                }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                }}{{/function:args}}{{!
            }}) -> {{#function:return_type}}{{> lib/return_type}}{{/function:return_type}}{{!
                }} + ::std::marker::Send + ::std::marker::Sync + 'mock) {{!
            }}{
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |{{!
                    }}{{#function:args}}{{!
                    }}{{field:rust_name}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}| ::std::result::Result::Ok(mock({{!
                    }}{{#function:args}}{{!
                    }}{{field:rust_name}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }})));
            }

            pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut({{!
                }}{{#function:args}}{{!
                }}{{#field:type}}{{> lib/type}}{{/field:type}}{{!
                }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                }}{{/function:args}}{{!
            }}) -> ::std::result::Result<{{!
                    }}{{#function:return_type}}{{> lib/return_type}}{{/function:return_type}}, {{!
                    }}{{program:clients}}::errors::{{service:snake}}::{{function:upcamel}}Error>{{!
                }} + ::std::marker::Send + ::std::marker::Sync + 'mock) {{!
            }}{
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |{{!
                    }}{{#function:args}}{{!
                    }}{{field:rust_name}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}| mock({{!
                    }}{{#function:args}}{{!
                    }}{{field:rust_name}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: ::std::convert::Into<{{program:clients}}::errors::{{service:snake}}::{{function:upcamel}}Error>,
                E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = ::std::boxed::Box::new(move |{{!
                    }}{{#function:args}}{{!
                    }}_: {{#field:type}}{{> lib/type}}{{/field:type}}{{!
                    }}{{#if (not last?)}}, {{/if (not last?)}}{{!
                    }}{{/function:args}}{{!
                }}| ::std::result::Result::Err(exception.clone().into()));
            }
        }{{!
        }}{{/if (not function:starts_interaction?)}}{{!
        }}{{/service:rustFunctions}}
    }{{!
}}{{/program:services}}
}
{{/if program:services?}}
{{#if (not program:services?)}}
#![doc(hidden)]
#![allow({{!
}}{{#if (not program:multifile?)}}non_snake_case, unused_crate_dependencies, {{/if (not program:multifile?)}}{{!
}}unused_imports)]

pub(crate) use {{program:types}} as types;
{{/if (not program:services?)}}
{{#if program:direct_dependencies?}}

#[doc(hidden)]
pub mod __dependencies {
    {{#program:direct_dependencies}}
    #[doc(hidden)]
    pub mod {{dependency:name_unmangled}}_mocks {
        #[doc(hidden)]
        pub use ::{{dependency:name_unmangled}}_mocks::*;
    }
    {{/program:direct_dependencies}}
}
{{/if program:direct_dependencies?}}
