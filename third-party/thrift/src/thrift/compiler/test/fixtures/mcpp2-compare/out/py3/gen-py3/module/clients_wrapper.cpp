/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <thrift/compiler/test/fixtures/mcpp2-compare/gen-py3/module/clients_wrapper.h>

namespace some {
namespace valid {
namespace ns {


folly::Future<folly::Unit>
ReturnServiceClientWrapper::noReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_noReturn, channel_);
  try {
    client->noReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<bool>
ReturnServiceClientWrapper::boolReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<bool>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<bool>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_boolReturn, channel_);
  try {
    client->boolReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<bool>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int16_t>
ReturnServiceClientWrapper::i16Return(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int16_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int16_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i16Return, channel_);
  try {
    client->i16Return(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<int16_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int32_t>
ReturnServiceClientWrapper::i32Return(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int32_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int32_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i32Return, channel_);
  try {
    client->i32Return(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<int32_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int64_t>
ReturnServiceClientWrapper::i64Return(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int64_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int64_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i64Return, channel_);
  try {
    client->i64Return(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<int64_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<float>
ReturnServiceClientWrapper::floatReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<float>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<float>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_floatReturn, channel_);
  try {
    client->floatReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<float>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<double>
ReturnServiceClientWrapper::doubleReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<double>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<double>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_doubleReturn, channel_);
  try {
    client->doubleReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<double>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::string>
ReturnServiceClientWrapper::stringReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::string>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::string>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_stringReturn, channel_);
  try {
    client->stringReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::string>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::string>
ReturnServiceClientWrapper::binaryReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::string>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::string>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_binaryReturn, channel_);
  try {
    client->binaryReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::string>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::map<std::string,int64_t>>
ReturnServiceClientWrapper::mapReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::map<std::string,int64_t>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::map<std::string,int64_t>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_mapReturn, channel_);
  try {
    client->mapReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::map<std::string,int64_t>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int32_t>
ReturnServiceClientWrapper::simpleTypedefReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int32_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int32_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_simpleTypedefReturn, channel_);
  try {
    client->simpleTypedefReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<int32_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>
ReturnServiceClientWrapper::complexTypedefReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_complexTypedefReturn, channel_);
  try {
    client->complexTypedefReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<std::vector<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>>>
ReturnServiceClientWrapper::list_mostComplexTypedefReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<std::vector<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<std::vector<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_list_mostComplexTypedefReturn, channel_);
  try {
    client->list_mostComplexTypedefReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::vector<std::vector<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::MyEnumA>
ReturnServiceClientWrapper::enumReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::MyEnumA>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::MyEnumA>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_enumReturn, channel_);
  try {
    client->enumReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::MyEnumA>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<::some::valid::ns::MyEnumA>>
ReturnServiceClientWrapper::list_EnumReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<::some::valid::ns::MyEnumA>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<::some::valid::ns::MyEnumA>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_list_EnumReturn, channel_);
  try {
    client->list_EnumReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::vector<::some::valid::ns::MyEnumA>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::MyStruct>
ReturnServiceClientWrapper::structReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::MyStruct>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::MyStruct>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_structReturn, channel_);
  try {
    client->structReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::MyStruct>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::set<::some::valid::ns::MyStruct>>
ReturnServiceClientWrapper::set_StructReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::set<::some::valid::ns::MyStruct>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::set<::some::valid::ns::MyStruct>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_set_StructReturn, channel_);
  try {
    client->set_StructReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::set<::some::valid::ns::MyStruct>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::ComplexUnion>
ReturnServiceClientWrapper::unionReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::ComplexUnion>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::ComplexUnion>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_unionReturn, channel_);
  try {
    client->unionReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::ComplexUnion>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<::some::valid::ns::ComplexUnion>>
ReturnServiceClientWrapper::list_UnionReturn(
    apache::thrift::RpcOptions& rpcOptions) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<::some::valid::ns::ComplexUnion>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<::some::valid::ns::ComplexUnion>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_list_UnionReturn, channel_);
  try {
    client->list_UnionReturn(
      rpcOptions,
      std::move(callback)
    );
  } catch (...) {
    return folly::makeFuture<std::vector<::some::valid::ns::ComplexUnion>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::IOBuf>
ReturnServiceClientWrapper::readDataEb(
    apache::thrift::RpcOptions& rpcOptions,
    int64_t arg_size) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::IOBuf>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::IOBuf>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_readDataEb, channel_);
  try {
    client->readDataEb(
      rpcOptions,
      std::move(callback),
      arg_size
    );
  } catch (...) {
    return folly::makeFuture<folly::IOBuf>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::unique_ptr<folly::IOBuf>>
ReturnServiceClientWrapper::readData(
    apache::thrift::RpcOptions& rpcOptions,
    int64_t arg_size) {
  auto* client = static_cast<::some::valid::ns::ReturnServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::unique_ptr<folly::IOBuf>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::unique_ptr<folly::IOBuf>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_readData, channel_);
  try {
    client->readData(
      rpcOptions,
      std::move(callback),
      arg_size
    );
  } catch (...) {
    return folly::makeFuture<std::unique_ptr<folly::IOBuf>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_i16_param(
    apache::thrift::RpcOptions& rpcOptions,
    int16_t arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_i16_param, channel_);
  try {
    client->void_ret_i16_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_byte_i16_param(
    apache::thrift::RpcOptions& rpcOptions,
    int8_t arg_param1,
    int16_t arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_byte_i16_param, channel_);
  try {
    client->void_ret_byte_i16_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_map_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::map<std::string,int64_t> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_map_param, channel_);
  try {
    client->void_ret_map_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_map_setlist_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::map<std::string,int64_t> arg_param1,
    std::set<std::vector<std::string>> arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_map_setlist_param, channel_);
  try {
    client->void_ret_map_setlist_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_map_typedef_param(
    apache::thrift::RpcOptions& rpcOptions,
    int32_t arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_map_typedef_param, channel_);
  try {
    client->void_ret_map_typedef_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_enum_param(
    apache::thrift::RpcOptions& rpcOptions,
    ::some::valid::ns::MyEnumA arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_enum_param, channel_);
  try {
    client->void_ret_enum_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_struct_param(
    apache::thrift::RpcOptions& rpcOptions,
    ::some::valid::ns::MyStruct arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_struct_param, channel_);
  try {
    client->void_ret_struct_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::void_ret_listunion_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::vector<::some::valid::ns::ComplexUnion> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_void_ret_listunion_param, channel_);
  try {
    client->void_ret_listunion_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<bool>
ParamServiceClientWrapper::bool_ret_i32_i64_param(
    apache::thrift::RpcOptions& rpcOptions,
    int32_t arg_param1,
    int64_t arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<bool>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<bool>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_bool_ret_i32_i64_param, channel_);
  try {
    client->bool_ret_i32_i64_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<bool>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<bool>
ParamServiceClientWrapper::bool_ret_map_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::map<std::string,int64_t> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<bool>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<bool>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_bool_ret_map_param, channel_);
  try {
    client->bool_ret_map_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<bool>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<bool>
ParamServiceClientWrapper::bool_ret_union_param(
    apache::thrift::RpcOptions& rpcOptions,
    ::some::valid::ns::ComplexUnion arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<bool>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<bool>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_bool_ret_union_param, channel_);
  try {
    client->bool_ret_union_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<bool>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int64_t>
ParamServiceClientWrapper::i64_ret_float_double_param(
    apache::thrift::RpcOptions& rpcOptions,
    float arg_param1,
    double arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int64_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int64_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i64_ret_float_double_param, channel_);
  try {
    client->i64_ret_float_double_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<int64_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int64_t>
ParamServiceClientWrapper::i64_ret_string_typedef_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::string arg_param1,
    std::set<std::vector<std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>>>> arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int64_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int64_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i64_ret_string_typedef_param, channel_);
  try {
    client->i64_ret_string_typedef_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<int64_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int64_t>
ParamServiceClientWrapper::i64_ret_i32_i32_i32_i32_i32_param(
    apache::thrift::RpcOptions& rpcOptions,
    int32_t arg_param1,
    int32_t arg_param2,
    int32_t arg_param3,
    int32_t arg_param4,
    int32_t arg_param5) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int64_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int64_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_i64_ret_i32_i32_i32_i32_i32_param, channel_);
  try {
    client->i64_ret_i32_i32_i32_i32_i32_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2,
      arg_param3,
      arg_param4,
      arg_param5
    );
  } catch (...) {
    return folly::makeFuture<int64_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<double>
ParamServiceClientWrapper::double_ret_setstruct_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::set<::some::valid::ns::MyStruct> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<double>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<double>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_double_ret_setstruct_param, channel_);
  try {
    client->double_ret_setstruct_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<double>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::string>
ParamServiceClientWrapper::string_ret_string_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::string arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::string>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::string>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_string_ret_string_param, channel_);
  try {
    client->string_ret_string_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::string>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::string>
ParamServiceClientWrapper::binary_ret_binary_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::string arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::string>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::string>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_binary_ret_binary_param, channel_);
  try {
    client->binary_ret_binary_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::string>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::map<std::string,int64_t>>
ParamServiceClientWrapper::map_ret_bool_param(
    apache::thrift::RpcOptions& rpcOptions,
    bool arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::map<std::string,int64_t>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::map<std::string,int64_t>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_map_ret_bool_param, channel_);
  try {
    client->map_ret_bool_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::map<std::string,int64_t>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<bool>>
ParamServiceClientWrapper::list_ret_map_setlist_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::map<int32_t,std::vector<std::string>> arg_param1,
    std::vector<std::string> arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<bool>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<bool>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_list_ret_map_setlist_param, channel_);
  try {
    client->list_ret_map_setlist_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<std::vector<bool>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::map<std::set<std::vector<int32_t>>,std::map<std::vector<std::set<std::string>>,std::string>>>
ParamServiceClientWrapper::mapsetlistmapliststring_ret_listlistlist_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::vector<std::vector<std::vector<std::vector<int32_t>>>> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::map<std::set<std::vector<int32_t>>,std::map<std::vector<std::set<std::string>>,std::string>>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::map<std::set<std::vector<int32_t>>,std::map<std::vector<std::set<std::string>>,std::string>>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_mapsetlistmapliststring_ret_listlistlist_param, channel_);
  try {
    client->mapsetlistmapliststring_ret_listlistlist_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::map<std::set<std::vector<int32_t>>,std::map<std::vector<std::set<std::string>>,std::string>>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<int32_t>
ParamServiceClientWrapper::typedef_ret_i32_param(
    apache::thrift::RpcOptions& rpcOptions,
    int32_t arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<int32_t>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<int32_t>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_typedef_ret_i32_param, channel_);
  try {
    client->typedef_ret_i32_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<int32_t>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<int32_t>>
ParamServiceClientWrapper::listtypedef_ret_typedef_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::vector<std::map<::some::valid::ns::Empty,::some::valid::ns::MyStruct>> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<int32_t>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<int32_t>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_listtypedef_ret_typedef_param, channel_);
  try {
    client->listtypedef_ret_typedef_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::vector<int32_t>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::MyEnumA>
ParamServiceClientWrapper::enum_ret_double_param(
    apache::thrift::RpcOptions& rpcOptions,
    double arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::MyEnumA>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::MyEnumA>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_enum_ret_double_param, channel_);
  try {
    client->enum_ret_double_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::MyEnumA>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::MyEnumA>
ParamServiceClientWrapper::enum_ret_double_enum_param(
    apache::thrift::RpcOptions& rpcOptions,
    double arg_param1,
    ::some::valid::ns::MyEnumA arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::MyEnumA>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::MyEnumA>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_enum_ret_double_enum_param, channel_);
  try {
    client->enum_ret_double_enum_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::MyEnumA>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<::some::valid::ns::MyEnumA>>
ParamServiceClientWrapper::listenum_ret_map_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::map<std::string,int64_t> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<::some::valid::ns::MyEnumA>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<::some::valid::ns::MyEnumA>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_listenum_ret_map_param, channel_);
  try {
    client->listenum_ret_map_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::vector<::some::valid::ns::MyEnumA>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::MyStruct>
ParamServiceClientWrapper::struct_ret_i16_param(
    apache::thrift::RpcOptions& rpcOptions,
    int16_t arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::MyStruct>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::MyStruct>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_struct_ret_i16_param, channel_);
  try {
    client->struct_ret_i16_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::MyStruct>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::set<::some::valid::ns::MyStruct>>
ParamServiceClientWrapper::setstruct_ret_set_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::set<std::string> arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::set<::some::valid::ns::MyStruct>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::set<::some::valid::ns::MyStruct>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_setstruct_ret_set_param, channel_);
  try {
    client->setstruct_ret_set_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::set<::some::valid::ns::MyStruct>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<::some::valid::ns::ComplexUnion>
ParamServiceClientWrapper::union_ret_i32_i32_param(
    apache::thrift::RpcOptions& rpcOptions,
    int32_t arg_param1,
    int32_t arg_param2) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<::some::valid::ns::ComplexUnion>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<::some::valid::ns::ComplexUnion>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_union_ret_i32_i32_param, channel_);
  try {
    client->union_ret_i32_i32_param(
      rpcOptions,
      std::move(callback),
      arg_param1,
      arg_param2
    );
  } catch (...) {
    return folly::makeFuture<::some::valid::ns::ComplexUnion>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<std::vector<::some::valid::ns::ComplexUnion>>
ParamServiceClientWrapper::listunion_string_param(
    apache::thrift::RpcOptions& rpcOptions,
    std::string arg_param1) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<std::vector<::some::valid::ns::ComplexUnion>>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<std::vector<::some::valid::ns::ComplexUnion>>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_listunion_string_param, channel_);
  try {
    client->listunion_string_param(
      rpcOptions,
      std::move(callback),
      arg_param1
    );
  } catch (...) {
    return folly::makeFuture<std::vector<::some::valid::ns::ComplexUnion>>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

folly::Future<folly::Unit>
ParamServiceClientWrapper::annotatedParams(
    apache::thrift::RpcOptions& rpcOptions,
    ::some::valid::ns::containerStruct arg_no_annotation,
    std::set<int32_t> arg_opt_ref_type_shared,
    CppFakeI32 arg_base_type,
    folly::small_vector<int64_t, 8 > arg_list_type,
    folly::sorted_vector_set<std::string> arg_set_type,
    FakeMap arg_map_type,
    std::unordered_map<std::string, containerStruct> arg_map_struct_type,
    folly::IOBuf arg_iobuf_type,
    std::unique_ptr<folly::IOBuf> arg_iobuf_ptr,
    std::vector<int32_t> arg_list_i32_template,
    std::vector<std::string> arg_list_string_template,
    std::set<std::string> arg_set_template,
    std::map<int64_t,std::string> arg_map_template,
    std::list<int32_t> arg_typedef_list_template,
    std::deque<std::string> arg_typedef_deque_template,
    folly::sorted_vector_set<std::string> arg_typedef_set_template,
    folly::sorted_vector_map<int64_t,std::string> arg_typedef_map_template,
    folly::IOBuf arg_iobuf_type_val,
    std::unique_ptr<folly::IOBuf> arg_iobuf_ptr_val,
    ::some::valid::ns::containerStruct arg_struct_struct) {
  auto* client = static_cast<::some::valid::ns::ParamServiceAsyncClient*>(async_client_.get());
  using CallbackHelper = apache::thrift::detail::FutureCallbackHelper<folly::Unit>;
  folly::Promise<CallbackHelper::PromiseResult> _promise;
  auto _future = _promise.getFuture();
  auto callback = std::make_unique<::thrift::py3::FutureCallback<folly::Unit>>(
    std::move(_promise), rpcOptions, client->recv_wrapped_annotatedParams, channel_);
  try {
    client->annotatedParams(
      rpcOptions,
      std::move(callback),
      arg_no_annotation,
      arg_opt_ref_type_shared,
      arg_base_type,
      arg_list_type,
      arg_set_type,
      arg_map_type,
      arg_map_struct_type,
      arg_iobuf_type,
      arg_iobuf_ptr,
      arg_list_i32_template,
      arg_list_string_template,
      arg_set_template,
      arg_map_template,
      arg_typedef_list_template,
      arg_typedef_deque_template,
      arg_typedef_set_template,
      arg_typedef_map_template,
      arg_iobuf_type_val,
      arg_iobuf_ptr_val,
      arg_struct_struct
    );
  } catch (...) {
    return folly::makeFuture<folly::Unit>(folly::exception_wrapper(
      std::current_exception()
    ));
  }
  return std::move(_future).thenValue(CallbackHelper::extractResult);
}

} // namespace some
} // namespace valid
} // namespace ns
