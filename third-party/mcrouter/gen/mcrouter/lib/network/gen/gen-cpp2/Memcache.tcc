/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include "mcrouter/lib/network/gen/gen-cpp2/Memcache.h"

#include <thrift/lib/cpp2/gen/service_tcc.h>

namespace facebook { namespace memcache { namespace thrift {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGetRequest*>> Memcache_mcGet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGetReply*>> Memcache_mcGet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McSetRequest*>> Memcache_mcSet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McSetReply*>> Memcache_mcSet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McDeleteRequest*>> Memcache_mcDelete_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McDeleteReply*>> Memcache_mcDelete_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McLeaseGetRequest*>> Memcache_mcLeaseGet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McLeaseGetReply*>> Memcache_mcLeaseGet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McLeaseSetRequest*>> Memcache_mcLeaseSet_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McLeaseSetReply*>> Memcache_mcLeaseSet_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McAddRequest*>> Memcache_mcAdd_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McAddReply*>> Memcache_mcAdd_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McReplaceRequest*>> Memcache_mcReplace_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McReplaceReply*>> Memcache_mcReplace_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGetsRequest*>> Memcache_mcGets_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGetsReply*>> Memcache_mcGets_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McCasRequest*>> Memcache_mcCas_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McCasReply*>> Memcache_mcCas_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McIncrRequest*>> Memcache_mcIncr_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McIncrReply*>> Memcache_mcIncr_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McDecrRequest*>> Memcache_mcDecr_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McDecrReply*>> Memcache_mcDecr_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McMetagetRequest*>> Memcache_mcMetaget_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McMetagetReply*>> Memcache_mcMetaget_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McAppendRequest*>> Memcache_mcAppend_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McAppendReply*>> Memcache_mcAppend_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McPrependRequest*>> Memcache_mcPrepend_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McPrependReply*>> Memcache_mcPrepend_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McTouchRequest*>> Memcache_mcTouch_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McTouchReply*>> Memcache_mcTouch_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McFlushReRequest*>> Memcache_mcFlushRe_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McFlushReReply*>> Memcache_mcFlushRe_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McFlushAllRequest*>> Memcache_mcFlushAll_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McFlushAllReply*>> Memcache_mcFlushAll_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGatRequest*>> Memcache_mcGat_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGatReply*>> Memcache_mcGat_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGatsRequest*>> Memcache_mcGats_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McGatsReply*>> Memcache_mcGats_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, apache::thrift::protocol::T_STRUCT, facebook::memcache::McVersionRequest*>> Memcache_mcVersion_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, apache::thrift::protocol::T_STRUCT, facebook::memcache::McVersionReply*>> Memcache_mcVersion_presult;
template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcGet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcGet_pargs args;
  facebook::memcache::McGetRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcGet", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcGet");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McGetReply>>(std::move(req), std::move(ctxStack), return_mcGet<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcGet<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcGet(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcGet(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McGetReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcGet_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McGetReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcGet", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcGet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcGet");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcSet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcSet_pargs args;
  facebook::memcache::McSetRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcSet", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcSet");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McSetReply>>(std::move(req), std::move(ctxStack), return_mcSet<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcSet<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcSet(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcSet(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McSetReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcSet_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McSetReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcSet", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcSet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcSet");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcDelete(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcDelete_pargs args;
  facebook::memcache::McDeleteRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcDelete", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcDelete");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McDeleteReply>>(std::move(req), std::move(ctxStack), return_mcDelete<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcDelete<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcDelete(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcDelete(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McDeleteReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcDelete_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McDeleteReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcDelete", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcDelete(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcDelete");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcLeaseGet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcLeaseGet_pargs args;
  facebook::memcache::McLeaseGetRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcLeaseGet", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcLeaseGet");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McLeaseGetReply>>(std::move(req), std::move(ctxStack), return_mcLeaseGet<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcLeaseGet<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcLeaseGet(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcLeaseGet(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McLeaseGetReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcLeaseGet_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McLeaseGetReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcLeaseGet", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcLeaseGet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcLeaseGet");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcLeaseSet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcLeaseSet_pargs args;
  facebook::memcache::McLeaseSetRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcLeaseSet", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcLeaseSet");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McLeaseSetReply>>(std::move(req), std::move(ctxStack), return_mcLeaseSet<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcLeaseSet<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcLeaseSet(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcLeaseSet(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McLeaseSetReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcLeaseSet_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McLeaseSetReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcLeaseSet", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcLeaseSet(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcLeaseSet");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcAdd(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcAdd_pargs args;
  facebook::memcache::McAddRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcAdd", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcAdd");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McAddReply>>(std::move(req), std::move(ctxStack), return_mcAdd<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcAdd<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcAdd(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcAdd(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McAddReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcAdd_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McAddReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcAdd", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcAdd(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcAdd");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcReplace(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcReplace_pargs args;
  facebook::memcache::McReplaceRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcReplace", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcReplace");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McReplaceReply>>(std::move(req), std::move(ctxStack), return_mcReplace<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcReplace<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcReplace(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcReplace(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McReplaceReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcReplace_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McReplaceReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcReplace", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcReplace(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcReplace");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcGets(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcGets_pargs args;
  facebook::memcache::McGetsRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcGets", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcGets");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McGetsReply>>(std::move(req), std::move(ctxStack), return_mcGets<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcGets<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcGets(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcGets(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McGetsReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcGets_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McGetsReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcGets", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcGets(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcGets");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcCas(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcCas_pargs args;
  facebook::memcache::McCasRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcCas", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcCas");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McCasReply>>(std::move(req), std::move(ctxStack), return_mcCas<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcCas<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcCas(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcCas(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McCasReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcCas_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McCasReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcCas", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcCas(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcCas");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcIncr(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcIncr_pargs args;
  facebook::memcache::McIncrRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcIncr", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcIncr");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McIncrReply>>(std::move(req), std::move(ctxStack), return_mcIncr<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcIncr<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcIncr(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcIncr(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McIncrReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcIncr_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McIncrReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcIncr", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcIncr(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcIncr");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcDecr(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcDecr_pargs args;
  facebook::memcache::McDecrRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcDecr", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcDecr");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McDecrReply>>(std::move(req), std::move(ctxStack), return_mcDecr<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcDecr<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcDecr(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcDecr(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McDecrReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcDecr_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McDecrReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcDecr", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcDecr(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcDecr");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcMetaget(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcMetaget_pargs args;
  facebook::memcache::McMetagetRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcMetaget", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcMetaget");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McMetagetReply>>(std::move(req), std::move(ctxStack), return_mcMetaget<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcMetaget<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcMetaget(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcMetaget(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McMetagetReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcMetaget_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McMetagetReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcMetaget", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcMetaget(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcMetaget");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcAppend(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcAppend_pargs args;
  facebook::memcache::McAppendRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcAppend", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcAppend");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McAppendReply>>(std::move(req), std::move(ctxStack), return_mcAppend<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcAppend<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcAppend(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcAppend(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McAppendReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcAppend_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McAppendReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcAppend", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcAppend(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcAppend");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcPrepend(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcPrepend_pargs args;
  facebook::memcache::McPrependRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcPrepend", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcPrepend");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McPrependReply>>(std::move(req), std::move(ctxStack), return_mcPrepend<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcPrepend<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcPrepend(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcPrepend(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McPrependReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcPrepend_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McPrependReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcPrepend", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcPrepend(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcPrepend");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcTouch(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcTouch_pargs args;
  facebook::memcache::McTouchRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcTouch", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcTouch");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McTouchReply>>(std::move(req), std::move(ctxStack), return_mcTouch<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcTouch<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcTouch(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcTouch(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McTouchReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcTouch_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McTouchReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcTouch", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcTouch(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcTouch");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcFlushRe(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcFlushRe_pargs args;
  facebook::memcache::McFlushReRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcFlushRe", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcFlushRe");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McFlushReReply>>(std::move(req), std::move(ctxStack), return_mcFlushRe<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcFlushRe<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcFlushRe(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcFlushRe(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McFlushReReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcFlushRe_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McFlushReReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcFlushRe", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcFlushRe(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcFlushRe");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcFlushAll(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcFlushAll_pargs args;
  facebook::memcache::McFlushAllRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcFlushAll", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcFlushAll");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McFlushAllReply>>(std::move(req), std::move(ctxStack), return_mcFlushAll<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcFlushAll<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcFlushAll(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcFlushAll(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McFlushAllReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcFlushAll_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McFlushAllReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcFlushAll", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcFlushAll(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcFlushAll");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcGat(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcGat_pargs args;
  facebook::memcache::McGatRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcGat", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcGat");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McGatReply>>(std::move(req), std::move(ctxStack), return_mcGat<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcGat<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcGat(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcGat(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McGatReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcGat_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McGatReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcGat", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcGat(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcGat");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcGats(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcGats_pargs args;
  facebook::memcache::McGatsRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcGats", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcGats");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McGatsReply>>(std::move(req), std::move(ctxStack), return_mcGats<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcGats<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcGats(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcGats(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McGatsReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcGats_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McGatsReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcGats", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcGats(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcGats");
    return;
  }
}

template <typename ProtocolIn_, typename ProtocolOut_>
void MemcacheAsyncProcessor::process_mcVersion(std::unique_ptr<apache::thrift::ResponseChannelRequest> req, std::unique_ptr<folly::IOBuf> buf, apache::thrift::Cpp2RequestContext* ctx,folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  // make sure getConnectionContext is null
  // so async calls don't accidentally use it
  iface_->setConnectionContext(nullptr);
  Memcache_mcVersion_pargs args;
  facebook::memcache::McVersionRequest uarg_request;
  args.get<0>().value = &uarg_request;
  std::unique_ptr<apache::thrift::ContextStack> ctxStack(this->getContextStack(this->getServiceName(), "Memcache.mcVersion", ctx));
  try {
    folly::io::Cursor cursor(buf.get());
    cursor.skip(ctx->getMessageBeginSize());
    ProtocolIn_ iprot;
    iprot.setInput(cursor);
    deserializeRequest(args, buf.get(), &iprot, ctxStack.get());
  }
  catch (const std::exception& ex) {
    apache::thrift::detail::ap::process_handle_exn_deserialization<ProtocolOut_>(
        ex, std::move(req), ctx, eb, "mcVersion");
    return;
  }
  req->setStartedProcessing();
  auto callback = std::make_unique<apache::thrift::HandlerCallback<facebook::memcache::McVersionReply>>(std::move(req), std::move(ctxStack), return_mcVersion<ProtocolIn_,ProtocolOut_>, throw_wrapped_mcVersion<ProtocolIn_, ProtocolOut_>, ctx->getProtoSeqId(), eb, tm, ctx);
  ctx->setStartedProcessing();
  iface_->async_eb_mcVersion(std::move(callback), args.get<0>().ref());
}

template <class ProtocolIn_, class ProtocolOut_>
folly::IOBufQueue MemcacheAsyncProcessor::return_mcVersion(int32_t protoSeqId, apache::thrift::ContextStack* ctx, facebook::memcache::McVersionReply const& _return) {
  ProtocolOut_ prot;
  Memcache_mcVersion_presult result;
  result.get<0>().value = const_cast<facebook::memcache::McVersionReply*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("mcVersion", &prot, protoSeqId, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void MemcacheAsyncProcessor::throw_wrapped_mcVersion(std::unique_ptr<apache::thrift::ResponseChannelRequest> req,int32_t protoSeqId,apache::thrift::ContextStack* ctx,folly::exception_wrapper ew,apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    (void)protoSeqId;
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<ProtocolOut_>(
        ew, std::move(req), reqCtx, ctx, "mcVersion");
    return;
  }
}

}}} // facebook::memcache::thrift
namespace apache { namespace thrift {

}} // apache::thrift
