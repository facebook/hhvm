// @generated by Thrift for thrift/compiler/test/fixtures/patch/src/module.thrift
// This file is probably not the place you want to edit!


#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::redundant_closure, clippy::type_complexity)]

pub mod errors;

#[allow(unused_imports)]
pub(crate) use crate as types;

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyData {
    pub data1: ::std::string::String,
    pub data2: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyDataWithCustomDefault {
    pub data1: ::std::string::String,
    pub data2: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum InnerUnion {
    innerOption(::std::vec::Vec<::std::primitive::u8>),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Debug)]
pub enum MyUnion {
    option1(::std::string::String),
    option2(::std::primitive::i32),
    option3(crate::types::InnerUnion),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq)]
pub struct MyStruct {
    pub boolVal: ::std::primitive::bool,
    pub byteVal: ::std::primitive::i8,
    pub i16Val: ::std::primitive::i16,
    pub i32Val: ::std::primitive::i32,
    pub i64Val: ::std::primitive::i64,
    pub floatVal: ::std::primitive::f32,
    pub doubleVal: ::std::primitive::f64,
    pub stringVal: ::std::string::String,
    pub binaryVal: ::std::vec::Vec<::std::primitive::u8>,
    pub enumVal: crate::types::MyEnum,
    pub structVal: crate::types::MyData,
    pub unionVal: crate::types::MyUnion,
    pub lateStructVal: crate::types::LateDefStruct,
    pub optBoolVal: ::std::option::Option<::std::primitive::bool>,
    pub optByteVal: ::std::option::Option<::std::primitive::i8>,
    pub optI16Val: ::std::option::Option<::std::primitive::i16>,
    pub optI32Val: ::std::option::Option<::std::primitive::i32>,
    pub optI64Val: ::std::option::Option<::std::primitive::i64>,
    pub optFloatVal: ::std::option::Option<::std::primitive::f32>,
    pub optDoubleVal: ::std::option::Option<::std::primitive::f64>,
    pub optStringVal: ::std::option::Option<::std::string::String>,
    pub optBinaryVal: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub optEnumVal: ::std::option::Option<crate::types::MyEnum>,
    pub optStructVal: ::std::option::Option<crate::types::MyData>,
    pub optLateStructVal: ::std::option::Option<crate::types::LateDefStruct>,
    pub optListVal: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    pub optSetVal: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub optMapVal: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    pub listMap: ::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    pub mapMap: ::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    pub i32WithCustomDefault: ::std::primitive::i32,
    pub structWithCustomDefault: crate::types::MyDataWithCustomDefault,
    pub structWithFieldCustomDefault: crate::types::MyData,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LateDefStruct {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Recursive {
    pub nodes: ::std::collections::BTreeMap<::std::string::String, crate::types::Recursive>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Bar {
    pub r#loop: crate::types::Loop,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct Loop {
    pub bar: crate::types::Bar,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RefFields {
    pub unique: ::std::vec::Vec<::std::primitive::i32>,
    pub shared_const: ::std::vec::Vec<::std::primitive::i32>,
    pub shared_mustable: ::std::vec::Vec<::std::primitive::i32>,
    pub opt_unique: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_shared_const: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_shared_mustable: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_box: ::std::option::Option<::std::boxed::Box<::std::vec::Vec<::std::primitive::i32>>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::MyDataFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::MyDataEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::MyDataFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataFieldPatch {
    pub data1: patch__types::StringPatch,
    pub data2: patch__types::I32Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyDataEnsureStruct {
    pub data1: ::std::option::Option<::std::string::String>,
    pub data2: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataWithCustomDefaultPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyDataWithCustomDefault>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::MyDataWithCustomDefaultFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::MyDataWithCustomDefaultEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::MyDataWithCustomDefaultFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataWithCustomDefaultFieldPatch {
    pub data1: patch__types::StringPatch,
    pub data2: patch__types::I32Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyDataWithCustomDefaultEnsureStruct {
    pub data1: ::std::option::Option<::std::string::String>,
    pub data2: ::std::option::Option<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct InnerUnionPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::InnerUnion>>,
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::InnerUnionFieldPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: crate::types::InnerUnion,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::InnerUnionFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct InnerUnionFieldPatch {
    pub innerOption: patch__types::BinaryPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyUnionPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyUnion>>,
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyUnionFieldPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: crate::types::MyUnion,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyUnionFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyUnionFieldPatch {
    pub option1: patch__types::StringPatch,
    pub option2: patch__types::I32Patch,
    pub option3: crate::types::InnerUnionPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyStruct>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::MyStructFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::MyStructEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::MyStructFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyStructField10Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<crate::types::MyEnum>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyStructField23Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<crate::types::MyEnum>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyStructField26Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::primitive::i16>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::primitive::i16>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField27Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::collections::BTreeSet<::std::string::String>,
    #[doc = "Adds entries, if not already present. Applies fourth."]
    pub add: ::std::collections::BTreeSet<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField28Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::fbthrift::builtin_types::HashMap<::std::string::String, patch__types::StringPatch>,
    #[doc = "Add the given values, if the keys are not already present. Applies forth."]
    pub add: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::fbthrift::builtin_types::HashMap<::std::string::String, patch__types::StringPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::fbthrift::builtin_types::HashSet<::std::string::String>,
    #[doc = "Adds or replaces the given key/value pairs. Applies fifth."]
    pub put: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField29Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField30Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::fbthrift::builtin_types::HashMap<::std::string::String, crate::types::MyStructField30Patch1>,
    #[doc = "Add the given values, if the keys are not already present. Applies forth."]
    pub add: ::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::fbthrift::builtin_types::HashMap<::std::string::String, crate::types::MyStructField30Patch1>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::fbthrift::builtin_types::HashSet<::std::string::String>,
    #[doc = "Adds or replaces the given key/value pairs. Applies fifth."]
    pub put: ::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField30Patch1 {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::fbthrift::builtin_types::HashMap<::std::string::String, patch__types::I32Patch>,
    #[doc = "Add the given values, if the keys are not already present. Applies forth."]
    pub add: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::fbthrift::builtin_types::HashMap<::std::string::String, patch__types::I32Patch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::fbthrift::builtin_types::HashSet<::std::string::String>,
    #[doc = "Adds or replaces the given key/value pairs. Applies fifth."]
    pub put: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructFieldPatch {
    pub structWithCustomDefault: crate::types::MyDataWithCustomDefaultPatch,
    pub i32WithCustomDefault: patch__types::I32Patch,
    pub mapMap: crate::types::MyStructField30Patch,
    pub listMap: crate::types::MyStructField29Patch,
    pub optMapVal: crate::types::MyStructField28Patch,
    pub optSetVal: crate::types::MyStructField27Patch,
    pub optListVal: crate::types::MyStructField26Patch,
    pub optLateStructVal: crate::types::LateDefStructPatch,
    pub optStructVal: crate::types::MyDataPatch,
    pub optEnumVal: crate::types::MyStructField23Patch,
    pub optBinaryVal: patch__types::BinaryPatch,
    pub optStringVal: patch__types::StringPatch,
    pub optDoubleVal: patch__types::DoublePatch,
    pub optFloatVal: patch__types::FloatPatch,
    pub optI64Val: patch__types::I64Patch,
    pub optI32Val: patch__types::I32Patch,
    pub optI16Val: patch__types::I16Patch,
    pub optByteVal: patch__types::BytePatch,
    pub optBoolVal: patch__types::BoolPatch,
    pub lateStructVal: crate::types::LateDefStructPatch,
    pub unionVal: crate::types::MyUnionPatch,
    pub structVal: crate::types::MyDataPatch,
    pub enumVal: crate::types::MyStructField10Patch,
    pub binaryVal: patch__types::BinaryPatch,
    pub stringVal: patch__types::StringPatch,
    pub doubleVal: patch__types::DoublePatch,
    pub floatVal: patch__types::FloatPatch,
    pub i64Val: patch__types::I64Patch,
    pub i32Val: patch__types::I32Patch,
    pub i16Val: patch__types::I16Patch,
    pub byteVal: patch__types::BytePatch,
    pub boolVal: patch__types::BoolPatch,
    pub structWithFieldCustomDefault: crate::types::MyDataPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructEnsureStruct {
    pub structWithCustomDefault: ::std::option::Option<::std::boxed::Box<crate::types::MyDataWithCustomDefault>>,
    pub i32WithCustomDefault: ::std::option::Option<::std::primitive::i32>,
    pub mapMap: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>>,
    pub listMap: ::std::option::Option<::std::vec::Vec<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i32>>>,
    pub optMapVal: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    pub optSetVal: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub optListVal: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    pub optLateStructVal: ::std::option::Option<::std::boxed::Box<crate::types::LateDefStruct>>,
    pub optStructVal: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    pub optEnumVal: ::std::option::Option<crate::types::MyEnum>,
    pub optBinaryVal: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub optStringVal: ::std::option::Option<::std::string::String>,
    pub optDoubleVal: ::std::option::Option<::std::primitive::f64>,
    pub optFloatVal: ::std::option::Option<::std::primitive::f32>,
    pub optI64Val: ::std::option::Option<::std::primitive::i64>,
    pub optI32Val: ::std::option::Option<::std::primitive::i32>,
    pub optI16Val: ::std::option::Option<::std::primitive::i16>,
    pub optByteVal: ::std::option::Option<::std::primitive::i8>,
    pub optBoolVal: ::std::option::Option<::std::primitive::bool>,
    pub lateStructVal: ::std::option::Option<::std::boxed::Box<crate::types::LateDefStruct>>,
    pub unionVal: ::std::option::Option<::std::boxed::Box<crate::types::MyUnion>>,
    pub structVal: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    pub enumVal: ::std::option::Option<crate::types::MyEnum>,
    pub binaryVal: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub stringVal: ::std::option::Option<::std::string::String>,
    pub doubleVal: ::std::option::Option<::std::primitive::f64>,
    pub floatVal: ::std::option::Option<::std::primitive::f32>,
    pub i64Val: ::std::option::Option<::std::primitive::i64>,
    pub i32Val: ::std::option::Option<::std::primitive::i32>,
    pub i16Val: ::std::option::Option<::std::primitive::i16>,
    pub byteVal: ::std::option::Option<::std::primitive::i8>,
    pub boolVal: ::std::option::Option<::std::primitive::bool>,
    pub structWithFieldCustomDefault: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LateDefStructPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::LateDefStruct>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::LateDefStructFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::LateDefStructEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::LateDefStructFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LateDefStructFieldPatch {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct LateDefStructEnsureStruct {
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RecursivePatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::Recursive>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::RecursiveFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::RecursiveEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::RecursiveFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RecursiveField1Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, crate::types::Recursive>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RecursiveFieldPatch {
    pub nodes: crate::types::RecursiveField1Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RecursiveEnsureStruct {
    pub nodes: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, crate::types::Recursive>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BarPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::Bar>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::BarFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::BarEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::BarFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BarFieldPatch {
    pub r#loop: crate::types::LoopPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct BarEnsureStruct {
    pub r#loop: ::std::option::Option<::std::boxed::Box<crate::types::Loop>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct LoopPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::Loop>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RefFieldsPatch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::RefFields>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: ::std::boxed::Box<crate::types::RefFieldsFieldPatch>,
    #[doc = "Initialize fields, using the given defaults. Applies third."]
    pub ensure: ::std::boxed::Box<crate::types::RefFieldsEnsureStruct>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: ::std::boxed::Box<crate::types::RefFieldsFieldPatch>,
    #[doc = "Removes entries, if present. Applies third."]
    pub remove: ::std::boxed::Box<patch__types::FieldIdList>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RefFieldsField1Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::primitive::i32>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RefFieldsField4Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::primitive::i32>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RefFieldsField7Patch {
    #[doc = "Assigns to a (set) value.\n\nIf set, all other operations are ignored.\n\nNote: Optional and union fields must be set before assigned."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::primitive::i32>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::primitive::i32>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct RefFieldsFieldPatch {
    pub unique: crate::types::RefFieldsField1Patch,
    pub opt_unique: crate::types::RefFieldsField4Patch,
    pub opt_box: crate::types::RefFieldsField7Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RefFieldsEnsureStruct {
    pub unique: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub shared_const: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub shared_mustable: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_unique: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_shared_const: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_shared_mustable: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    pub opt_box: ::std::option::Option<::std::vec::Vec<::std::primitive::i32>>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct MyEnum(pub ::std::primitive::i32);

impl MyEnum {
    pub const MyValue0: Self = MyEnum(0i32);
}

impl ::fbthrift::ThriftEnum for MyEnum {
    fn enumerate() -> &'static [(Self, &'static str)] {
        &[
            (Self::MyValue0, "MyValue0"),
        ]
    }

    fn variants() -> &'static [&'static str] {
        &[
            "MyValue0",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::MyValue0,
        ]
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for MyEnum {
    fn default() -> Self {
        Self(0)
    }
}

impl<'a> ::std::convert::From<&'a MyEnum> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a MyEnum) -> Self {
        x.0
    }
}

impl ::std::convert::From<MyEnum> for ::std::primitive::i32 {
    #[inline]
    fn from(x: MyEnum) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for MyEnum {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for MyEnum {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("MyValue0", 0),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for MyEnum {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "MyEnum::{}", self)
    }
}

impl ::std::str::FromStr for MyEnum {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("MyValue0", 0),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "MyEnum").map(Self)
    }
}

impl ::fbthrift::GetTType for MyEnum {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl ::fbthrift::GetUri for self::MyEnum {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyEnum"
    }
}

impl<P> ::fbthrift::Serialize<P> for MyEnum
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for MyEnum
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(::anyhow::Context::context(p.read_i32(), "Expected a number indicating enum variant")?))
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyData {
    fn default() -> Self {
        Self {
            data1: ::std::default::Default::default(),
            data2: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyData")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyData {}
unsafe impl ::std::marker::Sync for self::MyData {}
impl ::std::marker::Unpin for self::MyData {}
impl ::std::panic::RefUnwindSafe for self::MyData {}
impl ::std::panic::UnwindSafe for self::MyData {}

impl ::fbthrift::GetTType for self::MyData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyData {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyData"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyData");
        p.write_field_begin("data1", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::I32, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyData")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_default(),
            data2: field_data2.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for MyData {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            1 => {
            },
            2 => {
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataWithCustomDefault {
    fn default() -> Self {
        Self {
            data1: "1".to_owned(),
            data2: 2,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataWithCustomDefault {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataWithCustomDefault")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataWithCustomDefault {}
unsafe impl ::std::marker::Sync for self::MyDataWithCustomDefault {}
impl ::std::marker::Unpin for self::MyDataWithCustomDefault {}
impl ::std::panic::RefUnwindSafe for self::MyDataWithCustomDefault {}
impl ::std::panic::UnwindSafe for self::MyDataWithCustomDefault {}

impl ::fbthrift::GetTType for self::MyDataWithCustomDefault {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataWithCustomDefault {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataWithCustomDefault"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataWithCustomDefault
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataWithCustomDefault");
        p.write_field_begin("data1", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataWithCustomDefault
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::I32, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataWithCustomDefault")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_else(|| "1".to_owned()),
            data2: field_data2.unwrap_or(2),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for MyDataWithCustomDefault {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            1 => {
            },
            2 => {
            },
            _ => {}
        }

        None
    }
}



impl ::std::default::Default for InnerUnion {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for InnerUnion {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnion {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnion"
    }
}

impl<P> ::fbthrift::Serialize<P> for InnerUnion
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnion");
        match self {
            Self::innerOption(inner) => {
                p.write_field_begin("innerOption", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for InnerUnion
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("innerOption", ::fbthrift::TType::String, 1),
        ];
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a InnerUnion")?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::String, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::innerOption(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ProtocolError::UnwantedExtraUnionField(
                    "InnerUnion".to_string(),
                    badty,
                    badid,
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

impl InnerUnion {
    /// Return current union variant name as a tuple of (Rust name, original name).
    pub fn variant_name(&self) -> Option<(&'static str, &'static str)> {
        match self {
            Self::innerOption(_) => Some(("innerOption", "innerOption")),
            Self::UnknownField(_) => None,
        }
    }
}

impl ::fbthrift::metadata::ThriftAnnotations for InnerUnion {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            1 => {
            },
            _ => {}
        }

        None
    }
}


impl ::std::default::Default for MyUnion {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for MyUnion {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnion {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnion"
    }
}

impl<P> ::fbthrift::Serialize<P> for MyUnion
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnion");
        match self {
            Self::option1(inner) => {
                p.write_field_begin("option1", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::option2(inner) => {
                p.write_field_begin("option2", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::option3(inner) => {
                p.write_field_begin("option3", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            Self::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for MyUnion
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("option1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("option2", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("option3", ::fbthrift::TType::Struct, 3),
        ];
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyUnion")?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::String, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::option1(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::option2(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(Self::option3(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ProtocolError::UnwantedExtraUnionField(
                    "MyUnion".to_string(),
                    badty,
                    badid,
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

impl MyUnion {
    /// Return current union variant name as a tuple of (Rust name, original name).
    pub fn variant_name(&self) -> Option<(&'static str, &'static str)> {
        match self {
            Self::option1(_) => Some(("option1", "option1")),
            Self::option2(_) => Some(("option2", "option2")),
            Self::option3(_) => Some(("option3", "option3")),
            Self::UnknownField(_) => None,
        }
    }
}

impl ::fbthrift::metadata::ThriftAnnotations for MyUnion {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            1 => {
            },
            2 => {
            },
            3 => {
            },
            _ => {}
        }

        None
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStruct {
    fn default() -> Self {
        Self {
            boolVal: ::std::default::Default::default(),
            byteVal: ::std::default::Default::default(),
            i16Val: ::std::default::Default::default(),
            i32Val: ::std::default::Default::default(),
            i64Val: ::std::default::Default::default(),
            floatVal: ::std::default::Default::default(),
            doubleVal: ::std::default::Default::default(),
            stringVal: ::std::default::Default::default(),
            binaryVal: ::std::default::Default::default(),
            enumVal: ::std::default::Default::default(),
            structVal: ::std::default::Default::default(),
            unionVal: ::std::default::Default::default(),
            lateStructVal: ::std::default::Default::default(),
            optBoolVal: ::std::option::Option::None,
            optByteVal: ::std::option::Option::None,
            optI16Val: ::std::option::Option::None,
            optI32Val: ::std::option::Option::None,
            optI64Val: ::std::option::Option::None,
            optFloatVal: ::std::option::Option::None,
            optDoubleVal: ::std::option::Option::None,
            optStringVal: ::std::option::Option::None,
            optBinaryVal: ::std::option::Option::None,
            optEnumVal: ::std::option::Option::None,
            optStructVal: ::std::option::Option::None,
            optLateStructVal: ::std::option::Option::None,
            optListVal: ::std::option::Option::None,
            optSetVal: ::std::option::Option::None,
            optMapVal: ::std::option::Option::None,
            listMap: ::std::default::Default::default(),
            mapMap: ::std::default::Default::default(),
            i32WithCustomDefault: 1,
            structWithCustomDefault: ::std::default::Default::default(),
            structWithFieldCustomDefault: crate::types::MyData {
                    data1: "1".to_owned(),
                    data2: 2,
                    ..::std::default::Default::default()
                },
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStruct")
            .field("boolVal", &self.boolVal)
            .field("byteVal", &self.byteVal)
            .field("i16Val", &self.i16Val)
            .field("i32Val", &self.i32Val)
            .field("i64Val", &self.i64Val)
            .field("floatVal", &self.floatVal)
            .field("doubleVal", &self.doubleVal)
            .field("stringVal", &self.stringVal)
            .field("binaryVal", &self.binaryVal)
            .field("enumVal", &self.enumVal)
            .field("structVal", &self.structVal)
            .field("unionVal", &self.unionVal)
            .field("lateStructVal", &self.lateStructVal)
            .field("optBoolVal", &self.optBoolVal)
            .field("optByteVal", &self.optByteVal)
            .field("optI16Val", &self.optI16Val)
            .field("optI32Val", &self.optI32Val)
            .field("optI64Val", &self.optI64Val)
            .field("optFloatVal", &self.optFloatVal)
            .field("optDoubleVal", &self.optDoubleVal)
            .field("optStringVal", &self.optStringVal)
            .field("optBinaryVal", &self.optBinaryVal)
            .field("optEnumVal", &self.optEnumVal)
            .field("optStructVal", &self.optStructVal)
            .field("optLateStructVal", &self.optLateStructVal)
            .field("optListVal", &self.optListVal)
            .field("optSetVal", &self.optSetVal)
            .field("optMapVal", &self.optMapVal)
            .field("listMap", &self.listMap)
            .field("mapMap", &self.mapMap)
            .field("i32WithCustomDefault", &self.i32WithCustomDefault)
            .field("structWithCustomDefault", &self.structWithCustomDefault)
            .field("structWithFieldCustomDefault", &self.structWithFieldCustomDefault)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStruct {}
unsafe impl ::std::marker::Sync for self::MyStruct {}
impl ::std::marker::Unpin for self::MyStruct {}
impl ::std::panic::RefUnwindSafe for self::MyStruct {}
impl ::std::panic::UnwindSafe for self::MyStruct {}

impl ::fbthrift::GetTType for self::MyStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStruct");
        p.write_field_begin("boolVal", ::fbthrift::TType::Bool, -1);
        ::fbthrift::Serialize::write(&self.boolVal, p);
        p.write_field_end();
        p.write_field_begin("byteVal", ::fbthrift::TType::Byte, -2);
        ::fbthrift::Serialize::write(&self.byteVal, p);
        p.write_field_end();
        p.write_field_begin("i16Val", ::fbthrift::TType::I16, -3);
        ::fbthrift::Serialize::write(&self.i16Val, p);
        p.write_field_end();
        p.write_field_begin("i32Val", ::fbthrift::TType::I32, -4);
        ::fbthrift::Serialize::write(&self.i32Val, p);
        p.write_field_end();
        p.write_field_begin("i64Val", ::fbthrift::TType::I64, -5);
        ::fbthrift::Serialize::write(&self.i64Val, p);
        p.write_field_end();
        p.write_field_begin("floatVal", ::fbthrift::TType::Float, -6);
        ::fbthrift::Serialize::write(&self.floatVal, p);
        p.write_field_end();
        p.write_field_begin("doubleVal", ::fbthrift::TType::Double, -7);
        ::fbthrift::Serialize::write(&self.doubleVal, p);
        p.write_field_end();
        p.write_field_begin("stringVal", ::fbthrift::TType::String, -8);
        ::fbthrift::Serialize::write(&self.stringVal, p);
        p.write_field_end();
        p.write_field_begin("binaryVal", ::fbthrift::TType::String, -9);
        ::fbthrift::Serialize::write(&self.binaryVal, p);
        p.write_field_end();
        p.write_field_begin("enumVal", ::fbthrift::TType::I32, -10);
        ::fbthrift::Serialize::write(&self.enumVal, p);
        p.write_field_end();
        p.write_field_begin("structVal", ::fbthrift::TType::Struct, -11);
        ::fbthrift::Serialize::write(&self.structVal, p);
        p.write_field_end();
        p.write_field_begin("unionVal", ::fbthrift::TType::Struct, -12);
        ::fbthrift::Serialize::write(&self.unionVal, p);
        p.write_field_end();
        p.write_field_begin("lateStructVal", ::fbthrift::TType::Struct, -13);
        ::fbthrift::Serialize::write(&self.lateStructVal, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.optBoolVal {
            p.write_field_begin("optBoolVal", ::fbthrift::TType::Bool, -14);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optByteVal {
            p.write_field_begin("optByteVal", ::fbthrift::TType::Byte, -15);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI16Val {
            p.write_field_begin("optI16Val", ::fbthrift::TType::I16, -16);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI32Val {
            p.write_field_begin("optI32Val", ::fbthrift::TType::I32, -17);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI64Val {
            p.write_field_begin("optI64Val", ::fbthrift::TType::I64, -18);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optFloatVal {
            p.write_field_begin("optFloatVal", ::fbthrift::TType::Float, -19);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optDoubleVal {
            p.write_field_begin("optDoubleVal", ::fbthrift::TType::Double, -20);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStringVal {
            p.write_field_begin("optStringVal", ::fbthrift::TType::String, -21);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optBinaryVal {
            p.write_field_begin("optBinaryVal", ::fbthrift::TType::String, -22);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optEnumVal {
            p.write_field_begin("optEnumVal", ::fbthrift::TType::I32, -23);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStructVal {
            p.write_field_begin("optStructVal", ::fbthrift::TType::Struct, -24);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optLateStructVal {
            p.write_field_begin("optLateStructVal", ::fbthrift::TType::Struct, -25);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optListVal {
            p.write_field_begin("optListVal", ::fbthrift::TType::List, -26);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optSetVal {
            p.write_field_begin("optSetVal", ::fbthrift::TType::Set, -27);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optMapVal {
            p.write_field_begin("optMapVal", ::fbthrift::TType::Map, -28);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("listMap", ::fbthrift::TType::List, -29);
        ::fbthrift::Serialize::write(&self.listMap, p);
        p.write_field_end();
        p.write_field_begin("mapMap", ::fbthrift::TType::Map, -30);
        ::fbthrift::Serialize::write(&self.mapMap, p);
        p.write_field_end();
        p.write_field_begin("i32WithCustomDefault", ::fbthrift::TType::I32, -31);
        ::fbthrift::Serialize::write(&self.i32WithCustomDefault, p);
        p.write_field_end();
        p.write_field_begin("structWithCustomDefault", ::fbthrift::TType::Struct, -32);
        ::fbthrift::Serialize::write(&self.structWithCustomDefault, p);
        p.write_field_end();
        p.write_field_begin("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.structWithFieldCustomDefault, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("binaryVal", ::fbthrift::TType::String, -9),
            ::fbthrift::Field::new("boolVal", ::fbthrift::TType::Bool, -1),
            ::fbthrift::Field::new("byteVal", ::fbthrift::TType::Byte, -2),
            ::fbthrift::Field::new("doubleVal", ::fbthrift::TType::Double, -7),
            ::fbthrift::Field::new("enumVal", ::fbthrift::TType::I32, -10),
            ::fbthrift::Field::new("floatVal", ::fbthrift::TType::Float, -6),
            ::fbthrift::Field::new("i16Val", ::fbthrift::TType::I16, -3),
            ::fbthrift::Field::new("i32Val", ::fbthrift::TType::I32, -4),
            ::fbthrift::Field::new("i32WithCustomDefault", ::fbthrift::TType::I32, -31),
            ::fbthrift::Field::new("i64Val", ::fbthrift::TType::I64, -5),
            ::fbthrift::Field::new("lateStructVal", ::fbthrift::TType::Struct, -13),
            ::fbthrift::Field::new("listMap", ::fbthrift::TType::List, -29),
            ::fbthrift::Field::new("mapMap", ::fbthrift::TType::Map, -30),
            ::fbthrift::Field::new("optBinaryVal", ::fbthrift::TType::String, -22),
            ::fbthrift::Field::new("optBoolVal", ::fbthrift::TType::Bool, -14),
            ::fbthrift::Field::new("optByteVal", ::fbthrift::TType::Byte, -15),
            ::fbthrift::Field::new("optDoubleVal", ::fbthrift::TType::Double, -20),
            ::fbthrift::Field::new("optEnumVal", ::fbthrift::TType::I32, -23),
            ::fbthrift::Field::new("optFloatVal", ::fbthrift::TType::Float, -19),
            ::fbthrift::Field::new("optI16Val", ::fbthrift::TType::I16, -16),
            ::fbthrift::Field::new("optI32Val", ::fbthrift::TType::I32, -17),
            ::fbthrift::Field::new("optI64Val", ::fbthrift::TType::I64, -18),
            ::fbthrift::Field::new("optLateStructVal", ::fbthrift::TType::Struct, -25),
            ::fbthrift::Field::new("optListVal", ::fbthrift::TType::List, -26),
            ::fbthrift::Field::new("optMapVal", ::fbthrift::TType::Map, -28),
            ::fbthrift::Field::new("optSetVal", ::fbthrift::TType::Set, -27),
            ::fbthrift::Field::new("optStringVal", ::fbthrift::TType::String, -21),
            ::fbthrift::Field::new("optStructVal", ::fbthrift::TType::Struct, -24),
            ::fbthrift::Field::new("stringVal", ::fbthrift::TType::String, -8),
            ::fbthrift::Field::new("structVal", ::fbthrift::TType::Struct, -11),
            ::fbthrift::Field::new("structWithCustomDefault", ::fbthrift::TType::Struct, -32),
            ::fbthrift::Field::new("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("unionVal", ::fbthrift::TType::Struct, -12),
        ];
        let mut field_boolVal = ::std::option::Option::None;
        let mut field_byteVal = ::std::option::Option::None;
        let mut field_i16Val = ::std::option::Option::None;
        let mut field_i32Val = ::std::option::Option::None;
        let mut field_i64Val = ::std::option::Option::None;
        let mut field_floatVal = ::std::option::Option::None;
        let mut field_doubleVal = ::std::option::Option::None;
        let mut field_stringVal = ::std::option::Option::None;
        let mut field_binaryVal = ::std::option::Option::None;
        let mut field_enumVal = ::std::option::Option::None;
        let mut field_structVal = ::std::option::Option::None;
        let mut field_unionVal = ::std::option::Option::None;
        let mut field_lateStructVal = ::std::option::Option::None;
        let mut field_optBoolVal = ::std::option::Option::None;
        let mut field_optByteVal = ::std::option::Option::None;
        let mut field_optI16Val = ::std::option::Option::None;
        let mut field_optI32Val = ::std::option::Option::None;
        let mut field_optI64Val = ::std::option::Option::None;
        let mut field_optFloatVal = ::std::option::Option::None;
        let mut field_optDoubleVal = ::std::option::Option::None;
        let mut field_optStringVal = ::std::option::Option::None;
        let mut field_optBinaryVal = ::std::option::Option::None;
        let mut field_optEnumVal = ::std::option::Option::None;
        let mut field_optStructVal = ::std::option::Option::None;
        let mut field_optLateStructVal = ::std::option::Option::None;
        let mut field_optListVal = ::std::option::Option::None;
        let mut field_optSetVal = ::std::option::Option::None;
        let mut field_optMapVal = ::std::option::Option::None;
        let mut field_listMap = ::std::option::Option::None;
        let mut field_mapMap = ::std::option::Option::None;
        let mut field_i32WithCustomDefault = ::std::option::Option::None;
        let mut field_structWithCustomDefault = ::std::option::Option::None;
        let mut field_structWithFieldCustomDefault = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, -1) => field_boolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, -2) => field_byteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, -3) => field_i16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -4) => field_i32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, -5) => field_i64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, -6) => field_floatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, -7) => field_doubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -8) => field_stringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -9) => field_binaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -10) => field_enumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -11) => field_structVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -12) => field_unionVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -13) => field_lateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, -14) => field_optBoolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, -15) => field_optByteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, -16) => field_optI16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -17) => field_optI32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, -18) => field_optI64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, -19) => field_optFloatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, -20) => field_optDoubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -21) => field_optStringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -22) => field_optBinaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -23) => field_optEnumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -24) => field_optStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -25) => field_optLateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, -26) => field_optListVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, -27) => field_optSetVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, -28) => field_optMapVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, -29) => field_listMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, -30) => field_mapMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -31) => field_i32WithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -32) => field_structWithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 1) => field_structWithFieldCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            boolVal: field_boolVal.unwrap_or_default(),
            byteVal: field_byteVal.unwrap_or_default(),
            i16Val: field_i16Val.unwrap_or_default(),
            i32Val: field_i32Val.unwrap_or_default(),
            i64Val: field_i64Val.unwrap_or_default(),
            floatVal: field_floatVal.unwrap_or_default(),
            doubleVal: field_doubleVal.unwrap_or_default(),
            stringVal: field_stringVal.unwrap_or_default(),
            binaryVal: field_binaryVal.unwrap_or_default(),
            enumVal: field_enumVal.unwrap_or_default(),
            structVal: field_structVal.unwrap_or_default(),
            unionVal: field_unionVal.unwrap_or_default(),
            lateStructVal: field_lateStructVal.unwrap_or_default(),
            optBoolVal: field_optBoolVal,
            optByteVal: field_optByteVal,
            optI16Val: field_optI16Val,
            optI32Val: field_optI32Val,
            optI64Val: field_optI64Val,
            optFloatVal: field_optFloatVal,
            optDoubleVal: field_optDoubleVal,
            optStringVal: field_optStringVal,
            optBinaryVal: field_optBinaryVal,
            optEnumVal: field_optEnumVal,
            optStructVal: field_optStructVal,
            optLateStructVal: field_optLateStructVal,
            optListVal: field_optListVal,
            optSetVal: field_optSetVal,
            optMapVal: field_optMapVal,
            listMap: field_listMap.unwrap_or_default(),
            mapMap: field_mapMap.unwrap_or_default(),
            i32WithCustomDefault: field_i32WithCustomDefault.unwrap_or(1),
            structWithCustomDefault: field_structWithCustomDefault.unwrap_or_default(),
            structWithFieldCustomDefault: field_structWithFieldCustomDefault.unwrap_or_else(|| crate::types::MyData {
                    data1: "1".to_owned(),
                    data2: 2,
                    ..::std::default::Default::default()
                }),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for MyStruct {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            -1 => {
            },
            -2 => {
            },
            -3 => {
            },
            -4 => {
            },
            -5 => {
            },
            -6 => {
            },
            -7 => {
            },
            -8 => {
            },
            -9 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Type>() {
                    let mut tmp = Some(cpp__types::Type {
                        name: "folly::IOBuf".to_owned(),
                        template: ::std::default::Default::default(),
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            -10 => {
            },
            -11 => {
            },
            -12 => {
            },
            -13 => {
            },
            -14 => {
            },
            -15 => {
            },
            -16 => {
            },
            -17 => {
            },
            -18 => {
            },
            -19 => {
            },
            -20 => {
            },
            -21 => {
            },
            -22 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Type>() {
                    let mut tmp = Some(cpp__types::Type {
                        name: "folly::IOBuf".to_owned(),
                        template: ::std::default::Default::default(),
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            -23 => {
            },
            -24 => {
            },
            -25 => {
            },
            -26 => {
            },
            -27 => {
            },
            -28 => {
            },
            -29 => {
            },
            -30 => {
            },
            -31 => {
            },
            -32 => {
            },
            1 => {
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LateDefStruct {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LateDefStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LateDefStruct")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LateDefStruct {}
unsafe impl ::std::marker::Sync for self::LateDefStruct {}
impl ::std::marker::Unpin for self::LateDefStruct {}
impl ::std::panic::RefUnwindSafe for self::LateDefStruct {}
impl ::std::panic::UnwindSafe for self::LateDefStruct {}

impl ::fbthrift::GetTType for self::LateDefStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::LateDefStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/LateDefStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::LateDefStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LateDefStruct");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LateDefStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a LateDefStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for LateDefStruct {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Recursive {
    fn default() -> Self {
        Self {
            nodes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Recursive {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Recursive")
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Recursive {}
unsafe impl ::std::marker::Sync for self::Recursive {}
impl ::std::marker::Unpin for self::Recursive {}
impl ::std::panic::RefUnwindSafe for self::Recursive {}
impl ::std::panic::UnwindSafe for self::Recursive {}

impl ::fbthrift::GetTType for self::Recursive {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::Recursive {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/Recursive"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::Recursive
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Recursive");
        p.write_field_begin("nodes", ::fbthrift::TType::Map, -1);
        ::fbthrift::Serialize::write(&self.nodes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Recursive
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::Map, -1),
        ];
        let mut field_nodes = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Recursive")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, -1) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            nodes: field_nodes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for Recursive {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            -1 => {

                if type_id == ::std::any::TypeId::of::<patch__types::AssignOnlyPatch>() {
                    let mut tmp = Some(patch__types::AssignOnlyPatch {
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }

                if let Some(r) = <patch__types::AssignOnlyPatch as ::fbthrift::metadata::ThriftAnnotations>::get_structured_annotation::<T>() {
                    return Some(r);
                }
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Bar {
    fn default() -> Self {
        Self {
            r#loop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Bar {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Bar")
            .field("r#loop", &self.r#loop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Bar {}
unsafe impl ::std::marker::Sync for self::Bar {}
impl ::std::marker::Unpin for self::Bar {}
impl ::std::panic::RefUnwindSafe for self::Bar {}
impl ::std::panic::UnwindSafe for self::Bar {}

impl ::fbthrift::GetTType for self::Bar {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::Bar {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/Bar"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::Bar
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Bar");
        p.write_field_begin("loop", ::fbthrift::TType::Struct, -1);
        ::fbthrift::Serialize::write(&self.r#loop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Bar
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("loop", ::fbthrift::TType::Struct, -1),
        ];
        let mut field_loop = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Bar")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -1) => field_loop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#loop: field_loop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for Bar {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            -1 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::Unique,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::Loop {
    fn default() -> Self {
        Self {
            bar: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::Loop {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("Loop")
            .field("bar", &self.bar)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::Loop {}
unsafe impl ::std::marker::Sync for self::Loop {}
impl ::std::marker::Unpin for self::Loop {}
impl ::std::panic::RefUnwindSafe for self::Loop {}
impl ::std::panic::UnwindSafe for self::Loop {}

impl ::fbthrift::GetTType for self::Loop {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::Loop {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/Loop"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::Loop
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("Loop");
        p.write_field_begin("bar", ::fbthrift::TType::Struct, -1);
        ::fbthrift::Serialize::write(&self.bar, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::Loop
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("bar", ::fbthrift::TType::Struct, -1),
        ];
        let mut field_bar = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Loop")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -1) => field_bar = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            bar: field_bar.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for Loop {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        if type_id == ::std::any::TypeId::of::<patch__types::AssignOnlyPatch>() {
            let mut tmp = Some(patch__types::AssignOnlyPatch {
                ..::std::default::Default::default()
            });
            let r: &mut dyn ::std::any::Any = &mut tmp;
            let r: &mut Option<T> = r.downcast_mut().unwrap();
            return r.take();
        }

        if let Some(r) = <patch__types::AssignOnlyPatch as ::fbthrift::metadata::ThriftAnnotations>::get_structured_annotation::<T>() {
            return Some(r);
        }

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            -1 => {

                if type_id == ::std::any::TypeId::of::<patch__types::AssignOnlyPatch>() {
                    let mut tmp = Some(patch__types::AssignOnlyPatch {
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }

                if let Some(r) = <patch__types::AssignOnlyPatch as ::fbthrift::metadata::ThriftAnnotations>::get_structured_annotation::<T>() {
                    return Some(r);
                }
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFields {
    fn default() -> Self {
        Self {
            unique: ::std::default::Default::default(),
            shared_const: ::std::default::Default::default(),
            shared_mustable: ::std::default::Default::default(),
            opt_unique: ::std::option::Option::None,
            opt_shared_const: ::std::option::Option::None,
            opt_shared_mustable: ::std::option::Option::None,
            opt_box: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFields {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFields")
            .field("unique", &self.unique)
            .field("shared_const", &self.shared_const)
            .field("shared_mustable", &self.shared_mustable)
            .field("opt_unique", &self.opt_unique)
            .field("opt_shared_const", &self.opt_shared_const)
            .field("opt_shared_mustable", &self.opt_shared_mustable)
            .field("opt_box", &self.opt_box)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFields {}
unsafe impl ::std::marker::Sync for self::RefFields {}
impl ::std::marker::Unpin for self::RefFields {}
impl ::std::panic::RefUnwindSafe for self::RefFields {}
impl ::std::panic::UnwindSafe for self::RefFields {}

impl ::fbthrift::GetTType for self::RefFields {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFields {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFields"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFields
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFields");
        p.write_field_begin("unique", ::fbthrift::TType::List, 1);
        ::fbthrift::Serialize::write(&self.unique, p);
        p.write_field_end();
        p.write_field_begin("shared_const", ::fbthrift::TType::List, 2);
        ::fbthrift::Serialize::write(&self.shared_const, p);
        p.write_field_end();
        p.write_field_begin("shared_mustable", ::fbthrift::TType::List, 3);
        ::fbthrift::Serialize::write(&self.shared_mustable, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.opt_unique {
            p.write_field_begin("opt_unique", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_shared_const {
            p.write_field_begin("opt_shared_const", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_shared_mustable {
            p.write_field_begin("opt_shared_mustable", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_box {
            p.write_field_begin("opt_box", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFields
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("opt_box", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("opt_shared_const", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("opt_shared_mustable", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("opt_unique", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("shared_const", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("shared_mustable", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("unique", ::fbthrift::TType::List, 1),
        ];
        let mut field_unique = ::std::option::Option::None;
        let mut field_shared_const = ::std::option::Option::None;
        let mut field_shared_mustable = ::std::option::Option::None;
        let mut field_opt_unique = ::std::option::Option::None;
        let mut field_opt_shared_const = ::std::option::Option::None;
        let mut field_opt_shared_mustable = ::std::option::Option::None;
        let mut field_opt_box = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFields")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_shared_const = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_shared_mustable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_opt_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_opt_shared_const = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_opt_shared_mustable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_opt_box = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            unique: field_unique.unwrap_or_default(),
            shared_const: field_shared_const.unwrap_or_default(),
            shared_mustable: field_shared_mustable.unwrap_or_default(),
            opt_unique: field_opt_unique,
            opt_shared_const: field_opt_shared_const,
            opt_shared_mustable: field_opt_shared_mustable,
            opt_box: field_opt_box,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


impl ::fbthrift::metadata::ThriftAnnotations for RefFields {
    fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        None
    }

    fn get_field_structured_annotation<T: Sized + 'static>(field_id: i16) -> ::std::option::Option<T> {
        #[allow(unused_variables)]
        let type_id = ::std::any::TypeId::of::<T>();

        #[allow(clippy::match_single_binding)]
        match field_id {
            1 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::Unique,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            2 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::Shared,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            3 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::SharedMutable,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            4 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::Unique,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            5 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::Shared,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            6 => {

                if type_id == ::std::any::TypeId::of::<cpp__types::Ref>() {
                    let mut tmp = Some(cpp__types::Ref {
                        r#type: cpp__types::RefType::SharedMutable,
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            7 => {

                if type_id == ::std::any::TypeId::of::<thrift__types::Box>() {
                    let mut tmp = Some(thrift__types::Box {
                        ..::std::default::Default::default()
                    });
                    let r: &mut dyn ::std::any::Any = &mut tmp;
                    let r: &mut Option<T> = r.downcast_mut().unwrap();
                    return r.take();
                }
            },
            _ => {}
        }

        None
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataPatch {}
unsafe impl ::std::marker::Sync for self::MyDataPatch {}
impl ::std::marker::Unpin for self::MyDataPatch {}
impl ::std::panic::RefUnwindSafe for self::MyDataPatch {}
impl ::std::panic::UnwindSafe for self::MyDataPatch {}

impl ::fbthrift::GetTType for self::MyDataPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataFieldPatch {
    fn default() -> Self {
        Self {
            data1: ::std::default::Default::default(),
            data2: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataFieldPatch")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyDataFieldPatch {}
impl ::std::marker::Unpin for self::MyDataFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::MyDataFieldPatch {}
impl ::std::panic::UnwindSafe for self::MyDataFieldPatch {}

impl ::fbthrift::GetTType for self::MyDataFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataFieldPatch");
        p.write_field_begin("data1", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_default(),
            data2: field_data2.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataEnsureStruct {
    fn default() -> Self {
        Self {
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataEnsureStruct")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataEnsureStruct {}
unsafe impl ::std::marker::Sync for self::MyDataEnsureStruct {}
impl ::std::marker::Unpin for self::MyDataEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::MyDataEnsureStruct {}
impl ::std::panic::UnwindSafe for self::MyDataEnsureStruct {}

impl ::fbthrift::GetTType for self::MyDataEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.data1 {
            p.write_field_begin("data1", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.data2 {
            p.write_field_begin("data2", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::I32, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1,
            data2: field_data2,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataWithCustomDefaultPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataWithCustomDefaultPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataWithCustomDefaultPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataWithCustomDefaultPatch {}
unsafe impl ::std::marker::Sync for self::MyDataWithCustomDefaultPatch {}
impl ::std::marker::Unpin for self::MyDataWithCustomDefaultPatch {}
impl ::std::panic::RefUnwindSafe for self::MyDataWithCustomDefaultPatch {}
impl ::std::panic::UnwindSafe for self::MyDataWithCustomDefaultPatch {}

impl ::fbthrift::GetTType for self::MyDataWithCustomDefaultPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataWithCustomDefaultPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataWithCustomDefaultPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataWithCustomDefaultPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataWithCustomDefaultPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataWithCustomDefaultPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataWithCustomDefaultPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataWithCustomDefaultFieldPatch {
    fn default() -> Self {
        Self {
            data1: ::std::default::Default::default(),
            data2: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataWithCustomDefaultFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataWithCustomDefaultFieldPatch")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataWithCustomDefaultFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyDataWithCustomDefaultFieldPatch {}
impl ::std::marker::Unpin for self::MyDataWithCustomDefaultFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::MyDataWithCustomDefaultFieldPatch {}
impl ::std::panic::UnwindSafe for self::MyDataWithCustomDefaultFieldPatch {}

impl ::fbthrift::GetTType for self::MyDataWithCustomDefaultFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataWithCustomDefaultFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataWithCustomDefaultFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataWithCustomDefaultFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataWithCustomDefaultFieldPatch");
        p.write_field_begin("data1", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataWithCustomDefaultFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataWithCustomDefaultFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_default(),
            data2: field_data2.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataWithCustomDefaultEnsureStruct {
    fn default() -> Self {
        Self {
            data1: ::std::option::Option::None,
            data2: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataWithCustomDefaultEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataWithCustomDefaultEnsureStruct")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataWithCustomDefaultEnsureStruct {}
unsafe impl ::std::marker::Sync for self::MyDataWithCustomDefaultEnsureStruct {}
impl ::std::marker::Unpin for self::MyDataWithCustomDefaultEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::MyDataWithCustomDefaultEnsureStruct {}
impl ::std::panic::UnwindSafe for self::MyDataWithCustomDefaultEnsureStruct {}

impl ::fbthrift::GetTType for self::MyDataWithCustomDefaultEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataWithCustomDefaultEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataWithCustomDefaultEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataWithCustomDefaultEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataWithCustomDefaultEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.data1 {
            p.write_field_begin("data1", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.data2 {
            p.write_field_begin("data2", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataWithCustomDefaultEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::I32, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyDataWithCustomDefaultEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1,
            data2: field_data2,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::InnerUnionPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::InnerUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("InnerUnionPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::InnerUnionPatch {}
unsafe impl ::std::marker::Sync for self::InnerUnionPatch {}
impl ::std::marker::Unpin for self::InnerUnionPatch {}
impl ::std::panic::RefUnwindSafe for self::InnerUnionPatch {}
impl ::std::panic::UnwindSafe for self::InnerUnionPatch {}

impl ::fbthrift::GetTType for self::InnerUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::InnerUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnionPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::InnerUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a InnerUnionPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::InnerUnionFieldPatch {
    fn default() -> Self {
        Self {
            innerOption: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::InnerUnionFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("InnerUnionFieldPatch")
            .field("innerOption", &self.innerOption)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::InnerUnionFieldPatch {}
unsafe impl ::std::marker::Sync for self::InnerUnionFieldPatch {}
impl ::std::marker::Unpin for self::InnerUnionFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::InnerUnionFieldPatch {}
impl ::std::panic::UnwindSafe for self::InnerUnionFieldPatch {}

impl ::fbthrift::GetTType for self::InnerUnionFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnionFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnionFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::InnerUnionFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnionFieldPatch");
        p.write_field_begin("innerOption", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.innerOption, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::InnerUnionFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("innerOption", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_innerOption = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a InnerUnionFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_innerOption = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            innerOption: field_innerOption.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyUnionPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyUnionPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyUnionPatch {}
unsafe impl ::std::marker::Sync for self::MyUnionPatch {}
impl ::std::marker::Unpin for self::MyUnionPatch {}
impl ::std::panic::RefUnwindSafe for self::MyUnionPatch {}
impl ::std::panic::UnwindSafe for self::MyUnionPatch {}

impl ::fbthrift::GetTType for self::MyUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnionPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyUnionPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyUnionFieldPatch {
    fn default() -> Self {
        Self {
            option1: ::std::default::Default::default(),
            option2: ::std::default::Default::default(),
            option3: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyUnionFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyUnionFieldPatch")
            .field("option1", &self.option1)
            .field("option2", &self.option2)
            .field("option3", &self.option3)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyUnionFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyUnionFieldPatch {}
impl ::std::marker::Unpin for self::MyUnionFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::MyUnionFieldPatch {}
impl ::std::panic::UnwindSafe for self::MyUnionFieldPatch {}

impl ::fbthrift::GetTType for self::MyUnionFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnionFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnionFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyUnionFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnionFieldPatch");
        p.write_field_begin("option1", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.option1, p);
        p.write_field_end();
        p.write_field_begin("option2", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.option2, p);
        p.write_field_end();
        p.write_field_begin("option3", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.option3, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyUnionFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("option1", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("option2", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("option3", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_option1 = ::std::option::Option::None;
        let mut field_option2 = ::std::option::Option::None;
        let mut field_option3 = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyUnionFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_option1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_option2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_option3 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            option1: field_option1.unwrap_or_default(),
            option2: field_option2.unwrap_or_default(),
            option3: field_option3.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructPatch {}
unsafe impl ::std::marker::Sync for self::MyStructPatch {}
impl ::std::marker::Unpin for self::MyStructPatch {}
impl ::std::panic::RefUnwindSafe for self::MyStructPatch {}
impl ::std::panic::UnwindSafe for self::MyStructPatch {}

impl ::fbthrift::GetTType for self::MyStructPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField10Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField10Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField10Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField10Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField10Patch {}
impl ::std::marker::Unpin for self::MyStructField10Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField10Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField10Patch {}

impl ::fbthrift::GetTType for self::MyStructField10Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField10Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField10Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField10Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField10Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField10Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField10Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField23Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField23Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField23Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField23Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField23Patch {}
impl ::std::marker::Unpin for self::MyStructField23Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField23Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField23Patch {}

impl ::fbthrift::GetTType for self::MyStructField23Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField23Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField23Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField23Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField23Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField23Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::I32, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField23Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField26Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField26Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField26Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField26Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField26Patch {}
impl ::std::marker::Unpin for self::MyStructField26Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField26Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField26Patch {}

impl ::fbthrift::GetTType for self::MyStructField26Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField26Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField26Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField26Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField26Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField26Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField26Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField27Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField27Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField27Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("remove", &self.remove)
            .field("add", &self.add)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField27Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField27Patch {}
impl ::std::marker::Unpin for self::MyStructField27Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField27Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField27Patch {}

impl ::fbthrift::GetTType for self::MyStructField27Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField27Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField27Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField27Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField27Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::Set, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Set, 8);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField27Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Set, 8),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Set, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::Set, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField27Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Set, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 8) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField28Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            put: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField28Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField28Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("add", &self.add)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .field("put", &self.put)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField28Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField28Patch {}
impl ::std::marker::Unpin for self::MyStructField28Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField28Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField28Patch {}

impl ::fbthrift::GetTType for self::MyStructField28Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField28Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField28Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField28Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField28Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::Set, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_begin("put", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.put, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField28Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("put", ::fbthrift::TType::Map, 9),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::Set, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let mut field_put = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField28Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_put = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            put: field_put.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField29Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField29Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField29Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField29Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField29Patch {}
impl ::std::marker::Unpin for self::MyStructField29Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField29Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField29Patch {}

impl ::fbthrift::GetTType for self::MyStructField29Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField29Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField29Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField29Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField29Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField29Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField29Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField30Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            put: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField30Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField30Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("add", &self.add)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .field("put", &self.put)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField30Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField30Patch {}
impl ::std::marker::Unpin for self::MyStructField30Patch {}
impl ::std::panic::RefUnwindSafe for self::MyStructField30Patch {}
impl ::std::panic::UnwindSafe for self::MyStructField30Patch {}

impl ::fbthrift::GetTType for self::MyStructField30Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField30Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField30Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField30Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField30Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::Set, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_begin("put", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.put, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField30Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("put", ::fbthrift::TType::Map, 9),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::Set, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let mut field_put = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField30Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_put = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            put: field_put.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField30Patch1 {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            put: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField30Patch1 {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField30Patch1")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("add", &self.add)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .field("put", &self.put)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField30Patch1 {}
unsafe impl ::std::marker::Sync for self::MyStructField30Patch1 {}
impl ::std::marker::Unpin for self::MyStructField30Patch1 {}
impl ::std::panic::RefUnwindSafe for self::MyStructField30Patch1 {}
impl ::std::panic::UnwindSafe for self::MyStructField30Patch1 {}

impl ::fbthrift::GetTType for self::MyStructField30Patch1 {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField30Patch1 {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField30Patch1"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField30Patch1
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField30Patch1");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Map, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Map, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::Set, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_begin("put", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.put, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField30Patch1
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Map, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Map, 3),
            ::fbthrift::Field::new("put", ::fbthrift::TType::Map, 9),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::Set, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let mut field_put = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructField30Patch1")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_put = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            put: field_put.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructFieldPatch {
    fn default() -> Self {
        Self {
            structWithCustomDefault: ::std::default::Default::default(),
            i32WithCustomDefault: ::std::default::Default::default(),
            mapMap: ::std::default::Default::default(),
            listMap: ::std::default::Default::default(),
            optMapVal: ::std::default::Default::default(),
            optSetVal: ::std::default::Default::default(),
            optListVal: ::std::default::Default::default(),
            optLateStructVal: ::std::default::Default::default(),
            optStructVal: ::std::default::Default::default(),
            optEnumVal: ::std::default::Default::default(),
            optBinaryVal: ::std::default::Default::default(),
            optStringVal: ::std::default::Default::default(),
            optDoubleVal: ::std::default::Default::default(),
            optFloatVal: ::std::default::Default::default(),
            optI64Val: ::std::default::Default::default(),
            optI32Val: ::std::default::Default::default(),
            optI16Val: ::std::default::Default::default(),
            optByteVal: ::std::default::Default::default(),
            optBoolVal: ::std::default::Default::default(),
            lateStructVal: ::std::default::Default::default(),
            unionVal: ::std::default::Default::default(),
            structVal: ::std::default::Default::default(),
            enumVal: ::std::default::Default::default(),
            binaryVal: ::std::default::Default::default(),
            stringVal: ::std::default::Default::default(),
            doubleVal: ::std::default::Default::default(),
            floatVal: ::std::default::Default::default(),
            i64Val: ::std::default::Default::default(),
            i32Val: ::std::default::Default::default(),
            i16Val: ::std::default::Default::default(),
            byteVal: ::std::default::Default::default(),
            boolVal: ::std::default::Default::default(),
            structWithFieldCustomDefault: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructFieldPatch")
            .field("structWithCustomDefault", &self.structWithCustomDefault)
            .field("i32WithCustomDefault", &self.i32WithCustomDefault)
            .field("mapMap", &self.mapMap)
            .field("listMap", &self.listMap)
            .field("optMapVal", &self.optMapVal)
            .field("optSetVal", &self.optSetVal)
            .field("optListVal", &self.optListVal)
            .field("optLateStructVal", &self.optLateStructVal)
            .field("optStructVal", &self.optStructVal)
            .field("optEnumVal", &self.optEnumVal)
            .field("optBinaryVal", &self.optBinaryVal)
            .field("optStringVal", &self.optStringVal)
            .field("optDoubleVal", &self.optDoubleVal)
            .field("optFloatVal", &self.optFloatVal)
            .field("optI64Val", &self.optI64Val)
            .field("optI32Val", &self.optI32Val)
            .field("optI16Val", &self.optI16Val)
            .field("optByteVal", &self.optByteVal)
            .field("optBoolVal", &self.optBoolVal)
            .field("lateStructVal", &self.lateStructVal)
            .field("unionVal", &self.unionVal)
            .field("structVal", &self.structVal)
            .field("enumVal", &self.enumVal)
            .field("binaryVal", &self.binaryVal)
            .field("stringVal", &self.stringVal)
            .field("doubleVal", &self.doubleVal)
            .field("floatVal", &self.floatVal)
            .field("i64Val", &self.i64Val)
            .field("i32Val", &self.i32Val)
            .field("i16Val", &self.i16Val)
            .field("byteVal", &self.byteVal)
            .field("boolVal", &self.boolVal)
            .field("structWithFieldCustomDefault", &self.structWithFieldCustomDefault)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyStructFieldPatch {}
impl ::std::marker::Unpin for self::MyStructFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::MyStructFieldPatch {}
impl ::std::panic::UnwindSafe for self::MyStructFieldPatch {}

impl ::fbthrift::GetTType for self::MyStructFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructFieldPatch");
        p.write_field_begin("structWithCustomDefault", ::fbthrift::TType::Struct, -32);
        ::fbthrift::Serialize::write(&self.structWithCustomDefault, p);
        p.write_field_end();
        p.write_field_begin("i32WithCustomDefault", ::fbthrift::TType::Struct, -31);
        ::fbthrift::Serialize::write(&self.i32WithCustomDefault, p);
        p.write_field_end();
        p.write_field_begin("mapMap", ::fbthrift::TType::Struct, -30);
        ::fbthrift::Serialize::write(&self.mapMap, p);
        p.write_field_end();
        p.write_field_begin("listMap", ::fbthrift::TType::Struct, -29);
        ::fbthrift::Serialize::write(&self.listMap, p);
        p.write_field_end();
        p.write_field_begin("optMapVal", ::fbthrift::TType::Struct, -28);
        ::fbthrift::Serialize::write(&self.optMapVal, p);
        p.write_field_end();
        p.write_field_begin("optSetVal", ::fbthrift::TType::Struct, -27);
        ::fbthrift::Serialize::write(&self.optSetVal, p);
        p.write_field_end();
        p.write_field_begin("optListVal", ::fbthrift::TType::Struct, -26);
        ::fbthrift::Serialize::write(&self.optListVal, p);
        p.write_field_end();
        p.write_field_begin("optLateStructVal", ::fbthrift::TType::Struct, -25);
        ::fbthrift::Serialize::write(&self.optLateStructVal, p);
        p.write_field_end();
        p.write_field_begin("optStructVal", ::fbthrift::TType::Struct, -24);
        ::fbthrift::Serialize::write(&self.optStructVal, p);
        p.write_field_end();
        p.write_field_begin("optEnumVal", ::fbthrift::TType::Struct, -23);
        ::fbthrift::Serialize::write(&self.optEnumVal, p);
        p.write_field_end();
        p.write_field_begin("optBinaryVal", ::fbthrift::TType::Struct, -22);
        ::fbthrift::Serialize::write(&self.optBinaryVal, p);
        p.write_field_end();
        p.write_field_begin("optStringVal", ::fbthrift::TType::Struct, -21);
        ::fbthrift::Serialize::write(&self.optStringVal, p);
        p.write_field_end();
        p.write_field_begin("optDoubleVal", ::fbthrift::TType::Struct, -20);
        ::fbthrift::Serialize::write(&self.optDoubleVal, p);
        p.write_field_end();
        p.write_field_begin("optFloatVal", ::fbthrift::TType::Struct, -19);
        ::fbthrift::Serialize::write(&self.optFloatVal, p);
        p.write_field_end();
        p.write_field_begin("optI64Val", ::fbthrift::TType::Struct, -18);
        ::fbthrift::Serialize::write(&self.optI64Val, p);
        p.write_field_end();
        p.write_field_begin("optI32Val", ::fbthrift::TType::Struct, -17);
        ::fbthrift::Serialize::write(&self.optI32Val, p);
        p.write_field_end();
        p.write_field_begin("optI16Val", ::fbthrift::TType::Struct, -16);
        ::fbthrift::Serialize::write(&self.optI16Val, p);
        p.write_field_end();
        p.write_field_begin("optByteVal", ::fbthrift::TType::Struct, -15);
        ::fbthrift::Serialize::write(&self.optByteVal, p);
        p.write_field_end();
        p.write_field_begin("optBoolVal", ::fbthrift::TType::Struct, -14);
        ::fbthrift::Serialize::write(&self.optBoolVal, p);
        p.write_field_end();
        p.write_field_begin("lateStructVal", ::fbthrift::TType::Struct, -13);
        ::fbthrift::Serialize::write(&self.lateStructVal, p);
        p.write_field_end();
        p.write_field_begin("unionVal", ::fbthrift::TType::Struct, -12);
        ::fbthrift::Serialize::write(&self.unionVal, p);
        p.write_field_end();
        p.write_field_begin("structVal", ::fbthrift::TType::Struct, -11);
        ::fbthrift::Serialize::write(&self.structVal, p);
        p.write_field_end();
        p.write_field_begin("enumVal", ::fbthrift::TType::Struct, -10);
        ::fbthrift::Serialize::write(&self.enumVal, p);
        p.write_field_end();
        p.write_field_begin("binaryVal", ::fbthrift::TType::Struct, -9);
        ::fbthrift::Serialize::write(&self.binaryVal, p);
        p.write_field_end();
        p.write_field_begin("stringVal", ::fbthrift::TType::Struct, -8);
        ::fbthrift::Serialize::write(&self.stringVal, p);
        p.write_field_end();
        p.write_field_begin("doubleVal", ::fbthrift::TType::Struct, -7);
        ::fbthrift::Serialize::write(&self.doubleVal, p);
        p.write_field_end();
        p.write_field_begin("floatVal", ::fbthrift::TType::Struct, -6);
        ::fbthrift::Serialize::write(&self.floatVal, p);
        p.write_field_end();
        p.write_field_begin("i64Val", ::fbthrift::TType::Struct, -5);
        ::fbthrift::Serialize::write(&self.i64Val, p);
        p.write_field_end();
        p.write_field_begin("i32Val", ::fbthrift::TType::Struct, -4);
        ::fbthrift::Serialize::write(&self.i32Val, p);
        p.write_field_end();
        p.write_field_begin("i16Val", ::fbthrift::TType::Struct, -3);
        ::fbthrift::Serialize::write(&self.i16Val, p);
        p.write_field_end();
        p.write_field_begin("byteVal", ::fbthrift::TType::Struct, -2);
        ::fbthrift::Serialize::write(&self.byteVal, p);
        p.write_field_end();
        p.write_field_begin("boolVal", ::fbthrift::TType::Struct, -1);
        ::fbthrift::Serialize::write(&self.boolVal, p);
        p.write_field_end();
        p.write_field_begin("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.structWithFieldCustomDefault, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("binaryVal", ::fbthrift::TType::Struct, -9),
            ::fbthrift::Field::new("boolVal", ::fbthrift::TType::Struct, -1),
            ::fbthrift::Field::new("byteVal", ::fbthrift::TType::Struct, -2),
            ::fbthrift::Field::new("doubleVal", ::fbthrift::TType::Struct, -7),
            ::fbthrift::Field::new("enumVal", ::fbthrift::TType::Struct, -10),
            ::fbthrift::Field::new("floatVal", ::fbthrift::TType::Struct, -6),
            ::fbthrift::Field::new("i16Val", ::fbthrift::TType::Struct, -3),
            ::fbthrift::Field::new("i32Val", ::fbthrift::TType::Struct, -4),
            ::fbthrift::Field::new("i32WithCustomDefault", ::fbthrift::TType::Struct, -31),
            ::fbthrift::Field::new("i64Val", ::fbthrift::TType::Struct, -5),
            ::fbthrift::Field::new("lateStructVal", ::fbthrift::TType::Struct, -13),
            ::fbthrift::Field::new("listMap", ::fbthrift::TType::Struct, -29),
            ::fbthrift::Field::new("mapMap", ::fbthrift::TType::Struct, -30),
            ::fbthrift::Field::new("optBinaryVal", ::fbthrift::TType::Struct, -22),
            ::fbthrift::Field::new("optBoolVal", ::fbthrift::TType::Struct, -14),
            ::fbthrift::Field::new("optByteVal", ::fbthrift::TType::Struct, -15),
            ::fbthrift::Field::new("optDoubleVal", ::fbthrift::TType::Struct, -20),
            ::fbthrift::Field::new("optEnumVal", ::fbthrift::TType::Struct, -23),
            ::fbthrift::Field::new("optFloatVal", ::fbthrift::TType::Struct, -19),
            ::fbthrift::Field::new("optI16Val", ::fbthrift::TType::Struct, -16),
            ::fbthrift::Field::new("optI32Val", ::fbthrift::TType::Struct, -17),
            ::fbthrift::Field::new("optI64Val", ::fbthrift::TType::Struct, -18),
            ::fbthrift::Field::new("optLateStructVal", ::fbthrift::TType::Struct, -25),
            ::fbthrift::Field::new("optListVal", ::fbthrift::TType::Struct, -26),
            ::fbthrift::Field::new("optMapVal", ::fbthrift::TType::Struct, -28),
            ::fbthrift::Field::new("optSetVal", ::fbthrift::TType::Struct, -27),
            ::fbthrift::Field::new("optStringVal", ::fbthrift::TType::Struct, -21),
            ::fbthrift::Field::new("optStructVal", ::fbthrift::TType::Struct, -24),
            ::fbthrift::Field::new("stringVal", ::fbthrift::TType::Struct, -8),
            ::fbthrift::Field::new("structVal", ::fbthrift::TType::Struct, -11),
            ::fbthrift::Field::new("structWithCustomDefault", ::fbthrift::TType::Struct, -32),
            ::fbthrift::Field::new("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("unionVal", ::fbthrift::TType::Struct, -12),
        ];
        let mut field_structWithCustomDefault = ::std::option::Option::None;
        let mut field_i32WithCustomDefault = ::std::option::Option::None;
        let mut field_mapMap = ::std::option::Option::None;
        let mut field_listMap = ::std::option::Option::None;
        let mut field_optMapVal = ::std::option::Option::None;
        let mut field_optSetVal = ::std::option::Option::None;
        let mut field_optListVal = ::std::option::Option::None;
        let mut field_optLateStructVal = ::std::option::Option::None;
        let mut field_optStructVal = ::std::option::Option::None;
        let mut field_optEnumVal = ::std::option::Option::None;
        let mut field_optBinaryVal = ::std::option::Option::None;
        let mut field_optStringVal = ::std::option::Option::None;
        let mut field_optDoubleVal = ::std::option::Option::None;
        let mut field_optFloatVal = ::std::option::Option::None;
        let mut field_optI64Val = ::std::option::Option::None;
        let mut field_optI32Val = ::std::option::Option::None;
        let mut field_optI16Val = ::std::option::Option::None;
        let mut field_optByteVal = ::std::option::Option::None;
        let mut field_optBoolVal = ::std::option::Option::None;
        let mut field_lateStructVal = ::std::option::Option::None;
        let mut field_unionVal = ::std::option::Option::None;
        let mut field_structVal = ::std::option::Option::None;
        let mut field_enumVal = ::std::option::Option::None;
        let mut field_binaryVal = ::std::option::Option::None;
        let mut field_stringVal = ::std::option::Option::None;
        let mut field_doubleVal = ::std::option::Option::None;
        let mut field_floatVal = ::std::option::Option::None;
        let mut field_i64Val = ::std::option::Option::None;
        let mut field_i32Val = ::std::option::Option::None;
        let mut field_i16Val = ::std::option::Option::None;
        let mut field_byteVal = ::std::option::Option::None;
        let mut field_boolVal = ::std::option::Option::None;
        let mut field_structWithFieldCustomDefault = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -32) => field_structWithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -31) => field_i32WithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -30) => field_mapMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -29) => field_listMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -28) => field_optMapVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -27) => field_optSetVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -26) => field_optListVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -25) => field_optLateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -24) => field_optStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -23) => field_optEnumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -22) => field_optBinaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -21) => field_optStringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -20) => field_optDoubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -19) => field_optFloatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -18) => field_optI64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -17) => field_optI32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -16) => field_optI16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -15) => field_optByteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -14) => field_optBoolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -13) => field_lateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -12) => field_unionVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -11) => field_structVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -10) => field_enumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -9) => field_binaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -8) => field_stringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -7) => field_doubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -6) => field_floatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -5) => field_i64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -4) => field_i32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -3) => field_i16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -2) => field_byteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -1) => field_boolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 1) => field_structWithFieldCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            structWithCustomDefault: field_structWithCustomDefault.unwrap_or_default(),
            i32WithCustomDefault: field_i32WithCustomDefault.unwrap_or_default(),
            mapMap: field_mapMap.unwrap_or_default(),
            listMap: field_listMap.unwrap_or_default(),
            optMapVal: field_optMapVal.unwrap_or_default(),
            optSetVal: field_optSetVal.unwrap_or_default(),
            optListVal: field_optListVal.unwrap_or_default(),
            optLateStructVal: field_optLateStructVal.unwrap_or_default(),
            optStructVal: field_optStructVal.unwrap_or_default(),
            optEnumVal: field_optEnumVal.unwrap_or_default(),
            optBinaryVal: field_optBinaryVal.unwrap_or_default(),
            optStringVal: field_optStringVal.unwrap_or_default(),
            optDoubleVal: field_optDoubleVal.unwrap_or_default(),
            optFloatVal: field_optFloatVal.unwrap_or_default(),
            optI64Val: field_optI64Val.unwrap_or_default(),
            optI32Val: field_optI32Val.unwrap_or_default(),
            optI16Val: field_optI16Val.unwrap_or_default(),
            optByteVal: field_optByteVal.unwrap_or_default(),
            optBoolVal: field_optBoolVal.unwrap_or_default(),
            lateStructVal: field_lateStructVal.unwrap_or_default(),
            unionVal: field_unionVal.unwrap_or_default(),
            structVal: field_structVal.unwrap_or_default(),
            enumVal: field_enumVal.unwrap_or_default(),
            binaryVal: field_binaryVal.unwrap_or_default(),
            stringVal: field_stringVal.unwrap_or_default(),
            doubleVal: field_doubleVal.unwrap_or_default(),
            floatVal: field_floatVal.unwrap_or_default(),
            i64Val: field_i64Val.unwrap_or_default(),
            i32Val: field_i32Val.unwrap_or_default(),
            i16Val: field_i16Val.unwrap_or_default(),
            byteVal: field_byteVal.unwrap_or_default(),
            boolVal: field_boolVal.unwrap_or_default(),
            structWithFieldCustomDefault: field_structWithFieldCustomDefault.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructEnsureStruct {
    fn default() -> Self {
        Self {
            structWithCustomDefault: ::std::option::Option::None,
            i32WithCustomDefault: ::std::option::Option::None,
            mapMap: ::std::option::Option::None,
            listMap: ::std::option::Option::None,
            optMapVal: ::std::option::Option::None,
            optSetVal: ::std::option::Option::None,
            optListVal: ::std::option::Option::None,
            optLateStructVal: ::std::option::Option::None,
            optStructVal: ::std::option::Option::None,
            optEnumVal: ::std::option::Option::None,
            optBinaryVal: ::std::option::Option::None,
            optStringVal: ::std::option::Option::None,
            optDoubleVal: ::std::option::Option::None,
            optFloatVal: ::std::option::Option::None,
            optI64Val: ::std::option::Option::None,
            optI32Val: ::std::option::Option::None,
            optI16Val: ::std::option::Option::None,
            optByteVal: ::std::option::Option::None,
            optBoolVal: ::std::option::Option::None,
            lateStructVal: ::std::option::Option::None,
            unionVal: ::std::option::Option::None,
            structVal: ::std::option::Option::None,
            enumVal: ::std::option::Option::None,
            binaryVal: ::std::option::Option::None,
            stringVal: ::std::option::Option::None,
            doubleVal: ::std::option::Option::None,
            floatVal: ::std::option::Option::None,
            i64Val: ::std::option::Option::None,
            i32Val: ::std::option::Option::None,
            i16Val: ::std::option::Option::None,
            byteVal: ::std::option::Option::None,
            boolVal: ::std::option::Option::None,
            structWithFieldCustomDefault: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructEnsureStruct")
            .field("structWithCustomDefault", &self.structWithCustomDefault)
            .field("i32WithCustomDefault", &self.i32WithCustomDefault)
            .field("mapMap", &self.mapMap)
            .field("listMap", &self.listMap)
            .field("optMapVal", &self.optMapVal)
            .field("optSetVal", &self.optSetVal)
            .field("optListVal", &self.optListVal)
            .field("optLateStructVal", &self.optLateStructVal)
            .field("optStructVal", &self.optStructVal)
            .field("optEnumVal", &self.optEnumVal)
            .field("optBinaryVal", &self.optBinaryVal)
            .field("optStringVal", &self.optStringVal)
            .field("optDoubleVal", &self.optDoubleVal)
            .field("optFloatVal", &self.optFloatVal)
            .field("optI64Val", &self.optI64Val)
            .field("optI32Val", &self.optI32Val)
            .field("optI16Val", &self.optI16Val)
            .field("optByteVal", &self.optByteVal)
            .field("optBoolVal", &self.optBoolVal)
            .field("lateStructVal", &self.lateStructVal)
            .field("unionVal", &self.unionVal)
            .field("structVal", &self.structVal)
            .field("enumVal", &self.enumVal)
            .field("binaryVal", &self.binaryVal)
            .field("stringVal", &self.stringVal)
            .field("doubleVal", &self.doubleVal)
            .field("floatVal", &self.floatVal)
            .field("i64Val", &self.i64Val)
            .field("i32Val", &self.i32Val)
            .field("i16Val", &self.i16Val)
            .field("byteVal", &self.byteVal)
            .field("boolVal", &self.boolVal)
            .field("structWithFieldCustomDefault", &self.structWithFieldCustomDefault)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructEnsureStruct {}
unsafe impl ::std::marker::Sync for self::MyStructEnsureStruct {}
impl ::std::marker::Unpin for self::MyStructEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::MyStructEnsureStruct {}
impl ::std::panic::UnwindSafe for self::MyStructEnsureStruct {}

impl ::fbthrift::GetTType for self::MyStructEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.structWithCustomDefault {
            p.write_field_begin("structWithCustomDefault", ::fbthrift::TType::Struct, -32);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.i32WithCustomDefault {
            p.write_field_begin("i32WithCustomDefault", ::fbthrift::TType::I32, -31);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.mapMap {
            p.write_field_begin("mapMap", ::fbthrift::TType::Map, -30);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.listMap {
            p.write_field_begin("listMap", ::fbthrift::TType::List, -29);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optMapVal {
            p.write_field_begin("optMapVal", ::fbthrift::TType::Map, -28);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optSetVal {
            p.write_field_begin("optSetVal", ::fbthrift::TType::Set, -27);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optListVal {
            p.write_field_begin("optListVal", ::fbthrift::TType::List, -26);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optLateStructVal {
            p.write_field_begin("optLateStructVal", ::fbthrift::TType::Struct, -25);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStructVal {
            p.write_field_begin("optStructVal", ::fbthrift::TType::Struct, -24);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optEnumVal {
            p.write_field_begin("optEnumVal", ::fbthrift::TType::I32, -23);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optBinaryVal {
            p.write_field_begin("optBinaryVal", ::fbthrift::TType::String, -22);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStringVal {
            p.write_field_begin("optStringVal", ::fbthrift::TType::String, -21);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optDoubleVal {
            p.write_field_begin("optDoubleVal", ::fbthrift::TType::Double, -20);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optFloatVal {
            p.write_field_begin("optFloatVal", ::fbthrift::TType::Float, -19);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI64Val {
            p.write_field_begin("optI64Val", ::fbthrift::TType::I64, -18);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI32Val {
            p.write_field_begin("optI32Val", ::fbthrift::TType::I32, -17);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI16Val {
            p.write_field_begin("optI16Val", ::fbthrift::TType::I16, -16);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optByteVal {
            p.write_field_begin("optByteVal", ::fbthrift::TType::Byte, -15);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optBoolVal {
            p.write_field_begin("optBoolVal", ::fbthrift::TType::Bool, -14);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.lateStructVal {
            p.write_field_begin("lateStructVal", ::fbthrift::TType::Struct, -13);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.unionVal {
            p.write_field_begin("unionVal", ::fbthrift::TType::Struct, -12);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.structVal {
            p.write_field_begin("structVal", ::fbthrift::TType::Struct, -11);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.enumVal {
            p.write_field_begin("enumVal", ::fbthrift::TType::I32, -10);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.binaryVal {
            p.write_field_begin("binaryVal", ::fbthrift::TType::String, -9);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.stringVal {
            p.write_field_begin("stringVal", ::fbthrift::TType::String, -8);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.doubleVal {
            p.write_field_begin("doubleVal", ::fbthrift::TType::Double, -7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.floatVal {
            p.write_field_begin("floatVal", ::fbthrift::TType::Float, -6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.i64Val {
            p.write_field_begin("i64Val", ::fbthrift::TType::I64, -5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.i32Val {
            p.write_field_begin("i32Val", ::fbthrift::TType::I32, -4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.i16Val {
            p.write_field_begin("i16Val", ::fbthrift::TType::I16, -3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.byteVal {
            p.write_field_begin("byteVal", ::fbthrift::TType::Byte, -2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.boolVal {
            p.write_field_begin("boolVal", ::fbthrift::TType::Bool, -1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.structWithFieldCustomDefault {
            p.write_field_begin("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("binaryVal", ::fbthrift::TType::String, -9),
            ::fbthrift::Field::new("boolVal", ::fbthrift::TType::Bool, -1),
            ::fbthrift::Field::new("byteVal", ::fbthrift::TType::Byte, -2),
            ::fbthrift::Field::new("doubleVal", ::fbthrift::TType::Double, -7),
            ::fbthrift::Field::new("enumVal", ::fbthrift::TType::I32, -10),
            ::fbthrift::Field::new("floatVal", ::fbthrift::TType::Float, -6),
            ::fbthrift::Field::new("i16Val", ::fbthrift::TType::I16, -3),
            ::fbthrift::Field::new("i32Val", ::fbthrift::TType::I32, -4),
            ::fbthrift::Field::new("i32WithCustomDefault", ::fbthrift::TType::I32, -31),
            ::fbthrift::Field::new("i64Val", ::fbthrift::TType::I64, -5),
            ::fbthrift::Field::new("lateStructVal", ::fbthrift::TType::Struct, -13),
            ::fbthrift::Field::new("listMap", ::fbthrift::TType::List, -29),
            ::fbthrift::Field::new("mapMap", ::fbthrift::TType::Map, -30),
            ::fbthrift::Field::new("optBinaryVal", ::fbthrift::TType::String, -22),
            ::fbthrift::Field::new("optBoolVal", ::fbthrift::TType::Bool, -14),
            ::fbthrift::Field::new("optByteVal", ::fbthrift::TType::Byte, -15),
            ::fbthrift::Field::new("optDoubleVal", ::fbthrift::TType::Double, -20),
            ::fbthrift::Field::new("optEnumVal", ::fbthrift::TType::I32, -23),
            ::fbthrift::Field::new("optFloatVal", ::fbthrift::TType::Float, -19),
            ::fbthrift::Field::new("optI16Val", ::fbthrift::TType::I16, -16),
            ::fbthrift::Field::new("optI32Val", ::fbthrift::TType::I32, -17),
            ::fbthrift::Field::new("optI64Val", ::fbthrift::TType::I64, -18),
            ::fbthrift::Field::new("optLateStructVal", ::fbthrift::TType::Struct, -25),
            ::fbthrift::Field::new("optListVal", ::fbthrift::TType::List, -26),
            ::fbthrift::Field::new("optMapVal", ::fbthrift::TType::Map, -28),
            ::fbthrift::Field::new("optSetVal", ::fbthrift::TType::Set, -27),
            ::fbthrift::Field::new("optStringVal", ::fbthrift::TType::String, -21),
            ::fbthrift::Field::new("optStructVal", ::fbthrift::TType::Struct, -24),
            ::fbthrift::Field::new("stringVal", ::fbthrift::TType::String, -8),
            ::fbthrift::Field::new("structVal", ::fbthrift::TType::Struct, -11),
            ::fbthrift::Field::new("structWithCustomDefault", ::fbthrift::TType::Struct, -32),
            ::fbthrift::Field::new("structWithFieldCustomDefault", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("unionVal", ::fbthrift::TType::Struct, -12),
        ];
        let mut field_structWithCustomDefault = ::std::option::Option::None;
        let mut field_i32WithCustomDefault = ::std::option::Option::None;
        let mut field_mapMap = ::std::option::Option::None;
        let mut field_listMap = ::std::option::Option::None;
        let mut field_optMapVal = ::std::option::Option::None;
        let mut field_optSetVal = ::std::option::Option::None;
        let mut field_optListVal = ::std::option::Option::None;
        let mut field_optLateStructVal = ::std::option::Option::None;
        let mut field_optStructVal = ::std::option::Option::None;
        let mut field_optEnumVal = ::std::option::Option::None;
        let mut field_optBinaryVal = ::std::option::Option::None;
        let mut field_optStringVal = ::std::option::Option::None;
        let mut field_optDoubleVal = ::std::option::Option::None;
        let mut field_optFloatVal = ::std::option::Option::None;
        let mut field_optI64Val = ::std::option::Option::None;
        let mut field_optI32Val = ::std::option::Option::None;
        let mut field_optI16Val = ::std::option::Option::None;
        let mut field_optByteVal = ::std::option::Option::None;
        let mut field_optBoolVal = ::std::option::Option::None;
        let mut field_lateStructVal = ::std::option::Option::None;
        let mut field_unionVal = ::std::option::Option::None;
        let mut field_structVal = ::std::option::Option::None;
        let mut field_enumVal = ::std::option::Option::None;
        let mut field_binaryVal = ::std::option::Option::None;
        let mut field_stringVal = ::std::option::Option::None;
        let mut field_doubleVal = ::std::option::Option::None;
        let mut field_floatVal = ::std::option::Option::None;
        let mut field_i64Val = ::std::option::Option::None;
        let mut field_i32Val = ::std::option::Option::None;
        let mut field_i16Val = ::std::option::Option::None;
        let mut field_byteVal = ::std::option::Option::None;
        let mut field_boolVal = ::std::option::Option::None;
        let mut field_structWithFieldCustomDefault = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a MyStructEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -32) => field_structWithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -31) => field_i32WithCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, -30) => field_mapMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, -29) => field_listMap = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, -28) => field_optMapVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, -27) => field_optSetVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, -26) => field_optListVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -25) => field_optLateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -24) => field_optStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -23) => field_optEnumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -22) => field_optBinaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -21) => field_optStringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, -20) => field_optDoubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, -19) => field_optFloatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, -18) => field_optI64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -17) => field_optI32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, -16) => field_optI16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, -15) => field_optByteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, -14) => field_optBoolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -13) => field_lateStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -12) => field_unionVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, -11) => field_structVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -10) => field_enumVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -9) => field_binaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, -8) => field_stringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, -7) => field_doubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, -6) => field_floatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, -5) => field_i64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, -4) => field_i32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, -3) => field_i16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, -2) => field_byteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, -1) => field_boolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 1) => field_structWithFieldCustomDefault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            structWithCustomDefault: field_structWithCustomDefault,
            i32WithCustomDefault: field_i32WithCustomDefault,
            mapMap: field_mapMap,
            listMap: field_listMap,
            optMapVal: field_optMapVal,
            optSetVal: field_optSetVal,
            optListVal: field_optListVal,
            optLateStructVal: field_optLateStructVal,
            optStructVal: field_optStructVal,
            optEnumVal: field_optEnumVal,
            optBinaryVal: field_optBinaryVal,
            optStringVal: field_optStringVal,
            optDoubleVal: field_optDoubleVal,
            optFloatVal: field_optFloatVal,
            optI64Val: field_optI64Val,
            optI32Val: field_optI32Val,
            optI16Val: field_optI16Val,
            optByteVal: field_optByteVal,
            optBoolVal: field_optBoolVal,
            lateStructVal: field_lateStructVal,
            unionVal: field_unionVal,
            structVal: field_structVal,
            enumVal: field_enumVal,
            binaryVal: field_binaryVal,
            stringVal: field_stringVal,
            doubleVal: field_doubleVal,
            floatVal: field_floatVal,
            i64Val: field_i64Val,
            i32Val: field_i32Val,
            i16Val: field_i16Val,
            byteVal: field_byteVal,
            boolVal: field_boolVal,
            structWithFieldCustomDefault: field_structWithFieldCustomDefault,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LateDefStructPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LateDefStructPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LateDefStructPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LateDefStructPatch {}
unsafe impl ::std::marker::Sync for self::LateDefStructPatch {}
impl ::std::marker::Unpin for self::LateDefStructPatch {}
impl ::std::panic::RefUnwindSafe for self::LateDefStructPatch {}
impl ::std::panic::UnwindSafe for self::LateDefStructPatch {}

impl ::fbthrift::GetTType for self::LateDefStructPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::LateDefStructPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/LateDefStructPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::LateDefStructPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LateDefStructPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LateDefStructPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a LateDefStructPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LateDefStructFieldPatch {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LateDefStructFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LateDefStructFieldPatch")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LateDefStructFieldPatch {}
unsafe impl ::std::marker::Sync for self::LateDefStructFieldPatch {}
impl ::std::marker::Unpin for self::LateDefStructFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::LateDefStructFieldPatch {}
impl ::std::panic::UnwindSafe for self::LateDefStructFieldPatch {}

impl ::fbthrift::GetTType for self::LateDefStructFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::LateDefStructFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/LateDefStructFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::LateDefStructFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LateDefStructFieldPatch");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LateDefStructFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a LateDefStructFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LateDefStructEnsureStruct {
    fn default() -> Self {
        Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LateDefStructEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LateDefStructEnsureStruct")
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LateDefStructEnsureStruct {}
unsafe impl ::std::marker::Sync for self::LateDefStructEnsureStruct {}
impl ::std::marker::Unpin for self::LateDefStructEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::LateDefStructEnsureStruct {}
impl ::std::panic::UnwindSafe for self::LateDefStructEnsureStruct {}

impl ::fbthrift::GetTType for self::LateDefStructEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::LateDefStructEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/LateDefStructEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::LateDefStructEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LateDefStructEnsureStruct");
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LateDefStructEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
        ];
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a LateDefStructEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RecursivePatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RecursivePatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RecursivePatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RecursivePatch {}
unsafe impl ::std::marker::Sync for self::RecursivePatch {}
impl ::std::marker::Unpin for self::RecursivePatch {}
impl ::std::panic::RefUnwindSafe for self::RecursivePatch {}
impl ::std::panic::UnwindSafe for self::RecursivePatch {}

impl ::fbthrift::GetTType for self::RecursivePatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RecursivePatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RecursivePatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RecursivePatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RecursivePatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RecursivePatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RecursivePatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RecursiveField1Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RecursiveField1Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RecursiveField1Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RecursiveField1Patch {}
unsafe impl ::std::marker::Sync for self::RecursiveField1Patch {}
impl ::std::marker::Unpin for self::RecursiveField1Patch {}
impl ::std::panic::RefUnwindSafe for self::RecursiveField1Patch {}
impl ::std::panic::UnwindSafe for self::RecursiveField1Patch {}

impl ::fbthrift::GetTType for self::RecursiveField1Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RecursiveField1Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RecursiveField1Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RecursiveField1Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RecursiveField1Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RecursiveField1Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RecursiveField1Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RecursiveFieldPatch {
    fn default() -> Self {
        Self {
            nodes: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RecursiveFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RecursiveFieldPatch")
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RecursiveFieldPatch {}
unsafe impl ::std::marker::Sync for self::RecursiveFieldPatch {}
impl ::std::marker::Unpin for self::RecursiveFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::RecursiveFieldPatch {}
impl ::std::panic::UnwindSafe for self::RecursiveFieldPatch {}

impl ::fbthrift::GetTType for self::RecursiveFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RecursiveFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RecursiveFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RecursiveFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RecursiveFieldPatch");
        p.write_field_begin("nodes", ::fbthrift::TType::Struct, -1);
        ::fbthrift::Serialize::write(&self.nodes, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RecursiveFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::Struct, -1),
        ];
        let mut field_nodes = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RecursiveFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -1) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            nodes: field_nodes.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RecursiveEnsureStruct {
    fn default() -> Self {
        Self {
            nodes: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RecursiveEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RecursiveEnsureStruct")
            .field("nodes", &self.nodes)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RecursiveEnsureStruct {}
unsafe impl ::std::marker::Sync for self::RecursiveEnsureStruct {}
impl ::std::marker::Unpin for self::RecursiveEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::RecursiveEnsureStruct {}
impl ::std::panic::UnwindSafe for self::RecursiveEnsureStruct {}

impl ::fbthrift::GetTType for self::RecursiveEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RecursiveEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RecursiveEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RecursiveEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RecursiveEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.nodes {
            p.write_field_begin("nodes", ::fbthrift::TType::Map, -1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RecursiveEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("nodes", ::fbthrift::TType::Map, -1),
        ];
        let mut field_nodes = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RecursiveEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, -1) => field_nodes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            nodes: field_nodes,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BarPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BarPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BarPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BarPatch {}
unsafe impl ::std::marker::Sync for self::BarPatch {}
impl ::std::marker::Unpin for self::BarPatch {}
impl ::std::panic::RefUnwindSafe for self::BarPatch {}
impl ::std::panic::UnwindSafe for self::BarPatch {}

impl ::fbthrift::GetTType for self::BarPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::BarPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/BarPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::BarPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BarPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BarPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a BarPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BarFieldPatch {
    fn default() -> Self {
        Self {
            r#loop: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BarFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BarFieldPatch")
            .field("r#loop", &self.r#loop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BarFieldPatch {}
unsafe impl ::std::marker::Sync for self::BarFieldPatch {}
impl ::std::marker::Unpin for self::BarFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::BarFieldPatch {}
impl ::std::panic::UnwindSafe for self::BarFieldPatch {}

impl ::fbthrift::GetTType for self::BarFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::BarFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/BarFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::BarFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BarFieldPatch");
        p.write_field_begin("loop", ::fbthrift::TType::Struct, -1);
        ::fbthrift::Serialize::write(&self.r#loop, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BarFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("loop", ::fbthrift::TType::Struct, -1),
        ];
        let mut field_loop = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a BarFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -1) => field_loop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#loop: field_loop.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::BarEnsureStruct {
    fn default() -> Self {
        Self {
            r#loop: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::BarEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("BarEnsureStruct")
            .field("r#loop", &self.r#loop)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::BarEnsureStruct {}
unsafe impl ::std::marker::Sync for self::BarEnsureStruct {}
impl ::std::marker::Unpin for self::BarEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::BarEnsureStruct {}
impl ::std::panic::UnwindSafe for self::BarEnsureStruct {}

impl ::fbthrift::GetTType for self::BarEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::BarEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/BarEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::BarEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("BarEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.r#loop {
            p.write_field_begin("loop", ::fbthrift::TType::Struct, -1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::BarEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("loop", ::fbthrift::TType::Struct, -1),
        ];
        let mut field_loop = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a BarEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, -1) => field_loop = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            r#loop: field_loop,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::LoopPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::LoopPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("LoopPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::LoopPatch {}
unsafe impl ::std::marker::Sync for self::LoopPatch {}
impl ::std::marker::Unpin for self::LoopPatch {}
impl ::std::panic::RefUnwindSafe for self::LoopPatch {}
impl ::std::panic::UnwindSafe for self::LoopPatch {}

impl ::fbthrift::GetTType for self::LoopPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::LoopPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/LoopPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::LoopPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("LoopPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::LoopPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a LoopPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .field("remove", &self.remove)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsPatch {}
unsafe impl ::std::marker::Sync for self::RefFieldsPatch {}
impl ::std::marker::Unpin for self::RefFieldsPatch {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsPatch {}
impl ::std::panic::UnwindSafe for self::RefFieldsPatch {}

impl ::fbthrift::GetTType for self::RefFieldsPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::List, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::List, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsField1Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsField1Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsField1Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsField1Patch {}
unsafe impl ::std::marker::Sync for self::RefFieldsField1Patch {}
impl ::std::marker::Unpin for self::RefFieldsField1Patch {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsField1Patch {}
impl ::std::panic::UnwindSafe for self::RefFieldsField1Patch {}

impl ::fbthrift::GetTType for self::RefFieldsField1Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsField1Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsField1Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsField1Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsField1Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsField1Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsField1Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsField4Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsField4Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsField4Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsField4Patch {}
unsafe impl ::std::marker::Sync for self::RefFieldsField4Patch {}
impl ::std::marker::Unpin for self::RefFieldsField4Patch {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsField4Patch {}
impl ::std::panic::UnwindSafe for self::RefFieldsField4Patch {}

impl ::fbthrift::GetTType for self::RefFieldsField4Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsField4Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsField4Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsField4Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsField4Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsField4Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsField4Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsField7Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsField7Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsField7Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsField7Patch {}
unsafe impl ::std::marker::Sync for self::RefFieldsField7Patch {}
impl ::std::marker::Unpin for self::RefFieldsField7Patch {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsField7Patch {}
impl ::std::panic::UnwindSafe for self::RefFieldsField7Patch {}

impl ::fbthrift::GetTType for self::RefFieldsField7Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsField7Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsField7Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsField7Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsField7Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsField7Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsField7Patch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsFieldPatch {
    fn default() -> Self {
        Self {
            unique: ::std::default::Default::default(),
            opt_unique: ::std::default::Default::default(),
            opt_box: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsFieldPatch")
            .field("unique", &self.unique)
            .field("opt_unique", &self.opt_unique)
            .field("opt_box", &self.opt_box)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsFieldPatch {}
unsafe impl ::std::marker::Sync for self::RefFieldsFieldPatch {}
impl ::std::marker::Unpin for self::RefFieldsFieldPatch {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsFieldPatch {}
impl ::std::panic::UnwindSafe for self::RefFieldsFieldPatch {}

impl ::fbthrift::GetTType for self::RefFieldsFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsFieldPatch");
        p.write_field_begin("unique", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.unique, p);
        p.write_field_end();
        p.write_field_begin("opt_unique", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.opt_unique, p);
        p.write_field_end();
        p.write_field_begin("opt_box", ::fbthrift::TType::Struct, 7);
        ::fbthrift::Serialize::write(&self.opt_box, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("opt_box", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("opt_unique", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("unique", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_unique = ::std::option::Option::None;
        let mut field_opt_unique = ::std::option::Option::None;
        let mut field_opt_box = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsFieldPatch")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_opt_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_opt_box = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            unique: field_unique.unwrap_or_default(),
            opt_unique: field_opt_unique.unwrap_or_default(),
            opt_box: field_opt_box.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::RefFieldsEnsureStruct {
    fn default() -> Self {
        Self {
            unique: ::std::option::Option::None,
            shared_const: ::std::option::Option::None,
            shared_mustable: ::std::option::Option::None,
            opt_unique: ::std::option::Option::None,
            opt_shared_const: ::std::option::Option::None,
            opt_shared_mustable: ::std::option::Option::None,
            opt_box: ::std::option::Option::None,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::RefFieldsEnsureStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("RefFieldsEnsureStruct")
            .field("unique", &self.unique)
            .field("shared_const", &self.shared_const)
            .field("shared_mustable", &self.shared_mustable)
            .field("opt_unique", &self.opt_unique)
            .field("opt_shared_const", &self.opt_shared_const)
            .field("opt_shared_mustable", &self.opt_shared_mustable)
            .field("opt_box", &self.opt_box)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::RefFieldsEnsureStruct {}
unsafe impl ::std::marker::Sync for self::RefFieldsEnsureStruct {}
impl ::std::marker::Unpin for self::RefFieldsEnsureStruct {}
impl ::std::panic::RefUnwindSafe for self::RefFieldsEnsureStruct {}
impl ::std::panic::UnwindSafe for self::RefFieldsEnsureStruct {}

impl ::fbthrift::GetTType for self::RefFieldsEnsureStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::RefFieldsEnsureStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/RefFieldsEnsureStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::RefFieldsEnsureStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("RefFieldsEnsureStruct");
        if let ::std::option::Option::Some(some) = &self.unique {
            p.write_field_begin("unique", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.shared_const {
            p.write_field_begin("shared_const", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.shared_mustable {
            p.write_field_begin("shared_mustable", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_unique {
            p.write_field_begin("opt_unique", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_shared_const {
            p.write_field_begin("opt_shared_const", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_shared_mustable {
            p.write_field_begin("opt_shared_mustable", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.opt_box {
            p.write_field_begin("opt_box", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::RefFieldsEnsureStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("opt_box", ::fbthrift::TType::List, 7),
            ::fbthrift::Field::new("opt_shared_const", ::fbthrift::TType::List, 5),
            ::fbthrift::Field::new("opt_shared_mustable", ::fbthrift::TType::List, 6),
            ::fbthrift::Field::new("opt_unique", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("shared_const", ::fbthrift::TType::List, 2),
            ::fbthrift::Field::new("shared_mustable", ::fbthrift::TType::List, 3),
            ::fbthrift::Field::new("unique", ::fbthrift::TType::List, 1),
        ];
        let mut field_unique = ::std::option::Option::None;
        let mut field_shared_const = ::std::option::Option::None;
        let mut field_shared_mustable = ::std::option::Option::None;
        let mut field_opt_unique = ::std::option::Option::None;
        let mut field_opt_shared_const = ::std::option::Option::None;
        let mut field_opt_shared_mustable = ::std::option::Option::None;
        let mut field_opt_box = ::std::option::Option::None;
        let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a RefFieldsEnsureStruct")?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 2) => field_shared_const = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 3) => field_shared_mustable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_opt_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 5) => field_opt_shared_const = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 6) => field_opt_shared_mustable = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 7) => field_opt_box = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            unique: field_unique,
            shared_const: field_shared_const,
            shared_mustable: field_shared_mustable,
            opt_unique: field_opt_unique,
            opt_shared_const: field_opt_shared_const,
            opt_shared_mustable: field_opt_shared_mustable,
            opt_box: field_opt_box,
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}




mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}

pub(crate) mod r#impl {
    use ref_cast::RefCast;

    #[derive(RefCast)]
    #[repr(transparent)]
    pub(crate) struct LocalImpl<T>(T);

    #[allow(unused)]
    pub(crate) fn write<T, P>(value: &T, p: &mut P)
    where
        LocalImpl<T>: ::fbthrift::Serialize<P>,
        P: ::fbthrift::ProtocolWriter,
    {
        ::fbthrift::Serialize::write(LocalImpl::ref_cast(value), p);
    }

    #[allow(unused)]
    pub(crate) fn read<T, P>(p: &mut P) -> ::anyhow::Result<T>
    where
        LocalImpl<T>: ::fbthrift::Deserialize<P>,
        P: ::fbthrift::ProtocolReader,
    {
        let value: LocalImpl<T> = ::fbthrift::Deserialize::read(p)?;
        ::std::result::Result::Ok(value.0)
    }
}
