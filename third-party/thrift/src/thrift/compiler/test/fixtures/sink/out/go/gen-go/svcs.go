// Autogenerated by Thrift for thrift/compiler/test/fixtures/sink/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "context"
    "errors"
    "fmt"
    "io"
    "iter"
    "reflect"
    "sync"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = io.EOF
var _ = iter.Pull[bool]
var _ = reflect.Ptr
var _ = sync.OnceFunc
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__


type SinkService interface {
    Method(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodAndReponse(ctx context.Context) (*InitialResponse, func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodThrow(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodSinkThrow(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFinalThrow(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodBothThrow(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFast(ctx context.Context) (func(context.Context, iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
}

type SinkServiceClient interface {
    io.Closer
    Method(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodAndReponse(ctx context.Context) (*InitialResponse, func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodSinkThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFinalThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodBothThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFast(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
}

type sinkServiceClientImpl struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ SinkServiceClient = (*sinkServiceClientImpl)(nil)

func NewSinkServiceChannelClient(channel thrift.RequestChannel) SinkServiceClient {
    return &sinkServiceClientImpl{
        ch: channel,
    }
}

func init() {
    thrift.InternalRegisterClientConstructor[SinkServiceClient](NewSinkServiceChannelClient)
}

func (c *sinkServiceClientImpl) Close() error {
    return c.ch.Close()
}

func (c *sinkServiceClientImpl) Method(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethod{
    }
    fbthriftFirstResp := newRespSinkServiceMethod()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "method",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethod()
                if err != nil {
                    yield(nil, err)
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethod()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodAndReponse(ctx context.Context) (*InitialResponse, func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    var fbthriftFirstRespZero *InitialResponse
    fbthriftReq := &reqSinkServiceMethodAndReponse{
    }
    fbthriftFirstResp := newRespSinkServiceMethodAndReponse()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodAndReponse",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return fbthriftFirstRespZero, nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodAndReponse()
                if err != nil {
                    yield(nil, err)
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodAndReponse()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftFirstResp.GetSuccess(), fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethodThrow{
    }
    fbthriftFirstResp := newRespSinkServiceMethodThrow()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodThrow",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodThrow()
                if err != nil {
                    yield(nil, err)
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodThrow()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodSinkThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethodSinkThrow{
    }
    fbthriftFirstResp := newRespSinkServiceMethodSinkThrow()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodSinkThrow",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodSinkThrow()
                if err != nil {
                    switch v := err.(type) {
                    case *SinkException1:
                        sinkPayload.Ex = v
                        yield(sinkPayload, nil)
                    default:
                        yield(nil, err)
                    }
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodSinkThrow()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodFinalThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethodFinalThrow{
    }
    fbthriftFirstResp := newRespSinkServiceMethodFinalThrow()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodFinalThrow",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodFinalThrow()
                if err != nil {
                    yield(nil, err)
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodFinalThrow()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodBothThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethodBothThrow{
    }
    fbthriftFirstResp := newRespSinkServiceMethodBothThrow()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodBothThrow",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodBothThrow()
                if err != nil {
                    switch v := err.(type) {
                    case *SinkException1:
                        sinkPayload.Ex = v
                        yield(sinkPayload, nil)
                    default:
                        yield(nil, err)
                    }
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodBothThrow()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}

func (c *sinkServiceClientImpl) MethodFast(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    fbthriftReq := &reqSinkServiceMethodFast{
    }
    fbthriftFirstResp := newRespSinkServiceMethodFast()

    fbthriftChannel := c.ch

    fbthriftSinkFn, fbthriftErr := fbthriftChannel.SendRequestSink(
        ctx,
        "methodFast",
        fbthriftReq,
        fbthriftFirstResp,
    )
    if fbthriftErr != nil {
        return nil, fbthriftErr
    }

    fbthriftSinkCallback := func(elemSeq iter.Seq2[*SinkPayload, error]) (*FinalResponse, error) {
        sinkPayloadSeq := func(yield func(thrift.WritableResult, error) bool) {
            for elem, err := range elemSeq {
                sinkPayload := newSinkSinkServiceMethodFast()
                if err != nil {
                    yield(nil, err)
                    return
                }
                sinkPayload.Success = elem
                if !yield(sinkPayload, nil) {
                    return
                }
            }
        }
        fbthriftFinalResp := newRespFinalSinkServiceMethodFast()
        fbthriftFinalErr := fbthriftSinkFn(sinkPayloadSeq, fbthriftFinalResp)
        if fbthriftFinalErr != nil {
            return nil, fbthriftFinalErr
        } else if fbthriftFinalEx := fbthriftFinalResp.Exception(); fbthriftFinalEx != nil {
            return nil, fbthriftFinalEx
        }
        return fbthriftFinalResp.GetSuccess(), nil
    }

    return fbthriftSinkCallback, nil
}


type SinkServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              SinkService
}

func NewSinkServiceProcessor(handler SinkService) *SinkServiceProcessor {
    p := &SinkServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }
    p.AddToProcessorFunctionMap("method", &procFuncSinkServiceMethod{handler: handler})
    p.AddToProcessorFunctionMap("methodAndReponse", &procFuncSinkServiceMethodAndReponse{handler: handler})
    p.AddToProcessorFunctionMap("methodThrow", &procFuncSinkServiceMethodThrow{handler: handler})
    p.AddToProcessorFunctionMap("methodSinkThrow", &procFuncSinkServiceMethodSinkThrow{handler: handler})
    p.AddToProcessorFunctionMap("methodFinalThrow", &procFuncSinkServiceMethodFinalThrow{handler: handler})
    p.AddToProcessorFunctionMap("methodBothThrow", &procFuncSinkServiceMethodBothThrow{handler: handler})
    p.AddToProcessorFunctionMap("methodFast", &procFuncSinkServiceMethodFast{handler: handler})
    p.AddToFunctionServiceMap("method", "SinkService")
    p.AddToFunctionServiceMap("methodAndReponse", "SinkService")
    p.AddToFunctionServiceMap("methodThrow", "SinkService")
    p.AddToFunctionServiceMap("methodSinkThrow", "SinkService")
    p.AddToFunctionServiceMap("methodFinalThrow", "SinkService")
    p.AddToFunctionServiceMap("methodBothThrow", "SinkService")
    p.AddToFunctionServiceMap("methodFast", "SinkService")

    return p
}

func (p *SinkServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *SinkServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *SinkServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *SinkServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *SinkServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *SinkServiceProcessor) PackageName() string {
    return "module"
}

func (p *SinkServiceProcessor) GetInteractionProcessors() []thrift.Processor {
    return []thrift.Processor{}
}

func (p *SinkServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.SinkService")
}


type procFuncSinkServiceMethod struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethod)(nil)

func (p *procFuncSinkServiceMethod) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethod()
}

func (p *procFuncSinkServiceMethod) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethod) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodAndReponse struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodAndReponse)(nil)

func (p *procFuncSinkServiceMethodAndReponse) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodAndReponse()
}

func (p *procFuncSinkServiceMethodAndReponse) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodAndReponse) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodThrow struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodThrow)(nil)

func (p *procFuncSinkServiceMethodThrow) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodThrow()
}

func (p *procFuncSinkServiceMethodThrow) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodThrow) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodSinkThrow struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodSinkThrow)(nil)

func (p *procFuncSinkServiceMethodSinkThrow) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodSinkThrow()
}

func (p *procFuncSinkServiceMethodSinkThrow) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodSinkThrow) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodFinalThrow struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodFinalThrow)(nil)

func (p *procFuncSinkServiceMethodFinalThrow) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodFinalThrow()
}

func (p *procFuncSinkServiceMethodFinalThrow) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodFinalThrow) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodBothThrow struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodBothThrow)(nil)

func (p *procFuncSinkServiceMethodBothThrow) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodBothThrow()
}

func (p *procFuncSinkServiceMethodBothThrow) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodBothThrow) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

type procFuncSinkServiceMethodFast struct {
    handler SinkService
}
// Compile time interface enforcer
var _ thrift.ProcessorFunction = (*procFuncSinkServiceMethodFast)(nil)

func (p *procFuncSinkServiceMethodFast) NewReqArgs() thrift.ReadableStruct {
    return newReqSinkServiceMethodFast()
}

func (p *procFuncSinkServiceMethodFast) RunContext(ctx context.Context, reqStruct thrift.ReadableStruct) (thrift.WritableStruct, error) {
    return nil, errors.New("not supported")
}

func (p *procFuncSinkServiceMethodFast) RunStreamContext(ctx context.Context) {
    // NOT IMPLEMENTED
}

