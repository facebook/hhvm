/**
 * Autogenerated by Thrift for src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::size;
folly::Range<::apache::thrift::fixtures::types::has_bitwise_ops const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _has_bitwise_ops_EnumMapFactory::ValuesToNamesMapType _has_bitwise_ops_VALUES_TO_NAMES = _has_bitwise_ops_EnumMapFactory::makeValuesToNamesMap();
const _has_bitwise_ops_EnumMapFactory::NamesToValuesMapType _has_bitwise_ops_NAMES_TO_VALUES = _has_bitwise_ops_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING
#endif
}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::size;
folly::Range<::apache::thrift::fixtures::types::is_unscoped const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _is_unscoped_EnumMapFactory::ValuesToNamesMapType _is_unscoped_VALUES_TO_NAMES = _is_unscoped_EnumMapFactory::makeValuesToNamesMap();
const _is_unscoped_EnumMapFactory::NamesToValuesMapType _is_unscoped_NAMES_TO_VALUES = _is_unscoped_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING
#endif
}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::size;
folly::Range<::apache::thrift::fixtures::types::MyForwardRefEnum const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyForwardRefEnum_EnumMapFactory::ValuesToNamesMapType _MyForwardRefEnum_VALUES_TO_NAMES = _MyForwardRefEnum_EnumMapFactory::makeValuesToNamesMap();
const _MyForwardRefEnum_EnumMapFactory::NamesToValuesMapType _MyForwardRefEnum_NAMES_TO_VALUES = _MyForwardRefEnum_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING
#endif
}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::size;
folly::Range<::apache::thrift::fixtures::types::MyEnumA const*> const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyEnumA>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyEnumA>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::MyEnumA>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift

namespace apache { namespace thrift { namespace fixtures { namespace types {
#ifndef ANDROID
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _MyEnumA_EnumMapFactory::ValuesToNamesMapType _MyEnumA_VALUES_TO_NAMES = _MyEnumA_EnumMapFactory::makeValuesToNamesMap();
const _MyEnumA_EnumMapFactory::NamesToValuesMapType _MyEnumA_NAMES_TO_VALUES = _MyEnumA_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING
#endif
}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::decorated_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::decorated_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece decorated_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<decorated_struct>::fields_names[folly::to_underlying(ord) - 1];
}

decorated_struct::decorated_struct(const decorated_struct&) = default;
decorated_struct& decorated_struct::operator=(const decorated_struct&) = default;
decorated_struct::decorated_struct(FOLLY_MAYBE_UNUSED decorated_struct&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

decorated_struct& decorated_struct::operator=(FOLLY_MAYBE_UNUSED decorated_struct&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


decorated_struct::decorated_struct(apache::thrift::FragileConstructor, ::std::string field__arg) :
    __fbthrift_field_field(std::move(field__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void decorated_struct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

void decorated_struct::__fbthrift_clear_terse_fields() {
}

bool decorated_struct::__fbthrift_is_empty() const {
  return false;
}

bool decorated_struct::operator==(FOLLY_MAYBE_UNUSED const decorated_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return false;
  }
  return true;
}

bool decorated_struct::operator<(FOLLY_MAYBE_UNUSED const decorated_struct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.field_ref() == rhs.field_ref())) {
    return lhs.field_ref() < rhs.field_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED decorated_struct& a, FOLLY_MAYBE_UNUSED decorated_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

template void decorated_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t decorated_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t decorated_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void decorated_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t decorated_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t decorated_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t decorated_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ContainerStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ContainerStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ContainerStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ContainerStruct>::fields_names[folly::to_underlying(ord) - 1];
}

ContainerStruct::ContainerStruct(const ContainerStruct&) = default;
ContainerStruct& ContainerStruct::operator=(const ContainerStruct&) = default;
ContainerStruct::ContainerStruct() {
}


ContainerStruct::~ContainerStruct() {}

ContainerStruct::ContainerStruct(FOLLY_MAYBE_UNUSED ContainerStruct&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __fbthrift_field_fieldH(std::move(other.__fbthrift_field_fieldH)),
    __isset(other.__isset) {
}

ContainerStruct& ContainerStruct::operator=(FOLLY_MAYBE_UNUSED ContainerStruct&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    this->__fbthrift_field_fieldH = std::move(other.__fbthrift_field_fieldH);
    __isset = other.__isset;
    return *this;
}


ContainerStruct::ContainerStruct(apache::thrift::FragileConstructor, ::std::vector<::std::int32_t> fieldA__arg, std::list<::std::int32_t> fieldB__arg, std::deque<::std::int32_t> fieldC__arg, folly::fbvector<::std::int32_t> fieldD__arg, folly::small_vector<::std::int32_t> fieldE__arg, folly::sorted_vector_set<::std::int32_t> fieldF__arg, folly::sorted_vector_map<::std::int32_t, ::std::string> fieldG__arg, ::apache::thrift::fixtures::types::SomeMap fieldH__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)),
    __fbthrift_field_fieldH(std::move(fieldH__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
}


void ContainerStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA.clear();
  this->__fbthrift_field_fieldB.clear();
  this->__fbthrift_field_fieldC.clear();
  this->__fbthrift_field_fieldD.clear();
  this->__fbthrift_field_fieldE.clear();
  this->__fbthrift_field_fieldF.clear();
  this->__fbthrift_field_fieldG.clear();
  this->__fbthrift_field_fieldH.clear();
  __isset = {};
}

void ContainerStruct::__fbthrift_clear_terse_fields() {
}

bool ContainerStruct::__fbthrift_is_empty() const {
  return false;
}

bool ContainerStruct::operator==(FOLLY_MAYBE_UNUSED const ContainerStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  if (!(lhs.fieldB_ref() == rhs.fieldB_ref())) {
    return false;
  }
  if (!(lhs.fieldC_ref() == rhs.fieldC_ref())) {
    return false;
  }
  if (!(lhs.fieldD_ref() == rhs.fieldD_ref())) {
    return false;
  }
  if (!(lhs.fieldE_ref() == rhs.fieldE_ref())) {
    return false;
  }
  if (!(lhs.fieldF_ref() == rhs.fieldF_ref())) {
    return false;
  }
  if (!(lhs.fieldG_ref() == rhs.fieldG_ref())) {
    return false;
  }
  if (!(lhs.fieldH_ref() == rhs.fieldH_ref())) {
    return false;
  }
  return true;
}

const ::std::vector<::std::int32_t>& ContainerStruct::get_fieldA() const& {
  return __fbthrift_field_fieldA;
}

::std::vector<::std::int32_t> ContainerStruct::get_fieldA() && {
  return std::move(__fbthrift_field_fieldA);
}

const std::list<::std::int32_t>& ContainerStruct::get_fieldB() const& {
  return __fbthrift_field_fieldB;
}

std::list<::std::int32_t> ContainerStruct::get_fieldB() && {
  return std::move(__fbthrift_field_fieldB);
}

const std::deque<::std::int32_t>& ContainerStruct::get_fieldC() const& {
  return __fbthrift_field_fieldC;
}

std::deque<::std::int32_t> ContainerStruct::get_fieldC() && {
  return std::move(__fbthrift_field_fieldC);
}

const folly::fbvector<::std::int32_t>& ContainerStruct::get_fieldD() const& {
  return __fbthrift_field_fieldD;
}

folly::fbvector<::std::int32_t> ContainerStruct::get_fieldD() && {
  return std::move(__fbthrift_field_fieldD);
}

const folly::small_vector<::std::int32_t>& ContainerStruct::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

folly::small_vector<::std::int32_t> ContainerStruct::get_fieldE() && {
  return std::move(__fbthrift_field_fieldE);
}

const folly::sorted_vector_set<::std::int32_t>& ContainerStruct::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

folly::sorted_vector_set<::std::int32_t> ContainerStruct::get_fieldF() && {
  return std::move(__fbthrift_field_fieldF);
}

const folly::sorted_vector_map<::std::int32_t, ::std::string>& ContainerStruct::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

folly::sorted_vector_map<::std::int32_t, ::std::string> ContainerStruct::get_fieldG() && {
  return std::move(__fbthrift_field_fieldG);
}

const ::apache::thrift::fixtures::types::SomeMap& ContainerStruct::get_fieldH() const& {
  return __fbthrift_field_fieldH;
}

::apache::thrift::fixtures::types::SomeMap ContainerStruct::get_fieldH() && {
  return std::move(__fbthrift_field_fieldH);
}


void swap(FOLLY_MAYBE_UNUSED ContainerStruct& a, FOLLY_MAYBE_UNUSED ContainerStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__fbthrift_field_fieldH, b.__fbthrift_field_fieldH);
  swap(a.__isset, b.__isset);
}

template void ContainerStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ContainerStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ContainerStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ContainerStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ContainerStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ContainerStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ContainerStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::CppTypeStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::CppTypeStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece CppTypeStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CppTypeStruct>::fields_names[folly::to_underlying(ord) - 1];
}

CppTypeStruct::CppTypeStruct(const CppTypeStruct&) = default;
CppTypeStruct& CppTypeStruct::operator=(const CppTypeStruct&) = default;
CppTypeStruct::CppTypeStruct(FOLLY_MAYBE_UNUSED CppTypeStruct&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __isset(other.__isset) {
}

CppTypeStruct& CppTypeStruct::operator=(FOLLY_MAYBE_UNUSED CppTypeStruct&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    __isset = other.__isset;
    return *this;
}


CppTypeStruct::CppTypeStruct(apache::thrift::FragileConstructor, std::list<int32_t> fieldA__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void CppTypeStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA.clear();
  __isset = {};
}

void CppTypeStruct::__fbthrift_clear_terse_fields() {
}

bool CppTypeStruct::__fbthrift_is_empty() const {
  return false;
}

bool CppTypeStruct::operator==(FOLLY_MAYBE_UNUSED const CppTypeStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return false;
  }
  return true;
}

bool CppTypeStruct::operator<(FOLLY_MAYBE_UNUSED const CppTypeStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.fieldA_ref() == rhs.fieldA_ref())) {
    return lhs.fieldA_ref() < rhs.fieldA_ref();
  }
  return false;
}

const std::list<int32_t>& CppTypeStruct::get_fieldA() const& {
  return __fbthrift_field_fieldA;
}

std::list<int32_t> CppTypeStruct::get_fieldA() && {
  return std::move(__fbthrift_field_fieldA);
}


void swap(FOLLY_MAYBE_UNUSED CppTypeStruct& a, FOLLY_MAYBE_UNUSED CppTypeStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__isset, b.__isset);
}

template void CppTypeStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CppTypeStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CppTypeStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CppTypeStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CppTypeStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CppTypeStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::VirtualStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::VirtualStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece VirtualStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<VirtualStruct>::fields_names[folly::to_underlying(ord) - 1];
}

VirtualStruct::VirtualStruct(const VirtualStruct&) = default;
VirtualStruct& VirtualStruct::operator=(const VirtualStruct&) = default;
VirtualStruct::VirtualStruct(FOLLY_MAYBE_UNUSED VirtualStruct&& other) noexcept :
    __fbthrift_field_MyIntField(std::move(other.__fbthrift_field_MyIntField)),
    __isset(other.__isset) {
}

VirtualStruct& VirtualStruct::operator=(FOLLY_MAYBE_UNUSED VirtualStruct&& other) noexcept {
    this->__fbthrift_field_MyIntField = std::move(other.__fbthrift_field_MyIntField);
    __isset = other.__isset;
    return *this;
}


VirtualStruct::VirtualStruct(apache::thrift::FragileConstructor, ::std::int64_t MyIntField__arg) :
    __fbthrift_field_MyIntField(std::move(MyIntField__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void VirtualStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_MyIntField = ::std::int64_t();
  __isset = {};
}

void VirtualStruct::__fbthrift_clear_terse_fields() {
}

bool VirtualStruct::__fbthrift_is_empty() const {
  return false;
}

bool VirtualStruct::operator==(FOLLY_MAYBE_UNUSED const VirtualStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return false;
  }
  return true;
}

bool VirtualStruct::operator<(FOLLY_MAYBE_UNUSED const VirtualStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return lhs.MyIntField_ref() < rhs.MyIntField_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED VirtualStruct& a, FOLLY_MAYBE_UNUSED VirtualStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_MyIntField, b.__fbthrift_field_MyIntField);
  swap(a.__isset, b.__isset);
}

template void VirtualStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t VirtualStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t VirtualStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void VirtualStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t VirtualStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t VirtualStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t VirtualStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::MyStructWithForwardRefEnum>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece MyStructWithForwardRefEnum::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyStructWithForwardRefEnum>::fields_names[folly::to_underlying(ord) - 1];
}

MyStructWithForwardRefEnum::MyStructWithForwardRefEnum(const MyStructWithForwardRefEnum&) = default;
MyStructWithForwardRefEnum& MyStructWithForwardRefEnum::operator=(const MyStructWithForwardRefEnum&) = default;
MyStructWithForwardRefEnum::MyStructWithForwardRefEnum(FOLLY_MAYBE_UNUSED MyStructWithForwardRefEnum&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __isset(other.__isset) {
}

MyStructWithForwardRefEnum& MyStructWithForwardRefEnum::operator=(FOLLY_MAYBE_UNUSED MyStructWithForwardRefEnum&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    __isset = other.__isset;
    return *this;
}


MyStructWithForwardRefEnum::MyStructWithForwardRefEnum(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::MyForwardRefEnum a__arg, ::apache::thrift::fixtures::types::MyForwardRefEnum b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void MyStructWithForwardRefEnum::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::apache::thrift::fixtures::types::MyForwardRefEnum();
  this->__fbthrift_field_b = ::apache::thrift::fixtures::types::MyForwardRefEnum();
  __isset = {};
}

void MyStructWithForwardRefEnum::__fbthrift_clear_terse_fields() {
}

bool MyStructWithForwardRefEnum::__fbthrift_is_empty() const {
  return false;
}

bool MyStructWithForwardRefEnum::operator==(FOLLY_MAYBE_UNUSED const MyStructWithForwardRefEnum& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  return true;
}

bool MyStructWithForwardRefEnum::operator<(FOLLY_MAYBE_UNUSED const MyStructWithForwardRefEnum& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED MyStructWithForwardRefEnum& a, FOLLY_MAYBE_UNUSED MyStructWithForwardRefEnum& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}

template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStructWithForwardRefEnum::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStructWithForwardRefEnum::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStructWithForwardRefEnum::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::TrivialNumeric>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::TrivialNumeric>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece TrivialNumeric::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TrivialNumeric>::fields_names[folly::to_underlying(ord) - 1];
}


TrivialNumeric::TrivialNumeric(apache::thrift::FragileConstructor, ::std::int32_t a__arg, bool b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void TrivialNumeric::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = bool();
  __isset = {};
}

void TrivialNumeric::__fbthrift_clear_terse_fields() {
}

bool TrivialNumeric::__fbthrift_is_empty() const {
  return false;
}

bool TrivialNumeric::operator==(FOLLY_MAYBE_UNUSED const TrivialNumeric& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  return true;
}

bool TrivialNumeric::operator<(FOLLY_MAYBE_UNUSED const TrivialNumeric& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED TrivialNumeric& a, FOLLY_MAYBE_UNUSED TrivialNumeric& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}

template void TrivialNumeric::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TrivialNumeric::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TrivialNumeric::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TrivialNumeric::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TrivialNumeric::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TrivialNumeric::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::TrivialNestedWithDefault>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::TrivialNestedWithDefault>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece TrivialNestedWithDefault::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TrivialNestedWithDefault>::fields_names[folly::to_underlying(ord) - 1];
}


TrivialNestedWithDefault::TrivialNestedWithDefault(apache::thrift::FragileConstructor, ::std::int32_t z__arg, ::apache::thrift::fixtures::types::TrivialNumeric n__arg) :
    __fbthrift_field_z(std::move(z__arg)),
    __fbthrift_field_n(std::move(n__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void TrivialNestedWithDefault::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_z = ::std::int32_t();
  ::apache::thrift::clear(this->__fbthrift_field_n);
  __isset = {};
}

void TrivialNestedWithDefault::__fbthrift_clear_terse_fields() {
}

bool TrivialNestedWithDefault::__fbthrift_is_empty() const {
  return false;
}

bool TrivialNestedWithDefault::operator==(FOLLY_MAYBE_UNUSED const TrivialNestedWithDefault& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.z_ref() == rhs.z_ref())) {
    return false;
  }
  if (!(lhs.n_ref() == rhs.n_ref())) {
    return false;
  }
  return true;
}

bool TrivialNestedWithDefault::operator<(FOLLY_MAYBE_UNUSED const TrivialNestedWithDefault& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.z_ref() == rhs.z_ref())) {
    return lhs.z_ref() < rhs.z_ref();
  }
  if (!(lhs.n_ref() == rhs.n_ref())) {
    return lhs.n_ref() < rhs.n_ref();
  }
  return false;
}

const ::apache::thrift::fixtures::types::TrivialNumeric& TrivialNestedWithDefault::get_n() const& {
  return __fbthrift_field_n;
}

::apache::thrift::fixtures::types::TrivialNumeric TrivialNestedWithDefault::get_n() && {
  return std::move(__fbthrift_field_n);
}


void swap(FOLLY_MAYBE_UNUSED TrivialNestedWithDefault& a, FOLLY_MAYBE_UNUSED TrivialNestedWithDefault& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_z, b.__fbthrift_field_z);
  swap(a.__fbthrift_field_n, b.__fbthrift_field_n);
  swap(a.__isset, b.__isset);
}

template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TrivialNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TrivialNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TrivialNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TrivialNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TrivialNestedWithDefault,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::TrivialNumeric>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ComplexString>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ComplexString>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ComplexString::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ComplexString>::fields_names[folly::to_underlying(ord) - 1];
}

ComplexString::ComplexString(const ComplexString&) = default;
ComplexString& ComplexString::operator=(const ComplexString&) = default;
ComplexString::ComplexString(FOLLY_MAYBE_UNUSED ComplexString&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __isset(other.__isset) {
}

ComplexString& ComplexString::operator=(FOLLY_MAYBE_UNUSED ComplexString&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    __isset = other.__isset;
    return *this;
}


ComplexString::ComplexString(apache::thrift::FragileConstructor, ::std::string a__arg, ::std::map<::std::string, ::std::int32_t> b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void ComplexString::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_b.clear();
  __isset = {};
}

void ComplexString::__fbthrift_clear_terse_fields() {
}

bool ComplexString::__fbthrift_is_empty() const {
  return false;
}

bool ComplexString::operator==(FOLLY_MAYBE_UNUSED const ComplexString& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return false;
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return false;
  }
  return true;
}

bool ComplexString::operator<(FOLLY_MAYBE_UNUSED const ComplexString& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.a_ref() == rhs.a_ref())) {
    return lhs.a_ref() < rhs.a_ref();
  }
  if (!(lhs.b_ref() == rhs.b_ref())) {
    return lhs.b_ref() < rhs.b_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::int32_t>& ComplexString::get_b() const& {
  return __fbthrift_field_b;
}

::std::map<::std::string, ::std::int32_t> ComplexString::get_b() && {
  return std::move(__fbthrift_field_b);
}


void swap(FOLLY_MAYBE_UNUSED ComplexString& a, FOLLY_MAYBE_UNUSED ComplexString& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}

template void ComplexString::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexString::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexString::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexString::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexString::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexString::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexString::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ComplexNestedWithDefault>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ComplexNestedWithDefault>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ComplexNestedWithDefault::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ComplexNestedWithDefault>::fields_names[folly::to_underlying(ord) - 1];
}

ComplexNestedWithDefault::ComplexNestedWithDefault(const ComplexNestedWithDefault&) = default;
ComplexNestedWithDefault& ComplexNestedWithDefault::operator=(const ComplexNestedWithDefault&) = default;
ComplexNestedWithDefault::ComplexNestedWithDefault(FOLLY_MAYBE_UNUSED ComplexNestedWithDefault&& other) noexcept :
    __fbthrift_field_z(std::move(other.__fbthrift_field_z)),
    __fbthrift_field_n(std::move(other.__fbthrift_field_n)),
    __isset(other.__isset) {
}

ComplexNestedWithDefault& ComplexNestedWithDefault::operator=(FOLLY_MAYBE_UNUSED ComplexNestedWithDefault&& other) noexcept {
    this->__fbthrift_field_z = std::move(other.__fbthrift_field_z);
    this->__fbthrift_field_n = std::move(other.__fbthrift_field_n);
    __isset = other.__isset;
    return *this;
}


ComplexNestedWithDefault::ComplexNestedWithDefault(apache::thrift::FragileConstructor, ::std::string z__arg, ::apache::thrift::fixtures::types::ComplexString n__arg) :
    __fbthrift_field_z(std::move(z__arg)),
    __fbthrift_field_n(std::move(n__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void ComplexNestedWithDefault::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_z = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  ::apache::thrift::clear(this->__fbthrift_field_n);
  __isset = {};
}

void ComplexNestedWithDefault::__fbthrift_clear_terse_fields() {
}

bool ComplexNestedWithDefault::__fbthrift_is_empty() const {
  return false;
}

bool ComplexNestedWithDefault::operator==(FOLLY_MAYBE_UNUSED const ComplexNestedWithDefault& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.z_ref() == rhs.z_ref())) {
    return false;
  }
  if (!(lhs.n_ref() == rhs.n_ref())) {
    return false;
  }
  return true;
}

bool ComplexNestedWithDefault::operator<(FOLLY_MAYBE_UNUSED const ComplexNestedWithDefault& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.z_ref() == rhs.z_ref())) {
    return lhs.z_ref() < rhs.z_ref();
  }
  if (!(lhs.n_ref() == rhs.n_ref())) {
    return lhs.n_ref() < rhs.n_ref();
  }
  return false;
}

const ::apache::thrift::fixtures::types::ComplexString& ComplexNestedWithDefault::get_n() const& {
  return __fbthrift_field_n;
}

::apache::thrift::fixtures::types::ComplexString ComplexNestedWithDefault::get_n() && {
  return std::move(__fbthrift_field_n);
}


void swap(FOLLY_MAYBE_UNUSED ComplexNestedWithDefault& a, FOLLY_MAYBE_UNUSED ComplexNestedWithDefault& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_z, b.__fbthrift_field_z);
  swap(a.__fbthrift_field_n, b.__fbthrift_field_n);
  swap(a.__isset, b.__isset);
}

template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ComplexNestedWithDefault::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ComplexNestedWithDefault::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ComplexNestedWithDefault::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ComplexNestedWithDefault::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexNestedWithDefault,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ComplexString>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MinPadding>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::MinPadding>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece MinPadding::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MinPadding>::fields_names[folly::to_underlying(ord) - 1];
}

MinPadding::MinPadding(const MinPadding&) = default;
MinPadding& MinPadding::operator=(const MinPadding&) = default;
MinPadding::MinPadding(FOLLY_MAYBE_UNUSED MinPadding&& other) noexcept :
    __fbthrift_field_big(std::move(other.__fbthrift_field_big)),
    __fbthrift_field_biggish(std::move(other.__fbthrift_field_biggish)),
    __fbthrift_field_medium(std::move(other.__fbthrift_field_medium)),
    __fbthrift_field_small(std::move(other.__fbthrift_field_small)),
    __fbthrift_field_tiny(std::move(other.__fbthrift_field_tiny)) {
}

MinPadding& MinPadding::operator=(FOLLY_MAYBE_UNUSED MinPadding&& other) noexcept {
    this->__fbthrift_field_big = std::move(other.__fbthrift_field_big);
    this->__fbthrift_field_biggish = std::move(other.__fbthrift_field_biggish);
    this->__fbthrift_field_medium = std::move(other.__fbthrift_field_medium);
    this->__fbthrift_field_small = std::move(other.__fbthrift_field_small);
    this->__fbthrift_field_tiny = std::move(other.__fbthrift_field_tiny);
    return *this;
}


MinPadding::MinPadding(apache::thrift::FragileConstructor, ::std::int8_t small__arg, ::std::int64_t big__arg, ::std::int16_t medium__arg, ::std::int32_t biggish__arg, ::std::int8_t tiny__arg) :
    __fbthrift_field_big(std::move(big__arg)),
    __fbthrift_field_biggish(std::move(biggish__arg)),
    __fbthrift_field_medium(std::move(medium__arg)),
    __fbthrift_field_small(std::move(small__arg)),
    __fbthrift_field_tiny(std::move(tiny__arg)) {
}


void MinPadding::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_small = ::std::int8_t();
  this->__fbthrift_field_big = ::std::int64_t();
  this->__fbthrift_field_medium = ::std::int16_t();
  this->__fbthrift_field_biggish = ::std::int32_t();
  this->__fbthrift_field_tiny = ::std::int8_t();
}

void MinPadding::__fbthrift_clear_terse_fields() {
}

bool MinPadding::__fbthrift_is_empty() const {
  return false;
}

bool MinPadding::operator==(FOLLY_MAYBE_UNUSED const MinPadding& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.small_ref() == rhs.small_ref())) {
    return false;
  }
  if (!(lhs.big_ref() == rhs.big_ref())) {
    return false;
  }
  if (!(lhs.medium_ref() == rhs.medium_ref())) {
    return false;
  }
  if (!(lhs.biggish_ref() == rhs.biggish_ref())) {
    return false;
  }
  if (!(lhs.tiny_ref() == rhs.tiny_ref())) {
    return false;
  }
  return true;
}

bool MinPadding::operator<(FOLLY_MAYBE_UNUSED const MinPadding& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.small_ref() == rhs.small_ref())) {
    return lhs.small_ref() < rhs.small_ref();
  }
  if (!(lhs.big_ref() == rhs.big_ref())) {
    return lhs.big_ref() < rhs.big_ref();
  }
  if (!(lhs.medium_ref() == rhs.medium_ref())) {
    return lhs.medium_ref() < rhs.medium_ref();
  }
  if (!(lhs.biggish_ref() == rhs.biggish_ref())) {
    return lhs.biggish_ref() < rhs.biggish_ref();
  }
  if (!(lhs.tiny_ref() == rhs.tiny_ref())) {
    return lhs.tiny_ref() < rhs.tiny_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED MinPadding& a, FOLLY_MAYBE_UNUSED MinPadding& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_big, b.__fbthrift_field_big);
  swap(a.__fbthrift_field_biggish, b.__fbthrift_field_biggish);
  swap(a.__fbthrift_field_medium, b.__fbthrift_field_medium);
  swap(a.__fbthrift_field_small, b.__fbthrift_field_small);
  swap(a.__fbthrift_field_tiny, b.__fbthrift_field_tiny);
}

template void MinPadding::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MinPadding::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MinPadding::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MinPadding::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MinPadding::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MinPadding::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MinPadding::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyDataItem>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::MyDataItem>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece MyDataItem::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyDataItem>::fields_names[folly::to_underlying(ord) - 1];
}


MyDataItem::MyDataItem(apache::thrift::FragileConstructor) {}


void MyDataItem::__fbthrift_clear() {
  // clear all fields
}

void MyDataItem::__fbthrift_clear_terse_fields() {
}

bool MyDataItem::__fbthrift_is_empty() const {
  return true;
}




void swap(FOLLY_MAYBE_UNUSED MyDataItem& a, FOLLY_MAYBE_UNUSED MyDataItem& b) {
  using ::std::swap;
}

template void MyDataItem::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyDataItem::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyDataItem::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyDataItem::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyDataItem::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyDataItem::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyDataItem::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyDataItem::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::MyStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::MyStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece MyStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyStruct>::fields_names[folly::to_underlying(ord) - 1];
}

MyStruct::MyStruct(const MyStruct&) = default;
MyStruct& MyStruct::operator=(const MyStruct&) = default;
MyStruct::MyStruct(FOLLY_MAYBE_UNUSED MyStruct&& other) noexcept :
    __fbthrift_field_MyIntField(std::move(other.__fbthrift_field_MyIntField)),
    __fbthrift_field_MyStringField(std::move(other.__fbthrift_field_MyStringField)),
    __fbthrift_field_majorVer(std::move(other.__fbthrift_field_majorVer)),
    __fbthrift_field_data(std::move(other.__fbthrift_field_data)),
    __isset(other.__isset) {
}

MyStruct& MyStruct::operator=(FOLLY_MAYBE_UNUSED MyStruct&& other) noexcept {
    this->__fbthrift_field_MyIntField = std::move(other.__fbthrift_field_MyIntField);
    this->__fbthrift_field_MyStringField = std::move(other.__fbthrift_field_MyStringField);
    this->__fbthrift_field_majorVer = std::move(other.__fbthrift_field_majorVer);
    this->__fbthrift_field_data = std::move(other.__fbthrift_field_data);
    __isset = other.__isset;
    return *this;
}


MyStruct::MyStruct(apache::thrift::FragileConstructor, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::int64_t majorVer__arg, ::apache::thrift::fixtures::types::MyDataItem data__arg) :
    __fbthrift_field_MyIntField(std::move(MyIntField__arg)),
    __fbthrift_field_MyStringField(std::move(MyStringField__arg)),
    __fbthrift_field_majorVer(std::move(majorVer__arg)),
    __fbthrift_field_data(std::move(data__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void MyStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_MyIntField = ::std::int64_t();
  this->__fbthrift_field_MyStringField = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_majorVer = ::std::int64_t();
  __isset = {};
}

void MyStruct::__fbthrift_clear_terse_fields() {
}

bool MyStruct::__fbthrift_is_empty() const {
  return false;
}



const ::apache::thrift::fixtures::types::MyDataItem& MyStruct::get_data() const& {
  return __fbthrift_field_data;
}

::apache::thrift::fixtures::types::MyDataItem MyStruct::get_data() && {
  return std::move(__fbthrift_field_data);
}


void swap(FOLLY_MAYBE_UNUSED MyStruct& a, FOLLY_MAYBE_UNUSED MyStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_MyIntField, b.__fbthrift_field_MyIntField);
  swap(a.__fbthrift_field_MyStringField, b.__fbthrift_field_MyStringField);
  swap(a.__fbthrift_field_majorVer, b.__fbthrift_field_majorVer);
  swap(a.__fbthrift_field_data, b.__fbthrift_field_data);
  swap(a.__isset, b.__isset);
}

template void MyStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void MyStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t MyStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t MyStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t MyStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::MyDataItem>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::Renamed>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::Renamed>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece Renamed::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<Renamed>::fields_names[folly::to_underlying(ord) - 1];
}


Renamed::Renamed(apache::thrift::FragileConstructor, ::std::int64_t bar__arg) :
    __fbthrift_field_bar(std::move(bar__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void Renamed::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_bar = ::std::int64_t();
  __isset = {};
}

void Renamed::__fbthrift_clear_terse_fields() {
}

bool Renamed::__fbthrift_is_empty() const {
  return false;
}

bool Renamed::operator==(FOLLY_MAYBE_UNUSED const Renamed& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.bar_ref() == rhs.bar_ref())) {
    return false;
  }
  return true;
}

bool Renamed::operator<(FOLLY_MAYBE_UNUSED const Renamed& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.bar_ref() == rhs.bar_ref())) {
    return lhs.bar_ref() < rhs.bar_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED Renamed& a, FOLLY_MAYBE_UNUSED Renamed& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_bar, b.__fbthrift_field_bar);
  swap(a.__isset, b.__isset);
}

template void Renamed::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t Renamed::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t Renamed::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t Renamed::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void Renamed::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t Renamed::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t Renamed::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t Renamed::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AnnotatedTypes>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::AnnotatedTypes>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece AnnotatedTypes::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AnnotatedTypes>::fields_names[folly::to_underlying(ord) - 1];
}

AnnotatedTypes::AnnotatedTypes(const AnnotatedTypes&) = default;
AnnotatedTypes& AnnotatedTypes::operator=(const AnnotatedTypes&) = default;
AnnotatedTypes::AnnotatedTypes(FOLLY_MAYBE_UNUSED AnnotatedTypes&& other) noexcept :
    __fbthrift_field_binary_field(std::move(other.__fbthrift_field_binary_field)),
    __fbthrift_field_list_field(std::move(other.__fbthrift_field_list_field)),
    __isset(other.__isset) {
}

AnnotatedTypes& AnnotatedTypes::operator=(FOLLY_MAYBE_UNUSED AnnotatedTypes&& other) noexcept {
    this->__fbthrift_field_binary_field = std::move(other.__fbthrift_field_binary_field);
    this->__fbthrift_field_list_field = std::move(other.__fbthrift_field_list_field);
    __isset = other.__isset;
    return *this;
}


AnnotatedTypes::AnnotatedTypes(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::TBinary binary_field__arg, ::apache::thrift::fixtures::types::SomeListOfTypeMap list_field__arg) :
    __fbthrift_field_binary_field(std::move(binary_field__arg)),
    __fbthrift_field_list_field(std::move(list_field__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void AnnotatedTypes::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_binary_field = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_list_field.clear();
  __isset = {};
}

void AnnotatedTypes::__fbthrift_clear_terse_fields() {
}

bool AnnotatedTypes::__fbthrift_is_empty() const {
  return false;
}

bool AnnotatedTypes::operator==(FOLLY_MAYBE_UNUSED const AnnotatedTypes& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_binary_field, rhs.__fbthrift_field_binary_field)) {
    return false;
  }
  if (!(lhs.list_field_ref() == rhs.list_field_ref())) {
    return false;
  }
  return true;
}

const ::apache::thrift::fixtures::types::SomeListOfTypeMap& AnnotatedTypes::get_list_field() const& {
  return __fbthrift_field_list_field;
}

::apache::thrift::fixtures::types::SomeListOfTypeMap AnnotatedTypes::get_list_field() && {
  return std::move(__fbthrift_field_list_field);
}


void swap(FOLLY_MAYBE_UNUSED AnnotatedTypes& a, FOLLY_MAYBE_UNUSED AnnotatedTypes& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_binary_field, b.__fbthrift_field_binary_field);
  swap(a.__fbthrift_field_list_field, b.__fbthrift_field_list_field);
  swap(a.__isset, b.__isset);
}

template void AnnotatedTypes::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AnnotatedTypes::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AnnotatedTypes::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AnnotatedTypes::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AnnotatedTypes::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AnnotatedTypes::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AnnotatedTypes::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AnnotatedTypes::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ForwardUsageStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ForwardUsageStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageStruct>::fields_names[folly::to_underlying(ord) - 1];
}

ForwardUsageStruct::ForwardUsageStruct(const ForwardUsageStruct&) = default;
ForwardUsageStruct& ForwardUsageStruct::operator=(const ForwardUsageStruct&) = default;
ForwardUsageStruct::ForwardUsageStruct(FOLLY_MAYBE_UNUSED ForwardUsageStruct&& other) noexcept :
    __fbthrift_field_foo(std::move(other.__fbthrift_field_foo)),
    __isset(other.__isset) {
}

ForwardUsageStruct& ForwardUsageStruct::operator=(FOLLY_MAYBE_UNUSED ForwardUsageStruct&& other) noexcept {
    this->__fbthrift_field_foo = std::move(other.__fbthrift_field_foo);
    __isset = other.__isset;
    return *this;
}


ForwardUsageStruct::ForwardUsageStruct(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg) :
    __fbthrift_field_foo(std::move(foo__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void ForwardUsageStruct::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_foo);
  __isset = {};
}

void ForwardUsageStruct::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageStruct::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool ForwardUsageStruct::operator==(FOLLY_MAYBE_UNUSED const ForwardUsageStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.foo_ref() == rhs.foo_ref())) {
    return false;
  }
  return true;
}

bool ForwardUsageStruct::operator<(FOLLY_MAYBE_UNUSED const ForwardUsageStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.foo_ref() == rhs.foo_ref())) {
    return lhs.foo_ref() < rhs.foo_ref();
  }
  return false;
}

const ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageStruct::get_foo() const& {
  return foo_ref().has_value() ? std::addressof(__fbthrift_field_foo) : nullptr;
}

::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageStruct::get_foo() & {
  return foo_ref().has_value() ? std::addressof(__fbthrift_field_foo) : nullptr;
}


void swap(FOLLY_MAYBE_UNUSED ForwardUsageStruct& a, FOLLY_MAYBE_UNUSED ForwardUsageStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_foo, b.__fbthrift_field_foo);
  swap(a.__isset, b.__isset);
}

template void ForwardUsageStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageStruct,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageRoot>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ForwardUsageRoot>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ForwardUsageRoot::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageRoot>::fields_names[folly::to_underlying(ord) - 1];
}

ForwardUsageRoot::ForwardUsageRoot(const ForwardUsageRoot& srcObj) :
    __fbthrift_field_ForwardUsageStruct(srcObj.__fbthrift_field_ForwardUsageStruct),
    __fbthrift_field_ForwardUsageByRef(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_ForwardUsageByRef)),
    __isset(srcObj.__isset) {
}

ForwardUsageRoot& ForwardUsageRoot::operator=(const ForwardUsageRoot& other) {
  ForwardUsageRoot tmp(other);
  swap(*this, tmp);
  return *this;
}

ForwardUsageRoot::ForwardUsageRoot(FOLLY_MAYBE_UNUSED ForwardUsageRoot&& other) noexcept :
    __fbthrift_field_ForwardUsageStruct(std::move(other.__fbthrift_field_ForwardUsageStruct)),
    __fbthrift_field_ForwardUsageByRef(std::move(other.__fbthrift_field_ForwardUsageByRef)),
    __isset(other.__isset) {
}

ForwardUsageRoot& ForwardUsageRoot::operator=(FOLLY_MAYBE_UNUSED ForwardUsageRoot&& other) noexcept {
    this->__fbthrift_field_ForwardUsageStruct = std::move(other.__fbthrift_field_ForwardUsageStruct);
    this->__fbthrift_field_ForwardUsageByRef = std::move(other.__fbthrift_field_ForwardUsageByRef);
    __isset = other.__isset;
    return *this;
}


ForwardUsageRoot::ForwardUsageRoot(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::ForwardUsageStruct ForwardUsageStruct__arg, ::std::unique_ptr<::apache::thrift::fixtures::types::ForwardUsageByRef> ForwardUsageByRef__arg) :
    __fbthrift_field_ForwardUsageStruct(std::move(ForwardUsageStruct__arg)),
    __fbthrift_field_ForwardUsageByRef(std::move(ForwardUsageByRef__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void ForwardUsageRoot::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_ForwardUsageStruct);
  this->__fbthrift_field_ForwardUsageByRef.reset();
  __isset = {};
}

void ForwardUsageRoot::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageRoot::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__fbthrift_field_ForwardUsageByRef);
}

bool ForwardUsageRoot::operator==(FOLLY_MAYBE_UNUSED const ForwardUsageRoot& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.ForwardUsageStruct_ref() == rhs.ForwardUsageStruct_ref())) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.ForwardUsageByRef_ref(), rhs.ForwardUsageByRef_ref()))) {
    return false;
  }
  return true;
}

bool ForwardUsageRoot::operator<(FOLLY_MAYBE_UNUSED const ForwardUsageRoot& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.ForwardUsageStruct_ref() == rhs.ForwardUsageStruct_ref())) {
    return lhs.ForwardUsageStruct_ref() < rhs.ForwardUsageStruct_ref();
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.ForwardUsageByRef_ref(), rhs.ForwardUsageByRef_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.ForwardUsageByRef_ref(), rhs.ForwardUsageByRef_ref());
  }
  return false;
}

const ::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() const& {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(__fbthrift_field_ForwardUsageStruct) : nullptr;
}

::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() & {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(__fbthrift_field_ForwardUsageStruct) : nullptr;
}


void swap(FOLLY_MAYBE_UNUSED ForwardUsageRoot& a, FOLLY_MAYBE_UNUSED ForwardUsageRoot& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_ForwardUsageStruct, b.__fbthrift_field_ForwardUsageStruct);
  swap(a.__fbthrift_field_ForwardUsageByRef, b.__fbthrift_field_ForwardUsageByRef);
  swap(a.__isset, b.__isset);
}

template void ForwardUsageRoot::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageRoot::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageRoot::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageRoot::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageRoot::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageRoot::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageRoot::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageRoot::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageStruct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageByRef>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::ForwardUsageByRef>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::ForwardUsageByRef>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece ForwardUsageByRef::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageByRef>::fields_names[folly::to_underlying(ord) - 1];
}

ForwardUsageByRef::ForwardUsageByRef(const ForwardUsageByRef&) = default;
ForwardUsageByRef& ForwardUsageByRef::operator=(const ForwardUsageByRef&) = default;
ForwardUsageByRef::ForwardUsageByRef(FOLLY_MAYBE_UNUSED ForwardUsageByRef&& other) noexcept :
    __fbthrift_field_foo(std::move(other.__fbthrift_field_foo)),
    __isset(other.__isset) {
}

ForwardUsageByRef& ForwardUsageByRef::operator=(FOLLY_MAYBE_UNUSED ForwardUsageByRef&& other) noexcept {
    this->__fbthrift_field_foo = std::move(other.__fbthrift_field_foo);
    __isset = other.__isset;
    return *this;
}


ForwardUsageByRef::ForwardUsageByRef(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::ForwardUsageRoot foo__arg) :
    __fbthrift_field_foo(std::move(foo__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void ForwardUsageByRef::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_foo);
  __isset = {};
}

void ForwardUsageByRef::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageByRef::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool ForwardUsageByRef::operator==(FOLLY_MAYBE_UNUSED const ForwardUsageByRef& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.foo_ref() == rhs.foo_ref())) {
    return false;
  }
  return true;
}

bool ForwardUsageByRef::operator<(FOLLY_MAYBE_UNUSED const ForwardUsageByRef& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.foo_ref() == rhs.foo_ref())) {
    return lhs.foo_ref() < rhs.foo_ref();
  }
  return false;
}

const ::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageByRef::get_foo() const& {
  return foo_ref().has_value() ? std::addressof(__fbthrift_field_foo) : nullptr;
}

::apache::thrift::fixtures::types::ForwardUsageRoot* ForwardUsageByRef::get_foo() & {
  return foo_ref().has_value() ? std::addressof(__fbthrift_field_foo) : nullptr;
}


void swap(FOLLY_MAYBE_UNUSED ForwardUsageByRef& a, FOLLY_MAYBE_UNUSED ForwardUsageByRef& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_foo, b.__fbthrift_field_foo);
  swap(a.__isset, b.__isset);
}

template void ForwardUsageByRef::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ForwardUsageByRef::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ForwardUsageByRef::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ForwardUsageByRef::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ForwardUsageByRef::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ForwardUsageByRef::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ForwardUsageByRef::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ForwardUsageByRef::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageByRef,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveEmpty>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::NoexceptMoveEmpty>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece NoexceptMoveEmpty::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<NoexceptMoveEmpty>::fields_names[folly::to_underlying(ord) - 1];
}


NoexceptMoveEmpty::NoexceptMoveEmpty(apache::thrift::FragileConstructor) {}


void NoexceptMoveEmpty::__fbthrift_clear() {
  // clear all fields
}

void NoexceptMoveEmpty::__fbthrift_clear_terse_fields() {
}

bool NoexceptMoveEmpty::__fbthrift_is_empty() const {
  return true;
}

bool NoexceptMoveEmpty::operator==(FOLLY_MAYBE_UNUSED const NoexceptMoveEmpty& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  return true;
}

bool NoexceptMoveEmpty::operator<(FOLLY_MAYBE_UNUSED const NoexceptMoveEmpty& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  return false;
}


void swap(FOLLY_MAYBE_UNUSED NoexceptMoveEmpty& a, FOLLY_MAYBE_UNUSED NoexceptMoveEmpty& b) {
  using ::std::swap;
}

template void NoexceptMoveEmpty::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveEmpty::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveEmpty::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveEmpty::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveEmpty::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveEmpty::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveEmpty::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveEmpty::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveSimpleStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::NoexceptMoveSimpleStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece NoexceptMoveSimpleStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<NoexceptMoveSimpleStruct>::fields_names[folly::to_underlying(ord) - 1];
}


NoexceptMoveSimpleStruct::NoexceptMoveSimpleStruct(apache::thrift::FragileConstructor, ::std::int64_t boolField__arg) :
    __fbthrift_field_boolField(std::move(boolField__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void NoexceptMoveSimpleStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_boolField = ::std::int64_t();
  __isset = {};
}

void NoexceptMoveSimpleStruct::__fbthrift_clear_terse_fields() {
}

bool NoexceptMoveSimpleStruct::__fbthrift_is_empty() const {
  return false;
}

bool NoexceptMoveSimpleStruct::operator==(FOLLY_MAYBE_UNUSED const NoexceptMoveSimpleStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.boolField_ref() == rhs.boolField_ref())) {
    return false;
  }
  return true;
}

bool NoexceptMoveSimpleStruct::operator<(FOLLY_MAYBE_UNUSED const NoexceptMoveSimpleStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.boolField_ref() == rhs.boolField_ref())) {
    return lhs.boolField_ref() < rhs.boolField_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED NoexceptMoveSimpleStruct& a, FOLLY_MAYBE_UNUSED NoexceptMoveSimpleStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_boolField, b.__fbthrift_field_boolField);
  swap(a.__isset, b.__isset);
}

template void NoexceptMoveSimpleStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveSimpleStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveSimpleStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveSimpleStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveSimpleStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoexceptMoveComplexStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::NoexceptMoveComplexStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece NoexceptMoveComplexStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<NoexceptMoveComplexStruct>::fields_names[folly::to_underlying(ord) - 1];
}

NoexceptMoveComplexStruct::NoexceptMoveComplexStruct(const NoexceptMoveComplexStruct&) = default;
NoexceptMoveComplexStruct& NoexceptMoveComplexStruct::operator=(const NoexceptMoveComplexStruct&) = default;
NoexceptMoveComplexStruct::NoexceptMoveComplexStruct() :
      __fbthrift_field_MyBoolField(),
      __fbthrift_field_MyIntField(static_cast<::std::int64_t>(12)),
      __fbthrift_field_MyStringField(apache::thrift::StringTraits<std::string>::fromStringLiteral("test")),
      __fbthrift_field_MyMapEnumAndInt(static_cast<::std::map<::apache::thrift::fixtures::types::MyEnumA, ::std::string>>(std::initializer_list<std::pair<const ::apache::thrift::fixtures::types::MyEnumA, ::std::string>>{{ ::apache::thrift::fixtures::types::MyEnumA::fieldA, apache::thrift::StringTraits<std::string>::fromStringLiteral("fieldA")},
  { ::apache::thrift::fixtures::types::MyEnumA::fieldC, apache::thrift::StringTraits<std::string>::fromStringLiteral("fieldC")}})) {
}


NoexceptMoveComplexStruct::~NoexceptMoveComplexStruct() {}

NoexceptMoveComplexStruct::NoexceptMoveComplexStruct(FOLLY_MAYBE_UNUSED NoexceptMoveComplexStruct&& other) noexcept :
    __fbthrift_field_MyBoolField(std::move(other.__fbthrift_field_MyBoolField)),
    __fbthrift_field_MyIntField(std::move(other.__fbthrift_field_MyIntField)),
    __fbthrift_field_MyStringField(std::move(other.__fbthrift_field_MyStringField)),
    __fbthrift_field_MyStringField2(std::move(other.__fbthrift_field_MyStringField2)),
    __fbthrift_field_MyBinaryField(std::move(other.__fbthrift_field_MyBinaryField)),
    __fbthrift_field_MyBinaryField2(std::move(other.__fbthrift_field_MyBinaryField2)),
    __fbthrift_field_MyBinaryField3(std::move(other.__fbthrift_field_MyBinaryField3)),
    __fbthrift_field_MyBinaryListField4(std::move(other.__fbthrift_field_MyBinaryListField4)),
    __fbthrift_field_MyMapEnumAndInt(std::move(other.__fbthrift_field_MyMapEnumAndInt)),
    __isset(other.__isset) {
}

NoexceptMoveComplexStruct& NoexceptMoveComplexStruct::operator=(FOLLY_MAYBE_UNUSED NoexceptMoveComplexStruct&& other) noexcept {
    this->__fbthrift_field_MyBoolField = std::move(other.__fbthrift_field_MyBoolField);
    this->__fbthrift_field_MyIntField = std::move(other.__fbthrift_field_MyIntField);
    this->__fbthrift_field_MyStringField = std::move(other.__fbthrift_field_MyStringField);
    this->__fbthrift_field_MyStringField2 = std::move(other.__fbthrift_field_MyStringField2);
    this->__fbthrift_field_MyBinaryField = std::move(other.__fbthrift_field_MyBinaryField);
    this->__fbthrift_field_MyBinaryField2 = std::move(other.__fbthrift_field_MyBinaryField2);
    this->__fbthrift_field_MyBinaryField3 = std::move(other.__fbthrift_field_MyBinaryField3);
    this->__fbthrift_field_MyBinaryListField4 = std::move(other.__fbthrift_field_MyBinaryListField4);
    this->__fbthrift_field_MyMapEnumAndInt = std::move(other.__fbthrift_field_MyMapEnumAndInt);
    __isset = other.__isset;
    return *this;
}


NoexceptMoveComplexStruct::NoexceptMoveComplexStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map<::apache::thrift::fixtures::types::MyEnumA, ::std::string> MyMapEnumAndInt__arg) :
    __fbthrift_field_MyBoolField(std::move(MyBoolField__arg)),
    __fbthrift_field_MyIntField(std::move(MyIntField__arg)),
    __fbthrift_field_MyStringField(std::move(MyStringField__arg)),
    __fbthrift_field_MyStringField2(std::move(MyStringField2__arg)),
    __fbthrift_field_MyBinaryField(std::move(MyBinaryField__arg)),
    __fbthrift_field_MyBinaryField2(std::move(MyBinaryField2__arg)),
    __fbthrift_field_MyBinaryField3(std::move(MyBinaryField3__arg)),
    __fbthrift_field_MyBinaryListField4(std::move(MyBinaryListField4__arg)),
    __fbthrift_field_MyMapEnumAndInt(std::move(MyMapEnumAndInt__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
}


void NoexceptMoveComplexStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_MyBoolField = bool();
  this->__fbthrift_field_MyIntField = ::std::int64_t();
  this->__fbthrift_field_MyStringField = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_MyStringField2 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_MyBinaryField = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_MyBinaryField2 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_MyBinaryField3 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_MyBinaryListField4.clear();
  this->__fbthrift_field_MyMapEnumAndInt.clear();
  __isset = {};
}

void NoexceptMoveComplexStruct::__fbthrift_clear_terse_fields() {
}

bool NoexceptMoveComplexStruct::__fbthrift_is_empty() const {
  return false;
}

bool NoexceptMoveComplexStruct::operator==(FOLLY_MAYBE_UNUSED const NoexceptMoveComplexStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.MyBoolField_ref() == rhs.MyBoolField_ref())) {
    return false;
  }
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return false;
  }
  if (!(lhs.MyStringField_ref() == rhs.MyStringField_ref())) {
    return false;
  }
  if (!(lhs.MyStringField2_ref() == rhs.MyStringField2_ref())) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField, rhs.__fbthrift_field_MyBinaryField)) {
    return false;
  }
  if (lhs.MyBinaryField2_ref().has_value() != rhs.MyBinaryField2_ref().has_value() || (lhs.MyBinaryField2_ref().has_value() && !apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField2, rhs.__fbthrift_field_MyBinaryField2))) {
    return false;
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField3, rhs.__fbthrift_field_MyBinaryField3)) {
    return false;
  }
  if (!(lhs.MyBinaryListField4_ref() == rhs.MyBinaryListField4_ref())) {
    return false;
  }
  if (!(lhs.MyMapEnumAndInt_ref() == rhs.MyMapEnumAndInt_ref())) {
    return false;
  }
  return true;
}

bool NoexceptMoveComplexStruct::operator<(FOLLY_MAYBE_UNUSED const NoexceptMoveComplexStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.MyBoolField_ref() == rhs.MyBoolField_ref())) {
    return lhs.MyBoolField_ref() < rhs.MyBoolField_ref();
  }
  if (!(lhs.MyIntField_ref() == rhs.MyIntField_ref())) {
    return lhs.MyIntField_ref() < rhs.MyIntField_ref();
  }
  if (!(lhs.MyStringField_ref() == rhs.MyStringField_ref())) {
    return lhs.MyStringField_ref() < rhs.MyStringField_ref();
  }
  if (!(lhs.MyStringField2_ref() == rhs.MyStringField2_ref())) {
    return lhs.MyStringField2_ref() < rhs.MyStringField2_ref();
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField, rhs.__fbthrift_field_MyBinaryField)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.__fbthrift_field_MyBinaryField, rhs.__fbthrift_field_MyBinaryField);
  }
  if (lhs.MyBinaryField2_ref().has_value() != rhs.MyBinaryField2_ref().has_value() || (lhs.MyBinaryField2_ref().has_value() && !apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField2, rhs.__fbthrift_field_MyBinaryField2))) {
    return !lhs.MyBinaryField2_ref().has_value() || (rhs.MyBinaryField2_ref().has_value() && apache::thrift::StringTraits<std::string>::isLess(lhs.__fbthrift_field_MyBinaryField2, rhs.__fbthrift_field_MyBinaryField2));
  }
  if (!apache::thrift::StringTraits<std::string>::isEqual(lhs.__fbthrift_field_MyBinaryField3, rhs.__fbthrift_field_MyBinaryField3)) {
    return apache::thrift::StringTraits<std::string>::isLess(lhs.__fbthrift_field_MyBinaryField3, rhs.__fbthrift_field_MyBinaryField3);
  }
  if (!(lhs.MyBinaryListField4_ref() == rhs.MyBinaryListField4_ref())) {
    return lhs.MyBinaryListField4_ref() < rhs.MyBinaryListField4_ref();
  }
  if (!(lhs.MyMapEnumAndInt_ref() == rhs.MyMapEnumAndInt_ref())) {
    return lhs.MyMapEnumAndInt_ref() < rhs.MyMapEnumAndInt_ref();
  }
  return false;
}

const ::std::vector<::std::string>& NoexceptMoveComplexStruct::get_MyBinaryListField4() const& {
  return __fbthrift_field_MyBinaryListField4;
}

::std::vector<::std::string> NoexceptMoveComplexStruct::get_MyBinaryListField4() && {
  return std::move(__fbthrift_field_MyBinaryListField4);
}

const ::std::map<::apache::thrift::fixtures::types::MyEnumA, ::std::string>& NoexceptMoveComplexStruct::get_MyMapEnumAndInt() const& {
  return __fbthrift_field_MyMapEnumAndInt;
}

::std::map<::apache::thrift::fixtures::types::MyEnumA, ::std::string> NoexceptMoveComplexStruct::get_MyMapEnumAndInt() && {
  return std::move(__fbthrift_field_MyMapEnumAndInt);
}


void swap(FOLLY_MAYBE_UNUSED NoexceptMoveComplexStruct& a, FOLLY_MAYBE_UNUSED NoexceptMoveComplexStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_MyBoolField, b.__fbthrift_field_MyBoolField);
  swap(a.__fbthrift_field_MyIntField, b.__fbthrift_field_MyIntField);
  swap(a.__fbthrift_field_MyStringField, b.__fbthrift_field_MyStringField);
  swap(a.__fbthrift_field_MyStringField2, b.__fbthrift_field_MyStringField2);
  swap(a.__fbthrift_field_MyBinaryField, b.__fbthrift_field_MyBinaryField);
  swap(a.__fbthrift_field_MyBinaryField2, b.__fbthrift_field_MyBinaryField2);
  swap(a.__fbthrift_field_MyBinaryField3, b.__fbthrift_field_MyBinaryField3);
  swap(a.__fbthrift_field_MyBinaryListField4, b.__fbthrift_field_MyBinaryListField4);
  swap(a.__fbthrift_field_MyMapEnumAndInt, b.__fbthrift_field_MyMapEnumAndInt);
  swap(a.__isset, b.__isset);
}

template void NoexceptMoveComplexStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoexceptMoveComplexStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoexceptMoveComplexStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoexceptMoveComplexStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoexceptMoveComplexStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::NoExceptMoveUnion>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::size;
folly::Range<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type const*> const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::NoExceptMoveUnion::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece NoExceptMoveUnion::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<NoExceptMoveUnion>::fields_names[folly::to_underlying(ord) - 1];
}

void NoExceptMoveUnion::__fbthrift_clear() {
  // clear all fields
  if (getType() == Type::__EMPTY__) { return; }
  switch(getType()) {
    case Type::string_field:
      destruct(value_.string_field);
      break;
    case Type::i32_field:
      destruct(value_.i32_field);
      break;
    default:
      assert(false);
      break;
  }
  type_ = folly::to_underlying(Type::__EMPTY__);
}

bool NoExceptMoveUnion::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}

bool NoExceptMoveUnion::operator==(const NoExceptMoveUnion& rhs) const {
  if (getType() != rhs.getType()) { return false; }
  switch(getType()) {
    case Type::string_field:
      return value_.string_field == rhs.value_.string_field;
    case Type::i32_field:
      return value_.i32_field == rhs.value_.i32_field;
    default:
      return true;
  }
}

bool NoExceptMoveUnion::operator<(FOLLY_MAYBE_UNUSED const NoExceptMoveUnion& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (lhs.getType() != rhs.getType()) {
    return lhs.getType() < rhs.getType();
  }
  switch (lhs.getType()) {
    case Type::string_field:
      return lhs.value_.string_field < rhs.value_.string_field;
    case Type::i32_field:
      return lhs.value_.i32_field < rhs.value_.i32_field;
    default:
      return false;
  }
}

void swap(NoExceptMoveUnion& a, NoExceptMoveUnion& b) {
  NoExceptMoveUnion temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void NoExceptMoveUnion::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NoExceptMoveUnion::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NoExceptMoveUnion::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NoExceptMoveUnion::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NoExceptMoveUnion::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NoExceptMoveUnion::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NoExceptMoveUnion::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NoExceptMoveUnion::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AllocatorAware>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::AllocatorAware>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece AllocatorAware::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AllocatorAware>::fields_names[folly::to_underlying(ord) - 1];
}

AllocatorAware::AllocatorAware(const AllocatorAware& srcObj) :
    __fbthrift_alloc(srcObj.__fbthrift_alloc),
    __fbthrift_field_aa_list(srcObj.__fbthrift_field_aa_list),
    __fbthrift_field_aa_set(srcObj.__fbthrift_field_aa_set),
    __fbthrift_field_aa_map(srcObj.__fbthrift_field_aa_map),
    __fbthrift_field_aa_string(srcObj.__fbthrift_field_aa_string),
    __fbthrift_field_not_a_container(srcObj.__fbthrift_field_not_a_container),
    __fbthrift_field_aa_unique(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::integral>(srcObj.__fbthrift_field_aa_unique)),
    __fbthrift_field_aa_shared(srcObj.__fbthrift_field_aa_shared),
    __isset(srcObj.__isset) {
}

AllocatorAware& AllocatorAware::operator=(const AllocatorAware& other) {
  AllocatorAware tmp(other, get_allocator());
  swap(*this, tmp);
  ::apache::thrift::detail::copy_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
  return *this;
}

AllocatorAware::AllocatorAware() :
    __fbthrift_alloc(allocator_type()),
    __fbthrift_field_aa_list(__fbthrift_alloc),
    __fbthrift_field_aa_set(__fbthrift_alloc),
    __fbthrift_field_aa_map(__fbthrift_alloc),
    __fbthrift_field_aa_string(__fbthrift_alloc),
    __fbthrift_field_not_a_container(),
    __fbthrift_field_aa_unique(folly::allocate_unique<::std::int32_t>(__fbthrift_alloc)),
    __fbthrift_field_aa_shared(std::allocate_shared<::std::int32_t>(__fbthrift_alloc)) {
}


AllocatorAware::~AllocatorAware() {}

AllocatorAware::AllocatorAware(FOLLY_MAYBE_UNUSED AllocatorAware&& other) noexcept :
    __fbthrift_alloc(std::move(other.__fbthrift_alloc)),
    __fbthrift_field_aa_list(std::move(other.__fbthrift_field_aa_list)),
    __fbthrift_field_aa_set(std::move(other.__fbthrift_field_aa_set)),
    __fbthrift_field_aa_map(std::move(other.__fbthrift_field_aa_map)),
    __fbthrift_field_aa_string(std::move(other.__fbthrift_field_aa_string)),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __fbthrift_field_aa_unique(std::move(other.__fbthrift_field_aa_unique)),
    __fbthrift_field_aa_shared(std::move(other.__fbthrift_field_aa_shared)),
    __isset(other.__isset) {
}

AllocatorAware& AllocatorAware::operator=(FOLLY_MAYBE_UNUSED AllocatorAware&& other) noexcept {
    this->__fbthrift_field_aa_list = std::move(other.__fbthrift_field_aa_list);
    this->__fbthrift_field_aa_set = std::move(other.__fbthrift_field_aa_set);
    this->__fbthrift_field_aa_map = std::move(other.__fbthrift_field_aa_map);
    this->__fbthrift_field_aa_string = std::move(other.__fbthrift_field_aa_string);
    this->__fbthrift_field_not_a_container = std::move(other.__fbthrift_field_not_a_container);
    this->__fbthrift_field_aa_unique = std::move(other.__fbthrift_field_aa_unique);
    this->__fbthrift_field_aa_shared = std::move(other.__fbthrift_field_aa_shared);
    __isset = other.__isset;
  ::apache::thrift::detail::move_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
    return *this;
}


AllocatorAware::AllocatorAware(apache::thrift::FragileConstructor, ::std::vector<::std::int32_t> aa_list__arg, ::std::set<::std::int32_t> aa_set__arg, ::std::map<::std::int32_t, ::std::int32_t> aa_map__arg, ::std::string aa_string__arg, ::std::int32_t not_a_container__arg, ::std::unique_ptr<::std::int32_t> aa_unique__arg, ::std::shared_ptr<::std::int32_t> aa_shared__arg) :
    __fbthrift_field_aa_list(std::move(aa_list__arg)),
    __fbthrift_field_aa_set(std::move(aa_set__arg)),
    __fbthrift_field_aa_map(std::move(aa_map__arg)),
    __fbthrift_field_aa_string(std::move(aa_string__arg)),
    __fbthrift_field_not_a_container(std::move(not_a_container__arg)),
    __fbthrift_field_aa_unique(std::move(aa_unique__arg)),
    __fbthrift_field_aa_shared(std::move(aa_shared__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}


void AllocatorAware::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_aa_list.clear();
  this->__fbthrift_field_aa_set.clear();
  this->__fbthrift_field_aa_map.clear();
  this->__fbthrift_field_aa_string = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_not_a_container = ::std::int32_t();
  this->__fbthrift_field_aa_unique = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::std::int32_t>>(this->get_allocator());
  this->__fbthrift_field_aa_shared = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<::std::int32_t>>(this->get_allocator());
  __isset = {};
}

void AllocatorAware::__fbthrift_clear_terse_fields() {
}

bool AllocatorAware::__fbthrift_is_empty() const {
  return false;
}

bool AllocatorAware::operator==(FOLLY_MAYBE_UNUSED const AllocatorAware& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.aa_list_ref() == rhs.aa_list_ref())) {
    return false;
  }
  if (!(lhs.aa_set_ref() == rhs.aa_set_ref())) {
    return false;
  }
  if (!(lhs.aa_map_ref() == rhs.aa_map_ref())) {
    return false;
  }
  if (!(lhs.aa_string_ref() == rhs.aa_string_ref())) {
    return false;
  }
  if (!(lhs.not_a_container_ref() == rhs.not_a_container_ref())) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aa_unique_ref(), rhs.aa_unique_ref()))) {
    return false;
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aa_shared_ref(), rhs.aa_shared_ref()))) {
    return false;
  }
  return true;
}

bool AllocatorAware::operator<(FOLLY_MAYBE_UNUSED const AllocatorAware& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.aa_list_ref() == rhs.aa_list_ref())) {
    return lhs.aa_list_ref() < rhs.aa_list_ref();
  }
  if (!(lhs.aa_set_ref() == rhs.aa_set_ref())) {
    return lhs.aa_set_ref() < rhs.aa_set_ref();
  }
  if (!(lhs.aa_map_ref() == rhs.aa_map_ref())) {
    return lhs.aa_map_ref() < rhs.aa_map_ref();
  }
  if (!(lhs.aa_string_ref() == rhs.aa_string_ref())) {
    return lhs.aa_string_ref() < rhs.aa_string_ref();
  }
  if (!(lhs.not_a_container_ref() == rhs.not_a_container_ref())) {
    return lhs.not_a_container_ref() < rhs.not_a_container_ref();
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aa_unique_ref(), rhs.aa_unique_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.aa_unique_ref(), rhs.aa_unique_ref());
  }
  if ((!::apache::thrift::detail::pointer_equal(lhs.aa_shared_ref(), rhs.aa_shared_ref()))) {
    return ::apache::thrift::detail::pointer_less(lhs.aa_shared_ref(), rhs.aa_shared_ref());
  }
  return false;
}

const ::std::vector<::std::int32_t>& AllocatorAware::get_aa_list() const& {
  return __fbthrift_field_aa_list;
}

::std::vector<::std::int32_t> AllocatorAware::get_aa_list() && {
  return std::move(__fbthrift_field_aa_list);
}

const ::std::set<::std::int32_t>& AllocatorAware::get_aa_set() const& {
  return __fbthrift_field_aa_set;
}

::std::set<::std::int32_t> AllocatorAware::get_aa_set() && {
  return std::move(__fbthrift_field_aa_set);
}

const ::std::map<::std::int32_t, ::std::int32_t>& AllocatorAware::get_aa_map() const& {
  return __fbthrift_field_aa_map;
}

::std::map<::std::int32_t, ::std::int32_t> AllocatorAware::get_aa_map() && {
  return std::move(__fbthrift_field_aa_map);
}


void swap(FOLLY_MAYBE_UNUSED AllocatorAware& a, FOLLY_MAYBE_UNUSED AllocatorAware& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_aa_list, b.__fbthrift_field_aa_list);
  swap(a.__fbthrift_field_aa_set, b.__fbthrift_field_aa_set);
  swap(a.__fbthrift_field_aa_map, b.__fbthrift_field_aa_map);
  swap(a.__fbthrift_field_aa_string, b.__fbthrift_field_aa_string);
  swap(a.__fbthrift_field_not_a_container, b.__fbthrift_field_not_a_container);
  swap(a.__fbthrift_field_aa_unique, b.__fbthrift_field_aa_unique);
  swap(a.__fbthrift_field_aa_shared, b.__fbthrift_field_aa_shared);
  swap(a.__isset, b.__isset);
  ::apache::thrift::detail::swap_allocators(a.__fbthrift_alloc, b.__fbthrift_alloc);
}

template void AllocatorAware::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllocatorAware::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllocatorAware::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllocatorAware::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllocatorAware::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllocatorAware::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllocatorAware::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllocatorAware::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::AllocatorAware2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::AllocatorAware2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece AllocatorAware2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AllocatorAware2>::fields_names[folly::to_underlying(ord) - 1];
}

AllocatorAware2::AllocatorAware2(const AllocatorAware2& srcObj) :
    __fbthrift_alloc(srcObj.__fbthrift_alloc),
    __fbthrift_field_not_a_container(srcObj.__fbthrift_field_not_a_container),
    __isset(srcObj.__isset) {
}

AllocatorAware2& AllocatorAware2::operator=(const AllocatorAware2& other) {
  AllocatorAware2 tmp(other, get_allocator());
  swap(*this, tmp);
  ::apache::thrift::detail::copy_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
  return *this;
}

AllocatorAware2::AllocatorAware2(FOLLY_MAYBE_UNUSED AllocatorAware2&& other) noexcept :
    __fbthrift_alloc(std::move(other.__fbthrift_alloc)),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __isset(other.__isset) {
}

AllocatorAware2& AllocatorAware2::operator=(FOLLY_MAYBE_UNUSED AllocatorAware2&& other) noexcept {
    this->__fbthrift_field_not_a_container = std::move(other.__fbthrift_field_not_a_container);
    __isset = other.__isset;
  ::apache::thrift::detail::move_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
    return *this;
}


AllocatorAware2::AllocatorAware2(apache::thrift::FragileConstructor, ::std::int32_t not_a_container__arg) :
    __fbthrift_field_not_a_container(std::move(not_a_container__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void AllocatorAware2::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_not_a_container = ::std::int32_t();
  __isset = {};
}

void AllocatorAware2::__fbthrift_clear_terse_fields() {
}

bool AllocatorAware2::__fbthrift_is_empty() const {
  return false;
}

bool AllocatorAware2::operator==(FOLLY_MAYBE_UNUSED const AllocatorAware2& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.not_a_container_ref() == rhs.not_a_container_ref())) {
    return false;
  }
  return true;
}

bool AllocatorAware2::operator<(FOLLY_MAYBE_UNUSED const AllocatorAware2& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.not_a_container_ref() == rhs.not_a_container_ref())) {
    return lhs.not_a_container_ref() < rhs.not_a_container_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED AllocatorAware2& a, FOLLY_MAYBE_UNUSED AllocatorAware2& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_not_a_container, b.__fbthrift_field_not_a_container);
  swap(a.__isset, b.__isset);
  ::apache::thrift::detail::swap_allocators(a.__fbthrift_alloc, b.__fbthrift_alloc);
}

template void AllocatorAware2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t AllocatorAware2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t AllocatorAware2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t AllocatorAware2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void AllocatorAware2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t AllocatorAware2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t AllocatorAware2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t AllocatorAware2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::TypedefStruct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::TypedefStruct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece TypedefStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TypedefStruct>::fields_names[folly::to_underlying(ord) - 1];
}

TypedefStruct::TypedefStruct(const TypedefStruct&) = default;
TypedefStruct& TypedefStruct::operator=(const TypedefStruct&) = default;
TypedefStruct::TypedefStruct(FOLLY_MAYBE_UNUSED TypedefStruct&& other) noexcept :
    __fbthrift_field_i32_field(std::move(other.__fbthrift_field_i32_field)),
    __fbthrift_field_IntTypedef_field(std::move(other.__fbthrift_field_IntTypedef_field)),
    __fbthrift_field_UintTypedef_field(std::move(other.__fbthrift_field_UintTypedef_field)),
    __isset(other.__isset) {
}

TypedefStruct& TypedefStruct::operator=(FOLLY_MAYBE_UNUSED TypedefStruct&& other) noexcept {
    this->__fbthrift_field_i32_field = std::move(other.__fbthrift_field_i32_field);
    this->__fbthrift_field_IntTypedef_field = std::move(other.__fbthrift_field_IntTypedef_field);
    this->__fbthrift_field_UintTypedef_field = std::move(other.__fbthrift_field_UintTypedef_field);
    __isset = other.__isset;
    return *this;
}


TypedefStruct::TypedefStruct(apache::thrift::FragileConstructor, ::std::int32_t i32_field__arg, ::apache::thrift::fixtures::types::IntTypedef IntTypedef_field__arg, std::uint32_t UintTypedef_field__arg) :
    __fbthrift_field_i32_field(std::move(i32_field__arg)),
    __fbthrift_field_IntTypedef_field(std::move(IntTypedef_field__arg)),
    __fbthrift_field_UintTypedef_field(std::move(UintTypedef_field__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void TypedefStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_i32_field = ::std::int32_t();
  this->__fbthrift_field_IntTypedef_field = ::apache::thrift::fixtures::types::IntTypedef();
  this->__fbthrift_field_UintTypedef_field = std::uint32_t();
  __isset = {};
}

void TypedefStruct::__fbthrift_clear_terse_fields() {
}

bool TypedefStruct::__fbthrift_is_empty() const {
  return false;
}

bool TypedefStruct::operator==(FOLLY_MAYBE_UNUSED const TypedefStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.i32_field_ref() == rhs.i32_field_ref())) {
    return false;
  }
  if (!(lhs.IntTypedef_field_ref() == rhs.IntTypedef_field_ref())) {
    return false;
  }
  if (!(lhs.UintTypedef_field_ref() == rhs.UintTypedef_field_ref())) {
    return false;
  }
  return true;
}

bool TypedefStruct::operator<(FOLLY_MAYBE_UNUSED const TypedefStruct& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.i32_field_ref() == rhs.i32_field_ref())) {
    return lhs.i32_field_ref() < rhs.i32_field_ref();
  }
  if (!(lhs.IntTypedef_field_ref() == rhs.IntTypedef_field_ref())) {
    return lhs.IntTypedef_field_ref() < rhs.IntTypedef_field_ref();
  }
  if (!(lhs.UintTypedef_field_ref() == rhs.UintTypedef_field_ref())) {
    return lhs.UintTypedef_field_ref() < rhs.UintTypedef_field_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED TypedefStruct& a, FOLLY_MAYBE_UNUSED TypedefStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_i32_field, b.__fbthrift_field_i32_field);
  swap(a.__fbthrift_field_IntTypedef_field, b.__fbthrift_field_IntTypedef_field);
  swap(a.__fbthrift_field_UintTypedef_field, b.__fbthrift_field_UintTypedef_field);
  swap(a.__isset, b.__isset);
}

template void TypedefStruct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t TypedefStruct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t TypedefStruct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t TypedefStruct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void TypedefStruct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t TypedefStruct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t TypedefStruct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t TypedefStruct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::fixtures::types::StructWithDoubleUnderscores>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::fixtures::types::StructWithDoubleUnderscores>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift { namespace fixtures { namespace types {

const folly::StringPiece StructWithDoubleUnderscores::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<StructWithDoubleUnderscores>::fields_names[folly::to_underlying(ord) - 1];
}


StructWithDoubleUnderscores::StructWithDoubleUnderscores(apache::thrift::FragileConstructor, ::std::int32_t __field__arg) :
    __fbthrift_field___field(std::move(__field__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void StructWithDoubleUnderscores::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field___field = ::std::int32_t();
  __isset = {};
}

void StructWithDoubleUnderscores::__fbthrift_clear_terse_fields() {
}

bool StructWithDoubleUnderscores::__fbthrift_is_empty() const {
  return false;
}

bool StructWithDoubleUnderscores::operator==(FOLLY_MAYBE_UNUSED const StructWithDoubleUnderscores& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.__field_ref() == rhs.__field_ref())) {
    return false;
  }
  return true;
}

bool StructWithDoubleUnderscores::operator<(FOLLY_MAYBE_UNUSED const StructWithDoubleUnderscores& rhs) const {
  FOLLY_MAYBE_UNUSED auto& lhs = *this;
  if (!(lhs.__field_ref() == rhs.__field_ref())) {
    return lhs.__field_ref() < rhs.__field_ref();
  }
  return false;
}


void swap(FOLLY_MAYBE_UNUSED StructWithDoubleUnderscores& a, FOLLY_MAYBE_UNUSED StructWithDoubleUnderscores& b) {
  using ::std::swap;
  swap(a.__fbthrift_field___field, b.__fbthrift_field___field);
  swap(a.__isset, b.__isset);
}

template void StructWithDoubleUnderscores::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StructWithDoubleUnderscores::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StructWithDoubleUnderscores::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StructWithDoubleUnderscores::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StructWithDoubleUnderscores::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StructWithDoubleUnderscores::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StructWithDoubleUnderscores::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StructWithDoubleUnderscores::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}}}} // apache::thrift::fixtures::types

namespace apache { namespace thrift { namespace fixtures { namespace types { namespace {
FOLLY_MAYBE_UNUSED FOLLY_ERASE void validateAdapters() {
}
}}}}} // apache::thrift::fixtures::types
