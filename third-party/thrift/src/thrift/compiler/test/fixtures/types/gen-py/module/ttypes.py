#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException


import included.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass

def __EXPAND_THRIFT_SPEC(spec):
    next_id = 0
    for item in spec:
        if next_id >= 0 and item[0] < 0:
            next_id = item[0]
        if item[0] != next_id:
            for _ in range(next_id, item[0]):
                yield None
        yield item
        next_id = item[0] + 1

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'has_bitwise_ops', 'is_unscoped', 'MyForwardRefEnum', 'empty_struct', 'decorated_struct', 'ContainerStruct', 'CppTypeStruct', 'VirtualStruct', 'MyStructWithForwardRefEnum', 'TrivialNumeric', 'TrivialNestedWithDefault', 'ComplexString', 'ComplexNestedWithDefault', 'MinPadding', 'MinPaddingWithCustomType', 'MyStruct', 'MyDataItem', 'Renaming', 'AnnotatedTypes', 'ForwardUsageRoot', 'ForwardUsageStruct', 'ForwardUsageByRef', 'IncompleteMap', 'IncompleteMapDep', 'CompleteMap', 'CompleteMapDep', 'IncompleteList', 'IncompleteListDep', 'CompleteList', 'CompleteListDep', 'AdaptedList', 'AdaptedListDep', 'DependentAdaptedList', 'DependentAdaptedListDep', 'AllocatorAware', 'AllocatorAware2', 'TypedefStruct', 'StructWithDoubleUnderscores', 'TBinary', 'IntTypedef', 'UintTypedef']

class has_bitwise_ops:
  none = 0
  zero = 1
  one = 2
  two = 4
  three = 8

  _VALUES_TO_NAMES = {
    0: "none",
    1: "zero",
    2: "one",
    4: "two",
    8: "three",
  }

  _NAMES_TO_VALUES = {
    "none": 0,
    "zero": 1,
    "one": 2,
    "two": 4,
    "three": 8,
  }

class is_unscoped:
  hello = 0
  world = 1

  _VALUES_TO_NAMES = {
    0: "hello",
    1: "world",
  }

  _NAMES_TO_VALUES = {
    "hello": 0,
    "world": 1,
  }

class MyForwardRefEnum:
  ZERO = 0
  NONZERO = 12

  _VALUES_TO_NAMES = {
    0: "ZERO",
    12: "NONZERO",
  }

  _NAMES_TO_VALUES = {
    "ZERO": 0,
    "NONZERO": 12,
  }

class empty_struct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('empty_struct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.empty_struct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.empty_struct, self)

  def _to_py_deprecated(self):
    return self

class decorated_struct:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('decorated_struct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRING, 1)
      oprot.writeString(self.field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.field, bytes) else oprot.writeString(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.decorated_struct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.decorated_struct, self)

  def _to_py_deprecated(self):
    return self

class ContainerStruct:
  r"""
  Attributes:
   - fieldA
   - fieldB
   - fieldC
   - fieldD
   - fieldE
   - fieldF
   - fieldG
   - fieldH
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 12:
        if ftype == TType.LIST:
          self.fieldA = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI32()
              self.fieldA.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI32()
              self.fieldA.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.fieldB = []
          (_etype10, _size7) = iprot.readListBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readI32()
              self.fieldB.append(_elem12)
          else: 
            while iprot.peekList():
              _elem13 = iprot.readI32()
              self.fieldB.append(_elem13)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.fieldC = []
          (_etype17, _size14) = iprot.readListBegin()
          if _size14 >= 0:
            for _i18 in range(_size14):
              _elem19 = iprot.readI32()
              self.fieldC.append(_elem19)
          else: 
            while iprot.peekList():
              _elem20 = iprot.readI32()
              self.fieldC.append(_elem20)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fieldD = []
          (_etype24, _size21) = iprot.readListBegin()
          if _size21 >= 0:
            for _i25 in range(_size21):
              _elem26 = iprot.readI32()
              self.fieldD.append(_elem26)
          else: 
            while iprot.peekList():
              _elem27 = iprot.readI32()
              self.fieldD.append(_elem27)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.fieldE = []
          (_etype31, _size28) = iprot.readListBegin()
          if _size28 >= 0:
            for _i32 in range(_size28):
              _elem33 = iprot.readI32()
              self.fieldE.append(_elem33)
          else: 
            while iprot.peekList():
              _elem34 = iprot.readI32()
              self.fieldE.append(_elem34)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.SET:
          self.fieldF = set()
          (_etype38, _size35) = iprot.readSetBegin()
          if _size35 >= 0:
            for _i39 in range(_size35):
              _elem40 = iprot.readI32()
              self.fieldF.add(_elem40)
          else: 
            while iprot.peekSet():
              _elem41 = iprot.readI32()
              self.fieldF.add(_elem41)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.fieldG = {}
          (_ktype43, _vtype44, _size42 ) = iprot.readMapBegin() 
          if _size42 >= 0:
            for _i46 in range(_size42):
              _key47 = iprot.readI32()
              _val48 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldG[_key47] = _val48
          else: 
            while iprot.peekMap():
              _key49 = iprot.readI32()
              _val50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldG[_key49] = _val50
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.fieldH = {}
          (_ktype52, _vtype53, _size51 ) = iprot.readMapBegin() 
          if _size51 >= 0:
            for _i55 in range(_size51):
              _key56 = iprot.readI32()
              _val57 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldH[_key56] = _val57
          else: 
            while iprot.peekMap():
              _key58 = iprot.readI32()
              _val59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.fieldH[_key58] = _val59
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ContainerStruct')
    if self.fieldB != None:
      oprot.writeFieldBegin('fieldB', TType.LIST, 2)
      oprot.writeListBegin(TType.I32, len(self.fieldB))
      for iter60 in self.fieldB:
        oprot.writeI32(iter60)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldC != None:
      oprot.writeFieldBegin('fieldC', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.fieldC))
      for iter61 in self.fieldC:
        oprot.writeI32(iter61)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldD != None:
      oprot.writeFieldBegin('fieldD', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.fieldD))
      for iter62 in self.fieldD:
        oprot.writeI32(iter62)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldE != None:
      oprot.writeFieldBegin('fieldE', TType.LIST, 5)
      oprot.writeListBegin(TType.I32, len(self.fieldE))
      for iter63 in self.fieldE:
        oprot.writeI32(iter63)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.fieldF != None:
      oprot.writeFieldBegin('fieldF', TType.SET, 6)
      oprot.writeSetBegin(TType.I32, len(self.fieldF))
      for iter64 in self.fieldF:
        oprot.writeI32(iter64)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.fieldG != None:
      oprot.writeFieldBegin('fieldG', TType.MAP, 7)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.fieldG))
      for kiter65,viter66 in self.fieldG.items():
        oprot.writeI32(kiter65)
        oprot.writeString(viter66.encode('utf-8')) if UTF8STRINGS and not isinstance(viter66, bytes) else oprot.writeString(viter66)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fieldH != None:
      oprot.writeFieldBegin('fieldH', TType.MAP, 8)
      oprot.writeMapBegin(TType.I32, TType.STRING, len(self.fieldH))
      for kiter67,viter68 in self.fieldH.items():
        oprot.writeI32(kiter67)
        oprot.writeString(viter68.encode('utf-8')) if UTF8STRINGS and not isinstance(viter68, bytes) else oprot.writeString(viter68)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.fieldA != None:
      oprot.writeFieldBegin('fieldA', TType.LIST, 12)
      oprot.writeListBegin(TType.I32, len(self.fieldA))
      for iter69 in self.fieldA:
        oprot.writeI32(iter69)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.fieldA is not None:
      value = pprint.pformat(self.fieldA, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldA=%s' % (value))
    if self.fieldB is not None:
      value = pprint.pformat(self.fieldB, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldB=%s' % (value))
    if self.fieldC is not None:
      value = pprint.pformat(self.fieldC, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldC=%s' % (value))
    if self.fieldD is not None:
      value = pprint.pformat(self.fieldD, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldD=%s' % (value))
    if self.fieldE is not None:
      value = pprint.pformat(self.fieldE, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldE=%s' % (value))
    if self.fieldF is not None:
      value = pprint.pformat(self.fieldF, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldF=%s' % (value))
    if self.fieldG is not None:
      value = pprint.pformat(self.fieldG, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldG=%s' % (value))
    if self.fieldH is not None:
      value = pprint.pformat(self.fieldH, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldH=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'fieldB',
      'fieldC',
      'fieldD',
      'fieldE',
      'fieldF',
      'fieldG',
      'fieldH',
      'fieldA',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ContainerStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ContainerStruct, self)

  def _to_py_deprecated(self):
    return self

class CppTypeStruct:
  r"""
  Attributes:
   - fieldA
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.fieldA = []
          (_etype73, _size70) = iprot.readListBegin()
          if _size70 >= 0:
            for _i74 in range(_size70):
              _elem75 = iprot.readI32()
              self.fieldA.append(_elem75)
          else: 
            while iprot.peekList():
              _elem76 = iprot.readI32()
              self.fieldA.append(_elem76)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CppTypeStruct')
    if self.fieldA != None:
      oprot.writeFieldBegin('fieldA', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.fieldA))
      for iter77 in self.fieldA:
        oprot.writeI32(iter77)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.fieldA is not None:
      value = pprint.pformat(self.fieldA, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    fieldA=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'fieldA',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CppTypeStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CppTypeStruct, self)

  def _to_py_deprecated(self):
    return self

class VirtualStruct:
  r"""
  Attributes:
   - MyIntField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('VirtualStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.VirtualStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.VirtualStruct, self)

  def _to_py_deprecated(self):
    return self

class MyStructWithForwardRefEnum:
  r"""
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.b = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructWithForwardRefEnum')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.I32, 2)
      oprot.writeI32(self.b)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructWithForwardRefEnum, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructWithForwardRefEnum, self)

  def _to_py_deprecated(self):
    return self

class TrivialNumeric:
  r"""
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.a = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.b = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TrivialNumeric')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.I32, 1)
      oprot.writeI32(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.BOOL, 2)
      oprot.writeBool(self.b)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TrivialNumeric, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TrivialNumeric, self)

  def _to_py_deprecated(self):
    return self

class TrivialNestedWithDefault:
  r"""
  Attributes:
   - z
   - n
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.z = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.n = TrivialNumeric()
          self.n.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TrivialNestedWithDefault')
    if self.z != None:
      oprot.writeFieldBegin('z', TType.I32, 1)
      oprot.writeI32(self.z)
      oprot.writeFieldEnd()
    if self.n != None:
      oprot.writeFieldBegin('n', TType.STRUCT, 2)
      self.n.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.z is not None:
      value = pprint.pformat(self.z, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    z=%s' % (value))
    if self.n is not None:
      value = pprint.pformat(self.n, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    n=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'z',
      'n',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TrivialNestedWithDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TrivialNestedWithDefault, self)

  def _to_py_deprecated(self):
    return self

class ComplexString:
  r"""
  Attributes:
   - a
   - b
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.a = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.b = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          if _size78 >= 0:
            for _i82 in range(_size78):
              _key83 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val84 = iprot.readI32()
              self.b[_key83] = _val84
          else: 
            while iprot.peekMap():
              _key85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val86 = iprot.readI32()
              self.b[_key85] = _val86
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ComplexString')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRING, 1)
      oprot.writeString(self.a.encode('utf-8')) if UTF8STRINGS and not isinstance(self.a, bytes) else oprot.writeString(self.a)
      oprot.writeFieldEnd()
    if self.b != None:
      oprot.writeFieldBegin('b', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.b))
      for kiter87,viter88 in self.b.items():
        oprot.writeString(kiter87.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter87, bytes) else oprot.writeString(kiter87)
        oprot.writeI32(viter88)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    if self.b is not None:
      value = pprint.pformat(self.b, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    b=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
      'b',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ComplexString, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ComplexString, self)

  def _to_py_deprecated(self):
    return self

class ComplexNestedWithDefault:
  r"""
  Attributes:
   - z
   - n
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.z = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.n = ComplexString()
          self.n.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ComplexNestedWithDefault')
    if self.z != None:
      oprot.writeFieldBegin('z', TType.STRING, 1)
      oprot.writeString(self.z.encode('utf-8')) if UTF8STRINGS and not isinstance(self.z, bytes) else oprot.writeString(self.z)
      oprot.writeFieldEnd()
    if self.n != None:
      oprot.writeFieldBegin('n', TType.STRUCT, 2)
      self.n.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.z is not None:
      value = pprint.pformat(self.z, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    z=%s' % (value))
    if self.n is not None:
      value = pprint.pformat(self.n, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    n=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'z',
      'n',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ComplexNestedWithDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ComplexNestedWithDefault, self)

  def _to_py_deprecated(self):
    return self

class MinPadding:
  r"""
  Attributes:
   - small
   - big
   - medium
   - biggish
   - tiny
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.small = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.big = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.medium = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.biggish = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.tiny = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MinPadding')
    if self.small != None:
      oprot.writeFieldBegin('small', TType.BYTE, 1)
      oprot.writeByte(self.small)
      oprot.writeFieldEnd()
    if self.big != None:
      oprot.writeFieldBegin('big', TType.I64, 2)
      oprot.writeI64(self.big)
      oprot.writeFieldEnd()
    if self.medium != None:
      oprot.writeFieldBegin('medium', TType.I16, 3)
      oprot.writeI16(self.medium)
      oprot.writeFieldEnd()
    if self.biggish != None:
      oprot.writeFieldBegin('biggish', TType.I32, 4)
      oprot.writeI32(self.biggish)
      oprot.writeFieldEnd()
    if self.tiny != None:
      oprot.writeFieldBegin('tiny', TType.BYTE, 5)
      oprot.writeByte(self.tiny)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.small is not None:
      value = pprint.pformat(self.small, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    small=%s' % (value))
    if self.big is not None:
      value = pprint.pformat(self.big, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    big=%s' % (value))
    if self.medium is not None:
      value = pprint.pformat(self.medium, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    medium=%s' % (value))
    if self.biggish is not None:
      value = pprint.pformat(self.biggish, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    biggish=%s' % (value))
    if self.tiny is not None:
      value = pprint.pformat(self.tiny, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tiny=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'small',
      'big',
      'medium',
      'biggish',
      'tiny',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MinPadding, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MinPadding, self)

  def _to_py_deprecated(self):
    return self

class MinPaddingWithCustomType:
  r"""
  Attributes:
   - small
   - big
   - medium
   - biggish
   - tiny
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.small = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.big = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.medium = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.biggish = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.tiny = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MinPaddingWithCustomType')
    if self.small != None:
      oprot.writeFieldBegin('small', TType.BYTE, 1)
      oprot.writeByte(self.small)
      oprot.writeFieldEnd()
    if self.big != None:
      oprot.writeFieldBegin('big', TType.I64, 2)
      oprot.writeI64(self.big)
      oprot.writeFieldEnd()
    if self.medium != None:
      oprot.writeFieldBegin('medium', TType.I16, 3)
      oprot.writeI16(self.medium)
      oprot.writeFieldEnd()
    if self.biggish != None:
      oprot.writeFieldBegin('biggish', TType.I32, 4)
      oprot.writeI32(self.biggish)
      oprot.writeFieldEnd()
    if self.tiny != None:
      oprot.writeFieldBegin('tiny', TType.BYTE, 5)
      oprot.writeByte(self.tiny)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.small is not None:
      value = pprint.pformat(self.small, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    small=%s' % (value))
    if self.big is not None:
      value = pprint.pformat(self.big, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    big=%s' % (value))
    if self.medium is not None:
      value = pprint.pformat(self.medium, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    medium=%s' % (value))
    if self.biggish is not None:
      value = pprint.pformat(self.biggish, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    biggish=%s' % (value))
    if self.tiny is not None:
      value = pprint.pformat(self.tiny, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    tiny=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'small',
      'big',
      'medium',
      'biggish',
      'tiny',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MinPaddingWithCustomType, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MinPaddingWithCustomType, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - MyIntField
   - MyStringField
   - majorVer
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.MyIntField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.MyStringField = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.majorVer = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.data = MyDataItem()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.MyIntField != None:
      oprot.writeFieldBegin('MyIntField', TType.I64, 1)
      oprot.writeI64(self.MyIntField)
      oprot.writeFieldEnd()
    if self.MyStringField != None:
      oprot.writeFieldBegin('MyStringField', TType.STRING, 2)
      oprot.writeString(self.MyStringField.encode('utf-8')) if UTF8STRINGS and not isinstance(self.MyStringField, bytes) else oprot.writeString(self.MyStringField)
      oprot.writeFieldEnd()
    if self.majorVer != None:
      oprot.writeFieldBegin('majorVer', TType.I64, 3)
      oprot.writeI64(self.majorVer)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRUCT, 4)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.MyIntField is not None:
      value = pprint.pformat(self.MyIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyIntField=%s' % (value))
    if self.MyStringField is not None:
      value = pprint.pformat(self.MyStringField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    MyStringField=%s' % (value))
    if self.majorVer is not None:
      value = pprint.pformat(self.majorVer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    majorVer=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'MyIntField',
      'MyStringField',
      'majorVer',
      'data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataItem:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataItem')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataItem, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataItem, self)

  def _to_py_deprecated(self):
    return self

class Renaming:
  r"""
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.foo = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Renaming')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.I64, 1)
      oprot.writeI64(self.foo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Renaming, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Renaming, self)

  def _to_py_deprecated(self):
    return self

class AnnotatedTypes:
  r"""
  Attributes:
   - binary_field
   - list_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.binary_field = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.list_field = []
          (_etype92, _size89) = iprot.readListBegin()
          if _size89 >= 0:
            for _i93 in range(_size89):
              _elem94 = {}
              (_ktype96, _vtype97, _size95 ) = iprot.readMapBegin() 
              if _size95 >= 0:
                for _i99 in range(_size95):
                  _key100 = iprot.readI32()
                  _val101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem94[_key100] = _val101
              else: 
                while iprot.peekMap():
                  _key102 = iprot.readI32()
                  _val103 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem94[_key102] = _val103
              iprot.readMapEnd()
              self.list_field.append(_elem94)
          else: 
            while iprot.peekList():
              _elem104 = {}
              (_ktype106, _vtype107, _size105 ) = iprot.readMapBegin() 
              if _size105 >= 0:
                for _i109 in range(_size105):
                  _key110 = iprot.readI32()
                  _val111 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem104[_key110] = _val111
              else: 
                while iprot.peekMap():
                  _key112 = iprot.readI32()
                  _val113 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _elem104[_key112] = _val113
              iprot.readMapEnd()
              self.list_field.append(_elem104)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AnnotatedTypes')
    if self.binary_field != None:
      oprot.writeFieldBegin('binary_field', TType.STRING, 1)
      oprot.writeString(self.binary_field)
      oprot.writeFieldEnd()
    if self.list_field != None:
      oprot.writeFieldBegin('list_field', TType.LIST, 2)
      oprot.writeListBegin(TType.MAP, len(self.list_field))
      for iter114 in self.list_field:
        oprot.writeMapBegin(TType.I32, TType.STRING, len(iter114))
        for kiter115,viter116 in iter114.items():
          oprot.writeI32(kiter115)
          oprot.writeString(viter116.encode('utf-8')) if UTF8STRINGS and not isinstance(viter116, bytes) else oprot.writeString(viter116)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.binary_field is not None:
      value = pprint.pformat(self.binary_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_field=%s' % (value))
    if self.list_field is not None:
      value = pprint.pformat(self.list_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    list_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'binary_field',
      'list_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AnnotatedTypes, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AnnotatedTypes, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageRoot:
  r"""
  Attributes:
   - ForwardUsageStruct
   - ForwardUsageByRef
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ForwardUsageStruct = ForwardUsageStruct()
          self.ForwardUsageStruct.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ForwardUsageByRef = ForwardUsageByRef()
          self.ForwardUsageByRef.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageRoot')
    if self.ForwardUsageStruct != None:
      oprot.writeFieldBegin('ForwardUsageStruct', TType.STRUCT, 1)
      self.ForwardUsageStruct.write(oprot)
      oprot.writeFieldEnd()
    if self.ForwardUsageByRef != None:
      oprot.writeFieldBegin('ForwardUsageByRef', TType.STRUCT, 2)
      self.ForwardUsageByRef.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ForwardUsageStruct is not None:
      value = pprint.pformat(self.ForwardUsageStruct, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ForwardUsageStruct=%s' % (value))
    if self.ForwardUsageByRef is not None:
      value = pprint.pformat(self.ForwardUsageByRef, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ForwardUsageByRef=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'ForwardUsageStruct',
      'ForwardUsageByRef',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageRoot, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageRoot, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageStruct:
  r"""
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.foo = ForwardUsageRoot()
          self.foo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageStruct')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.STRUCT, 1)
      self.foo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageStruct, self)

  def _to_py_deprecated(self):
    return self

class ForwardUsageByRef:
  r"""
  Attributes:
   - foo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.foo = ForwardUsageRoot()
          self.foo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ForwardUsageByRef')
    if self.foo != None:
      oprot.writeFieldBegin('foo', TType.STRUCT, 1)
      self.foo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.foo is not None:
      value = pprint.pformat(self.foo, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    foo=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'foo',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ForwardUsageByRef, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ForwardUsageByRef, self)

  def _to_py_deprecated(self):
    return self

class IncompleteMap:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.field = {}
          (_ktype118, _vtype119, _size117 ) = iprot.readMapBegin() 
          if _size117 >= 0:
            for _i121 in range(_size117):
              _key122 = iprot.readI32()
              _val123 = IncompleteMapDep()
              _val123.read(iprot)
              self.field[_key122] = _val123
          else: 
            while iprot.peekMap():
              _key124 = iprot.readI32()
              _val125 = IncompleteMapDep()
              _val125.read(iprot)
              self.field[_key124] = _val125
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IncompleteMap')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.field))
      for kiter126,viter127 in self.field.items():
        oprot.writeI32(kiter126)
        viter127.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.IncompleteMap, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.IncompleteMap, self)

  def _to_py_deprecated(self):
    return self

class IncompleteMapDep:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IncompleteMapDep')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.IncompleteMapDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.IncompleteMapDep, self)

  def _to_py_deprecated(self):
    return self

class CompleteMap:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.field = {}
          (_ktype129, _vtype130, _size128 ) = iprot.readMapBegin() 
          if _size128 >= 0:
            for _i132 in range(_size128):
              _key133 = iprot.readI32()
              _val134 = CompleteMapDep()
              _val134.read(iprot)
              self.field[_key133] = _val134
          else: 
            while iprot.peekMap():
              _key135 = iprot.readI32()
              _val136 = CompleteMapDep()
              _val136.read(iprot)
              self.field[_key135] = _val136
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CompleteMap')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.field))
      for kiter137,viter138 in self.field.items():
        oprot.writeI32(kiter137)
        viter138.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CompleteMap, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CompleteMap, self)

  def _to_py_deprecated(self):
    return self

class CompleteMapDep:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CompleteMapDep')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CompleteMapDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CompleteMapDep, self)

  def _to_py_deprecated(self):
    return self

class IncompleteList:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.field = []
          (_etype142, _size139) = iprot.readListBegin()
          if _size139 >= 0:
            for _i143 in range(_size139):
              _elem144 = IncompleteListDep()
              _elem144.read(iprot)
              self.field.append(_elem144)
          else: 
            while iprot.peekList():
              _elem145 = IncompleteListDep()
              _elem145.read(iprot)
              self.field.append(_elem145)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IncompleteList')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.field))
      for iter146 in self.field:
        iter146.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.IncompleteList, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.IncompleteList, self)

  def _to_py_deprecated(self):
    return self

class IncompleteListDep:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IncompleteListDep')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.IncompleteListDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.IncompleteListDep, self)

  def _to_py_deprecated(self):
    return self

class CompleteList:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.field = []
          (_etype150, _size147) = iprot.readListBegin()
          if _size147 >= 0:
            for _i151 in range(_size147):
              _elem152 = CompleteListDep()
              _elem152.read(iprot)
              self.field.append(_elem152)
          else: 
            while iprot.peekList():
              _elem153 = CompleteListDep()
              _elem153.read(iprot)
              self.field.append(_elem153)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CompleteList')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.field))
      for iter154 in self.field:
        iter154.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CompleteList, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CompleteList, self)

  def _to_py_deprecated(self):
    return self

class CompleteListDep:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CompleteListDep')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CompleteListDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CompleteListDep, self)

  def _to_py_deprecated(self):
    return self

class AdaptedList:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.field = []
          (_etype158, _size155) = iprot.readListBegin()
          if _size155 >= 0:
            for _i159 in range(_size155):
              _elem160 = AdaptedListDep()
              _elem160.read(iprot)
              self.field.append(_elem160)
          else: 
            while iprot.peekList():
              _elem161 = AdaptedListDep()
              _elem161.read(iprot)
              self.field.append(_elem161)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedList')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.field))
      for iter162 in self.field:
        iter162.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedList, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedList, self)

  def _to_py_deprecated(self):
    return self

class AdaptedListDep:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.field = AdaptedList()
          self.field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedListDep')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRUCT, 1)
      self.field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedListDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedListDep, self)

  def _to_py_deprecated(self):
    return self

class DependentAdaptedList:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.field = []
          (_etype166, _size163) = iprot.readListBegin()
          if _size163 >= 0:
            for _i167 in range(_size163):
              _elem168 = DependentAdaptedListDep()
              _elem168.read(iprot)
              self.field.append(_elem168)
          else: 
            while iprot.peekList():
              _elem169 = DependentAdaptedListDep()
              _elem169.read(iprot)
              self.field.append(_elem169)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DependentAdaptedList')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.field))
      for iter170 in self.field:
        iter170.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DependentAdaptedList, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DependentAdaptedList, self)

  def _to_py_deprecated(self):
    return self

class DependentAdaptedListDep:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.field = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DependentAdaptedListDep')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I16, 1)
      oprot.writeI16(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DependentAdaptedListDep, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DependentAdaptedListDep, self)

  def _to_py_deprecated(self):
    return self

class AllocatorAware:
  r"""
  Attributes:
   - aa_list
   - aa_set
   - aa_map
   - aa_string
   - not_a_container
   - aa_unique
   - aa_shared
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.aa_list = []
          (_etype174, _size171) = iprot.readListBegin()
          if _size171 >= 0:
            for _i175 in range(_size171):
              _elem176 = iprot.readI32()
              self.aa_list.append(_elem176)
          else: 
            while iprot.peekList():
              _elem177 = iprot.readI32()
              self.aa_list.append(_elem177)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.aa_set = set()
          (_etype181, _size178) = iprot.readSetBegin()
          if _size178 >= 0:
            for _i182 in range(_size178):
              _elem183 = iprot.readI32()
              self.aa_set.add(_elem183)
          else: 
            while iprot.peekSet():
              _elem184 = iprot.readI32()
              self.aa_set.add(_elem184)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.aa_map = {}
          (_ktype186, _vtype187, _size185 ) = iprot.readMapBegin() 
          if _size185 >= 0:
            for _i189 in range(_size185):
              _key190 = iprot.readI32()
              _val191 = iprot.readI32()
              self.aa_map[_key190] = _val191
          else: 
            while iprot.peekMap():
              _key192 = iprot.readI32()
              _val193 = iprot.readI32()
              self.aa_map[_key192] = _val193
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.aa_string = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.not_a_container = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.aa_unique = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.aa_shared = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AllocatorAware')
    if self.aa_list != None:
      oprot.writeFieldBegin('aa_list', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.aa_list))
      for iter194 in self.aa_list:
        oprot.writeI32(iter194)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.aa_set != None:
      oprot.writeFieldBegin('aa_set', TType.SET, 2)
      oprot.writeSetBegin(TType.I32, len(self.aa_set))
      for iter195 in self.aa_set:
        oprot.writeI32(iter195)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.aa_map != None:
      oprot.writeFieldBegin('aa_map', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.aa_map))
      for kiter196,viter197 in self.aa_map.items():
        oprot.writeI32(kiter196)
        oprot.writeI32(viter197)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.aa_string != None:
      oprot.writeFieldBegin('aa_string', TType.STRING, 4)
      oprot.writeString(self.aa_string.encode('utf-8')) if UTF8STRINGS and not isinstance(self.aa_string, bytes) else oprot.writeString(self.aa_string)
      oprot.writeFieldEnd()
    if self.not_a_container != None:
      oprot.writeFieldBegin('not_a_container', TType.I32, 5)
      oprot.writeI32(self.not_a_container)
      oprot.writeFieldEnd()
    if self.aa_unique != None:
      oprot.writeFieldBegin('aa_unique', TType.I32, 6)
      oprot.writeI32(self.aa_unique)
      oprot.writeFieldEnd()
    if self.aa_shared != None:
      oprot.writeFieldBegin('aa_shared', TType.I32, 7)
      oprot.writeI32(self.aa_shared)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.aa_list is not None:
      value = pprint.pformat(self.aa_list, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_list=%s' % (value))
    if self.aa_set is not None:
      value = pprint.pformat(self.aa_set, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_set=%s' % (value))
    if self.aa_map is not None:
      value = pprint.pformat(self.aa_map, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_map=%s' % (value))
    if self.aa_string is not None:
      value = pprint.pformat(self.aa_string, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_string=%s' % (value))
    if self.not_a_container is not None:
      value = pprint.pformat(self.not_a_container, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    not_a_container=%s' % (value))
    if self.aa_unique is not None:
      value = pprint.pformat(self.aa_unique, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_unique=%s' % (value))
    if self.aa_shared is not None:
      value = pprint.pformat(self.aa_shared, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    aa_shared=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'aa_list',
      'aa_set',
      'aa_map',
      'aa_string',
      'not_a_container',
      'aa_unique',
      'aa_shared',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AllocatorAware, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AllocatorAware, self)

  def _to_py_deprecated(self):
    return self

class AllocatorAware2:
  r"""
  Attributes:
   - not_a_container
   - box_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.not_a_container = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.box_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AllocatorAware2')
    if self.not_a_container != None:
      oprot.writeFieldBegin('not_a_container', TType.I32, 1)
      oprot.writeI32(self.not_a_container)
      oprot.writeFieldEnd()
    if self.box_field != None:
      oprot.writeFieldBegin('box_field', TType.I32, 2)
      oprot.writeI32(self.box_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.not_a_container is not None:
      value = pprint.pformat(self.not_a_container, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    not_a_container=%s' % (value))
    if self.box_field is not None:
      value = pprint.pformat(self.box_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    box_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'not_a_container',
      'box_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AllocatorAware2, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AllocatorAware2, self)

  def _to_py_deprecated(self):
    return self

class TypedefStruct:
  r"""
  Attributes:
   - i32_field
   - IntTypedef_field
   - UintTypedef_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.i32_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.IntTypedef_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.UintTypedef_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TypedefStruct')
    if self.i32_field != None:
      oprot.writeFieldBegin('i32_field', TType.I32, 1)
      oprot.writeI32(self.i32_field)
      oprot.writeFieldEnd()
    if self.IntTypedef_field != None:
      oprot.writeFieldBegin('IntTypedef_field', TType.I32, 2)
      oprot.writeI32(self.IntTypedef_field)
      oprot.writeFieldEnd()
    if self.UintTypedef_field != None:
      oprot.writeFieldBegin('UintTypedef_field', TType.I32, 3)
      oprot.writeI32(self.UintTypedef_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.i32_field is not None:
      value = pprint.pformat(self.i32_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32_field=%s' % (value))
    if self.IntTypedef_field is not None:
      value = pprint.pformat(self.IntTypedef_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    IntTypedef_field=%s' % (value))
    if self.UintTypedef_field is not None:
      value = pprint.pformat(self.UintTypedef_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    UintTypedef_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'i32_field',
      'IntTypedef_field',
      'UintTypedef_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TypedefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TypedefStruct, self)

  def _to_py_deprecated(self):
    return self

class StructWithDoubleUnderscores:
  r"""
  Attributes:
   - __field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.__field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithDoubleUnderscores')
    if self.__field != None:
      oprot.writeFieldBegin('__field', TType.I32, 1)
      oprot.writeI32(self.__field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if getattr(self, "__field", None) is not None:
      value = pprint.pformat(getattr(self, "__field", None), indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    __field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      '__field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.fixtures.types.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructWithDoubleUnderscores, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.fixtures.types.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructWithDoubleUnderscores, self)

  def _to_py_deprecated(self):
    return self

TBinary = UnimplementedTypedef()
IntTypedef = UnimplementedTypedef()
UintTypedef = IntTypedef
all_structs.append(empty_struct)
empty_struct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

empty_struct.thrift_struct_annotations = {
}
empty_struct.thrift_field_annotations = {
}

all_structs.append(decorated_struct)
decorated_struct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'field', True, None, 2, ), # 1
)))

decorated_struct.thrift_struct_annotations = {
  "cpp.declare_equal_to": "1",
  "cpp.declare_hash": "1",
}
decorated_struct.thrift_field_annotations = {
}

def decorated_struct__init__(self, field=None,):
  self.field = field

decorated_struct.__init__ = decorated_struct__init__

def decorated_struct__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

decorated_struct.__getstate__ = lambda self: self.__dict__.copy()
decorated_struct.__setstate__ = decorated_struct__setstate__

all_structs.append(ContainerStruct)
ContainerStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (2, TType.LIST, 'fieldB', (TType.I32,None), None, 2, ), # 2
  (3, TType.LIST, 'fieldC', (TType.I32,None), None, 2, ), # 3
  (4, TType.LIST, 'fieldD', (TType.I32,None), None, 2, ), # 4
  (5, TType.LIST, 'fieldE', (TType.I32,None), None, 2, ), # 5
  (6, TType.SET, 'fieldF', (TType.I32,None), None, 2, ), # 6
  (7, TType.MAP, 'fieldG', (TType.I32,None,TType.STRING,True), None, 2, ), # 7
  (8, TType.MAP, 'fieldH', (TType.I32,None,TType.STRING,True), None, 2, ), # 8
  (12, TType.LIST, 'fieldA', (TType.I32,None), None, 2, ), # 12
)))

ContainerStruct.thrift_struct_annotations = {
}
ContainerStruct.thrift_field_annotations = {
}

def ContainerStruct__init__(self, fieldA=None, fieldB=None, fieldC=None, fieldD=None, fieldE=None, fieldF=None, fieldG=None, fieldH=None,):
  self.fieldA = fieldA
  self.fieldB = fieldB
  self.fieldC = fieldC
  self.fieldD = fieldD
  self.fieldE = fieldE
  self.fieldF = fieldF
  self.fieldG = fieldG
  self.fieldH = fieldH

ContainerStruct.__init__ = ContainerStruct__init__

def ContainerStruct__setstate__(self, state):
  state.setdefault('fieldA', None)
  state.setdefault('fieldB', None)
  state.setdefault('fieldC', None)
  state.setdefault('fieldD', None)
  state.setdefault('fieldE', None)
  state.setdefault('fieldF', None)
  state.setdefault('fieldG', None)
  state.setdefault('fieldH', None)
  self.__dict__ = state

ContainerStruct.__getstate__ = lambda self: self.__dict__.copy()
ContainerStruct.__setstate__ = ContainerStruct__setstate__

all_structs.append(CppTypeStruct)
CppTypeStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'fieldA', (TType.I32,None), None, 2, ), # 1
)))

CppTypeStruct.thrift_struct_annotations = {
}
CppTypeStruct.thrift_field_annotations = {
}

def CppTypeStruct__init__(self, fieldA=None,):
  self.fieldA = fieldA

CppTypeStruct.__init__ = CppTypeStruct__init__

def CppTypeStruct__setstate__(self, state):
  state.setdefault('fieldA', None)
  self.__dict__ = state

CppTypeStruct.__getstate__ = lambda self: self.__dict__.copy()
CppTypeStruct.__setstate__ = CppTypeStruct__setstate__

all_structs.append(VirtualStruct)
VirtualStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
)))

VirtualStruct.thrift_struct_annotations = {
  "cpp.virtual": "1",
}
VirtualStruct.thrift_field_annotations = {
}

def VirtualStruct__init__(self, MyIntField=None,):
  self.MyIntField = MyIntField

VirtualStruct.__init__ = VirtualStruct__init__

def VirtualStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  self.__dict__ = state

VirtualStruct.__getstate__ = lambda self: self.__dict__.copy()
VirtualStruct.__setstate__ = VirtualStruct__setstate__

all_structs.append(MyStructWithForwardRefEnum)
MyStructWithForwardRefEnum.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'a', MyForwardRefEnum,   12, 2, ), # 1
  (2, TType.I32, 'b', MyForwardRefEnum,   12, 2, ), # 2
)))

MyStructWithForwardRefEnum.thrift_struct_annotations = {
}
MyStructWithForwardRefEnum.thrift_field_annotations = {
}

def MyStructWithForwardRefEnum__init__(self, a=MyStructWithForwardRefEnum.thrift_spec[1][4], b=MyStructWithForwardRefEnum.thrift_spec[2][4],):
  if a is self.thrift_spec[1][4]:
    a =   12
  self.a = a
  if b is self.thrift_spec[2][4]:
    b =   12
  self.b = b

MyStructWithForwardRefEnum.__init__ = MyStructWithForwardRefEnum__init__

def MyStructWithForwardRefEnum__setstate__(self, state):
  state.setdefault('a',   12)
  state.setdefault('b',   12)
  self.__dict__ = state

MyStructWithForwardRefEnum.__getstate__ = lambda self: self.__dict__.copy()
MyStructWithForwardRefEnum.__setstate__ = MyStructWithForwardRefEnum__setstate__

all_structs.append(TrivialNumeric)
TrivialNumeric.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'a', None, None, 2, ), # 1
  (2, TType.BOOL, 'b', None, None, 2, ), # 2
)))

TrivialNumeric.thrift_struct_annotations = {
}
TrivialNumeric.thrift_field_annotations = {
}

def TrivialNumeric__init__(self, a=None, b=None,):
  self.a = a
  self.b = b

TrivialNumeric.__init__ = TrivialNumeric__init__

def TrivialNumeric__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  self.__dict__ = state

TrivialNumeric.__getstate__ = lambda self: self.__dict__.copy()
TrivialNumeric.__setstate__ = TrivialNumeric__setstate__

all_structs.append(TrivialNestedWithDefault)
TrivialNestedWithDefault.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'z', None, 4, 2, ), # 1
  (2, TType.STRUCT, 'n', [TrivialNumeric, TrivialNumeric.thrift_spec, False], TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  }), 2, ), # 2
)))

TrivialNestedWithDefault.thrift_struct_annotations = {
}
TrivialNestedWithDefault.thrift_field_annotations = {
}

def TrivialNestedWithDefault__init__(self, z=TrivialNestedWithDefault.thrift_spec[1][4], n=TrivialNestedWithDefault.thrift_spec[2][4],):
  self.z = z
  if n is self.thrift_spec[2][4]:
    n = TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  })
  self.n = n

TrivialNestedWithDefault.__init__ = TrivialNestedWithDefault__init__

def TrivialNestedWithDefault__setstate__(self, state):
  state.setdefault('z', 4)
  state.setdefault('n', TrivialNumeric(**{
    "a" : 3,
    "b" : True,
  }))
  self.__dict__ = state

TrivialNestedWithDefault.__getstate__ = lambda self: self.__dict__.copy()
TrivialNestedWithDefault.__setstate__ = TrivialNestedWithDefault__setstate__

all_structs.append(ComplexString)
ComplexString.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'a', True, None, 2, ), # 1
  (2, TType.MAP, 'b', (TType.STRING,True,TType.I32,None), None, 2, ), # 2
)))

ComplexString.thrift_struct_annotations = {
}
ComplexString.thrift_field_annotations = {
}

def ComplexString__init__(self, a=None, b=None,):
  self.a = a
  self.b = b

ComplexString.__init__ = ComplexString__init__

def ComplexString__setstate__(self, state):
  state.setdefault('a', None)
  state.setdefault('b', None)
  self.__dict__ = state

ComplexString.__getstate__ = lambda self: self.__dict__.copy()
ComplexString.__setstate__ = ComplexString__setstate__

all_structs.append(ComplexNestedWithDefault)
ComplexNestedWithDefault.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'z', True, "4", 2, ), # 1
  (2, TType.STRUCT, 'n', [ComplexString, ComplexString.thrift_spec, False], ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  }), 2, ), # 2
)))

ComplexNestedWithDefault.thrift_struct_annotations = {
}
ComplexNestedWithDefault.thrift_field_annotations = {
}

def ComplexNestedWithDefault__init__(self, z=ComplexNestedWithDefault.thrift_spec[1][4], n=ComplexNestedWithDefault.thrift_spec[2][4],):
  self.z = z
  if n is self.thrift_spec[2][4]:
    n = ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  })
  self.n = n

ComplexNestedWithDefault.__init__ = ComplexNestedWithDefault__init__

def ComplexNestedWithDefault__setstate__(self, state):
  state.setdefault('z', "4")
  state.setdefault('n', ComplexString(**{
    "a" : "3",
    "b" : {
      "a" : 3,
    },
  }))
  self.__dict__ = state

ComplexNestedWithDefault.__getstate__ = lambda self: self.__dict__.copy()
ComplexNestedWithDefault.__setstate__ = ComplexNestedWithDefault__setstate__

all_structs.append(MinPadding)
MinPadding.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BYTE, 'small', None, None, 0, ), # 1
  (2, TType.I64, 'big', None, None, 0, ), # 2
  (3, TType.I16, 'medium', None, None, 0, ), # 3
  (4, TType.I32, 'biggish', None, None, 0, ), # 4
  (5, TType.BYTE, 'tiny', None, None, 0, ), # 5
)))

MinPadding.thrift_struct_annotations = {
}
MinPadding.thrift_field_annotations = {
}

def MinPadding__init__(self, small=None, big=None, medium=None, biggish=None, tiny=None,):
  self.small = small
  self.big = big
  self.medium = medium
  self.biggish = biggish
  self.tiny = tiny

MinPadding.__init__ = MinPadding__init__

def MinPadding__setstate__(self, state):
  state.setdefault('small', None)
  state.setdefault('big', None)
  state.setdefault('medium', None)
  state.setdefault('biggish', None)
  state.setdefault('tiny', None)
  self.__dict__ = state

MinPadding.__getstate__ = lambda self: self.__dict__.copy()
MinPadding.__setstate__ = MinPadding__setstate__

all_structs.append(MinPaddingWithCustomType)
MinPaddingWithCustomType.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BYTE, 'small', None, None, 3, ), # 1
  (2, TType.I64, 'big', None, None, 3, ), # 2
  (3, TType.I16, 'medium', None, None, 3, ), # 3
  (4, TType.I32, 'biggish', None, None, 3, ), # 4
  (5, TType.BYTE, 'tiny', None, None, 3, ), # 5
)))

MinPaddingWithCustomType.thrift_struct_annotations = {
}
MinPaddingWithCustomType.thrift_field_annotations = {
}

def MinPaddingWithCustomType__init__(self, small=None, big=None, medium=None, biggish=None, tiny=None,):
  self.small = small
  self.big = big
  self.medium = medium
  self.biggish = biggish
  self.tiny = tiny

MinPaddingWithCustomType.__init__ = MinPaddingWithCustomType__init__

def MinPaddingWithCustomType__setstate__(self, state):
  state.setdefault('small', None)
  state.setdefault('big', None)
  state.setdefault('medium', None)
  state.setdefault('biggish', None)
  state.setdefault('tiny', None)
  self.__dict__ = state

MinPaddingWithCustomType.__getstate__ = lambda self: self.__dict__.copy()
MinPaddingWithCustomType.__setstate__ = MinPaddingWithCustomType__setstate__

all_structs.append(MyStruct)
MyStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'MyIntField', None, None, 2, ), # 1
  (2, TType.STRING, 'MyStringField', True, None, 2, ), # 2
  (3, TType.I64, 'majorVer', None, None, 2, ), # 3
  (4, TType.STRUCT, 'data', [MyDataItem, MyDataItem.thrift_spec, False], None, 2, ), # 4
)))

MyStruct.thrift_struct_annotations = {
  "cpp.noncomparable": "1",
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, MyIntField=None, MyStringField=None, majorVer=None, data=None,):
  self.MyIntField = MyIntField
  self.MyStringField = MyStringField
  self.majorVer = majorVer
  self.data = data

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('MyIntField', None)
  state.setdefault('MyStringField', None)
  state.setdefault('majorVer', None)
  state.setdefault('data', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(MyDataItem)
MyDataItem.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

MyDataItem.thrift_struct_annotations = {
  "cpp.noncomparable": "1",
}
MyDataItem.thrift_field_annotations = {
}

all_structs.append(Renaming)
Renaming.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'foo', None, None, 2, ), # 1
)))

Renaming.thrift_struct_annotations = {
  "cpp.name": "Renamed",
}
Renaming.thrift_field_annotations = {
  1: {
    "cpp.name": "bar",
  },
}

def Renaming__init__(self, foo=None,):
  self.foo = foo

Renaming.__init__ = Renaming__init__

def Renaming__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

Renaming.__getstate__ = lambda self: self.__dict__.copy()
Renaming.__setstate__ = Renaming__setstate__

all_structs.append(AnnotatedTypes)
AnnotatedTypes.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'binary_field', False, None, 2, ), # 1
  (2, TType.LIST, 'list_field', (TType.MAP,(TType.I32,None,TType.STRING,True)), None, 2, ), # 2
)))

AnnotatedTypes.thrift_struct_annotations = {
}
AnnotatedTypes.thrift_field_annotations = {
}

def AnnotatedTypes__init__(self, binary_field=None, list_field=None,):
  self.binary_field = binary_field
  self.list_field = list_field

AnnotatedTypes.__init__ = AnnotatedTypes__init__

def AnnotatedTypes__setstate__(self, state):
  state.setdefault('binary_field', None)
  state.setdefault('list_field', None)
  self.__dict__ = state

AnnotatedTypes.__getstate__ = lambda self: self.__dict__.copy()
AnnotatedTypes.__setstate__ = AnnotatedTypes__setstate__

all_structs.append(ForwardUsageRoot)
ForwardUsageRoot.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'ForwardUsageStruct', [ForwardUsageStruct, ForwardUsageStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.STRUCT, 'ForwardUsageByRef', [ForwardUsageByRef, ForwardUsageByRef.thrift_spec, False], None, 1, ), # 2
)))

ForwardUsageRoot.thrift_struct_annotations = {
}
ForwardUsageRoot.thrift_field_annotations = {
}

def ForwardUsageRoot__init__(self, ForwardUsageStruct=None, ForwardUsageByRef=None,):
  self.ForwardUsageStruct = ForwardUsageStruct
  self.ForwardUsageByRef = ForwardUsageByRef

ForwardUsageRoot.__init__ = ForwardUsageRoot__init__

def ForwardUsageRoot__setstate__(self, state):
  state.setdefault('ForwardUsageStruct', None)
  state.setdefault('ForwardUsageByRef', None)
  self.__dict__ = state

ForwardUsageRoot.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageRoot.__setstate__ = ForwardUsageRoot__setstate__

all_structs.append(ForwardUsageStruct)
ForwardUsageStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'foo', [ForwardUsageRoot, ForwardUsageRoot.thrift_spec, False], None, 1, ), # 1
)))

ForwardUsageStruct.thrift_struct_annotations = {
}
ForwardUsageStruct.thrift_field_annotations = {
}

def ForwardUsageStruct__init__(self, foo=None,):
  self.foo = foo

ForwardUsageStruct.__init__ = ForwardUsageStruct__init__

def ForwardUsageStruct__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

ForwardUsageStruct.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageStruct.__setstate__ = ForwardUsageStruct__setstate__

all_structs.append(ForwardUsageByRef)
ForwardUsageByRef.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'foo', [ForwardUsageRoot, ForwardUsageRoot.thrift_spec, False], None, 1, ), # 1
)))

ForwardUsageByRef.thrift_struct_annotations = {
}
ForwardUsageByRef.thrift_field_annotations = {
}

def ForwardUsageByRef__init__(self, foo=None,):
  self.foo = foo

ForwardUsageByRef.__init__ = ForwardUsageByRef__init__

def ForwardUsageByRef__setstate__(self, state):
  state.setdefault('foo', None)
  self.__dict__ = state

ForwardUsageByRef.__getstate__ = lambda self: self.__dict__.copy()
ForwardUsageByRef.__setstate__ = ForwardUsageByRef__setstate__

all_structs.append(IncompleteMap)
IncompleteMap.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.MAP, 'field', (TType.I32,None,TType.STRUCT,[IncompleteMapDep, IncompleteMapDep.thrift_spec, False]), None, 1, ), # 1
)))

IncompleteMap.thrift_struct_annotations = {
}
IncompleteMap.thrift_field_annotations = {
}

def IncompleteMap__init__(self, field=None,):
  self.field = field

IncompleteMap.__init__ = IncompleteMap__init__

def IncompleteMap__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

IncompleteMap.__getstate__ = lambda self: self.__dict__.copy()
IncompleteMap.__setstate__ = IncompleteMap__setstate__

all_structs.append(IncompleteMapDep)
IncompleteMapDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

IncompleteMapDep.thrift_struct_annotations = {
}
IncompleteMapDep.thrift_field_annotations = {
}

all_structs.append(CompleteMap)
CompleteMap.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.MAP, 'field', (TType.I32,None,TType.STRUCT,[CompleteMapDep, CompleteMapDep.thrift_spec, False]), None, 1, ), # 1
)))

CompleteMap.thrift_struct_annotations = {
}
CompleteMap.thrift_field_annotations = {
}

def CompleteMap__init__(self, field=None,):
  self.field = field

CompleteMap.__init__ = CompleteMap__init__

def CompleteMap__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

CompleteMap.__getstate__ = lambda self: self.__dict__.copy()
CompleteMap.__setstate__ = CompleteMap__setstate__

all_structs.append(CompleteMapDep)
CompleteMapDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

CompleteMapDep.thrift_struct_annotations = {
}
CompleteMapDep.thrift_field_annotations = {
}

all_structs.append(IncompleteList)
IncompleteList.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'field', (TType.STRUCT,[IncompleteListDep, IncompleteListDep.thrift_spec, False]), None, 1, ), # 1
)))

IncompleteList.thrift_struct_annotations = {
}
IncompleteList.thrift_field_annotations = {
}

def IncompleteList__init__(self, field=None,):
  self.field = field

IncompleteList.__init__ = IncompleteList__init__

def IncompleteList__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

IncompleteList.__getstate__ = lambda self: self.__dict__.copy()
IncompleteList.__setstate__ = IncompleteList__setstate__

all_structs.append(IncompleteListDep)
IncompleteListDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

IncompleteListDep.thrift_struct_annotations = {
}
IncompleteListDep.thrift_field_annotations = {
}

all_structs.append(CompleteList)
CompleteList.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'field', (TType.STRUCT,[CompleteListDep, CompleteListDep.thrift_spec, False]), None, 1, ), # 1
)))

CompleteList.thrift_struct_annotations = {
}
CompleteList.thrift_field_annotations = {
}

def CompleteList__init__(self, field=None,):
  self.field = field

CompleteList.__init__ = CompleteList__init__

def CompleteList__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

CompleteList.__getstate__ = lambda self: self.__dict__.copy()
CompleteList.__setstate__ = CompleteList__setstate__

all_structs.append(CompleteListDep)
CompleteListDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

CompleteListDep.thrift_struct_annotations = {
}
CompleteListDep.thrift_field_annotations = {
}

all_structs.append(AdaptedList)
AdaptedList.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'field', (TType.STRUCT,[AdaptedListDep, AdaptedListDep.thrift_spec, False]), None, 1, ), # 1
)))

AdaptedList.thrift_struct_annotations = {
}
AdaptedList.thrift_field_annotations = {
}

def AdaptedList__init__(self, field=None,):
  self.field = field

AdaptedList.__init__ = AdaptedList__init__

def AdaptedList__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

AdaptedList.__getstate__ = lambda self: self.__dict__.copy()
AdaptedList.__setstate__ = AdaptedList__setstate__

all_structs.append(AdaptedListDep)
AdaptedListDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'field', [AdaptedList, AdaptedList.thrift_spec, False], None, 2, ), # 1
)))

AdaptedListDep.thrift_struct_annotations = {
}
AdaptedListDep.thrift_field_annotations = {
}

def AdaptedListDep__init__(self, field=None,):
  self.field = field

AdaptedListDep.__init__ = AdaptedListDep__init__

def AdaptedListDep__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

AdaptedListDep.__getstate__ = lambda self: self.__dict__.copy()
AdaptedListDep.__setstate__ = AdaptedListDep__setstate__

all_structs.append(DependentAdaptedList)
DependentAdaptedList.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'field', (TType.STRUCT,[DependentAdaptedListDep, DependentAdaptedListDep.thrift_spec, False]), None, 1, ), # 1
)))

DependentAdaptedList.thrift_struct_annotations = {
}
DependentAdaptedList.thrift_field_annotations = {
}

def DependentAdaptedList__init__(self, field=None,):
  self.field = field

DependentAdaptedList.__init__ = DependentAdaptedList__init__

def DependentAdaptedList__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

DependentAdaptedList.__getstate__ = lambda self: self.__dict__.copy()
DependentAdaptedList.__setstate__ = DependentAdaptedList__setstate__

all_structs.append(DependentAdaptedListDep)
DependentAdaptedListDep.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I16, 'field', None, None, 1, ), # 1
)))

DependentAdaptedListDep.thrift_struct_annotations = {
}
DependentAdaptedListDep.thrift_field_annotations = {
}

def DependentAdaptedListDep__init__(self, field=None,):
  self.field = field

DependentAdaptedListDep.__init__ = DependentAdaptedListDep__init__

def DependentAdaptedListDep__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

DependentAdaptedListDep.__getstate__ = lambda self: self.__dict__.copy()
DependentAdaptedListDep.__setstate__ = DependentAdaptedListDep__setstate__

all_structs.append(AllocatorAware)
AllocatorAware.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.LIST, 'aa_list', (TType.I32,None), None, 2, ), # 1
  (2, TType.SET, 'aa_set', (TType.I32,None), None, 2, ), # 2
  (3, TType.MAP, 'aa_map', (TType.I32,None,TType.I32,None), None, 2, ), # 3
  (4, TType.STRING, 'aa_string', True, None, 2, ), # 4
  (5, TType.I32, 'not_a_container', None, None, 2, ), # 5
  (6, TType.I32, 'aa_unique', None, None, 2, ), # 6
  (7, TType.I32, 'aa_shared', None, None, 2, ), # 7
)))

AllocatorAware.thrift_struct_annotations = {
  "cpp.allocator": "some_allocator",
}
AllocatorAware.thrift_field_annotations = {
}

def AllocatorAware__init__(self, aa_list=None, aa_set=None, aa_map=None, aa_string=None, not_a_container=None, aa_unique=None, aa_shared=None,):
  self.aa_list = aa_list
  self.aa_set = aa_set
  self.aa_map = aa_map
  self.aa_string = aa_string
  self.not_a_container = not_a_container
  self.aa_unique = aa_unique
  self.aa_shared = aa_shared

AllocatorAware.__init__ = AllocatorAware__init__

def AllocatorAware__setstate__(self, state):
  state.setdefault('aa_list', None)
  state.setdefault('aa_set', None)
  state.setdefault('aa_map', None)
  state.setdefault('aa_string', None)
  state.setdefault('not_a_container', None)
  state.setdefault('aa_unique', None)
  state.setdefault('aa_shared', None)
  self.__dict__ = state

AllocatorAware.__getstate__ = lambda self: self.__dict__.copy()
AllocatorAware.__setstate__ = AllocatorAware__setstate__

all_structs.append(AllocatorAware2)
AllocatorAware2.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'not_a_container', None, None, 2, ), # 1
  (2, TType.I32, 'box_field', None, None, 1, ), # 2
)))

AllocatorAware2.thrift_struct_annotations = {
  "cpp.allocator": "some_allocator",
}
AllocatorAware2.thrift_field_annotations = {
}

def AllocatorAware2__init__(self, not_a_container=None, box_field=None,):
  self.not_a_container = not_a_container
  self.box_field = box_field

AllocatorAware2.__init__ = AllocatorAware2__init__

def AllocatorAware2__setstate__(self, state):
  state.setdefault('not_a_container', None)
  state.setdefault('box_field', None)
  self.__dict__ = state

AllocatorAware2.__getstate__ = lambda self: self.__dict__.copy()
AllocatorAware2.__setstate__ = AllocatorAware2__setstate__

all_structs.append(TypedefStruct)
TypedefStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'i32_field', None, None, 2, ), # 1
  (2, TType.I32, 'IntTypedef_field', None, None, 2, ), # 2
  (3, TType.I32, 'UintTypedef_field', None, None, 2, ), # 3
)))

TypedefStruct.thrift_struct_annotations = {
}
TypedefStruct.thrift_field_annotations = {
}

def TypedefStruct__init__(self, i32_field=None, IntTypedef_field=None, UintTypedef_field=None,):
  self.i32_field = i32_field
  self.IntTypedef_field = IntTypedef_field
  self.UintTypedef_field = UintTypedef_field

TypedefStruct.__init__ = TypedefStruct__init__

def TypedefStruct__setstate__(self, state):
  state.setdefault('i32_field', None)
  state.setdefault('IntTypedef_field', None)
  state.setdefault('UintTypedef_field', None)
  self.__dict__ = state

TypedefStruct.__getstate__ = lambda self: self.__dict__.copy()
TypedefStruct.__setstate__ = TypedefStruct__setstate__

all_structs.append(StructWithDoubleUnderscores)
StructWithDoubleUnderscores.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, '__field', None, None, 2, ), # 1
)))

StructWithDoubleUnderscores.thrift_struct_annotations = {
}
StructWithDoubleUnderscores.thrift_field_annotations = {
}

def StructWithDoubleUnderscores__init__(self, __field=None,):
  self.__field = __field

StructWithDoubleUnderscores.__init__ = StructWithDoubleUnderscores__init__

def StructWithDoubleUnderscores__setstate__(self, state):
  state.setdefault('__field', None)
  self.__dict__ = state

StructWithDoubleUnderscores.__getstate__ = lambda self: self.__dict__.copy()
StructWithDoubleUnderscores.__setstate__ = StructWithDoubleUnderscores__setstate__

fix_spec(all_structs)
del all_structs
