<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace facebook\thrift\annotation\python;

/**
 * An enum that specifies the constraint behavior on a field.
 * 
 * In this context, "constraint" refers to any logic applied by
 * Thrift-provided types and runtime libraries on native (Python)
 * operations that do not fully comply with the Thrift Object Model,
 * but could otherwise be valid Python.
 * 
 * An example of such an operation (and the first concrete use of
 * this annotation) is the handling of 32-bit floating point numbers:
 * native Python `float`s all have the same width, which is
 * typically 64 bits, whereas Thrift's `float` type is 32 bit
 * (compared to `double`, which is 64 bits). Writing a 64 bit
 * Python float to a 32-bit Thrift float is an example of a
 * potentially non-compliant operation, that may require a constraint
 * to be applied - implicitly or explicitly.
 * 
 * Original thrift enum:-
 * ConstraintLevel
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/ConstraintLevel'))>>
enum ConstraintLevel: int {
  /**
   * UNSPECIFIED: Intrinsic default value for this enum. Should never be assigned
   * explicitly. The actual constraint level applied on `UNSPECIFIED`
   * depends on the operation, and is documented below.
   */
  UNSPECIFIED = 0;
  /**
   * ALLOW_INVALID: applies the lowest level of validation on struct creation or
   * mutation. While some basic type checking may be performed,
   * does not fully validate that the value conforms to the
   * [Thrift Object Model](https://github.com/facebook/fbthrift/blob/main/thrift/doc/object-model/index.md#primitive-types).
   * 
   * Native (Python) operations with this constraint level SHOULD NOT
   * immediately fail, but MAY result in non-compliant Thrift values.
   * Subsequent operations on these values (eg. serialization) MAY fail.
   */
  ALLOW_INVALID = 1;
  /**
   * MAP: maps the input value to the closest conforming value. For example,
   * thrift-python MAPs integer `float` values to `i64` fields.
   * 
   * Native (Python) operations with this constraint level SHOULD NOT
   * immediately fail, and MUST produce a result that is compliant with the
   * Thrift Object Model. That result MAY not be the same as the originally
   * intended change by the user.
   */
  MAP = 2;
  /**
   * REJECT: applies the strictest level of validation on struct creation or
   * mutation. Raises an error for input types that do not exactly
   * conform to the Thrift Object Model. For example, integers
   * greater than INT64_MAX cause OverflowError when used with a Thrift
   * `i64` field.
   * 
   * Native (Python) operations with this constraint level MAY fail. If they do
   * not fail, they MUST produce a result that is both (1) compliant with the
   * Thrift Object Model, and (2) identical to the user's intent.
   */
  REJECT = 3;
}

class ConstraintLevel_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return \tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "python.ConstraintLevel",
        "elements" => dict[
          0 => "UNSPECIFIED",
          1 => "ALLOW_INVALID",
          2 => "MAP",
          3 => "REJECT",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Hides in thrift-py3 only, not in thrift-python
 * Allowed for all @scope.Definition, except for @scope.FunctionParameter as that would hide part of
 * the RPC function parameters.
 *
 * Original thrift struct:-
 * Py3Hidden
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/Py3Hidden'))>>
class Py3Hidden implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'Py3Hidden';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.Py3Hidden",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\RootDefinition' => \facebook\thrift\annotation\RootDefinition::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\Field' => \facebook\thrift\annotation\Field::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\TFunction' => \facebook\thrift\annotation\TFunction::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\Transitive' => \facebook\thrift\annotation\Transitive::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Hides in thrift-py-deprecated only
 *
 * Original thrift struct:-
 * PyDeprecatedHidden
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/PyDeprecatedHidden'))>>
class PyDeprecatedHidden implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'reason',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'reason' => 1,
  ];

  const type TConstructorShape = shape(
    ?'reason' => ?string,
  );

  const type TShape = shape(
    'reason' => string,
  );
  const int STRUCTURAL_ID = 8764363268396101679;
  /**
   * Original thrift field:-
   * 1: string reason
   */
  public string $reason;

  public function __construct(?string $reason = null)[] {
    $this->reason = $reason ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'reason'),
    );
  }

  public function getName()[]: string {
    return 'PyDeprecatedHidden';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.PyDeprecatedHidden",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "reason",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Field' => \facebook\thrift\annotation\Field::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['reason'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'reason' => $this->reason,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'reason') !== null) {
      $this->reason = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['reason']);
    }
  }

}

/**
 * Original thrift struct:-
 * Flags
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/Flags'))>>
class Flags implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'Flags';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.Flags",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Enum' => \facebook\thrift\annotation\Enum::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * Name
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/Name'))>>
class Name implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'name',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'name' => 1,
  ];

  const type TConstructorShape = shape(
    ?'name' => ?string,
  );

  const type TShape = shape(
    'name' => string,
  );
  const int STRUCTURAL_ID = 7068917836668558637;
  /**
   * Original thrift field:-
   * 1: string name
   */
  public string $name;

  public function __construct(?string $name = null)[] {
    $this->name = $name ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'name'),
    );
  }

  public function getName()[]: string {
    return 'Name';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.Name",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "name",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Definition' => \facebook\thrift\annotation\Definition::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['name'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'name' => $this->name,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'name') !== null) {
      $this->name = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['name']);
    }
  }

}

/**
 * An annotation that applies a Python adapter to typedef or field, or directly on struct.
 * This completely replaces the underlying type of a thrift for a custom implementation and
 * uses the specified adapter to convert to and from the underlying Thrift type during (de)serialization.
 * 
 * Example 1:
 * 
 *   @python.Adapter{name = "my.module.DatetimeAdapter", typeHint = "datetime.datetime"}
 *   typedef i64 Datetime
 * 
 * Here the type 'Datetime' has the Python adapter `DatetimeAdapter`.
 * 
 * 
 * Example 2:
 * 
 *   struct User {
 *     @python.Adapter{name = "my.module.DatetimeAdapter", typeHint = "datetime.datetime"}
 *     1: i64 created_at;
 *   }
 * Here the field `created_at` has the Python adapter `DatetimeAdapter`.
 * 
 * 
 * Example 3:
 * 
 * 
 *   @python.Adapter{name = "my.module.AnotherAdapter", typeHint = "my.module.AdaptedFoo"}
 *   struct Foo {
 *     1: string bar;
 *   }
 * 
 * Here the struct `Foo` has the Python adapter `AnotherAdapter`.
 * 
 *
 * Original thrift struct:-
 * Adapter
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/Adapter'))>>
class Adapter implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'name',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'typeHint',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'name' => 1,
    'typeHint' => 2,
  ];

  const type TConstructorShape = shape(
    ?'name' => ?string,
    ?'typeHint' => ?string,
  );

  const type TShape = shape(
    'name' => string,
    'typeHint' => string,
  );
  const int STRUCTURAL_ID = 4097712627775983104;
  /**
   * Fully qualified name of a Python adapter class, which should inherit from thrift.python.adapter.Adapter
   * 
   * Original thrift field:-
   * 1: string name
   */
  public string $name;
  /**
   * Fully qualified type hint the above implementation adapts to.
   * If ending with "[]", it becomes a generic, and the unadapted type will be filled between the brackets.
   * 
   * Original thrift field:-
   * 2: string typeHint
   */
  public string $typeHint;

  public function __construct(?string $name = null, ?string $typeHint = null)[] {
    $this->name = $name ?? '';
    $this->typeHint = $typeHint ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'name'),
      Shapes::idx($shape, 'typeHint'),
    );
  }

  public function getName()[]: string {
    return 'Adapter';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.Adapter",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "name",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "typeHint",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Field' => \facebook\thrift\annotation\Field::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\Typedef' => \facebook\thrift\annotation\Typedef::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\Structured' => \facebook\thrift\annotation\Structured::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['name'],
      $shape['typeHint'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'name' => $this->name,
      'typeHint' => $this->typeHint,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'name') !== null) {
      $this->name = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['name']);
    }
    if (idx($parsed, 'typeHint') !== null) {
      $this->typeHint = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['typeHint']);
    }
  }

}

/**
 * Controls cpp <-> python FFI for a struct or union
 * By default, struct uses marshal C API unless cpp.Type or cpp.Adapter is present
 * on a field or a type
 * Use this annotation to opt-in struct to marshal in spite of cpp.Type or cpp.Adapter
 * Alternatively, use this struct with serialize = false to use serialization for FFI.
 *
 * Original thrift struct:-
 * UseCAPI
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/UseCAPI'))>>
class UseCAPI implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'serialize',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'serialize' => 1,
  ];

  const type TConstructorShape = shape(
    ?'serialize' => ?bool,
  );

  const type TShape = shape(
    'serialize' => bool,
  );
  const int STRUCTURAL_ID = 7609034054625979820;
  /**
   * Original thrift field:-
   * 1: bool serialize
   */
  public bool $serialize;

  public function __construct(?bool $serialize = null)[] {
    $this->serialize = $serialize ?? false;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'serialize'),
    );
  }

  public function getName()[]: string {
    return 'UseCAPI';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.UseCAPI",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "serialize",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Structured' => \facebook\thrift\annotation\Structured::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['serialize'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'serialize' => $this->serialize,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'serialize') !== null) {
      $this->serialize = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['serialize']);
    }
  }

}

/**
 * Enables C++ Adapter for thrift-py3. It treats C++ Adapter on typedef as cpp.Type.
 * It is only available for typedefs that resolve to binary, string, and container type.
 *
 * Original thrift struct:-
 * Py3EnableCppAdapter
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/Py3EnableCppAdapter'))>>
class Py3EnableCppAdapter implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'Py3EnableCppAdapter';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.Py3EnableCppAdapter",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Typedef' => \facebook\thrift\annotation\Typedef::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Allows inheritance from a struct or exception in thrift-py3.
 * Inheritance from union is DEPRECATED!
 * Do not add new usage of this. Prefer composition over inheritance.
 *
 * Original thrift struct:-
 * MigrationBlockingAllowInheritance
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/MigrationBlockingAllowInheritance'))>>
class MigrationBlockingAllowInheritance implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'MigrationBlockingAllowInheritance';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.MigrationBlockingAllowInheritance",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Struct' => \facebook\thrift\annotation\Struct::fromShape(
          shape(
          )
        ),
        '\facebook\thrift\annotation\Exception' => \facebook\thrift\annotation\Exception::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Enables sorted order for a field with `set` type.
 * Only affects serialization for thrift-python and thrift-py3.
 * Note that `set` in thrift-python has no stable ordering once deserialized.
 * DO NOT RELY on this. Brittle tests that rely on this will eventually be disabled.
 *
 * Original thrift struct:-
 * DeprecatedSortSetOnSerialize
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/DeprecatedSortSetOnSerialize'))>>
class DeprecatedSortSetOnSerialize implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'DeprecatedSortSetOnSerialize';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.DeprecatedSortSetOnSerialize",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Field' => \facebook\thrift\annotation\Field::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Enables key-sorted order for a field with `map` type.
 * Only affects thrift-python and thrift-py3.
 * Note that key sorting only occurs on serialization, and not on deserialization.
 * DO NOT RELY on this. Brittle tests that rely on this will eventually be disabled.
 *
 * Original thrift struct:-
 * DeprecatedKeySortMapOnSerialize
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/DeprecatedKeySortMapOnSerialize'))>>
class DeprecatedKeySortMapOnSerialize implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'DeprecatedKeySortMapOnSerialize';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.DeprecatedKeySortMapOnSerialize",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Field' => \facebook\thrift\annotation\Field::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Disable caching all fields for a struct.
 * Also available as a thrift_library compiler option:
 *     thrift_library(..., thrift_python_options = ["disable_field_cache"])
 * 
 * Has NO effect in cinder runtime (e.g., IG Django)
 * Only affects thrift-python, not older deprecated variants.
 * 
 * Usage guidelines:
 *   - Improves latency/throughput when struct fields accessed only once.
 *   - Reduces memory usage for most use cases; try this to resolve OOMs.
 *   - Worsens latency for subsequent field accesses relative to default.
 *
 * Original thrift struct:-
 * DisableFieldCache
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/DisableFieldCache'))>>
class DisableFieldCache implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'DisableFieldCache';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.DisableFieldCache",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Struct' => \facebook\thrift\annotation\Struct::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Allows custom constraint on Thrift `float` fields, i.e., 32-bit floating-
 * point values, during Python thrift struct initialization or mutation.
 * 
 * This is necessary because Python's native floating-point number type
 * (`float`) may have more precision that 32 bits. Indeed, while the exact
 * precision is implementation-specified, it typically corresponds to `double`
 * in C, i.e. 64 bits (see
 * https://docs.python.org/3/library/stdtypes.html#typesnumeric). Ensuring that
 * such native values are valid 32-bit Thrift `float`s requires them to be
 * properly constrained, by either:
 * 1. rounding them to the closest 32-bit number, if they are in range, or
 * 2. bounding them to +/-Inf if they are greater/less than the max/min
 *    representable 32-bit number.
 * 
 * By default, in the absence of this annotation, thrift-python types ensure
 * that all values assigned to (or accessed from) single precision
 * floating-point (i.e., `float` in Thrift IDL) fields have the correct
 * precision, constraining them as needed.
 * 
 * Note that NaN is *never* a valid Thrift floating point number, as specified
 * in the [Thrift Object Model](https://github.com/facebook/fbthrift/blob/main/thrift/doc/object-model/index.md#primitive-types).
 * The behavior of Thrift operations in presence of native Python NaN values is
 * left undefined.
 * 
 * The behavior may be customized using each field of this struct. The defaults
 * correspond to the default behavior if this annotation is not applied to the
 * `float` type.
 * 
 * This annotation MUST NOT be applied on fields whose [Thrift IDL Type](https://github.com/facebook/fbthrift/blob/main/thrift/doc/glossary/kinds-of-types.md#thrift-idl-types)
 * is not `float`, or a container whose item type(s) are not `float` (or
 * containers that satisfy this property, recursively).
 *
 * Original thrift struct:-
 * ConstrainedFloat32
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/annotation/python/ConstrainedFloat32'))>>
class ConstrainedFloat32 implements \IThriftSyncStruct, \IThriftStructMetadata, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const \ThriftStructTypes::TSpec SPEC = dict[
    1 => shape(
      'var' => 'precision_loss',
      'type' => \TType::I32,
      'enum' => \facebook\thrift\annotation\python\ConstraintLevel::class,
    ),
    2 => shape(
      'var' => 'inf_overflow',
      'type' => \TType::I32,
      'enum' => \facebook\thrift\annotation\python\ConstraintLevel::class,
    ),
    3 => shape(
      'var' => 'not_a_number',
      'type' => \TType::I32,
      'enum' => \facebook\thrift\annotation\python\ConstraintLevel::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'precision_loss' => 1,
    'inf_overflow' => 2,
    'not_a_number' => 3,
  ];

  const type TConstructorShape = shape(
    ?'precision_loss' => ?\facebook\thrift\annotation\python\ConstraintLevel,
    ?'inf_overflow' => ?\facebook\thrift\annotation\python\ConstraintLevel,
    ?'not_a_number' => ?\facebook\thrift\annotation\python\ConstraintLevel,
  );

  const type TShape = shape(
    ?'precision_loss' => ?\facebook\thrift\annotation\python\ConstraintLevel,
    ?'inf_overflow' => ?\facebook\thrift\annotation\python\ConstraintLevel,
    ?'not_a_number' => ?\facebook\thrift\annotation\python\ConstraintLevel,
  );
  const int STRUCTURAL_ID = 7967781561537107582;
  /**
   * - `precision_loss`: controls handling of `float` in the range
   * (-MAX_FLOAT_32, +MAX_FLOAT_32).
   * * ALLOW_INVALID: no rounding is applied at struct creation, but MAP
   *   applies on serialization.
   * * MAP: rounded to the nearest valid 32-bit float according to IEEE754
   *   trunctation convention.
   * * REJECT: raises `TypeError` if the type is not already a 32-bit float
   * 
   * Original thrift field:-
   * 1: python.ConstraintLevel precision_loss
   */
  public ?\facebook\thrift\annotation\python\ConstraintLevel $precision_loss;
  /**
   * - `inf_overflow`: controls handling of `float` outside the range
   * [-MAX_FLOAT_32, +MAX_FLOAT_32].
   * NOTE: values that are already +/- `Inf` are unaffected by this option.
   * * ALLOW_INVALID: the value is preserved on struct creation, but MAP
   *   applies on serialization.
   * * MAP: rounded "up" to +/- Inf according to sign, according to IEEE754
   *   convention.
   * * REJECT: raises `OverflowError` if the type is outside the range
   *   [-MAX_FLOAT_32, +MAX_FLOAT_32], unless the value is already
   *    +/- `Inf`, in which case it's preserved.
   * 
   * Original thrift field:-
   * 2: python.ConstraintLevel inf_overflow
   */
  public ?\facebook\thrift\annotation\python\ConstraintLevel $inf_overflow;
  /**
   * - `not_a_number`: controls handling of special `NaN` values.
   * * ALLOW_INVALID: the value is preserved on struct creation and serialization.
   * * MAP: same as ALLOW_INVALID.
   * * REJECT: raises `TypeError`for `NaN` values.
   * 
   * Original thrift field:-
   * 3: python.ConstraintLevel not_a_number
   */
  public ?\facebook\thrift\annotation\python\ConstraintLevel $not_a_number;

  public function __construct(?\facebook\thrift\annotation\python\ConstraintLevel $precision_loss = null, ?\facebook\thrift\annotation\python\ConstraintLevel $inf_overflow = null, ?\facebook\thrift\annotation\python\ConstraintLevel $not_a_number = null)[] {
    $this->precision_loss = $precision_loss;
    $this->inf_overflow = $inf_overflow;
    $this->not_a_number = $not_a_number;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'precision_loss'),
      Shapes::idx($shape, 'inf_overflow'),
      Shapes::idx($shape, 'not_a_number'),
    );
  }

  public function getName()[]: string {
    return 'ConstrainedFloat32';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "python.ConstrainedFloat32",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_enum" => \tmeta_ThriftEnumType::fromShape(
                    shape(
                      "name" => "python.ConstraintLevel",
                    )
                  ),
                )
              ),
              "name" => "precision_loss",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_enum" => \tmeta_ThriftEnumType::fromShape(
                    shape(
                      "name" => "python.ConstraintLevel",
                    )
                  ),
                )
              ),
              "name" => "inf_overflow",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_enum" => \tmeta_ThriftEnumType::fromShape(
                    shape(
                      "name" => "python.ConstraintLevel",
                    )
                  ),
                )
              ),
              "name" => "not_a_number",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\facebook\thrift\annotation\Typedef' => \facebook\thrift\annotation\Typedef::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'precision_loss'),
      Shapes::idx($shape, 'inf_overflow'),
      Shapes::idx($shape, 'not_a_number'),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'precision_loss' => $this->precision_loss,
      'inf_overflow' => $this->inf_overflow,
      'not_a_number' => $this->not_a_number,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'precision_loss') !== null) {
      $this->precision_loss = \facebook\thrift\annotation\python\ConstraintLevel::coerce(HH\FIXME\UNSAFE_CAST<mixed, \facebook\thrift\annotation\python\ConstraintLevel>($parsed['precision_loss']));
    }
    if (idx($parsed, 'inf_overflow') !== null) {
      $this->inf_overflow = \facebook\thrift\annotation\python\ConstraintLevel::coerce(HH\FIXME\UNSAFE_CAST<mixed, \facebook\thrift\annotation\python\ConstraintLevel>($parsed['inf_overflow']));
    }
    if (idx($parsed, 'not_a_number') !== null) {
      $this->not_a_number = \facebook\thrift\annotation\python\ConstraintLevel::coerce(HH\FIXME\UNSAFE_CAST<mixed, \facebook\thrift\annotation\python\ConstraintLevel>($parsed['not_a_number']));
    }
  }

}

