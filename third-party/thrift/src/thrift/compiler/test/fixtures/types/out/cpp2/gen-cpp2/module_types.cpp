/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_types.tcc"
#include "thrift/compiler/test/fixtures/types/gen-cpp2/module_data.h"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

[[maybe_unused]] static constexpr std::string_view kModuleName = "module";


namespace apache { namespace thrift {

const std::string_view TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::__fbthrift_module_name_internal_do_not_use = kModuleName;
folly::Range<::apache::thrift::fixtures::types::has_bitwise_ops const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::values);
folly::Range<std::string_view const*> const TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::has_bitwise_ops>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findName(type value, std::string_view* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::has_bitwise_ops>::findValue(std::string_view name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache { namespace thrift {

const std::string_view TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::__fbthrift_module_name_internal_do_not_use = kModuleName;
folly::Range<::apache::thrift::fixtures::types::is_unscoped const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::values);
folly::Range<std::string_view const*> const TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::is_unscoped>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findName(type value, std::string_view* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::is_unscoped>::findValue(std::string_view name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache { namespace thrift {

const std::string_view TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::__fbthrift_module_name_internal_do_not_use = kModuleName;
folly::Range<::apache::thrift::fixtures::types::MyForwardRefEnum const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::values = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::values);
folly::Range<std::string_view const*> const TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::names = folly::range(TEnumDataStorage<::apache::thrift::fixtures::types::MyForwardRefEnum>::names);

bool TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findName(type value, std::string_view* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::apache::thrift::fixtures::types::MyForwardRefEnum>::findValue(std::string_view name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift



namespace apache::thrift::fixtures::types {

std::string_view empty_struct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/empty_struct";
}

std::string_view empty_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<empty_struct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view empty_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<empty_struct>::name;
}


empty_struct::empty_struct(apache::thrift::FragileConstructor) {}

void empty_struct::__fbthrift_clear() {
  // clear all fields
}

void empty_struct::__fbthrift_clear_terse_fields() {
}

bool empty_struct::__fbthrift_is_empty() const {
  return true;
}

bool empty_struct::operator==([[maybe_unused]] const empty_struct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool empty_struct::operator<([[maybe_unused]] const empty_struct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] empty_struct& a, [[maybe_unused]] empty_struct& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view decorated_struct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/decorated_struct";
}

std::string_view decorated_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<decorated_struct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view decorated_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<decorated_struct>::name;
}

decorated_struct::decorated_struct(const decorated_struct&) = default;
decorated_struct& decorated_struct::operator=(const decorated_struct&) = default;
decorated_struct::decorated_struct() {
}


decorated_struct::~decorated_struct() {}

decorated_struct::decorated_struct([[maybe_unused]] decorated_struct&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

decorated_struct& decorated_struct::operator=([[maybe_unused]] decorated_struct&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


decorated_struct::decorated_struct(apache::thrift::FragileConstructor, ::std::string field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void decorated_struct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  __isset = {};
}

void decorated_struct::__fbthrift_clear_terse_fields() {
}

bool decorated_struct::__fbthrift_is_empty() const {
  return false;
}

bool decorated_struct::operator==([[maybe_unused]] const decorated_struct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool decorated_struct::operator<([[maybe_unused]] const decorated_struct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] decorated_struct& a, [[maybe_unused]] decorated_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ContainerStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ContainerStruct";
}

std::string_view ContainerStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ContainerStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ContainerStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ContainerStruct>::name;
}

ContainerStruct::ContainerStruct(const ContainerStruct&) = default;
ContainerStruct& ContainerStruct::operator=(const ContainerStruct&) = default;
ContainerStruct::ContainerStruct() {
}


ContainerStruct::~ContainerStruct() {}

ContainerStruct::ContainerStruct([[maybe_unused]] ContainerStruct&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __fbthrift_field_fieldH(std::move(other.__fbthrift_field_fieldH)),
    __isset(other.__isset) {
}

ContainerStruct& ContainerStruct::operator=([[maybe_unused]] ContainerStruct&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    this->__fbthrift_field_fieldH = std::move(other.__fbthrift_field_fieldH);
    __isset = other.__isset;
    return *this;
}


ContainerStruct::ContainerStruct(apache::thrift::FragileConstructor, ::std::vector<::std::int32_t> fieldA__arg, std::list<::std::int32_t> fieldB__arg, std::deque<::std::int32_t> fieldC__arg, folly::fbvector<::std::int32_t> fieldD__arg, folly::small_vector<::std::int32_t> fieldE__arg, ::apache::thrift::fixtures::types::set_i32_7194 fieldF__arg, folly::sorted_vector_map<::std::int32_t, ::std::string> fieldG__arg, ::apache::thrift::fixtures::types::SomeMap fieldH__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)),
    __fbthrift_field_fieldH(std::move(fieldH__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
}

void ContainerStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA.clear();
  this->__fbthrift_field_fieldB.clear();
  this->__fbthrift_field_fieldC.clear();
  this->__fbthrift_field_fieldD.clear();
  this->__fbthrift_field_fieldE.clear();
  this->__fbthrift_field_fieldF.clear();
  this->__fbthrift_field_fieldG.clear();
  this->__fbthrift_field_fieldH.clear();
  __isset = {};
}

void ContainerStruct::__fbthrift_clear_terse_fields() {
}

bool ContainerStruct::__fbthrift_is_empty() const {
  return false;
}

bool ContainerStruct::operator==([[maybe_unused]] const ContainerStruct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ContainerStruct::operator<([[maybe_unused]] const ContainerStruct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::vector<::std::int32_t>& ContainerStruct::get_fieldA() const& {
  return __fbthrift_field_fieldA;
}

::std::vector<::std::int32_t> ContainerStruct::get_fieldA() && {
  return static_cast<::std::vector<::std::int32_t>&&>(__fbthrift_field_fieldA);
}

const std::list<::std::int32_t>& ContainerStruct::get_fieldB() const& {
  return __fbthrift_field_fieldB;
}

std::list<::std::int32_t> ContainerStruct::get_fieldB() && {
  return static_cast<std::list<::std::int32_t>&&>(__fbthrift_field_fieldB);
}

const std::deque<::std::int32_t>& ContainerStruct::get_fieldC() const& {
  return __fbthrift_field_fieldC;
}

std::deque<::std::int32_t> ContainerStruct::get_fieldC() && {
  return static_cast<std::deque<::std::int32_t>&&>(__fbthrift_field_fieldC);
}

const folly::fbvector<::std::int32_t>& ContainerStruct::get_fieldD() const& {
  return __fbthrift_field_fieldD;
}

folly::fbvector<::std::int32_t> ContainerStruct::get_fieldD() && {
  return static_cast<folly::fbvector<::std::int32_t>&&>(__fbthrift_field_fieldD);
}

const folly::small_vector<::std::int32_t>& ContainerStruct::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

folly::small_vector<::std::int32_t> ContainerStruct::get_fieldE() && {
  return static_cast<folly::small_vector<::std::int32_t>&&>(__fbthrift_field_fieldE);
}

const ::apache::thrift::fixtures::types::set_i32_7194& ContainerStruct::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

::apache::thrift::fixtures::types::set_i32_7194 ContainerStruct::get_fieldF() && {
  return static_cast<::apache::thrift::fixtures::types::set_i32_7194&&>(__fbthrift_field_fieldF);
}

const folly::sorted_vector_map<::std::int32_t, ::std::string>& ContainerStruct::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

folly::sorted_vector_map<::std::int32_t, ::std::string> ContainerStruct::get_fieldG() && {
  return static_cast<folly::sorted_vector_map<::std::int32_t, ::std::string>&&>(__fbthrift_field_fieldG);
}

const ::apache::thrift::fixtures::types::SomeMap& ContainerStruct::get_fieldH() const& {
  return __fbthrift_field_fieldH;
}

::apache::thrift::fixtures::types::SomeMap ContainerStruct::get_fieldH() && {
  return static_cast<::apache::thrift::fixtures::types::SomeMap&&>(__fbthrift_field_fieldH);
}

void swap([[maybe_unused]] ContainerStruct& a, [[maybe_unused]] ContainerStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__fbthrift_field_fieldH, b.__fbthrift_field_fieldH);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view CppTypeStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/CppTypeStruct";
}

std::string_view CppTypeStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CppTypeStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view CppTypeStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<CppTypeStruct>::name;
}

CppTypeStruct::CppTypeStruct(const CppTypeStruct&) = default;
CppTypeStruct& CppTypeStruct::operator=(const CppTypeStruct&) = default;
CppTypeStruct::CppTypeStruct() {
}


CppTypeStruct::~CppTypeStruct() {}

CppTypeStruct::CppTypeStruct([[maybe_unused]] CppTypeStruct&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __isset(other.__isset) {
}

CppTypeStruct& CppTypeStruct::operator=([[maybe_unused]] CppTypeStruct&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    __isset = other.__isset;
    return *this;
}


CppTypeStruct::CppTypeStruct(apache::thrift::FragileConstructor, std::list<int32_t> fieldA__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void CppTypeStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA.clear();
  __isset = {};
}

void CppTypeStruct::__fbthrift_clear_terse_fields() {
}

bool CppTypeStruct::__fbthrift_is_empty() const {
  return false;
}

bool CppTypeStruct::operator==([[maybe_unused]] const CppTypeStruct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool CppTypeStruct::operator<([[maybe_unused]] const CppTypeStruct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const std::list<int32_t>& CppTypeStruct::get_fieldA() const& {
  return __fbthrift_field_fieldA;
}

std::list<int32_t> CppTypeStruct::get_fieldA() && {
  return static_cast<std::list<int32_t>&&>(__fbthrift_field_fieldA);
}

void swap([[maybe_unused]] CppTypeStruct& a, [[maybe_unused]] CppTypeStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view VirtualStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/VirtualStruct";
}

std::string_view VirtualStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<VirtualStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view VirtualStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<VirtualStruct>::name;
}

VirtualStruct::VirtualStruct(const VirtualStruct&) = default;
VirtualStruct& VirtualStruct::operator=(const VirtualStruct&) = default;
VirtualStruct::VirtualStruct([[maybe_unused]] VirtualStruct&& other) noexcept :
    __fbthrift_field_MyIntField(std::move(other.__fbthrift_field_MyIntField)),
    __isset(other.__isset) {
}

VirtualStruct& VirtualStruct::operator=([[maybe_unused]] VirtualStruct&& other) noexcept {
    this->__fbthrift_field_MyIntField = std::move(other.__fbthrift_field_MyIntField);
    __isset = other.__isset;
    return *this;
}


VirtualStruct::VirtualStruct(apache::thrift::FragileConstructor, ::std::int64_t MyIntField__arg) :
    __fbthrift_field_MyIntField(std::move(MyIntField__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void VirtualStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_MyIntField = ::std::int64_t();
  __isset = {};
}

void VirtualStruct::__fbthrift_clear_terse_fields() {
}

bool VirtualStruct::__fbthrift_is_empty() const {
  return false;
}

bool VirtualStruct::operator==([[maybe_unused]] const VirtualStruct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool VirtualStruct::operator<([[maybe_unused]] const VirtualStruct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int64_t VirtualStruct::get_MyIntField() const {
  return __fbthrift_field_MyIntField;
}

::std::int64_t& VirtualStruct::set_MyIntField(::std::int64_t MyIntField_) {
  MyIntField_ref() = MyIntField_;
  return __fbthrift_field_MyIntField;
}

void swap([[maybe_unused]] VirtualStruct& a, [[maybe_unused]] VirtualStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_MyIntField, b.__fbthrift_field_MyIntField);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view MyStructWithForwardRefEnum::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/MyStructWithForwardRefEnum";
}

std::string_view MyStructWithForwardRefEnum::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyStructWithForwardRefEnum>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view MyStructWithForwardRefEnum::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<MyStructWithForwardRefEnum>::name;
}


MyStructWithForwardRefEnum::MyStructWithForwardRefEnum(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::MyForwardRefEnum a__arg, ::apache::thrift::fixtures::types::MyForwardRefEnum b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void MyStructWithForwardRefEnum::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::apache::thrift::fixtures::types::MyForwardRefEnum();
  this->__fbthrift_field_b = ::apache::thrift::fixtures::types::MyForwardRefEnum();
  __isset = {};
}

void MyStructWithForwardRefEnum::__fbthrift_clear_terse_fields() {
}

bool MyStructWithForwardRefEnum::__fbthrift_is_empty() const {
  return false;
}

bool MyStructWithForwardRefEnum::operator==([[maybe_unused]] const MyStructWithForwardRefEnum& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool MyStructWithForwardRefEnum::operator<([[maybe_unused]] const MyStructWithForwardRefEnum& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::apache::thrift::fixtures::types::MyForwardRefEnum MyStructWithForwardRefEnum::get_a() const {
  return __fbthrift_field_a;
}

::apache::thrift::fixtures::types::MyForwardRefEnum& MyStructWithForwardRefEnum::set_a(::apache::thrift::fixtures::types::MyForwardRefEnum a_) {
  a_ref() = a_;
  return __fbthrift_field_a;
}

::apache::thrift::fixtures::types::MyForwardRefEnum MyStructWithForwardRefEnum::get_b() const {
  return __fbthrift_field_b;
}

::apache::thrift::fixtures::types::MyForwardRefEnum& MyStructWithForwardRefEnum::set_b(::apache::thrift::fixtures::types::MyForwardRefEnum b_) {
  b_ref() = b_;
  return __fbthrift_field_b;
}

void swap([[maybe_unused]] MyStructWithForwardRefEnum& a, [[maybe_unused]] MyStructWithForwardRefEnum& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view TrivialNumeric::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/TrivialNumeric";
}

std::string_view TrivialNumeric::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TrivialNumeric>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TrivialNumeric::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TrivialNumeric>::name;
}


TrivialNumeric::TrivialNumeric(apache::thrift::FragileConstructor, ::std::int32_t a__arg, bool b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void TrivialNumeric::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = bool();
  __isset = {};
}

void TrivialNumeric::__fbthrift_clear_terse_fields() {
}

bool TrivialNumeric::__fbthrift_is_empty() const {
  return false;
}

bool TrivialNumeric::operator==([[maybe_unused]] const TrivialNumeric& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TrivialNumeric::operator<([[maybe_unused]] const TrivialNumeric& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int32_t TrivialNumeric::get_a() const {
  return __fbthrift_field_a;
}

::std::int32_t& TrivialNumeric::set_a(::std::int32_t a_) {
  a_ref() = a_;
  return __fbthrift_field_a;
}

bool TrivialNumeric::get_b() const {
  return __fbthrift_field_b;
}

bool& TrivialNumeric::set_b(bool b_) {
  b_ref() = b_;
  return __fbthrift_field_b;
}

void swap([[maybe_unused]] TrivialNumeric& a, [[maybe_unused]] TrivialNumeric& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view TrivialNestedWithDefault::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/TrivialNestedWithDefault";
}

std::string_view TrivialNestedWithDefault::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TrivialNestedWithDefault>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TrivialNestedWithDefault::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TrivialNestedWithDefault>::name;
}


TrivialNestedWithDefault::TrivialNestedWithDefault(apache::thrift::FragileConstructor, ::std::int32_t z__arg, ::apache::thrift::fixtures::types::TrivialNumeric n__arg) :
    __fbthrift_field_z(std::move(z__arg)),
    __fbthrift_field_n(std::move(n__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void TrivialNestedWithDefault::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_z = ::std::int32_t();
  ::apache::thrift::clear(this->__fbthrift_field_n);
  __isset = {};
}

void TrivialNestedWithDefault::__fbthrift_clear_terse_fields() {
}

bool TrivialNestedWithDefault::__fbthrift_is_empty() const {
  return false;
}

bool TrivialNestedWithDefault::operator==([[maybe_unused]] const TrivialNestedWithDefault& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TrivialNestedWithDefault::operator<([[maybe_unused]] const TrivialNestedWithDefault& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int32_t TrivialNestedWithDefault::get_z() const {
  return __fbthrift_field_z;
}

::std::int32_t& TrivialNestedWithDefault::set_z(::std::int32_t z_) {
  z_ref() = z_;
  return __fbthrift_field_z;
}

const ::apache::thrift::fixtures::types::TrivialNumeric& TrivialNestedWithDefault::get_n() const& {
  return __fbthrift_field_n;
}

::apache::thrift::fixtures::types::TrivialNumeric TrivialNestedWithDefault::get_n() && {
  return static_cast<::apache::thrift::fixtures::types::TrivialNumeric&&>(__fbthrift_field_n);
}

void swap([[maybe_unused]] TrivialNestedWithDefault& a, [[maybe_unused]] TrivialNestedWithDefault& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_z, b.__fbthrift_field_z);
  swap(a.__fbthrift_field_n, b.__fbthrift_field_n);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        TrivialNestedWithDefault,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::TrivialNumeric>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ComplexString::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ComplexString";
}

std::string_view ComplexString::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ComplexString>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ComplexString::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ComplexString>::name;
}

ComplexString::ComplexString(const ComplexString&) = default;
ComplexString& ComplexString::operator=(const ComplexString&) = default;
ComplexString::ComplexString() {
}


ComplexString::~ComplexString() {}

ComplexString::ComplexString([[maybe_unused]] ComplexString&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __isset(other.__isset) {
}

ComplexString& ComplexString::operator=([[maybe_unused]] ComplexString&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    __isset = other.__isset;
    return *this;
}


ComplexString::ComplexString(apache::thrift::FragileConstructor, ::std::string a__arg, ::std::map<::std::string, ::std::int32_t> b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void ComplexString::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_b.clear();
  __isset = {};
}

void ComplexString::__fbthrift_clear_terse_fields() {
}

bool ComplexString::__fbthrift_is_empty() const {
  return false;
}

bool ComplexString::operator==([[maybe_unused]] const ComplexString& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ComplexString::operator<([[maybe_unused]] const ComplexString& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::map<::std::string, ::std::int32_t>& ComplexString::get_b() const& {
  return __fbthrift_field_b;
}

::std::map<::std::string, ::std::int32_t> ComplexString::get_b() && {
  return static_cast<::std::map<::std::string, ::std::int32_t>&&>(__fbthrift_field_b);
}

void swap([[maybe_unused]] ComplexString& a, [[maybe_unused]] ComplexString& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ComplexNestedWithDefault::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ComplexNestedWithDefault";
}

std::string_view ComplexNestedWithDefault::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ComplexNestedWithDefault>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ComplexNestedWithDefault::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ComplexNestedWithDefault>::name;
}

ComplexNestedWithDefault::ComplexNestedWithDefault(const ComplexNestedWithDefault&) = default;
ComplexNestedWithDefault& ComplexNestedWithDefault::operator=(const ComplexNestedWithDefault&) = default;
ComplexNestedWithDefault::ComplexNestedWithDefault() :
    __fbthrift_field_z(apache::thrift::StringTraits<::std::string>::fromStringLiteral("4")),
    __fbthrift_field_n(::apache::thrift::detail::make_structured_constant<::apache::thrift::fixtures::types::ComplexString>(::apache::thrift::detail::wrap_struct_argument<::apache::thrift::ident::a>(apache::thrift::StringTraits<::std::string>::fromStringLiteral("3")), ::apache::thrift::detail::wrap_struct_argument<::apache::thrift::ident::b>(std::initializer_list<::std::map<::std::string, ::std::int32_t>::value_type>{ { apache::thrift::StringTraits<::std::string>::fromStringLiteral("a"), static_cast<::std::int32_t>(3) } }))) {
}


ComplexNestedWithDefault::~ComplexNestedWithDefault() {}

ComplexNestedWithDefault::ComplexNestedWithDefault([[maybe_unused]] ComplexNestedWithDefault&& other) noexcept :
    __fbthrift_field_z(std::move(other.__fbthrift_field_z)),
    __fbthrift_field_n(std::move(other.__fbthrift_field_n)),
    __isset(other.__isset) {
}

ComplexNestedWithDefault& ComplexNestedWithDefault::operator=([[maybe_unused]] ComplexNestedWithDefault&& other) noexcept {
    this->__fbthrift_field_z = std::move(other.__fbthrift_field_z);
    this->__fbthrift_field_n = std::move(other.__fbthrift_field_n);
    __isset = other.__isset;
    return *this;
}


ComplexNestedWithDefault::ComplexNestedWithDefault(apache::thrift::FragileConstructor, ::std::string z__arg, ::apache::thrift::fixtures::types::ComplexString n__arg) :
    __fbthrift_field_z(std::move(z__arg)),
    __fbthrift_field_n(std::move(n__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void ComplexNestedWithDefault::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_z = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  ::apache::thrift::clear(this->__fbthrift_field_n);
  __isset = {};
}

void ComplexNestedWithDefault::__fbthrift_clear_terse_fields() {
}

bool ComplexNestedWithDefault::__fbthrift_is_empty() const {
  return false;
}

bool ComplexNestedWithDefault::operator==([[maybe_unused]] const ComplexNestedWithDefault& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ComplexNestedWithDefault::operator<([[maybe_unused]] const ComplexNestedWithDefault& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::apache::thrift::fixtures::types::ComplexString& ComplexNestedWithDefault::get_n() const& {
  return __fbthrift_field_n;
}

::apache::thrift::fixtures::types::ComplexString ComplexNestedWithDefault::get_n() && {
  return static_cast<::apache::thrift::fixtures::types::ComplexString&&>(__fbthrift_field_n);
}

void swap([[maybe_unused]] ComplexNestedWithDefault& a, [[maybe_unused]] ComplexNestedWithDefault& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_z, b.__fbthrift_field_z);
  swap(a.__fbthrift_field_n, b.__fbthrift_field_n);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ComplexNestedWithDefault,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ComplexString>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view MinPadding::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/MinPadding";
}

std::string_view MinPadding::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MinPadding>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view MinPadding::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<MinPadding>::name;
}

MinPadding::MinPadding(const MinPadding&) = default;
MinPadding& MinPadding::operator=(const MinPadding&) = default;
MinPadding::MinPadding([[maybe_unused]] MinPadding&& other) noexcept :
    __fbthrift_field_big(std::move(other.__fbthrift_field_big)),
    __fbthrift_field_biggish(std::move(other.__fbthrift_field_biggish)),
    __fbthrift_field_medium(std::move(other.__fbthrift_field_medium)),
    __fbthrift_field_small(std::move(other.__fbthrift_field_small)),
    __fbthrift_field_tiny(std::move(other.__fbthrift_field_tiny)) {
}

MinPadding& MinPadding::operator=([[maybe_unused]] MinPadding&& other) noexcept {
    this->__fbthrift_field_big = std::move(other.__fbthrift_field_big);
    this->__fbthrift_field_biggish = std::move(other.__fbthrift_field_biggish);
    this->__fbthrift_field_medium = std::move(other.__fbthrift_field_medium);
    this->__fbthrift_field_small = std::move(other.__fbthrift_field_small);
    this->__fbthrift_field_tiny = std::move(other.__fbthrift_field_tiny);
    return *this;
}


MinPadding::MinPadding(apache::thrift::FragileConstructor, ::std::int8_t small__arg, ::std::int64_t big__arg, ::std::int16_t medium__arg, ::std::int32_t biggish__arg, ::std::int8_t tiny__arg) :
    __fbthrift_field_big(std::move(big__arg)),
    __fbthrift_field_biggish(std::move(biggish__arg)),
    __fbthrift_field_medium(std::move(medium__arg)),
    __fbthrift_field_small(std::move(small__arg)),
    __fbthrift_field_tiny(std::move(tiny__arg)) { 
}

void MinPadding::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_small = ::std::int8_t();
  this->__fbthrift_field_big = ::std::int64_t();
  this->__fbthrift_field_medium = ::std::int16_t();
  this->__fbthrift_field_biggish = ::std::int32_t();
  this->__fbthrift_field_tiny = ::std::int8_t();
}

void MinPadding::__fbthrift_clear_terse_fields() {
}

bool MinPadding::__fbthrift_is_empty() const {
  return false;
}

bool MinPadding::operator==([[maybe_unused]] const MinPadding& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool MinPadding::operator<([[maybe_unused]] const MinPadding& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int8_t MinPadding::get_small() const {
  return __fbthrift_field_small;
}

::std::int8_t& MinPadding::set_small(::std::int8_t small_) {
  small_ref() = small_;
  return __fbthrift_field_small;
}

::std::int64_t MinPadding::get_big() const {
  return __fbthrift_field_big;
}

::std::int64_t& MinPadding::set_big(::std::int64_t big_) {
  big_ref() = big_;
  return __fbthrift_field_big;
}

::std::int16_t MinPadding::get_medium() const {
  return __fbthrift_field_medium;
}

::std::int16_t& MinPadding::set_medium(::std::int16_t medium_) {
  medium_ref() = medium_;
  return __fbthrift_field_medium;
}

::std::int32_t MinPadding::get_biggish() const {
  return __fbthrift_field_biggish;
}

::std::int32_t& MinPadding::set_biggish(::std::int32_t biggish_) {
  biggish_ref() = biggish_;
  return __fbthrift_field_biggish;
}

::std::int8_t MinPadding::get_tiny() const {
  return __fbthrift_field_tiny;
}

::std::int8_t& MinPadding::set_tiny(::std::int8_t tiny_) {
  tiny_ref() = tiny_;
  return __fbthrift_field_tiny;
}

void swap([[maybe_unused]] MinPadding& a, [[maybe_unused]] MinPadding& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_big, b.__fbthrift_field_big);
  swap(a.__fbthrift_field_biggish, b.__fbthrift_field_biggish);
  swap(a.__fbthrift_field_medium, b.__fbthrift_field_medium);
  swap(a.__fbthrift_field_small, b.__fbthrift_field_small);
  swap(a.__fbthrift_field_tiny, b.__fbthrift_field_tiny);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view MinPaddingWithCustomType::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/MinPaddingWithCustomType";
}

std::string_view MinPaddingWithCustomType::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MinPaddingWithCustomType>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view MinPaddingWithCustomType::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<MinPaddingWithCustomType>::name;
}

MinPaddingWithCustomType::MinPaddingWithCustomType(const MinPaddingWithCustomType& srcObj) :
    __fbthrift_field_medium(srcObj.__fbthrift_field_medium),
    __fbthrift_field_big(srcObj.__fbthrift_field_big),
    __fbthrift_field_biggish(srcObj.__fbthrift_field_biggish),
    __fbthrift_field_small(srcObj.__fbthrift_field_small),
    __fbthrift_field_tiny(srcObj.__fbthrift_field_tiny) {
  ::apache::thrift::adapt_detail::construct<::my::Adapter, 3>(__fbthrift_field_medium, *this);
}

static void __fbthrift_swap(MinPaddingWithCustomType& lhs, MinPaddingWithCustomType& rhs) { swap(lhs, rhs); }
MinPaddingWithCustomType& MinPaddingWithCustomType::operator=(const MinPaddingWithCustomType& other) {
  MinPaddingWithCustomType tmp(other);
  __fbthrift_swap(*this, tmp);
  return *this;
}

MinPaddingWithCustomType::MinPaddingWithCustomType([[maybe_unused]] MinPaddingWithCustomType&& other) noexcept :
    __fbthrift_field_medium(std::move(other.__fbthrift_field_medium)),
    __fbthrift_field_big(std::move(other.__fbthrift_field_big)),
    __fbthrift_field_biggish(std::move(other.__fbthrift_field_biggish)),
    __fbthrift_field_small(std::move(other.__fbthrift_field_small)),
    __fbthrift_field_tiny(std::move(other.__fbthrift_field_tiny)) {
  ::apache::thrift::adapt_detail::construct<::my::Adapter, 3>(__fbthrift_field_medium, *this);
}

MinPaddingWithCustomType& MinPaddingWithCustomType::operator=([[maybe_unused]] MinPaddingWithCustomType&& other) noexcept {
    this->__fbthrift_field_medium = std::move(other.__fbthrift_field_medium);
    this->__fbthrift_field_big = std::move(other.__fbthrift_field_big);
    this->__fbthrift_field_biggish = std::move(other.__fbthrift_field_biggish);
    this->__fbthrift_field_small = std::move(other.__fbthrift_field_small);
    this->__fbthrift_field_tiny = std::move(other.__fbthrift_field_tiny);
    return *this;
}


MinPaddingWithCustomType::MinPaddingWithCustomType(apache::thrift::FragileConstructor, ::std::int8_t small__arg, ::std::int32_t biggish__arg, ::apache::thrift::adapt_detail::adapted_field_t<::my::Adapter, 3, ::std::int16_t, MinPaddingWithCustomType> medium__arg, ::std::int64_t big__arg, ::std::int8_t tiny__arg) :
    __fbthrift_field_medium(std::move(medium__arg)),
    __fbthrift_field_big(std::move(big__arg)),
    __fbthrift_field_biggish(std::move(biggish__arg)),
    __fbthrift_field_small(std::move(small__arg)),
    __fbthrift_field_tiny(std::move(tiny__arg)) { 
  ::apache::thrift::adapt_detail::construct<::my::Adapter, 3>(__fbthrift_field_medium, *this);
}

void MinPaddingWithCustomType::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_small = ::std::int8_t();
  this->__fbthrift_field_biggish = ::std::int32_t();
  ::apache::thrift::adapt_detail::clear<::my::Adapter, 3>(__fbthrift_field_medium, *this);
  this->__fbthrift_field_big = ::std::int64_t();
  this->__fbthrift_field_tiny = ::std::int8_t();
}

void MinPaddingWithCustomType::__fbthrift_clear_terse_fields() {
  this->__fbthrift_field_small = ::std::int8_t();
  this->__fbthrift_field_biggish = ::std::int32_t();
  ::apache::thrift::adapt_detail::clear<::my::Adapter, 3>(__fbthrift_field_medium, *this);
  this->__fbthrift_field_big = ::std::int64_t();
  this->__fbthrift_field_tiny = ::std::int8_t();
}

bool MinPaddingWithCustomType::__fbthrift_is_empty() const {
  return ::apache::thrift::op::isEmpty<::apache::thrift::type::byte_t>(this->__fbthrift_field_small) &&
 ::apache::thrift::op::isEmpty<::apache::thrift::type::i32_t>(this->__fbthrift_field_biggish) &&
 ::apache::thrift::op::isEmpty<::apache::thrift::op::get_field_tag<MinPaddingWithCustomType, ::apache::thrift::field_id<3>>>(this->__fbthrift_field_medium) &&
 ::apache::thrift::op::isEmpty<::apache::thrift::type::i64_t>(this->__fbthrift_field_big) &&
 ::apache::thrift::op::isEmpty<::apache::thrift::type::byte_t>(this->__fbthrift_field_tiny);
}

bool MinPaddingWithCustomType::operator==([[maybe_unused]] const MinPaddingWithCustomType& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool MinPaddingWithCustomType::operator<([[maybe_unused]] const MinPaddingWithCustomType& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] MinPaddingWithCustomType& a, [[maybe_unused]] MinPaddingWithCustomType& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_medium, b.__fbthrift_field_medium);
  swap(a.__fbthrift_field_big, b.__fbthrift_field_big);
  swap(a.__fbthrift_field_biggish, b.__fbthrift_field_biggish);
  swap(a.__fbthrift_field_small, b.__fbthrift_field_small);
  swap(a.__fbthrift_field_tiny, b.__fbthrift_field_tiny);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view MyStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/MyStruct";
}

std::string_view MyStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view MyStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<MyStruct>::name;
}

MyStruct::MyStruct(const MyStruct&) = default;
MyStruct& MyStruct::operator=(const MyStruct&) = default;
MyStruct::MyStruct() :
    __fbthrift_field_MyIntField(),
    __fbthrift_field_majorVer() {
}


MyStruct::~MyStruct() {}

MyStruct::MyStruct([[maybe_unused]] MyStruct&& other) noexcept :
    __fbthrift_field_MyIntField(std::move(other.__fbthrift_field_MyIntField)),
    __fbthrift_field_MyStringField(std::move(other.__fbthrift_field_MyStringField)),
    __fbthrift_field_majorVer(std::move(other.__fbthrift_field_majorVer)),
    __fbthrift_field_data(std::move(other.__fbthrift_field_data)),
    __isset(other.__isset) {
}

MyStruct& MyStruct::operator=([[maybe_unused]] MyStruct&& other) noexcept {
    this->__fbthrift_field_MyIntField = std::move(other.__fbthrift_field_MyIntField);
    this->__fbthrift_field_MyStringField = std::move(other.__fbthrift_field_MyStringField);
    this->__fbthrift_field_majorVer = std::move(other.__fbthrift_field_majorVer);
    this->__fbthrift_field_data = std::move(other.__fbthrift_field_data);
    __isset = other.__isset;
    return *this;
}


MyStruct::MyStruct(apache::thrift::FragileConstructor, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::int64_t majorVer__arg, ::apache::thrift::fixtures::types::MyDataItem data__arg) :
    __fbthrift_field_MyIntField(std::move(MyIntField__arg)),
    __fbthrift_field_MyStringField(std::move(MyStringField__arg)),
    __fbthrift_field_majorVer(std::move(majorVer__arg)),
    __fbthrift_field_data(std::move(data__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}

void MyStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_MyIntField = ::std::int64_t();
  this->__fbthrift_field_MyStringField = apache::thrift::StringTraits<::std::string>::fromStringLiteral("");
  this->__fbthrift_field_majorVer = ::std::int64_t();
  __isset = {};
}

void MyStruct::__fbthrift_clear_terse_fields() {
}

bool MyStruct::__fbthrift_is_empty() const {
  return false;
}




::std::int64_t MyStruct::get_MyIntField() const {
  return __fbthrift_field_MyIntField;
}

::std::int64_t& MyStruct::set_MyIntField(::std::int64_t MyIntField_) {
  MyIntField_ref() = MyIntField_;
  return __fbthrift_field_MyIntField;
}

::std::int64_t MyStruct::get_majorVer() const {
  return __fbthrift_field_majorVer;
}

::std::int64_t& MyStruct::set_majorVer(::std::int64_t majorVer_) {
  majorVer_ref() = majorVer_;
  return __fbthrift_field_majorVer;
}

const ::apache::thrift::fixtures::types::MyDataItem& MyStruct::get_data() const& {
  return __fbthrift_field_data;
}

::apache::thrift::fixtures::types::MyDataItem MyStruct::get_data() && {
  return static_cast<::apache::thrift::fixtures::types::MyDataItem&&>(__fbthrift_field_data);
}

void swap([[maybe_unused]] MyStruct& a, [[maybe_unused]] MyStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_MyIntField, b.__fbthrift_field_MyIntField);
  swap(a.__fbthrift_field_MyStringField, b.__fbthrift_field_MyStringField);
  swap(a.__fbthrift_field_majorVer, b.__fbthrift_field_majorVer);
  swap(a.__fbthrift_field_data, b.__fbthrift_field_data);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        MyStruct,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::MyDataItem>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view MyDataItem::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/MyDataItem";
}

std::string_view MyDataItem::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<MyDataItem>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view MyDataItem::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<MyDataItem>::name;
}


MyDataItem::MyDataItem(apache::thrift::FragileConstructor) {}

void MyDataItem::__fbthrift_clear() {
  // clear all fields
}

void MyDataItem::__fbthrift_clear_terse_fields() {
}

bool MyDataItem::__fbthrift_is_empty() const {
  return true;
}




void swap([[maybe_unused]] MyDataItem& a, [[maybe_unused]] MyDataItem& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view Renamed::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/Renaming";
}

std::string_view Renamed::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<Renamed>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view Renamed::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<Renamed>::name;
}


Renamed::Renamed(apache::thrift::FragileConstructor, ::std::int64_t bar__arg) :
    __fbthrift_field_bar(std::move(bar__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void Renamed::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_bar = ::std::int64_t();
  __isset = {};
}

void Renamed::__fbthrift_clear_terse_fields() {
}

bool Renamed::__fbthrift_is_empty() const {
  return false;
}

bool Renamed::operator==([[maybe_unused]] const Renamed& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool Renamed::operator<([[maybe_unused]] const Renamed& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int64_t Renamed::get_bar() const {
  return __fbthrift_field_bar;
}

::std::int64_t& Renamed::set_bar(::std::int64_t bar_) {
  bar_ref() = bar_;
  return __fbthrift_field_bar;
}

void swap([[maybe_unused]] Renamed& a, [[maybe_unused]] Renamed& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_bar, b.__fbthrift_field_bar);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view AnnotatedTypes::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/AnnotatedTypes";
}

std::string_view AnnotatedTypes::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AnnotatedTypes>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AnnotatedTypes::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AnnotatedTypes>::name;
}

AnnotatedTypes::AnnotatedTypes(const AnnotatedTypes&) = default;
AnnotatedTypes& AnnotatedTypes::operator=(const AnnotatedTypes&) = default;
AnnotatedTypes::AnnotatedTypes() {
}


AnnotatedTypes::~AnnotatedTypes() {}

AnnotatedTypes::AnnotatedTypes([[maybe_unused]] AnnotatedTypes&& other) noexcept :
    __fbthrift_field_binary_field(std::move(other.__fbthrift_field_binary_field)),
    __fbthrift_field_list_field(std::move(other.__fbthrift_field_list_field)),
    __isset(other.__isset) {
}

AnnotatedTypes& AnnotatedTypes::operator=([[maybe_unused]] AnnotatedTypes&& other) noexcept {
    this->__fbthrift_field_binary_field = std::move(other.__fbthrift_field_binary_field);
    this->__fbthrift_field_list_field = std::move(other.__fbthrift_field_list_field);
    __isset = other.__isset;
    return *this;
}


AnnotatedTypes::AnnotatedTypes(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::TBinary_8623 binary_field__arg, ::apache::thrift::fixtures::types::SomeListOfTypeMap_2468 list_field__arg) :
    __fbthrift_field_binary_field(std::move(binary_field__arg)),
    __fbthrift_field_list_field(std::move(list_field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}

void AnnotatedTypes::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_binary_field = apache::thrift::StringTraits<::apache::thrift::fixtures::types::TBinary_8623>::fromStringLiteral("");
  this->__fbthrift_field_list_field.clear();
  __isset = {};
}

void AnnotatedTypes::__fbthrift_clear_terse_fields() {
}

bool AnnotatedTypes::__fbthrift_is_empty() const {
  return false;
}

bool AnnotatedTypes::operator==([[maybe_unused]] const AnnotatedTypes& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AnnotatedTypes::operator<([[maybe_unused]] const AnnotatedTypes& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::apache::thrift::fixtures::types::SomeListOfTypeMap_2468& AnnotatedTypes::get_list_field() const& {
  return __fbthrift_field_list_field;
}

::apache::thrift::fixtures::types::SomeListOfTypeMap_2468 AnnotatedTypes::get_list_field() && {
  return static_cast<::apache::thrift::fixtures::types::SomeListOfTypeMap_2468&&>(__fbthrift_field_list_field);
}

void swap([[maybe_unused]] AnnotatedTypes& a, [[maybe_unused]] AnnotatedTypes& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_binary_field, b.__fbthrift_field_binary_field);
  swap(a.__fbthrift_field_list_field, b.__fbthrift_field_list_field);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ForwardUsageRoot::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ForwardUsageRoot";
}

std::string_view ForwardUsageRoot::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageRoot>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ForwardUsageRoot::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ForwardUsageRoot>::name;
}

ForwardUsageRoot::ForwardUsageRoot(const ForwardUsageRoot& srcObj) :
    __fbthrift_field_ForwardUsageStruct(srcObj.__fbthrift_field_ForwardUsageStruct),
    __fbthrift_field_ForwardUsageByRef(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_ForwardUsageByRef)),
    __isset(srcObj.__isset) {
}

static void __fbthrift_swap(ForwardUsageRoot& lhs, ForwardUsageRoot& rhs) { swap(lhs, rhs); }
ForwardUsageRoot& ForwardUsageRoot::operator=(const ForwardUsageRoot& other) {
  ForwardUsageRoot tmp(other);
  __fbthrift_swap(*this, tmp);
  return *this;
}

ForwardUsageRoot::ForwardUsageRoot() {
}


ForwardUsageRoot::~ForwardUsageRoot() {}

ForwardUsageRoot::ForwardUsageRoot([[maybe_unused]] ForwardUsageRoot&& other) noexcept :
    __fbthrift_field_ForwardUsageStruct(std::move(other.__fbthrift_field_ForwardUsageStruct)),
    __fbthrift_field_ForwardUsageByRef(std::move(other.__fbthrift_field_ForwardUsageByRef)),
    __isset(other.__isset) {
}

ForwardUsageRoot& ForwardUsageRoot::operator=([[maybe_unused]] ForwardUsageRoot&& other) noexcept {
    this->__fbthrift_field_ForwardUsageStruct = std::move(other.__fbthrift_field_ForwardUsageStruct);
    this->__fbthrift_field_ForwardUsageByRef = std::move(other.__fbthrift_field_ForwardUsageByRef);
    __isset = other.__isset;
    return *this;
}


ForwardUsageRoot::ForwardUsageRoot(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::ForwardUsageStruct ForwardUsageStruct__arg, ::std::unique_ptr<::apache::thrift::fixtures::types::ForwardUsageByRef> ForwardUsageByRef__arg) :
    __fbthrift_field_ForwardUsageStruct(std::move(ForwardUsageStruct__arg)),
    __fbthrift_field_ForwardUsageByRef(std::move(ForwardUsageByRef__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void ForwardUsageRoot::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_ForwardUsageStruct);
  this->__fbthrift_field_ForwardUsageByRef.reset();
  __isset = {};
}

void ForwardUsageRoot::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageRoot::__fbthrift_is_empty() const {
  return !(this->__isset.get(0)) &&
 !(this->__fbthrift_field_ForwardUsageByRef);
}

bool ForwardUsageRoot::operator==([[maybe_unused]] const ForwardUsageRoot& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ForwardUsageRoot::operator<([[maybe_unused]] const ForwardUsageRoot& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() const& {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(__fbthrift_field_ForwardUsageStruct) : nullptr;
}

::apache::thrift::fixtures::types::ForwardUsageStruct* ForwardUsageRoot::get_ForwardUsageStruct() & {
  return ForwardUsageStruct_ref().has_value() ? std::addressof(__fbthrift_field_ForwardUsageStruct) : nullptr;
}

void swap([[maybe_unused]] ForwardUsageRoot& a, [[maybe_unused]] ForwardUsageRoot& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_ForwardUsageStruct, b.__fbthrift_field_ForwardUsageStruct);
  swap(a.__fbthrift_field_ForwardUsageByRef, b.__fbthrift_field_ForwardUsageByRef);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageStruct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageRoot,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageByRef>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ForwardUsageStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ForwardUsageStruct";
}

std::string_view ForwardUsageStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ForwardUsageStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ForwardUsageStruct>::name;
}

ForwardUsageStruct::ForwardUsageStruct(const ForwardUsageStruct& srcObj) :
    __fbthrift_field_foo(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_foo)) {
}

static void __fbthrift_swap(ForwardUsageStruct& lhs, ForwardUsageStruct& rhs) { swap(lhs, rhs); }
ForwardUsageStruct& ForwardUsageStruct::operator=(const ForwardUsageStruct& other) {
  ForwardUsageStruct tmp(other);
  __fbthrift_swap(*this, tmp);
  return *this;
}

ForwardUsageStruct::ForwardUsageStruct() {
}


ForwardUsageStruct::~ForwardUsageStruct() {}

ForwardUsageStruct::ForwardUsageStruct([[maybe_unused]] ForwardUsageStruct&& other) noexcept :
    __fbthrift_field_foo(std::move(other.__fbthrift_field_foo)) {
}

ForwardUsageStruct& ForwardUsageStruct::operator=([[maybe_unused]] ForwardUsageStruct&& other) noexcept {
    this->__fbthrift_field_foo = std::move(other.__fbthrift_field_foo);
    return *this;
}


ForwardUsageStruct::ForwardUsageStruct(apache::thrift::FragileConstructor, ::std::unique_ptr<::apache::thrift::fixtures::types::ForwardUsageRoot> foo__arg) :
    __fbthrift_field_foo(std::move(foo__arg)) { 
}

void ForwardUsageStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_foo.reset();
}

void ForwardUsageStruct::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageStruct::__fbthrift_is_empty() const {
  return !(this->__fbthrift_field_foo);
}

bool ForwardUsageStruct::operator==([[maybe_unused]] const ForwardUsageStruct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ForwardUsageStruct::operator<([[maybe_unused]] const ForwardUsageStruct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] ForwardUsageStruct& a, [[maybe_unused]] ForwardUsageStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_foo, b.__fbthrift_field_foo);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageStruct,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view ForwardUsageByRef::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/ForwardUsageByRef";
}

std::string_view ForwardUsageByRef::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<ForwardUsageByRef>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view ForwardUsageByRef::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<ForwardUsageByRef>::name;
}

ForwardUsageByRef::ForwardUsageByRef(const ForwardUsageByRef& srcObj) :
    __fbthrift_field_foo(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_foo)) {
}

static void __fbthrift_swap(ForwardUsageByRef& lhs, ForwardUsageByRef& rhs) { swap(lhs, rhs); }
ForwardUsageByRef& ForwardUsageByRef::operator=(const ForwardUsageByRef& other) {
  ForwardUsageByRef tmp(other);
  __fbthrift_swap(*this, tmp);
  return *this;
}

ForwardUsageByRef::ForwardUsageByRef() {
}


ForwardUsageByRef::~ForwardUsageByRef() {}

ForwardUsageByRef::ForwardUsageByRef([[maybe_unused]] ForwardUsageByRef&& other) noexcept :
    __fbthrift_field_foo(std::move(other.__fbthrift_field_foo)) {
}

ForwardUsageByRef& ForwardUsageByRef::operator=([[maybe_unused]] ForwardUsageByRef&& other) noexcept {
    this->__fbthrift_field_foo = std::move(other.__fbthrift_field_foo);
    return *this;
}


ForwardUsageByRef::ForwardUsageByRef(apache::thrift::FragileConstructor, ::std::unique_ptr<::apache::thrift::fixtures::types::ForwardUsageRoot> foo__arg) :
    __fbthrift_field_foo(std::move(foo__arg)) { 
}

void ForwardUsageByRef::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_foo.reset();
}

void ForwardUsageByRef::__fbthrift_clear_terse_fields() {
}

bool ForwardUsageByRef::__fbthrift_is_empty() const {
  return !(this->__fbthrift_field_foo);
}

bool ForwardUsageByRef::operator==([[maybe_unused]] const ForwardUsageByRef& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool ForwardUsageByRef::operator<([[maybe_unused]] const ForwardUsageByRef& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] ForwardUsageByRef& a, [[maybe_unused]] ForwardUsageByRef& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_foo, b.__fbthrift_field_foo);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ForwardUsageByRef,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::ForwardUsageRoot>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view IncompleteMap::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/IncompleteMap";
}

std::string_view IncompleteMap::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IncompleteMap>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IncompleteMap::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IncompleteMap>::name;
}

IncompleteMap::IncompleteMap(const IncompleteMap&) = default;
IncompleteMap& IncompleteMap::operator=(const IncompleteMap&) = default;
IncompleteMap::IncompleteMap() {
}


IncompleteMap::~IncompleteMap() {}

IncompleteMap::IncompleteMap([[maybe_unused]] IncompleteMap&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

IncompleteMap& IncompleteMap::operator=([[maybe_unused]] IncompleteMap&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


IncompleteMap::IncompleteMap(apache::thrift::FragileConstructor, ::std::map<::std::int32_t, ::apache::thrift::fixtures::types::IncompleteMapDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void IncompleteMap::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void IncompleteMap::__fbthrift_clear_terse_fields() {
}

bool IncompleteMap::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool IncompleteMap::operator==([[maybe_unused]] const IncompleteMap& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IncompleteMap::operator<([[maybe_unused]] const IncompleteMap& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::map<::std::int32_t, ::apache::thrift::fixtures::types::IncompleteMapDep>* IncompleteMap::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

::std::map<::std::int32_t, ::apache::thrift::fixtures::types::IncompleteMapDep>* IncompleteMap::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] IncompleteMap& a, [[maybe_unused]] IncompleteMap& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IncompleteMap,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int32_t, ::apache::thrift::fixtures::types::IncompleteMapDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view IncompleteMapDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/IncompleteMapDep";
}

std::string_view IncompleteMapDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IncompleteMapDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IncompleteMapDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IncompleteMapDep>::name;
}


IncompleteMapDep::IncompleteMapDep(apache::thrift::FragileConstructor) {}

void IncompleteMapDep::__fbthrift_clear() {
  // clear all fields
}

void IncompleteMapDep::__fbthrift_clear_terse_fields() {
}

bool IncompleteMapDep::__fbthrift_is_empty() const {
  return true;
}

bool IncompleteMapDep::operator==([[maybe_unused]] const IncompleteMapDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IncompleteMapDep::operator<([[maybe_unused]] const IncompleteMapDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] IncompleteMapDep& a, [[maybe_unused]] IncompleteMapDep& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view CompleteMap::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/CompleteMap";
}

std::string_view CompleteMap::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CompleteMap>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view CompleteMap::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<CompleteMap>::name;
}

CompleteMap::CompleteMap(const CompleteMap&) = default;
CompleteMap& CompleteMap::operator=(const CompleteMap&) = default;
CompleteMap::CompleteMap() {
}


CompleteMap::~CompleteMap() {}

CompleteMap::CompleteMap([[maybe_unused]] CompleteMap&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

CompleteMap& CompleteMap::operator=([[maybe_unused]] CompleteMap&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


CompleteMap::CompleteMap(apache::thrift::FragileConstructor, std::unordered_map<::std::int32_t, ::apache::thrift::fixtures::types::CompleteMapDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void CompleteMap::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void CompleteMap::__fbthrift_clear_terse_fields() {
}

bool CompleteMap::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool CompleteMap::operator==([[maybe_unused]] const CompleteMap& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool CompleteMap::operator<([[maybe_unused]] const CompleteMap& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const std::unordered_map<::std::int32_t, ::apache::thrift::fixtures::types::CompleteMapDep>* CompleteMap::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

std::unordered_map<::std::int32_t, ::apache::thrift::fixtures::types::CompleteMapDep>* CompleteMap::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] CompleteMap& a, [[maybe_unused]] CompleteMap& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompleteMap,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        std::unordered_map<::std::int32_t, ::apache::thrift::fixtures::types::CompleteMapDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view CompleteMapDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/CompleteMapDep";
}

std::string_view CompleteMapDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CompleteMapDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view CompleteMapDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<CompleteMapDep>::name;
}


CompleteMapDep::CompleteMapDep(apache::thrift::FragileConstructor) {}

void CompleteMapDep::__fbthrift_clear() {
  // clear all fields
}

void CompleteMapDep::__fbthrift_clear_terse_fields() {
}

bool CompleteMapDep::__fbthrift_is_empty() const {
  return true;
}

bool CompleteMapDep::operator==([[maybe_unused]] const CompleteMapDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool CompleteMapDep::operator<([[maybe_unused]] const CompleteMapDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] CompleteMapDep& a, [[maybe_unused]] CompleteMapDep& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view IncompleteList::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/IncompleteList";
}

std::string_view IncompleteList::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IncompleteList>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IncompleteList::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IncompleteList>::name;
}

IncompleteList::IncompleteList(const IncompleteList&) = default;
IncompleteList& IncompleteList::operator=(const IncompleteList&) = default;
IncompleteList::IncompleteList() {
}


IncompleteList::~IncompleteList() {}

IncompleteList::IncompleteList([[maybe_unused]] IncompleteList&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

IncompleteList& IncompleteList::operator=([[maybe_unused]] IncompleteList&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


IncompleteList::IncompleteList(apache::thrift::FragileConstructor, ::std::list<::apache::thrift::fixtures::types::IncompleteListDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void IncompleteList::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void IncompleteList::__fbthrift_clear_terse_fields() {
}

bool IncompleteList::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool IncompleteList::operator==([[maybe_unused]] const IncompleteList& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IncompleteList::operator<([[maybe_unused]] const IncompleteList& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::list<::apache::thrift::fixtures::types::IncompleteListDep>* IncompleteList::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

::std::list<::apache::thrift::fixtures::types::IncompleteListDep>* IncompleteList::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] IncompleteList& a, [[maybe_unused]] IncompleteList& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        IncompleteList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::list<::apache::thrift::fixtures::types::IncompleteListDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view IncompleteListDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/IncompleteListDep";
}

std::string_view IncompleteListDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<IncompleteListDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view IncompleteListDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<IncompleteListDep>::name;
}


IncompleteListDep::IncompleteListDep(apache::thrift::FragileConstructor) {}

void IncompleteListDep::__fbthrift_clear() {
  // clear all fields
}

void IncompleteListDep::__fbthrift_clear_terse_fields() {
}

bool IncompleteListDep::__fbthrift_is_empty() const {
  return true;
}

bool IncompleteListDep::operator==([[maybe_unused]] const IncompleteListDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool IncompleteListDep::operator<([[maybe_unused]] const IncompleteListDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] IncompleteListDep& a, [[maybe_unused]] IncompleteListDep& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view CompleteList::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/CompleteList";
}

std::string_view CompleteList::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CompleteList>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view CompleteList::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<CompleteList>::name;
}

CompleteList::CompleteList(const CompleteList&) = default;
CompleteList& CompleteList::operator=(const CompleteList&) = default;
CompleteList::CompleteList() {
}


CompleteList::~CompleteList() {}

CompleteList::CompleteList([[maybe_unused]] CompleteList&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

CompleteList& CompleteList::operator=([[maybe_unused]] CompleteList&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


CompleteList::CompleteList(apache::thrift::FragileConstructor, folly::small_vector<::apache::thrift::fixtures::types::CompleteListDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void CompleteList::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void CompleteList::__fbthrift_clear_terse_fields() {
}

bool CompleteList::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool CompleteList::operator==([[maybe_unused]] const CompleteList& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool CompleteList::operator<([[maybe_unused]] const CompleteList& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const folly::small_vector<::apache::thrift::fixtures::types::CompleteListDep>* CompleteList::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

folly::small_vector<::apache::thrift::fixtures::types::CompleteListDep>* CompleteList::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] CompleteList& a, [[maybe_unused]] CompleteList& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompleteList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        folly::small_vector<::apache::thrift::fixtures::types::CompleteListDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view CompleteListDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/CompleteListDep";
}

std::string_view CompleteListDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<CompleteListDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view CompleteListDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<CompleteListDep>::name;
}


CompleteListDep::CompleteListDep(apache::thrift::FragileConstructor) {}

void CompleteListDep::__fbthrift_clear() {
  // clear all fields
}

void CompleteListDep::__fbthrift_clear_terse_fields() {
}

bool CompleteListDep::__fbthrift_is_empty() const {
  return true;
}

bool CompleteListDep::operator==([[maybe_unused]] const CompleteListDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool CompleteListDep::operator<([[maybe_unused]] const CompleteListDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] CompleteListDep& a, [[maybe_unused]] CompleteListDep& b) {
  using ::std::swap;
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view AdaptedList::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/AdaptedList";
}

std::string_view AdaptedList::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AdaptedList>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AdaptedList::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AdaptedList>::name;
}

AdaptedList::AdaptedList(const AdaptedList&) = default;
AdaptedList& AdaptedList::operator=(const AdaptedList&) = default;
AdaptedList::AdaptedList() {
}


AdaptedList::~AdaptedList() {}

AdaptedList::AdaptedList([[maybe_unused]] AdaptedList&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

AdaptedList& AdaptedList::operator=([[maybe_unused]] AdaptedList&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


AdaptedList::AdaptedList(apache::thrift::FragileConstructor, ::std::vector<::apache::thrift::fixtures::types::AdaptedListDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void AdaptedList::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void AdaptedList::__fbthrift_clear_terse_fields() {
}

bool AdaptedList::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool AdaptedList::operator==([[maybe_unused]] const AdaptedList& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AdaptedList::operator<([[maybe_unused]] const AdaptedList& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::vector<::apache::thrift::fixtures::types::AdaptedListDep>* AdaptedList::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

::std::vector<::apache::thrift::fixtures::types::AdaptedListDep>* AdaptedList::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] AdaptedList& a, [[maybe_unused]] AdaptedList& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdaptedList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::apache::thrift::fixtures::types::detail::AdaptedListDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {
namespace detail {

std::string_view AdaptedListDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/AdaptedListDep";
}

std::string_view AdaptedListDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AdaptedListDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AdaptedListDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AdaptedListDep>::name;
}

AdaptedListDep::AdaptedListDep(const AdaptedListDep&) = default;
AdaptedListDep& AdaptedListDep::operator=(const AdaptedListDep&) = default;
AdaptedListDep::AdaptedListDep([[maybe_unused]] AdaptedListDep&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

AdaptedListDep& AdaptedListDep::operator=([[maybe_unused]] AdaptedListDep&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


AdaptedListDep::AdaptedListDep(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::AdaptedList field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void AdaptedListDep::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_field);
  __isset = {};
}

void AdaptedListDep::__fbthrift_clear_terse_fields() {
}

bool AdaptedListDep::__fbthrift_is_empty() const {
  return false;
}

bool AdaptedListDep::operator==([[maybe_unused]] const AdaptedListDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AdaptedListDep::operator<([[maybe_unused]] const AdaptedListDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::apache::thrift::fixtures::types::AdaptedList& AdaptedListDep::get_field() const& {
  return __fbthrift_field_field;
}

::apache::thrift::fixtures::types::AdaptedList AdaptedListDep::get_field() && {
  return static_cast<::apache::thrift::fixtures::types::AdaptedList&&>(__fbthrift_field_field);
}

void swap([[maybe_unused]] AdaptedListDep& a, [[maybe_unused]] AdaptedListDep& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        AdaptedListDep,
        ::apache::thrift::type_class::structure,
        ::apache::thrift::fixtures::types::AdaptedList>,
    "inconsistent use of json option");

} // namespace detail
} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view DependentAdaptedList::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/DependentAdaptedList";
}

std::string_view DependentAdaptedList::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<DependentAdaptedList>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view DependentAdaptedList::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<DependentAdaptedList>::name;
}

DependentAdaptedList::DependentAdaptedList(const DependentAdaptedList&) = default;
DependentAdaptedList& DependentAdaptedList::operator=(const DependentAdaptedList&) = default;
DependentAdaptedList::DependentAdaptedList() {
}


DependentAdaptedList::~DependentAdaptedList() {}

DependentAdaptedList::DependentAdaptedList([[maybe_unused]] DependentAdaptedList&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)),
    __isset(other.__isset) {
}

DependentAdaptedList& DependentAdaptedList::operator=([[maybe_unused]] DependentAdaptedList&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    __isset = other.__isset;
    return *this;
}


DependentAdaptedList::DependentAdaptedList(apache::thrift::FragileConstructor, ::std::vector<::apache::thrift::fixtures::types::DependentAdaptedListDep> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void DependentAdaptedList::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.clear();
  __isset = {};
}

void DependentAdaptedList::__fbthrift_clear_terse_fields() {
}

bool DependentAdaptedList::__fbthrift_is_empty() const {
  return !(this->__isset.get(0));
}

bool DependentAdaptedList::operator==([[maybe_unused]] const DependentAdaptedList& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool DependentAdaptedList::operator<([[maybe_unused]] const DependentAdaptedList& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::std::vector<::apache::thrift::fixtures::types::DependentAdaptedListDep>* DependentAdaptedList::get_field() const& {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

::std::vector<::apache::thrift::fixtures::types::DependentAdaptedListDep>* DependentAdaptedList::get_field() & {
  return field_ref().has_value() ? std::addressof(__fbthrift_field_field) : nullptr;
}

void swap([[maybe_unused]] DependentAdaptedList& a, [[maybe_unused]] DependentAdaptedList& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__isset, b.__isset);
}

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        DependentAdaptedList,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::apache::thrift::fixtures::types::detail::DependentAdaptedListDep>>,
    "inconsistent use of json option");

} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {
namespace detail {

std::string_view DependentAdaptedListDep::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/DependentAdaptedListDep";
}

std::string_view DependentAdaptedListDep::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<DependentAdaptedListDep>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view DependentAdaptedListDep::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<DependentAdaptedListDep>::name;
}

DependentAdaptedListDep::DependentAdaptedListDep(const DependentAdaptedListDep&) = default;
DependentAdaptedListDep& DependentAdaptedListDep::operator=(const DependentAdaptedListDep&) = default;
DependentAdaptedListDep::DependentAdaptedListDep() {
}


DependentAdaptedListDep::~DependentAdaptedListDep() {}

DependentAdaptedListDep::DependentAdaptedListDep([[maybe_unused]] DependentAdaptedListDep&& other) noexcept :
    __fbthrift_field_field(std::move(other.__fbthrift_field_field)) {
}

DependentAdaptedListDep& DependentAdaptedListDep::operator=([[maybe_unused]] DependentAdaptedListDep&& other) noexcept {
    this->__fbthrift_field_field = std::move(other.__fbthrift_field_field);
    return *this;
}


DependentAdaptedListDep::DependentAdaptedListDep(apache::thrift::FragileConstructor, ::apache::thrift::detail::boxed_value_ptr<::std::int16_t> field__arg) :
    __fbthrift_field_field(std::move(field__arg)) { 
}

void DependentAdaptedListDep::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field.reset();
}

void DependentAdaptedListDep::__fbthrift_clear_terse_fields() {
}

bool DependentAdaptedListDep::__fbthrift_is_empty() const {
  return !(this->__fbthrift_field_field);
}

bool DependentAdaptedListDep::operator==([[maybe_unused]] const DependentAdaptedListDep& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool DependentAdaptedListDep::operator<([[maybe_unused]] const DependentAdaptedListDep& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] DependentAdaptedListDep& a, [[maybe_unused]] DependentAdaptedListDep& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
}


} // namespace detail
} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view AllocatorAware::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/AllocatorAware";
}

std::string_view AllocatorAware::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AllocatorAware>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AllocatorAware::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AllocatorAware>::name;
}

AllocatorAware::AllocatorAware(const AllocatorAware& srcObj) :
    __fbthrift_alloc(srcObj.__fbthrift_alloc),
    __fbthrift_field_aa_list(srcObj.__fbthrift_field_aa_list),
    __fbthrift_field_aa_set(srcObj.__fbthrift_field_aa_set),
    __fbthrift_field_aa_map(srcObj.__fbthrift_field_aa_map),
    __fbthrift_field_aa_string(srcObj.__fbthrift_field_aa_string),
    __fbthrift_field_not_a_container(srcObj.__fbthrift_field_not_a_container),
    __fbthrift_field_aa_unique(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::integral>(srcObj.__fbthrift_field_aa_unique)),
    __fbthrift_field_aa_shared(srcObj.__fbthrift_field_aa_shared),
    __isset(srcObj.__isset) {
}

static void __fbthrift_swap(AllocatorAware& lhs, AllocatorAware& rhs) { swap(lhs, rhs); }
AllocatorAware& AllocatorAware::operator=(const AllocatorAware& other) {
  AllocatorAware tmp(other, get_allocator());
  __fbthrift_swap(*this, tmp);
  ::apache::thrift::detail::copy_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
  return *this;
}

AllocatorAware::AllocatorAware() :
    __fbthrift_alloc(allocator_type()),
    __fbthrift_field_aa_list(__fbthrift_alloc),
    __fbthrift_field_aa_set(__fbthrift_alloc),
    __fbthrift_field_aa_map(__fbthrift_alloc),
    __fbthrift_field_aa_string(__fbthrift_alloc),
    __fbthrift_field_not_a_container(),
    __fbthrift_field_aa_unique(folly::allocate_unique<::apache::thrift::fixtures::types::i32_9314>(__fbthrift_alloc)),
    __fbthrift_field_aa_shared(std::allocate_shared<::apache::thrift::fixtures::types::i32_9314>(__fbthrift_alloc)) {
}


AllocatorAware::~AllocatorAware() {}

AllocatorAware::AllocatorAware(const allocator_type& alloc) noexcept :
    __fbthrift_alloc(alloc),
    __fbthrift_field_aa_list(alloc),
    __fbthrift_field_aa_set(alloc),
    __fbthrift_field_aa_map(alloc),
    __fbthrift_field_aa_string(alloc),
    __fbthrift_field_not_a_container(),
    __fbthrift_field_aa_unique(folly::allocate_unique<::apache::thrift::fixtures::types::i32_9314>(alloc)),
    __fbthrift_field_aa_shared(std::allocate_shared<::apache::thrift::fixtures::types::i32_9314>(alloc)) {}

AllocatorAware::AllocatorAware(const AllocatorAware& other, const allocator_type& alloc) :
    __fbthrift_alloc(alloc),
    __fbthrift_field_aa_list(other.__fbthrift_field_aa_list, alloc),
    __fbthrift_field_aa_set(other.__fbthrift_field_aa_set, alloc),
    __fbthrift_field_aa_map(other.__fbthrift_field_aa_map, alloc),
    __fbthrift_field_aa_string(other.__fbthrift_field_aa_string, alloc),
    __fbthrift_field_not_a_container(other.__fbthrift_field_not_a_container),
    __fbthrift_field_aa_unique(folly::allocate_unique<::apache::thrift::fixtures::types::i32_9314>(alloc, *other.__fbthrift_field_aa_unique)),
    __fbthrift_field_aa_shared(std::allocate_shared<::apache::thrift::fixtures::types::i32_9314>(alloc, *other.__fbthrift_field_aa_shared)),
    __isset(other.__isset) {}

AllocatorAware::AllocatorAware(AllocatorAware&& other, const allocator_type& alloc) :
    __fbthrift_alloc(alloc),
    __fbthrift_field_aa_list(std::move(other.__fbthrift_field_aa_list), alloc),
    __fbthrift_field_aa_set(std::move(other.__fbthrift_field_aa_set), alloc),
    __fbthrift_field_aa_map(std::move(other.__fbthrift_field_aa_map), alloc),
    __fbthrift_field_aa_string(std::move(other.__fbthrift_field_aa_string), alloc),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __fbthrift_field_aa_unique(folly::allocate_unique<::apache::thrift::fixtures::types::i32_9314>(alloc, std::move(*other.__fbthrift_field_aa_unique))),
    __fbthrift_field_aa_shared(std::allocate_shared<::apache::thrift::fixtures::types::i32_9314>(alloc, std::move(*other.__fbthrift_field_aa_shared))),
    __isset(other.__isset) {}
AllocatorAware::AllocatorAware([[maybe_unused]] AllocatorAware&& other) noexcept :
    __fbthrift_alloc(std::move(other.__fbthrift_alloc)),
    __fbthrift_field_aa_list(std::move(other.__fbthrift_field_aa_list)),
    __fbthrift_field_aa_set(std::move(other.__fbthrift_field_aa_set)),
    __fbthrift_field_aa_map(std::move(other.__fbthrift_field_aa_map)),
    __fbthrift_field_aa_string(std::move(other.__fbthrift_field_aa_string)),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __fbthrift_field_aa_unique(std::move(other.__fbthrift_field_aa_unique)),
    __fbthrift_field_aa_shared(std::move(other.__fbthrift_field_aa_shared)),
    __isset(other.__isset) {
}

AllocatorAware& AllocatorAware::operator=([[maybe_unused]] AllocatorAware&& other) noexcept {
    this->__fbthrift_field_aa_list = std::move(other.__fbthrift_field_aa_list);
    this->__fbthrift_field_aa_set = std::move(other.__fbthrift_field_aa_set);
    this->__fbthrift_field_aa_map = std::move(other.__fbthrift_field_aa_map);
    this->__fbthrift_field_aa_string = std::move(other.__fbthrift_field_aa_string);
    this->__fbthrift_field_not_a_container = std::move(other.__fbthrift_field_not_a_container);
    this->__fbthrift_field_aa_unique = std::move(other.__fbthrift_field_aa_unique);
    this->__fbthrift_field_aa_shared = std::move(other.__fbthrift_field_aa_shared);
    __isset = other.__isset;
  ::apache::thrift::detail::move_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
    return *this;
}


AllocatorAware::AllocatorAware(apache::thrift::FragileConstructor, ::apache::thrift::fixtures::types::list_i32_9187 aa_list__arg, ::apache::thrift::fixtures::types::set_i32_7070 aa_set__arg, ::apache::thrift::fixtures::types::map_i32_i32_9565 aa_map__arg, ::apache::thrift::fixtures::types::string_5252 aa_string__arg, ::std::int32_t not_a_container__arg, ::std::unique_ptr<::apache::thrift::fixtures::types::i32_9314> aa_unique__arg, ::std::shared_ptr<::apache::thrift::fixtures::types::i32_9314> aa_shared__arg) :
    __fbthrift_field_aa_list(std::move(aa_list__arg)),
    __fbthrift_field_aa_set(std::move(aa_set__arg)),
    __fbthrift_field_aa_map(std::move(aa_map__arg)),
    __fbthrift_field_aa_string(std::move(aa_string__arg)),
    __fbthrift_field_not_a_container(std::move(not_a_container__arg)),
    __fbthrift_field_aa_unique(std::move(aa_unique__arg)),
    __fbthrift_field_aa_shared(std::move(aa_shared__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}

void AllocatorAware::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_aa_list.clear();
  this->__fbthrift_field_aa_set.clear();
  this->__fbthrift_field_aa_map.clear();
  this->__fbthrift_field_aa_string = apache::thrift::StringTraits<::apache::thrift::fixtures::types::string_5252>::fromStringLiteral("");
  this->__fbthrift_field_not_a_container = ::std::int32_t();
  this->__fbthrift_field_aa_unique = ::apache::thrift::detail::make_mutable_smart_ptr<::std::unique_ptr<::apache::thrift::fixtures::types::i32_9314>>(this->get_allocator());
  this->__fbthrift_field_aa_shared = ::apache::thrift::detail::make_mutable_smart_ptr<::std::shared_ptr<::apache::thrift::fixtures::types::i32_9314>>(this->get_allocator());
  __isset = {};
}

void AllocatorAware::__fbthrift_clear_terse_fields() {
}

bool AllocatorAware::__fbthrift_is_empty() const {
  return false;
}

bool AllocatorAware::operator==([[maybe_unused]] const AllocatorAware& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AllocatorAware::operator<([[maybe_unused]] const AllocatorAware& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


const ::apache::thrift::fixtures::types::list_i32_9187& AllocatorAware::get_aa_list() const& {
  return __fbthrift_field_aa_list;
}

::apache::thrift::fixtures::types::list_i32_9187 AllocatorAware::get_aa_list() && {
  return static_cast<::apache::thrift::fixtures::types::list_i32_9187&&>(__fbthrift_field_aa_list);
}

const ::apache::thrift::fixtures::types::set_i32_7070& AllocatorAware::get_aa_set() const& {
  return __fbthrift_field_aa_set;
}

::apache::thrift::fixtures::types::set_i32_7070 AllocatorAware::get_aa_set() && {
  return static_cast<::apache::thrift::fixtures::types::set_i32_7070&&>(__fbthrift_field_aa_set);
}

const ::apache::thrift::fixtures::types::map_i32_i32_9565& AllocatorAware::get_aa_map() const& {
  return __fbthrift_field_aa_map;
}

::apache::thrift::fixtures::types::map_i32_i32_9565 AllocatorAware::get_aa_map() && {
  return static_cast<::apache::thrift::fixtures::types::map_i32_i32_9565&&>(__fbthrift_field_aa_map);
}

::std::int32_t AllocatorAware::get_not_a_container() const {
  return __fbthrift_field_not_a_container;
}

::std::int32_t& AllocatorAware::set_not_a_container(::std::int32_t not_a_container_) {
  not_a_container_ref() = not_a_container_;
  return __fbthrift_field_not_a_container;
}

void swap([[maybe_unused]] AllocatorAware& a, [[maybe_unused]] AllocatorAware& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_aa_list, b.__fbthrift_field_aa_list);
  swap(a.__fbthrift_field_aa_set, b.__fbthrift_field_aa_set);
  swap(a.__fbthrift_field_aa_map, b.__fbthrift_field_aa_map);
  swap(a.__fbthrift_field_aa_string, b.__fbthrift_field_aa_string);
  swap(a.__fbthrift_field_not_a_container, b.__fbthrift_field_not_a_container);
  swap(a.__fbthrift_field_aa_unique, b.__fbthrift_field_aa_unique);
  swap(a.__fbthrift_field_aa_shared, b.__fbthrift_field_aa_shared);
  swap(a.__isset, b.__isset);
  ::apache::thrift::detail::swap_allocators(a.__fbthrift_alloc, b.__fbthrift_alloc);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view AllocatorAware2::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/AllocatorAware2";
}

std::string_view AllocatorAware2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<AllocatorAware2>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view AllocatorAware2::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<AllocatorAware2>::name;
}

AllocatorAware2::AllocatorAware2(const AllocatorAware2& srcObj) :
    __fbthrift_alloc(srcObj.__fbthrift_alloc),
    __fbthrift_field_not_a_container(srcObj.__fbthrift_field_not_a_container),
    __fbthrift_field_box_field(srcObj.__fbthrift_field_box_field),
    __isset(srcObj.__isset) {
}

static void __fbthrift_swap(AllocatorAware2& lhs, AllocatorAware2& rhs) { swap(lhs, rhs); }
AllocatorAware2& AllocatorAware2::operator=(const AllocatorAware2& other) {
  AllocatorAware2 tmp(other, get_allocator());
  __fbthrift_swap(*this, tmp);
  ::apache::thrift::detail::copy_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
  return *this;
}

AllocatorAware2::AllocatorAware2() :
    __fbthrift_alloc(allocator_type()),
    __fbthrift_field_not_a_container(),
    __fbthrift_field_box_field(::std::int32_t()) {
}


AllocatorAware2::~AllocatorAware2() {}

AllocatorAware2::AllocatorAware2(const allocator_type& alloc) noexcept :
    __fbthrift_alloc(alloc),
    __fbthrift_field_not_a_container(),
    __fbthrift_field_box_field() {}

AllocatorAware2::AllocatorAware2(const AllocatorAware2& other, const allocator_type& alloc) :
    __fbthrift_alloc(alloc),
    __fbthrift_field_not_a_container(other.__fbthrift_field_not_a_container),
    __fbthrift_field_box_field(),
    __isset(other.__isset) {}

AllocatorAware2::AllocatorAware2(AllocatorAware2&& other, const allocator_type& alloc) :
    __fbthrift_alloc(alloc),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __fbthrift_field_box_field(),
    __isset(other.__isset) {}
AllocatorAware2::AllocatorAware2([[maybe_unused]] AllocatorAware2&& other) noexcept :
    __fbthrift_alloc(std::move(other.__fbthrift_alloc)),
    __fbthrift_field_not_a_container(std::move(other.__fbthrift_field_not_a_container)),
    __fbthrift_field_box_field(std::move(other.__fbthrift_field_box_field)),
    __isset(other.__isset) {
}

AllocatorAware2& AllocatorAware2::operator=([[maybe_unused]] AllocatorAware2&& other) noexcept {
    this->__fbthrift_field_not_a_container = std::move(other.__fbthrift_field_not_a_container);
    this->__fbthrift_field_box_field = std::move(other.__fbthrift_field_box_field);
    __isset = other.__isset;
  ::apache::thrift::detail::move_allocator(__fbthrift_alloc, other.__fbthrift_alloc);
    return *this;
}


AllocatorAware2::AllocatorAware2(apache::thrift::FragileConstructor, ::std::int32_t not_a_container__arg, ::apache::thrift::detail::boxed_value_ptr<::std::int32_t> box_field__arg) :
    __fbthrift_field_not_a_container(std::move(not_a_container__arg)),
    __fbthrift_field_box_field(std::move(box_field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void AllocatorAware2::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_not_a_container = ::std::int32_t();
  this->__fbthrift_field_box_field.reset();
  __isset = {};
}

void AllocatorAware2::__fbthrift_clear_terse_fields() {
}

bool AllocatorAware2::__fbthrift_is_empty() const {
  return false;
}

bool AllocatorAware2::operator==([[maybe_unused]] const AllocatorAware2& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool AllocatorAware2::operator<([[maybe_unused]] const AllocatorAware2& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int32_t AllocatorAware2::get_not_a_container() const {
  return __fbthrift_field_not_a_container;
}

::std::int32_t& AllocatorAware2::set_not_a_container(::std::int32_t not_a_container_) {
  not_a_container_ref() = not_a_container_;
  return __fbthrift_field_not_a_container;
}

void swap([[maybe_unused]] AllocatorAware2& a, [[maybe_unused]] AllocatorAware2& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_not_a_container, b.__fbthrift_field_not_a_container);
  swap(a.__fbthrift_field_box_field, b.__fbthrift_field_box_field);
  swap(a.__isset, b.__isset);
  ::apache::thrift::detail::swap_allocators(a.__fbthrift_alloc, b.__fbthrift_alloc);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view TypedefStruct::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/TypedefStruct";
}

std::string_view TypedefStruct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<TypedefStruct>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view TypedefStruct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<TypedefStruct>::name;
}

TypedefStruct::TypedefStruct(const TypedefStruct&) = default;
TypedefStruct& TypedefStruct::operator=(const TypedefStruct&) = default;
TypedefStruct::TypedefStruct([[maybe_unused]] TypedefStruct&& other) noexcept :
    __fbthrift_field_i32_field(std::move(other.__fbthrift_field_i32_field)),
    __fbthrift_field_IntTypedef_field(std::move(other.__fbthrift_field_IntTypedef_field)),
    __fbthrift_field_UintTypedef_field(std::move(other.__fbthrift_field_UintTypedef_field)),
    __isset(other.__isset) {
}

TypedefStruct& TypedefStruct::operator=([[maybe_unused]] TypedefStruct&& other) noexcept {
    this->__fbthrift_field_i32_field = std::move(other.__fbthrift_field_i32_field);
    this->__fbthrift_field_IntTypedef_field = std::move(other.__fbthrift_field_IntTypedef_field);
    this->__fbthrift_field_UintTypedef_field = std::move(other.__fbthrift_field_UintTypedef_field);
    __isset = other.__isset;
    return *this;
}


TypedefStruct::TypedefStruct(apache::thrift::FragileConstructor, ::std::int32_t i32_field__arg, ::apache::thrift::fixtures::types::IntTypedef IntTypedef_field__arg, ::apache::thrift::fixtures::types::UintTypedef UintTypedef_field__arg) :
    __fbthrift_field_i32_field(std::move(i32_field__arg)),
    __fbthrift_field_IntTypedef_field(std::move(IntTypedef_field__arg)),
    __fbthrift_field_UintTypedef_field(std::move(UintTypedef_field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}

void TypedefStruct::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_i32_field = ::std::int32_t();
  this->__fbthrift_field_IntTypedef_field = ::apache::thrift::fixtures::types::IntTypedef();
  this->__fbthrift_field_UintTypedef_field = ::apache::thrift::fixtures::types::UintTypedef();
  __isset = {};
}

void TypedefStruct::__fbthrift_clear_terse_fields() {
}

bool TypedefStruct::__fbthrift_is_empty() const {
  return false;
}

bool TypedefStruct::operator==([[maybe_unused]] const TypedefStruct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool TypedefStruct::operator<([[maybe_unused]] const TypedefStruct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int32_t TypedefStruct::get_i32_field() const {
  return __fbthrift_field_i32_field;
}

::std::int32_t& TypedefStruct::set_i32_field(::std::int32_t i32_field_) {
  i32_field_ref() = i32_field_;
  return __fbthrift_field_i32_field;
}

::apache::thrift::fixtures::types::IntTypedef TypedefStruct::get_IntTypedef_field() const {
  return __fbthrift_field_IntTypedef_field;
}

::apache::thrift::fixtures::types::IntTypedef& TypedefStruct::set_IntTypedef_field(::apache::thrift::fixtures::types::IntTypedef IntTypedef_field_) {
  IntTypedef_field_ref() = IntTypedef_field_;
  return __fbthrift_field_IntTypedef_field;
}

::apache::thrift::fixtures::types::UintTypedef TypedefStruct::get_UintTypedef_field() const {
  return __fbthrift_field_UintTypedef_field;
}

::apache::thrift::fixtures::types::UintTypedef& TypedefStruct::set_UintTypedef_field(::apache::thrift::fixtures::types::UintTypedef UintTypedef_field_) {
  UintTypedef_field_ref() = UintTypedef_field_;
  return __fbthrift_field_UintTypedef_field;
}

void swap([[maybe_unused]] TypedefStruct& a, [[maybe_unused]] TypedefStruct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_i32_field, b.__fbthrift_field_i32_field);
  swap(a.__fbthrift_field_IntTypedef_field, b.__fbthrift_field_IntTypedef_field);
  swap(a.__fbthrift_field_UintTypedef_field, b.__fbthrift_field_UintTypedef_field);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types


namespace apache::thrift::fixtures::types {

std::string_view StructWithDoubleUnderscores::__fbthrift_thrift_uri() {
  return "apache.org/thrift/fixtures/types/StructWithDoubleUnderscores";
}

std::string_view StructWithDoubleUnderscores::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<StructWithDoubleUnderscores>::fields_names[folly::to_underlying(ord) - 1];
}
std::string_view StructWithDoubleUnderscores::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<StructWithDoubleUnderscores>::name;
}


StructWithDoubleUnderscores::StructWithDoubleUnderscores(apache::thrift::FragileConstructor, ::std::int32_t __field__arg) :
    __fbthrift_field___field(std::move(__field__arg)) { 
  __isset.set(folly::index_constant<0>(), true);
}

void StructWithDoubleUnderscores::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field___field = ::std::int32_t();
  __isset = {};
}

void StructWithDoubleUnderscores::__fbthrift_clear_terse_fields() {
}

bool StructWithDoubleUnderscores::__fbthrift_is_empty() const {
  return false;
}

bool StructWithDoubleUnderscores::operator==([[maybe_unused]] const StructWithDoubleUnderscores& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool StructWithDoubleUnderscores::operator<([[maybe_unused]] const StructWithDoubleUnderscores& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


::std::int32_t StructWithDoubleUnderscores::get___field() const {
  return __fbthrift_field___field;
}

::std::int32_t& StructWithDoubleUnderscores::set___field(::std::int32_t __field_) {
  __field_ref() = __field_;
  return __fbthrift_field___field;
}

void swap([[maybe_unused]] StructWithDoubleUnderscores& a, [[maybe_unused]] StructWithDoubleUnderscores& b) {
  using ::std::swap;
  swap(a.__fbthrift_field___field, b.__fbthrift_field___field);
  swap(a.__isset, b.__isset);
}


} // namespace apache::thrift::fixtures::types

namespace apache::thrift::fixtures::types { namespace {
[[maybe_unused]] FOLLY_ERASE void validateAdapters() {
  ::apache::thrift::adapt_detail::validateFieldAdapter<::my::Adapter, 3, ::std::int16_t, ::apache::thrift::fixtures::types::MinPaddingWithCustomType>();
}
}} // namespace apache::thrift::fixtures::types
namespace apache::thrift::detail::annotation {
}
