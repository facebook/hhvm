#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.cpp.ttypes
import thrift.annotation.python.ttypes
import thrift.annotation.thrift.ttypes
import thrift.annotation.scope.ttypes
import thrift.annotation.hack.ttypes

import ::my
import my


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyAnnotation', 'Foo', 'Baz', 'Bar', 'DirectlyAdapted', 'StructWithFieldAdapter', 'TerseAdaptedFields', 'B', 'A', 'Config', 'MyStruct', 'SetWithAdapter', 'StringWithAdapter', 'ListWithElemAdapter', 'ListWithElemAdapter_withAdapter', 'MyI64', 'DoubleTypedefI64', 'MyI32', 'FooWithAdapter', 'StructWithAdapter', 'UnionWithAdapter', 'AdaptedA']

class MyAnnotation:
  """
  Attributes:
   - signature
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.signature = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyAnnotation')
    if self.signature != None:
      oprot.writeFieldBegin('signature', TType.STRING, 1)
      oprot.writeString(self.signature.encode('utf-8')) if UTF8STRINGS and not isinstance(self.signature, bytes) else oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'signature' in json_obj and json_obj['signature'] is not None:
      self.signature = json_obj['signature']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.signature is not None:
      value = pprint.pformat(self.signature, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    signature=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'signature',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyAnnotation, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyAnnotation, self)

  def _to_py_deprecated(self):
    return self

class Foo:
  """
  Attributes:
   - intField
   - optionalIntField
   - intFieldWithDefault
   - setField
   - optionalSetField
   - mapField
   - optionalMapField
   - binaryField
   - longField
   - adaptedLongField
   - doubleAdaptedField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.optionalIntField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intFieldWithDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.setField = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.optionalSetField = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.mapField = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = []
              (_etype24, _size21) = iprot.readListBegin()
              if _size21 >= 0:
                for _i25 in range(_size21):
                  _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem26)
              else: 
                while iprot.peekList():
                  _elem27 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem27)
              iprot.readListEnd()
              self.mapField[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = []
              (_etype33, _size30) = iprot.readListBegin()
              if _size30 >= 0:
                for _i34 in range(_size30):
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem35)
              else: 
                while iprot.peekList():
                  _elem36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem36)
              iprot.readListEnd()
              self.mapField[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.optionalMapField = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in range(_size44):
                  _elem49 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.optionalMapField[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in range(_size53):
                  _elem58 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.optionalMapField[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryField = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.longField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.adaptedLongField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.doubleAdaptedField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Foo')
    if self.intField != None:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      oprot.writeI32(self.intField)
      oprot.writeFieldEnd()
    if self.optionalIntField != None:
      oprot.writeFieldBegin('optionalIntField', TType.I32, 2)
      oprot.writeI32(self.optionalIntField)
      oprot.writeFieldEnd()
    if self.intFieldWithDefault != None:
      oprot.writeFieldBegin('intFieldWithDefault', TType.I32, 3)
      oprot.writeI32(self.intFieldWithDefault)
      oprot.writeFieldEnd()
    if self.setField != None:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.setField))
      for iter60 in self.setField:
        oprot.writeString(iter60.encode('utf-8')) if UTF8STRINGS and not isinstance(iter60, bytes) else oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optionalSetField != None:
      oprot.writeFieldBegin('optionalSetField', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.optionalSetField))
      for iter61 in self.optionalSetField:
        oprot.writeString(iter61.encode('utf-8')) if UTF8STRINGS and not isinstance(iter61, bytes) else oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mapField != None:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapField))
      for kiter62,viter63 in self.mapField.items():
        oprot.writeString(kiter62.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter62, bytes) else oprot.writeString(kiter62)
        oprot.writeListBegin(TType.STRING, len(viter63))
        for iter64 in viter63:
          oprot.writeString(iter64.encode('utf-8')) if UTF8STRINGS and not isinstance(iter64, bytes) else oprot.writeString(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optionalMapField != None:
      oprot.writeFieldBegin('optionalMapField', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.optionalMapField))
      for kiter65,viter66 in self.optionalMapField.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        oprot.writeListBegin(TType.STRING, len(viter66))
        for iter67 in viter66:
          oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.binaryField != None:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      oprot.writeString(self.binaryField)
      oprot.writeFieldEnd()
    if self.longField != None:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      oprot.writeI64(self.longField)
      oprot.writeFieldEnd()
    if self.adaptedLongField != None:
      oprot.writeFieldBegin('adaptedLongField', TType.I64, 10)
      oprot.writeI64(self.adaptedLongField)
      oprot.writeFieldEnd()
    if self.doubleAdaptedField != None:
      oprot.writeFieldBegin('doubleAdaptedField', TType.I64, 11)
      oprot.writeI64(self.doubleAdaptedField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'intField' in json_obj and json_obj['intField'] is not None:
      self.intField = json_obj['intField']
      if self.intField > 0x7fffffff or self.intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optionalIntField' in json_obj and json_obj['optionalIntField'] is not None:
      self.optionalIntField = json_obj['optionalIntField']
      if self.optionalIntField > 0x7fffffff or self.optionalIntField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'intFieldWithDefault' in json_obj and json_obj['intFieldWithDefault'] is not None:
      self.intFieldWithDefault = json_obj['intFieldWithDefault']
      if self.intFieldWithDefault > 0x7fffffff or self.intFieldWithDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'setField' in json_obj and json_obj['setField'] is not None:
      self.setField = set_cls()
      for _tmp_e68 in json_obj['setField']:
        self.setField.add(_tmp_e68)
    if 'optionalSetField' in json_obj and json_obj['optionalSetField'] is not None:
      self.optionalSetField = set_cls()
      for _tmp_e69 in json_obj['optionalSetField']:
        self.optionalSetField.add(_tmp_e69)
    if 'mapField' in json_obj and json_obj['mapField'] is not None:
      self.mapField = dict_cls()
      for _tmp_k70, _tmp_v71 in json_obj['mapField'].items():
        _tmp_kp72 = _tmp_k70
        _list73 = []
        for _tmp_e74 in _tmp_v71:
          _list73.append(_tmp_e74)
        self.mapField[_tmp_kp72] = _list73
    if 'optionalMapField' in json_obj and json_obj['optionalMapField'] is not None:
      self.optionalMapField = dict_cls()
      for _tmp_k75, _tmp_v76 in json_obj['optionalMapField'].items():
        _tmp_kp77 = _tmp_k75
        _list78 = []
        for _tmp_e79 in _tmp_v76:
          _list78.append(_tmp_e79)
        self.optionalMapField[_tmp_kp77] = _list78
    if 'binaryField' in json_obj and json_obj['binaryField'] is not None:
      self.binaryField = json_obj['binaryField']
    if 'longField' in json_obj and json_obj['longField'] is not None:
      self.longField = long(json_obj['longField'])
    if 'adaptedLongField' in json_obj and json_obj['adaptedLongField'] is not None:
      self.adaptedLongField = long(json_obj['adaptedLongField'])
    if 'doubleAdaptedField' in json_obj and json_obj['doubleAdaptedField'] is not None:
      self.doubleAdaptedField = long(json_obj['doubleAdaptedField'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.intField is not None:
      value = pprint.pformat(self.intField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intField=%s' % (value))
    if self.optionalIntField is not None:
      value = pprint.pformat(self.optionalIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalIntField=%s' % (value))
    if self.intFieldWithDefault is not None:
      value = pprint.pformat(self.intFieldWithDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intFieldWithDefault=%s' % (value))
    if self.setField is not None:
      value = pprint.pformat(self.setField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    setField=%s' % (value))
    if self.optionalSetField is not None:
      value = pprint.pformat(self.optionalSetField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalSetField=%s' % (value))
    if self.mapField is not None:
      value = pprint.pformat(self.mapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapField=%s' % (value))
    if self.optionalMapField is not None:
      value = pprint.pformat(self.optionalMapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalMapField=%s' % (value))
    if self.binaryField is not None:
      value = pprint.pformat(self.binaryField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryField=%s' % (value))
    if self.longField is not None:
      value = pprint.pformat(self.longField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    longField=%s' % (value))
    if self.adaptedLongField is not None:
      value = pprint.pformat(self.adaptedLongField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedLongField=%s' % (value))
    if self.doubleAdaptedField is not None:
      value = pprint.pformat(self.doubleAdaptedField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleAdaptedField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'intField',
      'optionalIntField',
      'intFieldWithDefault',
      'setField',
      'optionalSetField',
      'mapField',
      'optionalMapField',
      'binaryField',
      'longField',
      'adaptedLongField',
      'doubleAdaptedField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Foo, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Foo, self)

  def _to_py_deprecated(self):
    return self

class Baz(object):
  """
  Attributes:
   - intField
   - setField
   - mapField
   - binaryField
   - longField
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INTFIELD = 1
  SETFIELD = 4
  MAPFIELD = 6
  BINARYFIELD = 8
  LONGFIELD = 9
  
  @staticmethod
  def isUnion():
    return True

  def get_intField(self):
    assert self.field == 1
    return self.value

  def get_setField(self):
    assert self.field == 4
    return self.value

  def get_mapField(self):
    assert self.field == 6
    return self.value

  def get_binaryField(self):
    assert self.field == 8
    return self.value

  def get_longField(self):
    assert self.field == 9
    return self.value

  def set_intField(self, value):
    self.field = 1
    self.value = value

  def set_setField(self, value):
    self.field = 4
    self.value = value

  def set_mapField(self, value):
    self.field = 6
    self.value = value

  def set_binaryField(self, value):
    self.field = 8
    self.value = value

  def set_longField(self, value):
    self.field = 9
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('intField', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('setField', value)
    if self.field == 6:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mapField', value)
    if self.field == 8:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binaryField', value)
    if self.field == 9:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('longField', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_intField = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_intField(_fbthrift_intField)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          _fbthrift_setField = set()
          (_etype83, _size80) = iprot.readSetBegin()
          if _size80 >= 0:
            for _i84 in range(_size80):
              _elem85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem85)
          else: 
            while iprot.peekSet():
              _elem86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem86)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_setField(_fbthrift_setField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          _fbthrift_mapField = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          if _size87 >= 0:
            for _i91 in range(_size87):
              _key92 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val93 = []
              (_etype97, _size94) = iprot.readListBegin()
              if _size94 >= 0:
                for _i98 in range(_size94):
                  _elem99 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem99)
              else: 
                while iprot.peekList():
                  _elem100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem100)
              iprot.readListEnd()
              _fbthrift_mapField[_key92] = _val93
          else: 
            while iprot.peekMap():
              _key101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val102 = []
              (_etype106, _size103) = iprot.readListBegin()
              if _size103 >= 0:
                for _i107 in range(_size103):
                  _elem108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem108)
              else: 
                while iprot.peekList():
                  _elem109 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem109)
              iprot.readListEnd()
              _fbthrift_mapField[_key101] = _val102
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_mapField(_fbthrift_mapField)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          _fbthrift_binaryField = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binaryField(_fbthrift_binaryField)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          _fbthrift_longField = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_longField(_fbthrift_longField)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Baz')
    if self.field == 1:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      intField = self.value
      oprot.writeI32(intField)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      setField = self.value
      oprot.writeSetBegin(TType.STRING, len(setField))
      for iter110 in setField:
        oprot.writeString(iter110.encode('utf-8')) if UTF8STRINGS and not isinstance(iter110, bytes) else oprot.writeString(iter110)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      mapField = self.value
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(mapField))
      for kiter111,viter112 in mapField.items():
        oprot.writeString(kiter111.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter111, bytes) else oprot.writeString(kiter111)
        oprot.writeListBegin(TType.STRING, len(viter112))
        for iter113 in viter112:
          oprot.writeString(iter113.encode('utf-8')) if UTF8STRINGS and not isinstance(iter113, bytes) else oprot.writeString(iter113)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      binaryField = self.value
      oprot.writeString(binaryField)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      longField = self.value
      oprot.writeI64(longField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'intField' in obj:
      _fbthrift_intField = obj['intField']
      if _fbthrift_intField > 0x7fffffff or _fbthrift_intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_intField(_fbthrift_intField)
    if 'setField' in obj:
      _fbthrift_setField = set_cls()
      for _tmp_e114 in obj['setField']:
        _fbthrift_setField.add(_tmp_e114)
      self.set_setField(_fbthrift_setField)
    if 'mapField' in obj:
      _fbthrift_mapField = dict_cls()
      for _tmp_k115, _tmp_v116 in obj['mapField'].items():
        _tmp_kp117 = _tmp_k115
        _list118 = []
        for _tmp_e119 in _tmp_v116:
          _list118.append(_tmp_e119)
        _fbthrift_mapField[_tmp_kp117] = _list118
      self.set_mapField(_fbthrift_mapField)
    if 'binaryField' in obj:
      _fbthrift_binaryField = obj['binaryField']
      self.set_binaryField(_fbthrift_binaryField)
    if 'longField' in obj:
      _fbthrift_longField = long(obj['longField'])
      self.set_longField(_fbthrift_longField)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Baz, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Baz, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  """
  Attributes:
   - structField
   - optionalStructField
   - structListField
   - optionalStructListField
   - unionField
   - optionalUnionField
   - adaptedStructField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.structField = Foo()
          self.structField.read(iprot)
          self.structField = ::my.Adapter1.from_thrift(self.structField)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optionalStructField = Foo()
          self.optionalStructField.read(iprot)
          self.optionalStructField = my.Adapter1.from_thrift(self.optionalStructField)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.structListField = []
          (_etype123, _size120) = iprot.readListBegin()
          if _size120 >= 0:
            for _i124 in range(_size120):
              _elem125 = Foo()
              _elem125.read(iprot)
              _elem125 = my.Adapter1.from_thrift(_elem125)
              self.structListField.append(_elem125)
          else: 
            while iprot.peekList():
              _elem126 = Foo()
              _elem126.read(iprot)
              _elem126 = my.Adapter1.from_thrift(_elem126)
              self.structListField.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.optionalStructListField = []
          (_etype130, _size127) = iprot.readListBegin()
          if _size127 >= 0:
            for _i131 in range(_size127):
              _elem132 = Foo()
              _elem132.read(iprot)
              _elem132 = my.Adapter1.from_thrift(_elem132)
              self.optionalStructListField.append(_elem132)
          else: 
            while iprot.peekList():
              _elem133 = Foo()
              _elem133.read(iprot)
              _elem133 = my.Adapter1.from_thrift(_elem133)
              self.optionalStructListField.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.unionField = Baz()
          self.unionField.read(iprot)
          self.unionField = my.Adapter1.from_thrift(self.unionField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.optionalUnionField = Baz()
          self.optionalUnionField.read(iprot)
          self.optionalUnionField = my.Adapter1.from_thrift(self.optionalUnionField)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.adaptedStructField = DirectlyAdapted()
          self.adaptedStructField.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.structField != None:
      oprot.writeFieldBegin('structField', TType.STRUCT, 1)
      adpt134 = ::my.Adapter1.to_thrift(self.structField)
      adpt134.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalStructField != None:
      oprot.writeFieldBegin('optionalStructField', TType.STRUCT, 2)
      adpt135 = my.Adapter1.to_thrift(self.optionalStructField)
      adpt135.write(oprot)
      oprot.writeFieldEnd()
    if self.structListField != None:
      oprot.writeFieldBegin('structListField', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.structListField))
      for iter136 in self.structListField:
        adpt137 = my.Adapter1.to_thrift(iter136)
        adpt137.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optionalStructListField != None:
      oprot.writeFieldBegin('optionalStructListField', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.optionalStructListField))
      for iter138 in self.optionalStructListField:
        adpt139 = my.Adapter1.to_thrift(iter138)
        adpt139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unionField != None:
      oprot.writeFieldBegin('unionField', TType.STRUCT, 5)
      adpt140 = my.Adapter1.to_thrift(self.unionField)
      adpt140.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalUnionField != None:
      oprot.writeFieldBegin('optionalUnionField', TType.STRUCT, 6)
      adpt141 = my.Adapter1.to_thrift(self.optionalUnionField)
      adpt141.write(oprot)
      oprot.writeFieldEnd()
    if self.adaptedStructField != None:
      oprot.writeFieldBegin('adaptedStructField', TType.STRUCT, 7)
      self.adaptedStructField.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structField' in json_obj and json_obj['structField'] is not None:
      self.structField = Foo()
      self.structField.readFromJson(json_obj['structField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalStructField' in json_obj and json_obj['optionalStructField'] is not None:
      self.optionalStructField = Foo()
      self.optionalStructField.readFromJson(json_obj['optionalStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structListField' in json_obj and json_obj['structListField'] is not None:
      self.structListField = []
      for _tmp_e142 in json_obj['structListField']:
        _struct143 = Foo()
        _struct143.readFromJson(_tmp_e142, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.structListField.append(_struct143)
    if 'optionalStructListField' in json_obj and json_obj['optionalStructListField'] is not None:
      self.optionalStructListField = []
      for _tmp_e144 in json_obj['optionalStructListField']:
        _struct145 = Foo()
        _struct145.readFromJson(_tmp_e144, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.optionalStructListField.append(_struct145)
    if 'unionField' in json_obj and json_obj['unionField'] is not None:
      self.unionField = Baz()
      self.unionField.readFromJson(json_obj['unionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalUnionField' in json_obj and json_obj['optionalUnionField'] is not None:
      self.optionalUnionField = Baz()
      self.optionalUnionField.readFromJson(json_obj['optionalUnionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'adaptedStructField' in json_obj and json_obj['adaptedStructField'] is not None:
      self.adaptedStructField = DirectlyAdapted()
      self.adaptedStructField.readFromJson(json_obj['adaptedStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structField is not None:
      value = pprint.pformat(self.structField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structField=%s' % (value))
    if self.optionalStructField is not None:
      value = pprint.pformat(self.optionalStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructField=%s' % (value))
    if self.structListField is not None:
      value = pprint.pformat(self.structListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structListField=%s' % (value))
    if self.optionalStructListField is not None:
      value = pprint.pformat(self.optionalStructListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructListField=%s' % (value))
    if self.unionField is not None:
      value = pprint.pformat(self.unionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionField=%s' % (value))
    if self.optionalUnionField is not None:
      value = pprint.pformat(self.optionalUnionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalUnionField=%s' % (value))
    if self.adaptedStructField is not None:
      value = pprint.pformat(self.adaptedStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStructField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structField',
      'optionalStructField',
      'structListField',
      'optionalStructListField',
      'unionField',
      'optionalUnionField',
      'adaptedStructField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class DirectlyAdapted:
  """
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirectlyAdapted')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DirectlyAdapted, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DirectlyAdapted, self)

  def _to_py_deprecated(self):
    return self

class StructWithFieldAdapter:
  """
  Attributes:
   - field
   - shared_field
   - opt_shared_field
   - opt_boxed_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.opt_shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.opt_boxed_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithFieldAdapter')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.shared_field != None:
      oprot.writeFieldBegin('shared_field', TType.I32, 2)
      oprot.writeI32(self.shared_field)
      oprot.writeFieldEnd()
    if self.opt_shared_field != None:
      oprot.writeFieldBegin('opt_shared_field', TType.I32, 3)
      oprot.writeI32(self.opt_shared_field)
      oprot.writeFieldEnd()
    if self.opt_boxed_field != None:
      oprot.writeFieldBegin('opt_boxed_field', TType.I32, 4)
      oprot.writeI32(self.opt_boxed_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'shared_field' in json_obj and json_obj['shared_field'] is not None:
      self.shared_field = json_obj['shared_field']
      if self.shared_field > 0x7fffffff or self.shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_shared_field' in json_obj and json_obj['opt_shared_field'] is not None:
      self.opt_shared_field = json_obj['opt_shared_field']
      if self.opt_shared_field > 0x7fffffff or self.opt_shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_boxed_field' in json_obj and json_obj['opt_boxed_field'] is not None:
      self.opt_boxed_field = json_obj['opt_boxed_field']
      if self.opt_boxed_field > 0x7fffffff or self.opt_boxed_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.shared_field is not None:
      value = pprint.pformat(self.shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    shared_field=%s' % (value))
    if self.opt_shared_field is not None:
      value = pprint.pformat(self.opt_shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_shared_field=%s' % (value))
    if self.opt_boxed_field is not None:
      value = pprint.pformat(self.opt_boxed_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_boxed_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'shared_field',
      'opt_shared_field',
      'opt_boxed_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructWithFieldAdapter, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructWithFieldAdapter, self)

  def _to_py_deprecated(self):
    return self

class TerseAdaptedFields:
  """
  Attributes:
   - int_field
   - string_field
   - set_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype149, _size146) = iprot.readSetBegin()
          if _size146 >= 0:
            for _i150 in range(_size146):
              _elem151 = iprot.readI32()
              self.set_field.add(_elem151)
          else: 
            while iprot.peekSet():
              _elem152 = iprot.readI32()
              self.set_field.add(_elem152)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseAdaptedFields')
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 1)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 2)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 3)
      oprot.writeSetBegin(TType.I32, len(self.set_field))
      for iter153 in self.set_field:
        oprot.writeI32(iter153)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e154 in json_obj['set_field']:
        if _tmp_e154 > 0x7fffffff or _tmp_e154 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e154)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'int_field',
      'string_field',
      'set_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseAdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseAdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class B:
  """
  Attributes:
   - a
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.a = A()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('B')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRUCT, 1)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'a' in json_obj and json_obj['a'] is not None:
      self.a = A()
      self.a.readFromJson(json_obj['a'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.B, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.B, self)

  def _to_py_deprecated(self):
    return self

class A:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('A')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.A, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.A, self)

  def _to_py_deprecated(self):
    return self

class Config:
  """
  Attributes:
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Config')
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path.encode('utf-8')) if UTF8STRINGS and not isinstance(self.path, bytes) else oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'path' in json_obj and json_obj['path'] is not None:
      self.path = json_obj['path']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'path',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Config, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Config, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  """
  Attributes:
   - field
   - set_string
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.set_string = set()
          (_etype158, _size155) = iprot.readSetBegin()
          if _size155 >= 0:
            for _i159 in range(_size155):
              _elem160 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem160)
          else: 
            while iprot.peekSet():
              _elem161 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem161)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.set_string != None:
      oprot.writeFieldBegin('set_string', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.set_string))
      for iter162 in self.set_string:
        oprot.writeString(iter162.encode('utf-8')) if UTF8STRINGS and not isinstance(iter162, bytes) else oprot.writeString(iter162)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'set_string' in json_obj and json_obj['set_string'] is not None:
      self.set_string = set_cls()
      for _tmp_e163 in json_obj['set_string']:
        self.set_string.add(_tmp_e163)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.set_string is not None:
      value = pprint.pformat(self.set_string, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_string=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'set_string',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

SetWithAdapter = UnimplementedTypedef()
StringWithAdapter = UnimplementedTypedef()
ListWithElemAdapter = UnimplementedTypedef()
ListWithElemAdapter_withAdapter = ListWithElemAdapter
MyI64 = UnimplementedTypedef()
DoubleTypedefI64 = MyI64
MyI32 = UnimplementedTypedef()
FooWithAdapter = Foo
StructWithAdapter = my.Adapter2.Type
UnionWithAdapter = my.Adapter2.Type
AdaptedA = A
all_structs.append(MyAnnotation)
MyAnnotation.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'signature', True, None, 2, ), # 1
)

MyAnnotation.thrift_struct_annotations = {
}
MyAnnotation.thrift_field_annotations = {
}

def MyAnnotation__init__(self, signature=None,):
  self.signature = signature

MyAnnotation.__init__ = MyAnnotation__init__

def MyAnnotation__setstate__(self, state):
  state.setdefault('signature', None)
  self.__dict__ = state

MyAnnotation.__getstate__ = lambda self: self.__dict__.copy()
MyAnnotation.__setstate__ = MyAnnotation__setstate__

all_structs.append(Foo)
Foo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (2, TType.I32, 'optionalIntField', None, None, 1, ), # 2
  (3, TType.I32, 'intFieldWithDefault', None, 13, 2, ), # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (5, TType.SET, 'optionalSetField', (TType.STRING,True), None, 1, ), # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (7, TType.MAP, 'optionalMapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 1, ), # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
  (10, TType.I64, 'adaptedLongField', None, None, 2, ), # 10
  (11, TType.I64, 'doubleAdaptedField', None, None, 2, ), # 11
)

Foo.thrift_struct_annotations = {
  "thrift.uri": "facebook.com/thrift/compiler/test/fixtures/adapter/src/module/Foo",
}
Foo.thrift_field_annotations = {
}

def Foo__init__(self, intField=None, optionalIntField=None, intFieldWithDefault=Foo.thrift_spec[3][4], setField=None, optionalSetField=None, mapField=None, optionalMapField=None, binaryField=None, longField=None, adaptedLongField=None, doubleAdaptedField=None,):
  self.intField = intField
  self.optionalIntField = optionalIntField
  self.intFieldWithDefault = intFieldWithDefault
  self.setField = setField
  self.optionalSetField = optionalSetField
  self.mapField = mapField
  self.optionalMapField = optionalMapField
  self.binaryField = binaryField
  self.longField = longField
  self.adaptedLongField = adaptedLongField
  self.doubleAdaptedField = doubleAdaptedField

Foo.__init__ = Foo__init__

def Foo__setstate__(self, state):
  state.setdefault('intField', None)
  state.setdefault('optionalIntField', None)
  state.setdefault('intFieldWithDefault', 13)
  state.setdefault('setField', None)
  state.setdefault('optionalSetField', None)
  state.setdefault('mapField', None)
  state.setdefault('optionalMapField', None)
  state.setdefault('binaryField', None)
  state.setdefault('longField', None)
  state.setdefault('adaptedLongField', None)
  state.setdefault('doubleAdaptedField', None)
  self.__dict__ = state

Foo.__getstate__ = lambda self: self.__dict__.copy()
Foo.__setstate__ = Foo__setstate__

all_structs.append(Baz)
Baz.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  None, # 2
  None, # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  None, # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  None, # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
)

Baz.thrift_struct_annotations = {
}
Baz.thrift_field_annotations = {
}

def Baz__init__(self, intField=None, setField=None, mapField=None, binaryField=None, longField=None,):
  self.field = 0
  self.value = None
  if intField is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = intField
  if setField is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = setField
  if mapField is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = mapField
  if binaryField is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = binaryField
  if longField is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = longField

Baz.__init__ = Baz__init__

all_structs.append(Bar)
Bar.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'structField', [Foo, Foo.thrift_spec, False, ::my.Adapter1], None, 2, ), # 1
  (2, TType.STRUCT, 'optionalStructField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 1, ), # 2
  (3, TType.LIST, 'structListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 2, ), # 3
  (4, TType.LIST, 'optionalStructListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 1, ), # 4
  (5, TType.STRUCT, 'unionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 2, ), # 5
  (6, TType.STRUCT, 'optionalUnionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 1, ), # 6
  (7, TType.STRUCT, 'adaptedStructField', [DirectlyAdapted, DirectlyAdapted.thrift_spec, False], None, 2, ), # 7
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, structField=None, optionalStructField=None, structListField=None, optionalStructListField=None, unionField=None, optionalUnionField=None, adaptedStructField=None,):
  self.structField = structField
  self.optionalStructField = optionalStructField
  self.structListField = structListField
  self.optionalStructListField = optionalStructListField
  self.unionField = unionField
  self.optionalUnionField = optionalUnionField
  self.adaptedStructField = adaptedStructField

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('structField', None)
  state.setdefault('optionalStructField', None)
  state.setdefault('structListField', None)
  state.setdefault('optionalStructListField', None)
  state.setdefault('unionField', None)
  state.setdefault('optionalUnionField', None)
  state.setdefault('adaptedStructField', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(DirectlyAdapted)
DirectlyAdapted.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
)

DirectlyAdapted.thrift_struct_annotations = {
}
DirectlyAdapted.thrift_field_annotations = {
}

def DirectlyAdapted__init__(self, field=None,):
  self.field = field

DirectlyAdapted.__init__ = DirectlyAdapted__init__

def DirectlyAdapted__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

DirectlyAdapted.__getstate__ = lambda self: self.__dict__.copy()
DirectlyAdapted.__setstate__ = DirectlyAdapted__setstate__

all_structs.append(StructWithFieldAdapter)
StructWithFieldAdapter.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.I32, 'shared_field', None, None, 2, ), # 2
  (3, TType.I32, 'opt_shared_field', None, None, 1, ), # 3
  (4, TType.I32, 'opt_boxed_field', None, None, 1, ), # 4
)

StructWithFieldAdapter.thrift_struct_annotations = {
}
StructWithFieldAdapter.thrift_field_annotations = {
}

def StructWithFieldAdapter__init__(self, field=None, shared_field=None, opt_shared_field=None, opt_boxed_field=None,):
  self.field = field
  self.shared_field = shared_field
  self.opt_shared_field = opt_shared_field
  self.opt_boxed_field = opt_boxed_field

StructWithFieldAdapter.__init__ = StructWithFieldAdapter__init__

def StructWithFieldAdapter__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('shared_field', None)
  state.setdefault('opt_shared_field', None)
  state.setdefault('opt_boxed_field', None)
  self.__dict__ = state

StructWithFieldAdapter.__getstate__ = lambda self: self.__dict__.copy()
StructWithFieldAdapter.__setstate__ = StructWithFieldAdapter__setstate__

all_structs.append(TerseAdaptedFields)
TerseAdaptedFields.thrift_spec = (
  None, # 0
  (1, TType.I32, 'int_field', None, None, 3, ), # 1
  (2, TType.STRING, 'string_field', True, None, 3, ), # 2
  (3, TType.SET, 'set_field', (TType.I32,None), None, 3, ), # 3
)

TerseAdaptedFields.thrift_struct_annotations = {
}
TerseAdaptedFields.thrift_field_annotations = {
}

def TerseAdaptedFields__init__(self, int_field=None, string_field=None, set_field=None,):
  self.int_field = int_field
  self.string_field = string_field
  self.set_field = set_field

TerseAdaptedFields.__init__ = TerseAdaptedFields__init__

def TerseAdaptedFields__setstate__(self, state):
  state.setdefault('int_field', None)
  state.setdefault('string_field', None)
  state.setdefault('set_field', None)
  self.__dict__ = state

TerseAdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
TerseAdaptedFields.__setstate__ = TerseAdaptedFields__setstate__

all_structs.append(B)
B.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'a', [A, A.thrift_spec, False], None, 2, ), # 1
)

B.thrift_struct_annotations = {
}
B.thrift_field_annotations = {
}

def B__init__(self, a=None,):
  self.a = a

B.__init__ = B__init__

def B__setstate__(self, state):
  state.setdefault('a', None)
  self.__dict__ = state

B.__getstate__ = lambda self: self.__dict__.copy()
B.__setstate__ = B__setstate__

all_structs.append(A)
A.thrift_spec = (
)

A.thrift_struct_annotations = {
}
A.thrift_field_annotations = {
}

all_structs.append(Config)
Config.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'path', True, None, 2, ), # 1
)

Config.thrift_struct_annotations = {
}
Config.thrift_field_annotations = {
}

def Config__init__(self, path=None,):
  self.path = path

Config.__init__ = Config__init__

def Config__setstate__(self, state):
  state.setdefault('path', None)
  self.__dict__ = state

Config.__getstate__ = lambda self: self.__dict__.copy()
Config.__setstate__ = Config__setstate__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.SET, 'set_string', (TType.STRING,True), None, 2, ), # 2
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, field=None, set_string=None,):
  self.field = field
  self.set_string = set_string

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('set_string', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

fix_spec(all_structs)
del all_structs
