#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.lib.thrift.patch.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyEnum', 'MyData', 'MyDataWithCustomDefault', 'InnerUnion', 'MyUnion', 'MyStruct', 'LateDefStruct', 'Recursive', 'Bar', 'Loop', 'MyDataPatch', 'MyDataFieldPatch', 'MyDataEnsureStruct', 'MyDataWithCustomDefaultPatch', 'MyDataWithCustomDefaultFieldPatch', 'MyDataWithCustomDefaultEnsureStruct', 'InnerUnionPatch', 'InnerUnionFieldPatch', 'MyUnionPatch', 'MyUnionFieldPatch', 'MyStructPatch', 'MyStructField10Patch', 'MyStructField23Patch', 'MyStructField26Patch', 'MyStructField27Patch', 'MyStructField28Patch', 'MyStructField29Patch', 'MyStructField29Patch1', 'MyStructField30Patch', 'MyStructField30Patch1', 'MyStructFieldPatch', 'MyStructEnsureStruct', 'LateDefStructPatch', 'LateDefStructFieldPatch', 'LateDefStructEnsureStruct', 'RecursivePatch', 'RecursiveField1Patch', 'RecursiveFieldPatch', 'RecursiveEnsureStruct', 'BarPatch', 'BarFieldPatch', 'BarEnsureStruct', 'LoopPatch']

class MyEnum:
  MyValue0 = 0

  _VALUES_TO_NAMES = {
    0: "MyValue0",
  }

  _NAMES_TO_VALUES = {
    "MyValue0": 0,
  }

class MyData:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyData')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyData, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyData, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefault:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefault')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefault, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefault, self)

  def _to_py_deprecated(self):
    return self

class InnerUnion(object):
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INNEROPTION = 1
  
  @staticmethod
  def isUnion():
    return True

  def get_innerOption(self):
    assert self.field == 1
    return self.value

  def set_innerOption(self, value):
    self.field = 1
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('innerOption', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_innerOption = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_innerOption(_fbthrift_innerOption)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('InnerUnion')
    if self.field == 1:
      oprot.writeFieldBegin('innerOption', TType.STRING, 1)
      innerOption = self.value
      oprot.writeString(innerOption)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'innerOption' in obj:
      _fbthrift_innerOption = obj['innerOption']
      self.set_innerOption(_fbthrift_innerOption)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnion, self)

  def _to_py_deprecated(self):
    return self

class MyUnion(object):
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  OPTION1 = 1
  OPTION2 = 2
  OPTION3 = 3
  
  @staticmethod
  def isUnion():
    return True

  def get_option1(self):
    assert self.field == 1
    return self.value

  def get_option2(self):
    assert self.field == 2
    return self.value

  def get_option3(self):
    assert self.field == 3
    return self.value

  def set_option1(self, value):
    self.field = 1
    self.value = value

  def set_option2(self, value):
    self.field = 2
    self.value = value

  def set_option3(self, value):
    self.field = 3
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option1', value)
    if self.field == 2:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option2', value)
    if self.field == 3:
      padding = ' ' * 8
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('option3', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.STRING:
          _fbthrift_option1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_option1(_fbthrift_option1)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          _fbthrift_option2 = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_option2(_fbthrift_option2)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          _fbthrift_option3 = InnerUnion()
          _fbthrift_option3.read(iprot)
          assert self.field == 0 and self.value is None
          self.set_option3(_fbthrift_option3)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('MyUnion')
    if self.field == 1:
      oprot.writeFieldBegin('option1', TType.STRING, 1)
      option1 = self.value
      oprot.writeString(option1.encode('utf-8')) if UTF8STRINGS and not isinstance(option1, bytes) else oprot.writeString(option1)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('option2', TType.I32, 2)
      option2 = self.value
      oprot.writeI32(option2)
      oprot.writeFieldEnd()
    if self.field == 3:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      option3 = self.value
      option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'option1' in obj:
      _fbthrift_option1 = obj['option1']
      self.set_option1(_fbthrift_option1)
    if 'option2' in obj:
      _fbthrift_option2 = obj['option2']
      if _fbthrift_option2 > 0x7fffffff or _fbthrift_option2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_option2(_fbthrift_option2)
    if 'option3' in obj:
      _fbthrift_option3 = InnerUnion()
      _fbthrift_option3.readFromJson(obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
      self.set_option3(_fbthrift_option3)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnion, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - boolVal
   - byteVal
   - i16Val
   - i32Val
   - i64Val
   - floatVal
   - doubleVal
   - stringVal
   - binaryVal
   - enumVal
   - structVal
   - unionVal
   - lateStructVal
   - optBoolVal
   - optByteVal
   - optI16Val
   - optI32Val
   - optI64Val
   - optFloatVal
   - optDoubleVal
   - optStringVal
   - optBinaryVal
   - optEnumVal
   - optStructVal
   - optLateStructVal
   - optListVal
   - optSetVal
   - optMapVal
   - listMap
   - mapMap
   - i32WithCustomDefault
   - structWithCustomDefault
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readI16()
              self.optListVal.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = iprot.readI16()
              self.optListVal.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key21 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val22 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype26, _size23) = iprot.readListBegin()
          if _size23 >= 0:
            for _i27 in range(_size23):
              _elem28 = {}
              (_ktype30, _vtype31, _size29 ) = iprot.readMapBegin() 
              if _size29 >= 0:
                for _i33 in range(_size29):
                  _key34 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val35 = iprot.readI32()
                  _elem28[_key34] = _val35
              else: 
                while iprot.peekMap():
                  _key36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val37 = iprot.readI32()
                  _elem28[_key36] = _val37
              iprot.readMapEnd()
              self.listMap.append(_elem28)
          else: 
            while iprot.peekList():
              _elem38 = {}
              (_ktype40, _vtype41, _size39 ) = iprot.readMapBegin() 
              if _size39 >= 0:
                for _i43 in range(_size39):
                  _key44 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val45 = iprot.readI32()
                  _elem38[_key44] = _val45
              else: 
                while iprot.peekMap():
                  _key46 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val47 = iprot.readI32()
                  _elem38[_key46] = _val47
              iprot.readMapEnd()
              self.listMap.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = {}
              (_ktype56, _vtype57, _size55 ) = iprot.readMapBegin() 
              if _size55 >= 0:
                for _i59 in range(_size55):
                  _key60 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val61 = iprot.readI32()
                  _val54[_key60] = _val61
              else: 
                while iprot.peekMap():
                  _key62 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val63 = iprot.readI32()
                  _val54[_key62] = _val63
              iprot.readMapEnd()
              self.mapMap[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key64 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val65 = {}
              (_ktype67, _vtype68, _size66 ) = iprot.readMapBegin() 
              if _size66 >= 0:
                for _i70 in range(_size66):
                  _key71 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val72 = iprot.readI32()
                  _val65[_key71] = _val72
              else: 
                while iprot.peekMap():
                  _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val74 = iprot.readI32()
                  _val65[_key73] = _val74
              iprot.readMapEnd()
              self.mapMap[_key64] = _val65
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.I32:
          self.i32WithCustomDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefault()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyData()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.I32, -31)
      oprot.writeI32(self.i32WithCustomDefault)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter75,viter76 in self.mapMap.items():
        oprot.writeString(kiter75.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter75, bytes) else oprot.writeString(kiter75)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter76))
        for kiter77,viter78 in viter76.items():
          oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
          oprot.writeI32(viter78)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter79 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter79))
        for kiter80,viter81 in iter79.items():
          oprot.writeString(kiter80.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter80, bytes) else oprot.writeString(kiter80)
          oprot.writeI32(viter81)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter82,viter83 in self.optMapVal.items():
        oprot.writeString(kiter82.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter82, bytes) else oprot.writeString(kiter82)
        oprot.writeString(viter83.encode('utf-8')) if UTF8STRINGS and not isinstance(viter83, bytes) else oprot.writeString(viter83)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter84 in self.optSetVal:
        oprot.writeString(iter84.encode('utf-8')) if UTF8STRINGS and not isinstance(iter84, bytes) else oprot.writeString(iter84)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter85 in self.optListVal:
        oprot.writeI16(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e86 in json_obj['optListVal']:
        if _tmp_e86 > 0x7fff or _tmp_e86 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e86)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e87 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e87)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k88, _tmp_v89 in json_obj['optMapVal'].items():
        _tmp_kp90 = _tmp_k88
        self.optMapVal[_tmp_kp90] = _tmp_v89
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e91 in json_obj['listMap']:
        _map92 = dict_cls()
        for _tmp_k93, _tmp_v94 in _tmp_e91.items():
          _tmp_kp95 = _tmp_k93
          if _tmp_v94 > 0x7fffffff or _tmp_v94 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map92[_tmp_kp95] = _tmp_v94
        self.listMap.append(_map92)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k96, _tmp_v97 in json_obj['mapMap'].items():
        _tmp_kp98 = _tmp_k96
        _map99 = dict_cls()
        for _tmp_k100, _tmp_v101 in _tmp_v97.items():
          _tmp_kp102 = _tmp_k100
          if _tmp_v101 > 0x7fffffff or _tmp_v101 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map99[_tmp_kp102] = _tmp_v101
        self.mapMap[_tmp_kp98] = _map99
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = json_obj['i32WithCustomDefault']
      if self.i32WithCustomDefault > 0x7fffffff or self.i32WithCustomDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefault()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyData()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStruct, self)

  def _to_py_deprecated(self):
    return self

class Recursive:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype104, _vtype105, _size103 ) = iprot.readMapBegin() 
          if _size103 >= 0:
            for _i107 in range(_size103):
              _key108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val109 = Recursive()
              _val109.read(iprot)
              self.nodes[_key108] = _val109
          else: 
            while iprot.peekMap():
              _key110 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val111 = Recursive()
              _val111.read(iprot)
              self.nodes[_key110] = _val111
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Recursive')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter112,viter113 in self.nodes.items():
        oprot.writeString(kiter112.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter112, bytes) else oprot.writeString(kiter112)
        viter113.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k114, _tmp_v115 in json_obj['nodes'].items():
        _tmp_kp116 = _tmp_k114
        _struct117 = Recursive()
        _struct117.readFromJson(_tmp_v115, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp116] = _struct117

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Recursive, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Recursive, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class Loop:
  r"""
  Attributes:
   - bar
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.bar = Bar()
          self.bar.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Loop')
    if self.bar != None:
      oprot.writeFieldBegin('bar', TType.STRUCT, -1)
      self.bar.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'bar' in json_obj and json_obj['bar'] is not None:
      self.bar = Bar()
      self.bar.readFromJson(json_obj['bar'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.bar is not None:
      value = pprint.pformat(self.bar, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    bar=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'bar',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Loop, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Loop, self)

  def _to_py_deprecated(self):
    return self

class MyDataPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyData()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyDataEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyData()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyDataEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataFieldPatch:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataEnsureStruct:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataEnsureStruct')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyDataWithCustomDefault()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyDataWithCustomDefaultFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyDataWithCustomDefaultEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyDataWithCustomDefaultFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyDataWithCustomDefault()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyDataWithCustomDefaultFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyDataWithCustomDefaultEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyDataWithCustomDefaultFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultFieldPatch:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.data1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.data2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultFieldPatch')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRUCT, 1)
      self.data1.write(oprot)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.STRUCT, 2)
      self.data2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.data1.readFromJson(json_obj['data1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.data2.readFromJson(json_obj['data2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyDataWithCustomDefaultEnsureStruct:
  r"""
  Attributes:
   - data1
   - data2
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.data1 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.data2 = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyDataWithCustomDefaultEnsureStruct')
    if self.data1 != None:
      oprot.writeFieldBegin('data1', TType.STRING, 1)
      oprot.writeString(self.data1.encode('utf-8')) if UTF8STRINGS and not isinstance(self.data1, bytes) else oprot.writeString(self.data1)
      oprot.writeFieldEnd()
    if self.data2 != None:
      oprot.writeFieldBegin('data2', TType.I32, 2)
      oprot.writeI32(self.data2)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data1' in json_obj and json_obj['data1'] is not None:
      self.data1 = json_obj['data1']
    if 'data2' in json_obj and json_obj['data2'] is not None:
      self.data2 = json_obj['data2']
      if self.data2 > 0x7fffffff or self.data2 < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data1 is not None:
      value = pprint.pformat(self.data1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data1=%s' % (value))
    if self.data2 is not None:
      value = pprint.pformat(self.data2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data2=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data1',
      'data2',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyDataWithCustomDefaultEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyDataWithCustomDefaultEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = InnerUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = InnerUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = InnerUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = InnerUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = InnerUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = InnerUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = InnerUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = InnerUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class InnerUnionFieldPatch:
  r"""
  Attributes:
   - innerOption
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.innerOption.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InnerUnionFieldPatch')
    if self.innerOption != None:
      oprot.writeFieldBegin('innerOption', TType.STRUCT, 1)
      self.innerOption.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'innerOption' in json_obj and json_obj['innerOption'] is not None:
      self.innerOption = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.innerOption.readFromJson(json_obj['innerOption'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.innerOption is not None:
      value = pprint.pformat(self.innerOption, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    innerOption=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'innerOption',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.InnerUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.InnerUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears any set value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Assigns the value, if not already set to the same field. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyUnion()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyUnionFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ensure = MyUnion()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyUnionFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 4)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyUnion()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyUnionFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyUnion()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyUnionFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionPatch, self)

  def _to_py_deprecated(self):
    return self

class MyUnionFieldPatch:
  r"""
  Attributes:
   - option1
   - option2
   - option3
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.option1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.option2.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.option3 = InnerUnionPatch()
          self.option3.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyUnionFieldPatch')
    if self.option1 != None:
      oprot.writeFieldBegin('option1', TType.STRUCT, 1)
      self.option1.write(oprot)
      oprot.writeFieldEnd()
    if self.option2 != None:
      oprot.writeFieldBegin('option2', TType.STRUCT, 2)
      self.option2.write(oprot)
      oprot.writeFieldEnd()
    if self.option3 != None:
      oprot.writeFieldBegin('option3', TType.STRUCT, 3)
      self.option3.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'option1' in json_obj and json_obj['option1'] is not None:
      self.option1 = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.option1.readFromJson(json_obj['option1'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option2' in json_obj and json_obj['option2'] is not None:
      self.option2 = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.option2.readFromJson(json_obj['option2'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'option3' in json_obj and json_obj['option3'] is not None:
      self.option3 = InnerUnionPatch()
      self.option3.readFromJson(json_obj['option3'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.option1 is not None:
      value = pprint.pformat(self.option1, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option1=%s' % (value))
    if self.option2 is not None:
      value = pprint.pformat(self.option2, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option2=%s' % (value))
    if self.option3 is not None:
      value = pprint.pformat(self.option3, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    option3=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'option1',
      'option2',
      'option3',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyUnionFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyUnionFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = MyStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = MyStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = MyStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = MyStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = MyStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = MyStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = MyStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = MyStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField10Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField10Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField10Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField10Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField23Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField23Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if not self.assign in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.assign
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField23Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField23Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField26Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - remove: Removes entries, if present. Applies third.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype121, _size118) = iprot.readListBegin()
          if _size118 >= 0:
            for _i122 in range(_size118):
              _elem123 = iprot.readI16()
              self.assign.append(_elem123)
          else: 
            while iprot.peekList():
              _elem124 = iprot.readI16()
              self.assign.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype126, _vtype127, _size125 ) = iprot.readMapBegin() 
          if _size125 >= 0:
            for _i129 in range(_size125):
              _key130 = iprot.readI32()
              _val131 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val131.read(iprot)
              self.patch[_key130] = _val131
          else: 
            while iprot.peekMap():
              _key132 = iprot.readI32()
              _val133 = thrift.lib.thrift.patch.ttypes.I16Patch()
              _val133.read(iprot)
              self.patch[_key132] = _val133
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.remove = []
          (_etype137, _size134) = iprot.readListBegin()
          if _size134 >= 0:
            for _i138 in range(_size134):
              _elem139 = iprot.readI16()
              self.remove.append(_elem139)
          else: 
            while iprot.peekList():
              _elem140 = iprot.readI16()
              self.remove.append(_elem140)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype144, _size141) = iprot.readListBegin()
          if _size141 >= 0:
            for _i145 in range(_size141):
              _elem146 = iprot.readI16()
              self.prepend.append(_elem146)
          else: 
            while iprot.peekList():
              _elem147 = iprot.readI16()
              self.prepend.append(_elem147)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype151, _size148) = iprot.readListBegin()
          if _size148 >= 0:
            for _i152 in range(_size148):
              _elem153 = iprot.readI16()
              self.append.append(_elem153)
          else: 
            while iprot.peekList():
              _elem154 = iprot.readI16()
              self.append.append(_elem154)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField26Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.I16, len(self.assign))
      for iter155 in self.assign:
        oprot.writeI16(iter155)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter156,viter157 in self.patch.items():
        oprot.writeI32(kiter156)
        viter157.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.LIST, 7)
      oprot.writeListBegin(TType.I16, len(self.remove))
      for iter158 in self.remove:
        oprot.writeI16(iter158)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.I16, len(self.prepend))
      for iter159 in self.prepend:
        oprot.writeI16(iter159)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.I16, len(self.append))
      for iter160 in self.append:
        oprot.writeI16(iter160)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e161 in json_obj['assign']:
        if _tmp_e161 > 0x7fff or _tmp_e161 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign.append(_tmp_e161)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k162, _tmp_v163 in json_obj['patch'].items():
        _tmp_kp164 = int(_tmp_k162)
        if _tmp_kp164 > 0x7fffffff or _tmp_kp164 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k162)
        _struct165 = thrift.lib.thrift.patch.ttypes.I16Patch()
        _struct165.readFromJson(_tmp_v163, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp164] = _struct165
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = []
      for _tmp_e166 in json_obj['remove']:
        if _tmp_e166 > 0x7fff or _tmp_e166 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.remove.append(_tmp_e166)
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e167 in json_obj['prepend']:
        if _tmp_e167 > 0x7fff or _tmp_e167 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.prepend.append(_tmp_e167)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e168 in json_obj['append']:
        if _tmp_e168 > 0x7fff or _tmp_e168 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.append.append(_tmp_e168)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'remove',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField26Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField26Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField27Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - remove: Removes entries, if present. Applies third.
   - add: Adds entries, if not already present. Applies fourth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.assign = set()
          (_etype172, _size169) = iprot.readSetBegin()
          if _size169 >= 0:
            for _i173 in range(_size169):
              _elem174 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem174)
          else: 
            while iprot.peekSet():
              _elem175 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign.add(_elem175)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype179, _size176) = iprot.readSetBegin()
          if _size176 >= 0:
            for _i180 in range(_size176):
              _elem181 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem181)
          else: 
            while iprot.peekSet():
              _elem182 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem182)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.SET:
          self.add = set()
          (_etype186, _size183) = iprot.readSetBegin()
          if _size183 >= 0:
            for _i187 in range(_size183):
              _elem188 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem188)
          else: 
            while iprot.peekSet():
              _elem189 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add.add(_elem189)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField27Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.SET, 1)
      oprot.writeSetBegin(TType.STRING, len(self.assign))
      for iter190 in self.assign:
        oprot.writeString(iter190.encode('utf-8')) if UTF8STRINGS and not isinstance(iter190, bytes) else oprot.writeString(iter190)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter191 in self.remove:
        oprot.writeString(iter191.encode('utf-8')) if UTF8STRINGS and not isinstance(iter191, bytes) else oprot.writeString(iter191)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.SET, 8)
      oprot.writeSetBegin(TType.STRING, len(self.add))
      for iter192 in self.add:
        oprot.writeString(iter192.encode('utf-8')) if UTF8STRINGS and not isinstance(iter192, bytes) else oprot.writeString(iter192)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = set_cls()
      for _tmp_e193 in json_obj['assign']:
        self.assign.add(_tmp_e193)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e194 in json_obj['remove']:
        self.remove.add(_tmp_e194)
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = set_cls()
      for _tmp_e195 in json_obj['add']:
        self.add.add(_tmp_e195)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'remove',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField27Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField27Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField28Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype197, _vtype198, _size196 ) = iprot.readMapBegin() 
          if _size196 >= 0:
            for _i200 in range(_size196):
              _key201 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val202 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key201] = _val202
          else: 
            while iprot.peekMap():
              _key203 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val204 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.assign[_key203] = _val204
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype206, _vtype207, _size205 ) = iprot.readMapBegin() 
          if _size205 >= 0:
            for _i209 in range(_size205):
              _key210 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val211 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val211.read(iprot)
              self.patchPrior[_key210] = _val211
          else: 
            while iprot.peekMap():
              _key212 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val213 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val213.read(iprot)
              self.patchPrior[_key212] = _val213
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype215, _vtype216, _size214 ) = iprot.readMapBegin() 
          if _size214 >= 0:
            for _i218 in range(_size214):
              _key219 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val220 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key219] = _val220
          else: 
            while iprot.peekMap():
              _key221 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val222 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.add[_key221] = _val222
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype224, _vtype225, _size223 ) = iprot.readMapBegin() 
          if _size223 >= 0:
            for _i227 in range(_size223):
              _key228 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val229 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val229.read(iprot)
              self.patch[_key228] = _val229
          else: 
            while iprot.peekMap():
              _key230 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val231 = thrift.lib.thrift.patch.ttypes.StringPatch()
              _val231.read(iprot)
              self.patch[_key230] = _val231
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype235, _size232) = iprot.readSetBegin()
          if _size232 >= 0:
            for _i236 in range(_size232):
              _elem237 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem237)
          else: 
            while iprot.peekSet():
              _elem238 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem238)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype240, _vtype241, _size239 ) = iprot.readMapBegin() 
          if _size239 >= 0:
            for _i243 in range(_size239):
              _key244 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val245 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key244] = _val245
          else: 
            while iprot.peekMap():
              _key246 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val247 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.put[_key246] = _val247
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField28Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.assign))
      for kiter248,viter249 in self.assign.items():
        oprot.writeString(kiter248.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter248, bytes) else oprot.writeString(kiter248)
        oprot.writeString(viter249.encode('utf-8')) if UTF8STRINGS and not isinstance(viter249, bytes) else oprot.writeString(viter249)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter250,viter251 in self.patchPrior.items():
        oprot.writeString(kiter250.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter250, bytes) else oprot.writeString(kiter250)
        viter251.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.add))
      for kiter252,viter253 in self.add.items():
        oprot.writeString(kiter252.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter252, bytes) else oprot.writeString(kiter252)
        oprot.writeString(viter253.encode('utf-8')) if UTF8STRINGS and not isinstance(viter253, bytes) else oprot.writeString(viter253)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter254,viter255 in self.patch.items():
        oprot.writeString(kiter254.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter254, bytes) else oprot.writeString(kiter254)
        viter255.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter256 in self.remove:
        oprot.writeString(iter256.encode('utf-8')) if UTF8STRINGS and not isinstance(iter256, bytes) else oprot.writeString(iter256)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.put))
      for kiter257,viter258 in self.put.items():
        oprot.writeString(kiter257.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter257, bytes) else oprot.writeString(kiter257)
        oprot.writeString(viter258.encode('utf-8')) if UTF8STRINGS and not isinstance(viter258, bytes) else oprot.writeString(viter258)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k259, _tmp_v260 in json_obj['assign'].items():
        _tmp_kp261 = _tmp_k259
        self.assign[_tmp_kp261] = _tmp_v260
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k262, _tmp_v263 in json_obj['patchPrior'].items():
        _tmp_kp264 = _tmp_k262
        _struct265 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct265.readFromJson(_tmp_v263, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp264] = _struct265
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k266, _tmp_v267 in json_obj['add'].items():
        _tmp_kp268 = _tmp_k266
        self.add[_tmp_kp268] = _tmp_v267
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k269, _tmp_v270 in json_obj['patch'].items():
        _tmp_kp271 = _tmp_k269
        _struct272 = thrift.lib.thrift.patch.ttypes.StringPatch()
        _struct272.readFromJson(_tmp_v270, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp271] = _struct272
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e273 in json_obj['remove']:
        self.remove.add(_tmp_e273)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k274, _tmp_v275 in json_obj['put'].items():
        _tmp_kp276 = _tmp_k274
        self.put[_tmp_kp276] = _tmp_v275

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField28Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField28Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patch: Patches list values by index. Applies second.
   - remove: Removes entries, if present. Applies third.
   - prepend: Prepends to the front of a given list.
   - append: Appends to the back of a given list.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.assign = []
          (_etype280, _size277) = iprot.readListBegin()
          if _size277 >= 0:
            for _i281 in range(_size277):
              _elem282 = {}
              (_ktype284, _vtype285, _size283 ) = iprot.readMapBegin() 
              if _size283 >= 0:
                for _i287 in range(_size283):
                  _key288 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val289 = iprot.readI32()
                  _elem282[_key288] = _val289
              else: 
                while iprot.peekMap():
                  _key290 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val291 = iprot.readI32()
                  _elem282[_key290] = _val291
              iprot.readMapEnd()
              self.assign.append(_elem282)
          else: 
            while iprot.peekList():
              _elem292 = {}
              (_ktype294, _vtype295, _size293 ) = iprot.readMapBegin() 
              if _size293 >= 0:
                for _i297 in range(_size293):
                  _key298 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val299 = iprot.readI32()
                  _elem292[_key298] = _val299
              else: 
                while iprot.peekMap():
                  _key300 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val301 = iprot.readI32()
                  _elem292[_key300] = _val301
              iprot.readMapEnd()
              self.assign.append(_elem292)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype303, _vtype304, _size302 ) = iprot.readMapBegin() 
          if _size302 >= 0:
            for _i306 in range(_size302):
              _key307 = iprot.readI32()
              _val308 = MyStructField29Patch1()
              _val308.read(iprot)
              self.patch[_key307] = _val308
          else: 
            while iprot.peekMap():
              _key309 = iprot.readI32()
              _val310 = MyStructField29Patch1()
              _val310.read(iprot)
              self.patch[_key309] = _val310
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.remove = []
          (_etype314, _size311) = iprot.readListBegin()
          if _size311 >= 0:
            for _i315 in range(_size311):
              _elem316 = {}
              (_ktype318, _vtype319, _size317 ) = iprot.readMapBegin() 
              if _size317 >= 0:
                for _i321 in range(_size317):
                  _key322 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val323 = iprot.readI32()
                  _elem316[_key322] = _val323
              else: 
                while iprot.peekMap():
                  _key324 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val325 = iprot.readI32()
                  _elem316[_key324] = _val325
              iprot.readMapEnd()
              self.remove.append(_elem316)
          else: 
            while iprot.peekList():
              _elem326 = {}
              (_ktype328, _vtype329, _size327 ) = iprot.readMapBegin() 
              if _size327 >= 0:
                for _i331 in range(_size327):
                  _key332 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val333 = iprot.readI32()
                  _elem326[_key332] = _val333
              else: 
                while iprot.peekMap():
                  _key334 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val335 = iprot.readI32()
                  _elem326[_key334] = _val335
              iprot.readMapEnd()
              self.remove.append(_elem326)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.prepend = []
          (_etype339, _size336) = iprot.readListBegin()
          if _size336 >= 0:
            for _i340 in range(_size336):
              _elem341 = {}
              (_ktype343, _vtype344, _size342 ) = iprot.readMapBegin() 
              if _size342 >= 0:
                for _i346 in range(_size342):
                  _key347 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val348 = iprot.readI32()
                  _elem341[_key347] = _val348
              else: 
                while iprot.peekMap():
                  _key349 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val350 = iprot.readI32()
                  _elem341[_key349] = _val350
              iprot.readMapEnd()
              self.prepend.append(_elem341)
          else: 
            while iprot.peekList():
              _elem351 = {}
              (_ktype353, _vtype354, _size352 ) = iprot.readMapBegin() 
              if _size352 >= 0:
                for _i356 in range(_size352):
                  _key357 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val358 = iprot.readI32()
                  _elem351[_key357] = _val358
              else: 
                while iprot.peekMap():
                  _key359 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val360 = iprot.readI32()
                  _elem351[_key359] = _val360
              iprot.readMapEnd()
              self.prepend.append(_elem351)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.LIST:
          self.append = []
          (_etype364, _size361) = iprot.readListBegin()
          if _size361 >= 0:
            for _i365 in range(_size361):
              _elem366 = {}
              (_ktype368, _vtype369, _size367 ) = iprot.readMapBegin() 
              if _size367 >= 0:
                for _i371 in range(_size367):
                  _key372 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val373 = iprot.readI32()
                  _elem366[_key372] = _val373
              else: 
                while iprot.peekMap():
                  _key374 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val375 = iprot.readI32()
                  _elem366[_key374] = _val375
              iprot.readMapEnd()
              self.append.append(_elem366)
          else: 
            while iprot.peekList():
              _elem376 = {}
              (_ktype378, _vtype379, _size377 ) = iprot.readMapBegin() 
              if _size377 >= 0:
                for _i381 in range(_size377):
                  _key382 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val383 = iprot.readI32()
                  _elem376[_key382] = _val383
              else: 
                while iprot.peekMap():
                  _key384 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val385 = iprot.readI32()
                  _elem376[_key384] = _val385
              iprot.readMapEnd()
              self.append.append(_elem376)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.LIST, 1)
      oprot.writeListBegin(TType.MAP, len(self.assign))
      for iter386 in self.assign:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter386))
        for kiter387,viter388 in iter386.items():
          oprot.writeString(kiter387.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter387, bytes) else oprot.writeString(kiter387)
          oprot.writeI32(viter388)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.patch))
      for kiter389,viter390 in self.patch.items():
        oprot.writeI32(kiter389)
        viter390.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.LIST, 7)
      oprot.writeListBegin(TType.MAP, len(self.remove))
      for iter391 in self.remove:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter391))
        for kiter392,viter393 in iter391.items():
          oprot.writeString(kiter392.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter392, bytes) else oprot.writeString(kiter392)
          oprot.writeI32(viter393)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.LIST, 8)
      oprot.writeListBegin(TType.MAP, len(self.prepend))
      for iter394 in self.prepend:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter394))
        for kiter395,viter396 in iter394.items():
          oprot.writeString(kiter395.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter395, bytes) else oprot.writeString(kiter395)
          oprot.writeI32(viter396)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.LIST, 9)
      oprot.writeListBegin(TType.MAP, len(self.append))
      for iter397 in self.append:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter397))
        for kiter398,viter399 in iter397.items():
          oprot.writeString(kiter398.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter398, bytes) else oprot.writeString(kiter398)
          oprot.writeI32(viter399)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = []
      for _tmp_e400 in json_obj['assign']:
        _map401 = dict_cls()
        for _tmp_k402, _tmp_v403 in _tmp_e400.items():
          _tmp_kp404 = _tmp_k402
          if _tmp_v403 > 0x7fffffff or _tmp_v403 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map401[_tmp_kp404] = _tmp_v403
        self.assign.append(_map401)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k405, _tmp_v406 in json_obj['patch'].items():
        _tmp_kp407 = int(_tmp_k405)
        if _tmp_kp407 > 0x7fffffff or _tmp_kp407 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds the limit in key ' + _tmp_k405)
        _struct408 = MyStructField29Patch1()
        _struct408.readFromJson(_tmp_v406, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp407] = _struct408
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = []
      for _tmp_e409 in json_obj['remove']:
        _map410 = dict_cls()
        for _tmp_k411, _tmp_v412 in _tmp_e409.items():
          _tmp_kp413 = _tmp_k411
          if _tmp_v412 > 0x7fffffff or _tmp_v412 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map410[_tmp_kp413] = _tmp_v412
        self.remove.append(_map410)
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = []
      for _tmp_e414 in json_obj['prepend']:
        _map415 = dict_cls()
        for _tmp_k416, _tmp_v417 in _tmp_e414.items():
          _tmp_kp418 = _tmp_k416
          if _tmp_v417 > 0x7fffffff or _tmp_v417 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map415[_tmp_kp418] = _tmp_v417
        self.prepend.append(_map415)
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = []
      for _tmp_e419 in json_obj['append']:
        _map420 = dict_cls()
        for _tmp_k421, _tmp_v422 in _tmp_e419.items():
          _tmp_kp423 = _tmp_k421
          if _tmp_v422 > 0x7fffffff or _tmp_v422 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map420[_tmp_kp423] = _tmp_v422
        self.append.append(_map420)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patch',
      'remove',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField29Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype425, _vtype426, _size424 ) = iprot.readMapBegin() 
          if _size424 >= 0:
            for _i428 in range(_size424):
              _key429 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val430 = iprot.readI32()
              self.assign[_key429] = _val430
          else: 
            while iprot.peekMap():
              _key431 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val432 = iprot.readI32()
              self.assign[_key431] = _val432
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype434, _vtype435, _size433 ) = iprot.readMapBegin() 
          if _size433 >= 0:
            for _i437 in range(_size433):
              _key438 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val439 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val439.read(iprot)
              self.patchPrior[_key438] = _val439
          else: 
            while iprot.peekMap():
              _key440 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val441 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val441.read(iprot)
              self.patchPrior[_key440] = _val441
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype443, _vtype444, _size442 ) = iprot.readMapBegin() 
          if _size442 >= 0:
            for _i446 in range(_size442):
              _key447 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val448 = iprot.readI32()
              self.add[_key447] = _val448
          else: 
            while iprot.peekMap():
              _key449 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val450 = iprot.readI32()
              self.add[_key449] = _val450
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype452, _vtype453, _size451 ) = iprot.readMapBegin() 
          if _size451 >= 0:
            for _i455 in range(_size451):
              _key456 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val457 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val457.read(iprot)
              self.patch[_key456] = _val457
          else: 
            while iprot.peekMap():
              _key458 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val459 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val459.read(iprot)
              self.patch[_key458] = _val459
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype463, _size460) = iprot.readSetBegin()
          if _size460 >= 0:
            for _i464 in range(_size460):
              _elem465 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem465)
          else: 
            while iprot.peekSet():
              _elem466 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem466)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype468, _vtype469, _size467 ) = iprot.readMapBegin() 
          if _size467 >= 0:
            for _i471 in range(_size467):
              _key472 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val473 = iprot.readI32()
              self.put[_key472] = _val473
          else: 
            while iprot.peekMap():
              _key474 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val475 = iprot.readI32()
              self.put[_key474] = _val475
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField29Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter476,viter477 in self.assign.items():
        oprot.writeString(kiter476.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter476, bytes) else oprot.writeString(kiter476)
        oprot.writeI32(viter477)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter478,viter479 in self.patchPrior.items():
        oprot.writeString(kiter478.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter478, bytes) else oprot.writeString(kiter478)
        viter479.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter480,viter481 in self.add.items():
        oprot.writeString(kiter480.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter480, bytes) else oprot.writeString(kiter480)
        oprot.writeI32(viter481)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter482,viter483 in self.patch.items():
        oprot.writeString(kiter482.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter482, bytes) else oprot.writeString(kiter482)
        viter483.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter484 in self.remove:
        oprot.writeString(iter484.encode('utf-8')) if UTF8STRINGS and not isinstance(iter484, bytes) else oprot.writeString(iter484)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter485,viter486 in self.put.items():
        oprot.writeString(kiter485.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter485, bytes) else oprot.writeString(kiter485)
        oprot.writeI32(viter486)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k487, _tmp_v488 in json_obj['assign'].items():
        _tmp_kp489 = _tmp_k487
        if _tmp_v488 > 0x7fffffff or _tmp_v488 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp489] = _tmp_v488
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k490, _tmp_v491 in json_obj['patchPrior'].items():
        _tmp_kp492 = _tmp_k490
        _struct493 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct493.readFromJson(_tmp_v491, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp492] = _struct493
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k494, _tmp_v495 in json_obj['add'].items():
        _tmp_kp496 = _tmp_k494
        if _tmp_v495 > 0x7fffffff or _tmp_v495 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp496] = _tmp_v495
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k497, _tmp_v498 in json_obj['patch'].items():
        _tmp_kp499 = _tmp_k497
        _struct500 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct500.readFromJson(_tmp_v498, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp499] = _struct500
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e501 in json_obj['remove']:
        self.remove.add(_tmp_e501)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k502, _tmp_v503 in json_obj['put'].items():
        _tmp_kp504 = _tmp_k502
        if _tmp_v503 > 0x7fffffff or _tmp_v503 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp504] = _tmp_v503

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField29Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField29Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype506, _vtype507, _size505 ) = iprot.readMapBegin() 
          if _size505 >= 0:
            for _i509 in range(_size505):
              _key510 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val511 = {}
              (_ktype513, _vtype514, _size512 ) = iprot.readMapBegin() 
              if _size512 >= 0:
                for _i516 in range(_size512):
                  _key517 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val518 = iprot.readI32()
                  _val511[_key517] = _val518
              else: 
                while iprot.peekMap():
                  _key519 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val520 = iprot.readI32()
                  _val511[_key519] = _val520
              iprot.readMapEnd()
              self.assign[_key510] = _val511
          else: 
            while iprot.peekMap():
              _key521 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val522 = {}
              (_ktype524, _vtype525, _size523 ) = iprot.readMapBegin() 
              if _size523 >= 0:
                for _i527 in range(_size523):
                  _key528 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val529 = iprot.readI32()
                  _val522[_key528] = _val529
              else: 
                while iprot.peekMap():
                  _key530 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val531 = iprot.readI32()
                  _val522[_key530] = _val531
              iprot.readMapEnd()
              self.assign[_key521] = _val522
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype533, _vtype534, _size532 ) = iprot.readMapBegin() 
          if _size532 >= 0:
            for _i536 in range(_size532):
              _key537 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val538 = MyStructField30Patch1()
              _val538.read(iprot)
              self.patchPrior[_key537] = _val538
          else: 
            while iprot.peekMap():
              _key539 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val540 = MyStructField30Patch1()
              _val540.read(iprot)
              self.patchPrior[_key539] = _val540
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype542, _vtype543, _size541 ) = iprot.readMapBegin() 
          if _size541 >= 0:
            for _i545 in range(_size541):
              _key546 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val547 = {}
              (_ktype549, _vtype550, _size548 ) = iprot.readMapBegin() 
              if _size548 >= 0:
                for _i552 in range(_size548):
                  _key553 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val554 = iprot.readI32()
                  _val547[_key553] = _val554
              else: 
                while iprot.peekMap():
                  _key555 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val556 = iprot.readI32()
                  _val547[_key555] = _val556
              iprot.readMapEnd()
              self.add[_key546] = _val547
          else: 
            while iprot.peekMap():
              _key557 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val558 = {}
              (_ktype560, _vtype561, _size559 ) = iprot.readMapBegin() 
              if _size559 >= 0:
                for _i563 in range(_size559):
                  _key564 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val565 = iprot.readI32()
                  _val558[_key564] = _val565
              else: 
                while iprot.peekMap():
                  _key566 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val567 = iprot.readI32()
                  _val558[_key566] = _val567
              iprot.readMapEnd()
              self.add[_key557] = _val558
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype569, _vtype570, _size568 ) = iprot.readMapBegin() 
          if _size568 >= 0:
            for _i572 in range(_size568):
              _key573 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val574 = MyStructField30Patch1()
              _val574.read(iprot)
              self.patch[_key573] = _val574
          else: 
            while iprot.peekMap():
              _key575 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val576 = MyStructField30Patch1()
              _val576.read(iprot)
              self.patch[_key575] = _val576
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype580, _size577) = iprot.readSetBegin()
          if _size577 >= 0:
            for _i581 in range(_size577):
              _elem582 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem582)
          else: 
            while iprot.peekSet():
              _elem583 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem583)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype585, _vtype586, _size584 ) = iprot.readMapBegin() 
          if _size584 >= 0:
            for _i588 in range(_size584):
              _key589 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val590 = {}
              (_ktype592, _vtype593, _size591 ) = iprot.readMapBegin() 
              if _size591 >= 0:
                for _i595 in range(_size591):
                  _key596 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val597 = iprot.readI32()
                  _val590[_key596] = _val597
              else: 
                while iprot.peekMap():
                  _key598 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val599 = iprot.readI32()
                  _val590[_key598] = _val599
              iprot.readMapEnd()
              self.put[_key589] = _val590
          else: 
            while iprot.peekMap():
              _key600 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val601 = {}
              (_ktype603, _vtype604, _size602 ) = iprot.readMapBegin() 
              if _size602 >= 0:
                for _i606 in range(_size602):
                  _key607 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val608 = iprot.readI32()
                  _val601[_key607] = _val608
              else: 
                while iprot.peekMap():
                  _key609 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val610 = iprot.readI32()
                  _val601[_key609] = _val610
              iprot.readMapEnd()
              self.put[_key600] = _val601
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.assign))
      for kiter611,viter612 in self.assign.items():
        oprot.writeString(kiter611.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter611, bytes) else oprot.writeString(kiter611)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter612))
        for kiter613,viter614 in viter612.items():
          oprot.writeString(kiter613.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter613, bytes) else oprot.writeString(kiter613)
          oprot.writeI32(viter614)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter615,viter616 in self.patchPrior.items():
        oprot.writeString(kiter615.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter615, bytes) else oprot.writeString(kiter615)
        viter616.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.add))
      for kiter617,viter618 in self.add.items():
        oprot.writeString(kiter617.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter617, bytes) else oprot.writeString(kiter617)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter618))
        for kiter619,viter620 in viter618.items():
          oprot.writeString(kiter619.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter619, bytes) else oprot.writeString(kiter619)
          oprot.writeI32(viter620)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter621,viter622 in self.patch.items():
        oprot.writeString(kiter621.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter621, bytes) else oprot.writeString(kiter621)
        viter622.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter623 in self.remove:
        oprot.writeString(iter623.encode('utf-8')) if UTF8STRINGS and not isinstance(iter623, bytes) else oprot.writeString(iter623)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.put))
      for kiter624,viter625 in self.put.items():
        oprot.writeString(kiter624.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter624, bytes) else oprot.writeString(kiter624)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter625))
        for kiter626,viter627 in viter625.items():
          oprot.writeString(kiter626.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter626, bytes) else oprot.writeString(kiter626)
          oprot.writeI32(viter627)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k628, _tmp_v629 in json_obj['assign'].items():
        _tmp_kp630 = _tmp_k628
        _map631 = dict_cls()
        for _tmp_k632, _tmp_v633 in _tmp_v629.items():
          _tmp_kp634 = _tmp_k632
          if _tmp_v633 > 0x7fffffff or _tmp_v633 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map631[_tmp_kp634] = _tmp_v633
        self.assign[_tmp_kp630] = _map631
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k635, _tmp_v636 in json_obj['patchPrior'].items():
        _tmp_kp637 = _tmp_k635
        _struct638 = MyStructField30Patch1()
        _struct638.readFromJson(_tmp_v636, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp637] = _struct638
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k639, _tmp_v640 in json_obj['add'].items():
        _tmp_kp641 = _tmp_k639
        _map642 = dict_cls()
        for _tmp_k643, _tmp_v644 in _tmp_v640.items():
          _tmp_kp645 = _tmp_k643
          if _tmp_v644 > 0x7fffffff or _tmp_v644 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map642[_tmp_kp645] = _tmp_v644
        self.add[_tmp_kp641] = _map642
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k646, _tmp_v647 in json_obj['patch'].items():
        _tmp_kp648 = _tmp_k646
        _struct649 = MyStructField30Patch1()
        _struct649.readFromJson(_tmp_v647, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp648] = _struct649
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e650 in json_obj['remove']:
        self.remove.add(_tmp_e650)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k651, _tmp_v652 in json_obj['put'].items():
        _tmp_kp653 = _tmp_k651
        _map654 = dict_cls()
        for _tmp_k655, _tmp_v656 in _tmp_v652.items():
          _tmp_kp657 = _tmp_k655
          if _tmp_v656 > 0x7fffffff or _tmp_v656 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map654[_tmp_kp657] = _tmp_v656
        self.put[_tmp_kp653] = _map654

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch, self)

  def _to_py_deprecated(self):
    return self

class MyStructField30Patch1:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - add: Add the given values, if the keys are not already present. Applies forth.
   - patch: Patches any set value, including newly set values. Applies last.
   - remove: Removes entries, if present. Applies third.
   - put: Adds or replaces the given key/value pairs. Applies fifth.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype659, _vtype660, _size658 ) = iprot.readMapBegin() 
          if _size658 >= 0:
            for _i662 in range(_size658):
              _key663 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val664 = iprot.readI32()
              self.assign[_key663] = _val664
          else: 
            while iprot.peekMap():
              _key665 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val666 = iprot.readI32()
              self.assign[_key665] = _val666
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.patchPrior = {}
          (_ktype668, _vtype669, _size667 ) = iprot.readMapBegin() 
          if _size667 >= 0:
            for _i671 in range(_size667):
              _key672 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val673 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val673.read(iprot)
              self.patchPrior[_key672] = _val673
          else: 
            while iprot.peekMap():
              _key674 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val675 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val675.read(iprot)
              self.patchPrior[_key674] = _val675
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.add = {}
          (_ktype677, _vtype678, _size676 ) = iprot.readMapBegin() 
          if _size676 >= 0:
            for _i680 in range(_size676):
              _key681 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val682 = iprot.readI32()
              self.add[_key681] = _val682
          else: 
            while iprot.peekMap():
              _key683 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val684 = iprot.readI32()
              self.add[_key683] = _val684
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.patch = {}
          (_ktype686, _vtype687, _size685 ) = iprot.readMapBegin() 
          if _size685 >= 0:
            for _i689 in range(_size685):
              _key690 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val691 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val691.read(iprot)
              self.patch[_key690] = _val691
          else: 
            while iprot.peekMap():
              _key692 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val693 = thrift.lib.thrift.patch.ttypes.I32Patch()
              _val693.read(iprot)
              self.patch[_key692] = _val693
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.SET:
          self.remove = set()
          (_etype697, _size694) = iprot.readSetBegin()
          if _size694 >= 0:
            for _i698 in range(_size694):
              _elem699 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem699)
          else: 
            while iprot.peekSet():
              _elem700 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.remove.add(_elem700)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.put = {}
          (_ktype702, _vtype703, _size701 ) = iprot.readMapBegin() 
          if _size701 >= 0:
            for _i705 in range(_size701):
              _key706 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val707 = iprot.readI32()
              self.put[_key706] = _val707
          else: 
            while iprot.peekMap():
              _key708 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val709 = iprot.readI32()
              self.put[_key708] = _val709
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructField30Patch1')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.assign))
      for kiter710,viter711 in self.assign.items():
        oprot.writeString(kiter710.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter710, bytes) else oprot.writeString(kiter710)
        oprot.writeI32(viter711)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patchPrior))
      for kiter712,viter713 in self.patchPrior.items():
        oprot.writeString(kiter712.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter712, bytes) else oprot.writeString(kiter712)
        viter713.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.add))
      for kiter714,viter715 in self.add.items():
        oprot.writeString(kiter714.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter714, bytes) else oprot.writeString(kiter714)
        oprot.writeI32(viter715)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.patch))
      for kiter716,viter717 in self.patch.items():
        oprot.writeString(kiter716.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter716, bytes) else oprot.writeString(kiter716)
        viter717.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.remove != None:
      oprot.writeFieldBegin('remove', TType.SET, 7)
      oprot.writeSetBegin(TType.STRING, len(self.remove))
      for iter718 in self.remove:
        oprot.writeString(iter718.encode('utf-8')) if UTF8STRINGS and not isinstance(iter718, bytes) else oprot.writeString(iter718)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.put != None:
      oprot.writeFieldBegin('put', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.I32, len(self.put))
      for kiter719,viter720 in self.put.items():
        oprot.writeString(kiter719.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter719, bytes) else oprot.writeString(kiter719)
        oprot.writeI32(viter720)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k721, _tmp_v722 in json_obj['assign'].items():
        _tmp_kp723 = _tmp_k721
        if _tmp_v722 > 0x7fffffff or _tmp_v722 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.assign[_tmp_kp723] = _tmp_v722
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = dict_cls()
      for _tmp_k724, _tmp_v725 in json_obj['patchPrior'].items():
        _tmp_kp726 = _tmp_k724
        _struct727 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct727.readFromJson(_tmp_v725, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patchPrior[_tmp_kp726] = _struct727
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = dict_cls()
      for _tmp_k728, _tmp_v729 in json_obj['add'].items():
        _tmp_kp730 = _tmp_k728
        if _tmp_v729 > 0x7fffffff or _tmp_v729 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.add[_tmp_kp730] = _tmp_v729
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = dict_cls()
      for _tmp_k731, _tmp_v732 in json_obj['patch'].items():
        _tmp_kp733 = _tmp_k731
        _struct734 = thrift.lib.thrift.patch.ttypes.I32Patch()
        _struct734.readFromJson(_tmp_v732, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.patch[_tmp_kp733] = _struct734
    if 'remove' in json_obj and json_obj['remove'] is not None:
      self.remove = set_cls()
      for _tmp_e735 in json_obj['remove']:
        self.remove.add(_tmp_e735)
    if 'put' in json_obj and json_obj['put'] is not None:
      self.put = dict_cls()
      for _tmp_k736, _tmp_v737 in json_obj['put'].items():
        _tmp_kp738 = _tmp_k736
        if _tmp_v737 > 0x7fffffff or _tmp_v737 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.put[_tmp_kp738] = _tmp_v737

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    if self.remove is not None:
      value = pprint.pformat(self.remove, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    remove=%s' % (value))
    if self.put is not None:
      value = pprint.pformat(self.put, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    put=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'add',
      'patch',
      'remove',
      'put',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructField30Patch1, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructField30Patch1, self)

  def _to_py_deprecated(self):
    return self

class MyStructFieldPatch:
  r"""
  Attributes:
   - structWithCustomDefault
   - i32WithCustomDefault
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefaultPatch()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.STRUCT:
          self.i32WithCustomDefault = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32WithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.STRUCT:
          self.mapMap = MyStructField30Patch()
          self.mapMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.STRUCT:
          self.listMap = MyStructField29Patch()
          self.listMap.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.STRUCT:
          self.optMapVal = MyStructField28Patch()
          self.optMapVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.STRUCT:
          self.optSetVal = MyStructField27Patch()
          self.optSetVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.STRUCT:
          self.optListVal = MyStructField26Patch()
          self.optListVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStructPatch()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyDataPatch()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.STRUCT:
          self.optEnumVal = MyStructField23Patch()
          self.optEnumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRUCT:
          self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.optBinaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRUCT:
          self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.optStringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.STRUCT:
          self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.optDoubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.STRUCT:
          self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.optFloatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.STRUCT:
          self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.optI64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.STRUCT:
          self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.optI32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.STRUCT:
          self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.optI16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.STRUCT:
          self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.optByteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.STRUCT:
          self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.optBoolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStructPatch()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnionPatch()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyDataPatch()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.STRUCT:
          self.enumVal = MyStructField10Patch()
          self.enumVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRUCT:
          self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
          self.binaryVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRUCT:
          self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
          self.stringVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.STRUCT:
          self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
          self.doubleVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.STRUCT:
          self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
          self.floatVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.STRUCT:
          self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
          self.i64Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.STRUCT:
          self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
          self.i32Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.STRUCT:
          self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
          self.i16Val.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.STRUCT:
          self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
          self.byteVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.STRUCT:
          self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
          self.boolVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyDataPatch()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructFieldPatch')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.STRUCT, -31)
      self.i32WithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.STRUCT, -30)
      self.mapMap.write(oprot)
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.STRUCT, -29)
      self.listMap.write(oprot)
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.STRUCT, -28)
      self.optMapVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.STRUCT, -27)
      self.optSetVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.STRUCT, -26)
      self.optListVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.STRUCT, -23)
      self.optEnumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRUCT, -22)
      self.optBinaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRUCT, -21)
      self.optStringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.STRUCT, -20)
      self.optDoubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.STRUCT, -19)
      self.optFloatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.STRUCT, -18)
      self.optI64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.STRUCT, -17)
      self.optI32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.STRUCT, -16)
      self.optI16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.STRUCT, -15)
      self.optByteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.STRUCT, -14)
      self.optBoolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.STRUCT, -10)
      self.enumVal.write(oprot)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRUCT, -9)
      self.binaryVal.write(oprot)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRUCT, -8)
      self.stringVal.write(oprot)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.STRUCT, -7)
      self.doubleVal.write(oprot)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.STRUCT, -6)
      self.floatVal.write(oprot)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.STRUCT, -5)
      self.i64Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.STRUCT, -4)
      self.i32Val.write(oprot)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.STRUCT, -3)
      self.i16Val.write(oprot)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.STRUCT, -2)
      self.byteVal.write(oprot)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.STRUCT, -1)
      self.boolVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefaultPatch()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32WithCustomDefault.readFromJson(json_obj['i32WithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = MyStructField30Patch()
      self.mapMap.readFromJson(json_obj['mapMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = MyStructField29Patch()
      self.listMap.readFromJson(json_obj['listMap'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = MyStructField28Patch()
      self.optMapVal.readFromJson(json_obj['optMapVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = MyStructField27Patch()
      self.optSetVal.readFromJson(json_obj['optSetVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = MyStructField26Patch()
      self.optListVal.readFromJson(json_obj['optListVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStructPatch()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyDataPatch()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = MyStructField23Patch()
      self.optEnumVal.readFromJson(json_obj['optEnumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.optBinaryVal.readFromJson(json_obj['optBinaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.optStringVal.readFromJson(json_obj['optStringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.optDoubleVal.readFromJson(json_obj['optDoubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.optFloatVal.readFromJson(json_obj['optFloatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.optI64Val.readFromJson(json_obj['optI64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.optI32Val.readFromJson(json_obj['optI32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.optI16Val.readFromJson(json_obj['optI16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.optByteVal.readFromJson(json_obj['optByteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.optBoolVal.readFromJson(json_obj['optBoolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStructPatch()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnionPatch()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyDataPatch()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = MyStructField10Patch()
      self.enumVal.readFromJson(json_obj['enumVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = thrift.lib.thrift.patch.ttypes.BinaryPatch()
      self.binaryVal.readFromJson(json_obj['binaryVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = thrift.lib.thrift.patch.ttypes.StringPatch()
      self.stringVal.readFromJson(json_obj['stringVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = thrift.lib.thrift.patch.ttypes.DoublePatch()
      self.doubleVal.readFromJson(json_obj['doubleVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = thrift.lib.thrift.patch.ttypes.FloatPatch()
      self.floatVal.readFromJson(json_obj['floatVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = thrift.lib.thrift.patch.ttypes.I64Patch()
      self.i64Val.readFromJson(json_obj['i64Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = thrift.lib.thrift.patch.ttypes.I32Patch()
      self.i32Val.readFromJson(json_obj['i32Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = thrift.lib.thrift.patch.ttypes.I16Patch()
      self.i16Val.readFromJson(json_obj['i16Val'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = thrift.lib.thrift.patch.ttypes.BytePatch()
      self.byteVal.readFromJson(json_obj['byteVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = thrift.lib.thrift.patch.ttypes.BoolPatch()
      self.boolVal.readFromJson(json_obj['boolVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyDataPatch()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class MyStructEnsureStruct:
  r"""
  Attributes:
   - structWithCustomDefault
   - i32WithCustomDefault
   - mapMap
   - listMap
   - optMapVal
   - optSetVal
   - optListVal
   - optLateStructVal
   - optStructVal
   - optEnumVal
   - optBinaryVal
   - optStringVal
   - optDoubleVal
   - optFloatVal
   - optI64Val
   - optI32Val
   - optI16Val
   - optByteVal
   - optBoolVal
   - lateStructVal
   - unionVal
   - structVal
   - enumVal
   - binaryVal
   - stringVal
   - doubleVal
   - floatVal
   - i64Val
   - i32Val
   - i16Val
   - byteVal
   - boolVal
   - structWithFieldCustomDefault
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -32:
        if ftype == TType.STRUCT:
          self.structWithCustomDefault = MyDataWithCustomDefault()
          self.structWithCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -31:
        if ftype == TType.I32:
          self.i32WithCustomDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -30:
        if ftype == TType.MAP:
          self.mapMap = {}
          (_ktype740, _vtype741, _size739 ) = iprot.readMapBegin() 
          if _size739 >= 0:
            for _i743 in range(_size739):
              _key744 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val745 = {}
              (_ktype747, _vtype748, _size746 ) = iprot.readMapBegin() 
              if _size746 >= 0:
                for _i750 in range(_size746):
                  _key751 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val752 = iprot.readI32()
                  _val745[_key751] = _val752
              else: 
                while iprot.peekMap():
                  _key753 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val754 = iprot.readI32()
                  _val745[_key753] = _val754
              iprot.readMapEnd()
              self.mapMap[_key744] = _val745
          else: 
            while iprot.peekMap():
              _key755 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val756 = {}
              (_ktype758, _vtype759, _size757 ) = iprot.readMapBegin() 
              if _size757 >= 0:
                for _i761 in range(_size757):
                  _key762 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val763 = iprot.readI32()
                  _val756[_key762] = _val763
              else: 
                while iprot.peekMap():
                  _key764 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val765 = iprot.readI32()
                  _val756[_key764] = _val765
              iprot.readMapEnd()
              self.mapMap[_key755] = _val756
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -29:
        if ftype == TType.LIST:
          self.listMap = []
          (_etype769, _size766) = iprot.readListBegin()
          if _size766 >= 0:
            for _i770 in range(_size766):
              _elem771 = {}
              (_ktype773, _vtype774, _size772 ) = iprot.readMapBegin() 
              if _size772 >= 0:
                for _i776 in range(_size772):
                  _key777 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val778 = iprot.readI32()
                  _elem771[_key777] = _val778
              else: 
                while iprot.peekMap():
                  _key779 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val780 = iprot.readI32()
                  _elem771[_key779] = _val780
              iprot.readMapEnd()
              self.listMap.append(_elem771)
          else: 
            while iprot.peekList():
              _elem781 = {}
              (_ktype783, _vtype784, _size782 ) = iprot.readMapBegin() 
              if _size782 >= 0:
                for _i786 in range(_size782):
                  _key787 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val788 = iprot.readI32()
                  _elem781[_key787] = _val788
              else: 
                while iprot.peekMap():
                  _key789 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val790 = iprot.readI32()
                  _elem781[_key789] = _val790
              iprot.readMapEnd()
              self.listMap.append(_elem781)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -28:
        if ftype == TType.MAP:
          self.optMapVal = {}
          (_ktype792, _vtype793, _size791 ) = iprot.readMapBegin() 
          if _size791 >= 0:
            for _i795 in range(_size791):
              _key796 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val797 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key796] = _val797
          else: 
            while iprot.peekMap():
              _key798 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val799 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optMapVal[_key798] = _val799
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == -27:
        if ftype == TType.SET:
          self.optSetVal = set()
          (_etype803, _size800) = iprot.readSetBegin()
          if _size800 >= 0:
            for _i804 in range(_size800):
              _elem805 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem805)
          else: 
            while iprot.peekSet():
              _elem806 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optSetVal.add(_elem806)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == -26:
        if ftype == TType.LIST:
          self.optListVal = []
          (_etype810, _size807) = iprot.readListBegin()
          if _size807 >= 0:
            for _i811 in range(_size807):
              _elem812 = iprot.readI16()
              self.optListVal.append(_elem812)
          else: 
            while iprot.peekList():
              _elem813 = iprot.readI16()
              self.optListVal.append(_elem813)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == -25:
        if ftype == TType.STRUCT:
          self.optLateStructVal = LateDefStruct()
          self.optLateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -24:
        if ftype == TType.STRUCT:
          self.optStructVal = MyData()
          self.optStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -23:
        if ftype == TType.I32:
          self.optEnumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -22:
        if ftype == TType.STRING:
          self.optBinaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -21:
        if ftype == TType.STRING:
          self.optStringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -20:
        if ftype == TType.DOUBLE:
          self.optDoubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -19:
        if ftype == TType.FLOAT:
          self.optFloatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -18:
        if ftype == TType.I64:
          self.optI64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -17:
        if ftype == TType.I32:
          self.optI32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -16:
        if ftype == TType.I16:
          self.optI16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -15:
        if ftype == TType.BYTE:
          self.optByteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -14:
        if ftype == TType.BOOL:
          self.optBoolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == -13:
        if ftype == TType.STRUCT:
          self.lateStructVal = LateDefStruct()
          self.lateStructVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -12:
        if ftype == TType.STRUCT:
          self.unionVal = MyUnion()
          self.unionVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -11:
        if ftype == TType.STRUCT:
          self.structVal = MyData()
          self.structVal.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == -10:
        if ftype == TType.I32:
          self.enumVal = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -9:
        if ftype == TType.STRING:
          self.binaryVal = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -8:
        if ftype == TType.STRING:
          self.stringVal = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == -7:
        if ftype == TType.DOUBLE:
          self.doubleVal = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == -6:
        if ftype == TType.FLOAT:
          self.floatVal = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == -5:
        if ftype == TType.I64:
          self.i64Val = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == -4:
        if ftype == TType.I32:
          self.i32Val = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == -3:
        if ftype == TType.I16:
          self.i16Val = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == -2:
        if ftype == TType.BYTE:
          self.byteVal = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == -1:
        if ftype == TType.BOOL:
          self.boolVal = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.structWithFieldCustomDefault = MyData()
          self.structWithFieldCustomDefault.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStructEnsureStruct')
    if self.structWithCustomDefault != None:
      oprot.writeFieldBegin('structWithCustomDefault', TType.STRUCT, -32)
      self.structWithCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    if self.i32WithCustomDefault != None:
      oprot.writeFieldBegin('i32WithCustomDefault', TType.I32, -31)
      oprot.writeI32(self.i32WithCustomDefault)
      oprot.writeFieldEnd()
    if self.mapMap != None:
      oprot.writeFieldBegin('mapMap', TType.MAP, -30)
      oprot.writeMapBegin(TType.STRING, TType.MAP, len(self.mapMap))
      for kiter814,viter815 in self.mapMap.items():
        oprot.writeString(kiter814.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter814, bytes) else oprot.writeString(kiter814)
        oprot.writeMapBegin(TType.STRING, TType.I32, len(viter815))
        for kiter816,viter817 in viter815.items():
          oprot.writeString(kiter816.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter816, bytes) else oprot.writeString(kiter816)
          oprot.writeI32(viter817)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.listMap != None:
      oprot.writeFieldBegin('listMap', TType.LIST, -29)
      oprot.writeListBegin(TType.MAP, len(self.listMap))
      for iter818 in self.listMap:
        oprot.writeMapBegin(TType.STRING, TType.I32, len(iter818))
        for kiter819,viter820 in iter818.items():
          oprot.writeString(kiter819.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter819, bytes) else oprot.writeString(kiter819)
          oprot.writeI32(viter820)
        oprot.writeMapEnd()
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optMapVal != None:
      oprot.writeFieldBegin('optMapVal', TType.MAP, -28)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.optMapVal))
      for kiter821,viter822 in self.optMapVal.items():
        oprot.writeString(kiter821.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter821, bytes) else oprot.writeString(kiter821)
        oprot.writeString(viter822.encode('utf-8')) if UTF8STRINGS and not isinstance(viter822, bytes) else oprot.writeString(viter822)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optSetVal != None:
      oprot.writeFieldBegin('optSetVal', TType.SET, -27)
      oprot.writeSetBegin(TType.STRING, len(self.optSetVal))
      for iter823 in self.optSetVal:
        oprot.writeString(iter823.encode('utf-8')) if UTF8STRINGS and not isinstance(iter823, bytes) else oprot.writeString(iter823)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optListVal != None:
      oprot.writeFieldBegin('optListVal', TType.LIST, -26)
      oprot.writeListBegin(TType.I16, len(self.optListVal))
      for iter824 in self.optListVal:
        oprot.writeI16(iter824)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optLateStructVal != None:
      oprot.writeFieldBegin('optLateStructVal', TType.STRUCT, -25)
      self.optLateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optStructVal != None:
      oprot.writeFieldBegin('optStructVal', TType.STRUCT, -24)
      self.optStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.optEnumVal != None:
      oprot.writeFieldBegin('optEnumVal', TType.I32, -23)
      oprot.writeI32(self.optEnumVal)
      oprot.writeFieldEnd()
    if self.optBinaryVal != None:
      oprot.writeFieldBegin('optBinaryVal', TType.STRING, -22)
      oprot.writeString(self.optBinaryVal)
      oprot.writeFieldEnd()
    if self.optStringVal != None:
      oprot.writeFieldBegin('optStringVal', TType.STRING, -21)
      oprot.writeString(self.optStringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.optStringVal, bytes) else oprot.writeString(self.optStringVal)
      oprot.writeFieldEnd()
    if self.optDoubleVal != None:
      oprot.writeFieldBegin('optDoubleVal', TType.DOUBLE, -20)
      oprot.writeDouble(self.optDoubleVal)
      oprot.writeFieldEnd()
    if self.optFloatVal != None:
      oprot.writeFieldBegin('optFloatVal', TType.FLOAT, -19)
      oprot.writeFloat(self.optFloatVal)
      oprot.writeFieldEnd()
    if self.optI64Val != None:
      oprot.writeFieldBegin('optI64Val', TType.I64, -18)
      oprot.writeI64(self.optI64Val)
      oprot.writeFieldEnd()
    if self.optI32Val != None:
      oprot.writeFieldBegin('optI32Val', TType.I32, -17)
      oprot.writeI32(self.optI32Val)
      oprot.writeFieldEnd()
    if self.optI16Val != None:
      oprot.writeFieldBegin('optI16Val', TType.I16, -16)
      oprot.writeI16(self.optI16Val)
      oprot.writeFieldEnd()
    if self.optByteVal != None:
      oprot.writeFieldBegin('optByteVal', TType.BYTE, -15)
      oprot.writeByte(self.optByteVal)
      oprot.writeFieldEnd()
    if self.optBoolVal != None:
      oprot.writeFieldBegin('optBoolVal', TType.BOOL, -14)
      oprot.writeBool(self.optBoolVal)
      oprot.writeFieldEnd()
    if self.lateStructVal != None:
      oprot.writeFieldBegin('lateStructVal', TType.STRUCT, -13)
      self.lateStructVal.write(oprot)
      oprot.writeFieldEnd()
    if self.unionVal != None:
      oprot.writeFieldBegin('unionVal', TType.STRUCT, -12)
      self.unionVal.write(oprot)
      oprot.writeFieldEnd()
    if self.structVal != None:
      oprot.writeFieldBegin('structVal', TType.STRUCT, -11)
      self.structVal.write(oprot)
      oprot.writeFieldEnd()
    if self.enumVal != None:
      oprot.writeFieldBegin('enumVal', TType.I32, -10)
      oprot.writeI32(self.enumVal)
      oprot.writeFieldEnd()
    if self.binaryVal != None:
      oprot.writeFieldBegin('binaryVal', TType.STRING, -9)
      oprot.writeString(self.binaryVal)
      oprot.writeFieldEnd()
    if self.stringVal != None:
      oprot.writeFieldBegin('stringVal', TType.STRING, -8)
      oprot.writeString(self.stringVal.encode('utf-8')) if UTF8STRINGS and not isinstance(self.stringVal, bytes) else oprot.writeString(self.stringVal)
      oprot.writeFieldEnd()
    if self.doubleVal != None:
      oprot.writeFieldBegin('doubleVal', TType.DOUBLE, -7)
      oprot.writeDouble(self.doubleVal)
      oprot.writeFieldEnd()
    if self.floatVal != None:
      oprot.writeFieldBegin('floatVal', TType.FLOAT, -6)
      oprot.writeFloat(self.floatVal)
      oprot.writeFieldEnd()
    if self.i64Val != None:
      oprot.writeFieldBegin('i64Val', TType.I64, -5)
      oprot.writeI64(self.i64Val)
      oprot.writeFieldEnd()
    if self.i32Val != None:
      oprot.writeFieldBegin('i32Val', TType.I32, -4)
      oprot.writeI32(self.i32Val)
      oprot.writeFieldEnd()
    if self.i16Val != None:
      oprot.writeFieldBegin('i16Val', TType.I16, -3)
      oprot.writeI16(self.i16Val)
      oprot.writeFieldEnd()
    if self.byteVal != None:
      oprot.writeFieldBegin('byteVal', TType.BYTE, -2)
      oprot.writeByte(self.byteVal)
      oprot.writeFieldEnd()
    if self.boolVal != None:
      oprot.writeFieldBegin('boolVal', TType.BOOL, -1)
      oprot.writeBool(self.boolVal)
      oprot.writeFieldEnd()
    if self.structWithFieldCustomDefault != None:
      oprot.writeFieldBegin('structWithFieldCustomDefault', TType.STRUCT, 1)
      self.structWithFieldCustomDefault.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structWithCustomDefault' in json_obj and json_obj['structWithCustomDefault'] is not None:
      self.structWithCustomDefault = MyDataWithCustomDefault()
      self.structWithCustomDefault.readFromJson(json_obj['structWithCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'i32WithCustomDefault' in json_obj and json_obj['i32WithCustomDefault'] is not None:
      self.i32WithCustomDefault = json_obj['i32WithCustomDefault']
      if self.i32WithCustomDefault > 0x7fffffff or self.i32WithCustomDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'mapMap' in json_obj and json_obj['mapMap'] is not None:
      self.mapMap = dict_cls()
      for _tmp_k825, _tmp_v826 in json_obj['mapMap'].items():
        _tmp_kp827 = _tmp_k825
        _map828 = dict_cls()
        for _tmp_k829, _tmp_v830 in _tmp_v826.items():
          _tmp_kp831 = _tmp_k829
          if _tmp_v830 > 0x7fffffff or _tmp_v830 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map828[_tmp_kp831] = _tmp_v830
        self.mapMap[_tmp_kp827] = _map828
    if 'listMap' in json_obj and json_obj['listMap'] is not None:
      self.listMap = []
      for _tmp_e832 in json_obj['listMap']:
        _map833 = dict_cls()
        for _tmp_k834, _tmp_v835 in _tmp_e832.items():
          _tmp_kp836 = _tmp_k834
          if _tmp_v835 > 0x7fffffff or _tmp_v835 < -0x80000000:
            raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
          _map833[_tmp_kp836] = _tmp_v835
        self.listMap.append(_map833)
    if 'optMapVal' in json_obj and json_obj['optMapVal'] is not None:
      self.optMapVal = dict_cls()
      for _tmp_k837, _tmp_v838 in json_obj['optMapVal'].items():
        _tmp_kp839 = _tmp_k837
        self.optMapVal[_tmp_kp839] = _tmp_v838
    if 'optSetVal' in json_obj and json_obj['optSetVal'] is not None:
      self.optSetVal = set_cls()
      for _tmp_e840 in json_obj['optSetVal']:
        self.optSetVal.add(_tmp_e840)
    if 'optListVal' in json_obj and json_obj['optListVal'] is not None:
      self.optListVal = []
      for _tmp_e841 in json_obj['optListVal']:
        if _tmp_e841 > 0x7fff or _tmp_e841 < -0x8000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.optListVal.append(_tmp_e841)
    if 'optLateStructVal' in json_obj and json_obj['optLateStructVal'] is not None:
      self.optLateStructVal = LateDefStruct()
      self.optLateStructVal.readFromJson(json_obj['optLateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optStructVal' in json_obj and json_obj['optStructVal'] is not None:
      self.optStructVal = MyData()
      self.optStructVal.readFromJson(json_obj['optStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optEnumVal' in json_obj and json_obj['optEnumVal'] is not None:
      self.optEnumVal = json_obj['optEnumVal']
      if not self.optEnumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.optEnumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'optBinaryVal' in json_obj and json_obj['optBinaryVal'] is not None:
      self.optBinaryVal = json_obj['optBinaryVal']
    if 'optStringVal' in json_obj and json_obj['optStringVal'] is not None:
      self.optStringVal = json_obj['optStringVal']
    if 'optDoubleVal' in json_obj and json_obj['optDoubleVal'] is not None:
      self.optDoubleVal = float(json_obj['optDoubleVal'])
    if 'optFloatVal' in json_obj and json_obj['optFloatVal'] is not None:
      self.optFloatVal = float(json_obj['optFloatVal'])
    if 'optI64Val' in json_obj and json_obj['optI64Val'] is not None:
      self.optI64Val = long(json_obj['optI64Val'])
    if 'optI32Val' in json_obj and json_obj['optI32Val'] is not None:
      self.optI32Val = json_obj['optI32Val']
      if self.optI32Val > 0x7fffffff or self.optI32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optI16Val' in json_obj and json_obj['optI16Val'] is not None:
      self.optI16Val = json_obj['optI16Val']
      if self.optI16Val > 0x7fff or self.optI16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optByteVal' in json_obj and json_obj['optByteVal'] is not None:
      self.optByteVal = json_obj['optByteVal']
      if self.optByteVal > 0x7f or self.optByteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optBoolVal' in json_obj and json_obj['optBoolVal'] is not None:
      self.optBoolVal = json_obj['optBoolVal']
    if 'lateStructVal' in json_obj and json_obj['lateStructVal'] is not None:
      self.lateStructVal = LateDefStruct()
      self.lateStructVal.readFromJson(json_obj['lateStructVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'unionVal' in json_obj and json_obj['unionVal'] is not None:
      self.unionVal = MyUnion()
      self.unionVal.readFromJson(json_obj['unionVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structVal' in json_obj and json_obj['structVal'] is not None:
      self.structVal = MyData()
      self.structVal.readFromJson(json_obj['structVal'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'enumVal' in json_obj and json_obj['enumVal'] is not None:
      self.enumVal = json_obj['enumVal']
      if not self.enumVal in MyEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type MyEnum' % self.enumVal
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'binaryVal' in json_obj and json_obj['binaryVal'] is not None:
      self.binaryVal = json_obj['binaryVal']
    if 'stringVal' in json_obj and json_obj['stringVal'] is not None:
      self.stringVal = json_obj['stringVal']
    if 'doubleVal' in json_obj and json_obj['doubleVal'] is not None:
      self.doubleVal = float(json_obj['doubleVal'])
    if 'floatVal' in json_obj and json_obj['floatVal'] is not None:
      self.floatVal = float(json_obj['floatVal'])
    if 'i64Val' in json_obj and json_obj['i64Val'] is not None:
      self.i64Val = long(json_obj['i64Val'])
    if 'i32Val' in json_obj and json_obj['i32Val'] is not None:
      self.i32Val = json_obj['i32Val']
      if self.i32Val > 0x7fffffff or self.i32Val < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'i16Val' in json_obj and json_obj['i16Val'] is not None:
      self.i16Val = json_obj['i16Val']
      if self.i16Val > 0x7fff or self.i16Val < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'byteVal' in json_obj and json_obj['byteVal'] is not None:
      self.byteVal = json_obj['byteVal']
      if self.byteVal > 0x7f or self.byteVal < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'boolVal' in json_obj and json_obj['boolVal'] is not None:
      self.boolVal = json_obj['boolVal']
    if 'structWithFieldCustomDefault' in json_obj and json_obj['structWithFieldCustomDefault'] is not None:
      self.structWithFieldCustomDefault = MyData()
      self.structWithFieldCustomDefault.readFromJson(json_obj['structWithFieldCustomDefault'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structWithCustomDefault is not None:
      value = pprint.pformat(self.structWithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithCustomDefault=%s' % (value))
    if self.i32WithCustomDefault is not None:
      value = pprint.pformat(self.i32WithCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32WithCustomDefault=%s' % (value))
    if self.mapMap is not None:
      value = pprint.pformat(self.mapMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapMap=%s' % (value))
    if self.listMap is not None:
      value = pprint.pformat(self.listMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    listMap=%s' % (value))
    if self.optMapVal is not None:
      value = pprint.pformat(self.optMapVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optMapVal=%s' % (value))
    if self.optSetVal is not None:
      value = pprint.pformat(self.optSetVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optSetVal=%s' % (value))
    if self.optListVal is not None:
      value = pprint.pformat(self.optListVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optListVal=%s' % (value))
    if self.optLateStructVal is not None:
      value = pprint.pformat(self.optLateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optLateStructVal=%s' % (value))
    if self.optStructVal is not None:
      value = pprint.pformat(self.optStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStructVal=%s' % (value))
    if self.optEnumVal is not None:
      value = pprint.pformat(self.optEnumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optEnumVal=%s' % (value))
    if self.optBinaryVal is not None:
      value = pprint.pformat(self.optBinaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBinaryVal=%s' % (value))
    if self.optStringVal is not None:
      value = pprint.pformat(self.optStringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optStringVal=%s' % (value))
    if self.optDoubleVal is not None:
      value = pprint.pformat(self.optDoubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optDoubleVal=%s' % (value))
    if self.optFloatVal is not None:
      value = pprint.pformat(self.optFloatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optFloatVal=%s' % (value))
    if self.optI64Val is not None:
      value = pprint.pformat(self.optI64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI64Val=%s' % (value))
    if self.optI32Val is not None:
      value = pprint.pformat(self.optI32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI32Val=%s' % (value))
    if self.optI16Val is not None:
      value = pprint.pformat(self.optI16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optI16Val=%s' % (value))
    if self.optByteVal is not None:
      value = pprint.pformat(self.optByteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optByteVal=%s' % (value))
    if self.optBoolVal is not None:
      value = pprint.pformat(self.optBoolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optBoolVal=%s' % (value))
    if self.lateStructVal is not None:
      value = pprint.pformat(self.lateStructVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    lateStructVal=%s' % (value))
    if self.unionVal is not None:
      value = pprint.pformat(self.unionVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionVal=%s' % (value))
    if self.structVal is not None:
      value = pprint.pformat(self.structVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structVal=%s' % (value))
    if self.enumVal is not None:
      value = pprint.pformat(self.enumVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    enumVal=%s' % (value))
    if self.binaryVal is not None:
      value = pprint.pformat(self.binaryVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryVal=%s' % (value))
    if self.stringVal is not None:
      value = pprint.pformat(self.stringVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    stringVal=%s' % (value))
    if self.doubleVal is not None:
      value = pprint.pformat(self.doubleVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleVal=%s' % (value))
    if self.floatVal is not None:
      value = pprint.pformat(self.floatVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    floatVal=%s' % (value))
    if self.i64Val is not None:
      value = pprint.pformat(self.i64Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i64Val=%s' % (value))
    if self.i32Val is not None:
      value = pprint.pformat(self.i32Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i32Val=%s' % (value))
    if self.i16Val is not None:
      value = pprint.pformat(self.i16Val, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    i16Val=%s' % (value))
    if self.byteVal is not None:
      value = pprint.pformat(self.byteVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    byteVal=%s' % (value))
    if self.boolVal is not None:
      value = pprint.pformat(self.boolVal, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    boolVal=%s' % (value))
    if self.structWithFieldCustomDefault is not None:
      value = pprint.pformat(self.structWithFieldCustomDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structWithFieldCustomDefault=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structWithCustomDefault',
      'i32WithCustomDefault',
      'mapMap',
      'listMap',
      'optMapVal',
      'optSetVal',
      'optListVal',
      'optLateStructVal',
      'optStructVal',
      'optEnumVal',
      'optBinaryVal',
      'optStringVal',
      'optDoubleVal',
      'optFloatVal',
      'optI64Val',
      'optI32Val',
      'optI16Val',
      'optByteVal',
      'optBoolVal',
      'lateStructVal',
      'unionVal',
      'structVal',
      'enumVal',
      'binaryVal',
      'stringVal',
      'doubleVal',
      'floatVal',
      'i64Val',
      'i32Val',
      'i16Val',
      'byteVal',
      'boolVal',
      'structWithFieldCustomDefault',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = LateDefStruct()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = LateDefStructFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = LateDefStructEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = LateDefStructFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = LateDefStruct()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = LateDefStructFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = LateDefStructEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = LateDefStructFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructFieldPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructFieldPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class LateDefStructEnsureStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LateDefStructEnsureStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LateDefStructEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LateDefStructEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class RecursivePatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Recursive()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = RecursiveFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = RecursiveEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = RecursiveFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursivePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Recursive()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = RecursiveFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = RecursiveEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = RecursiveFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursivePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursivePatch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveField1Patch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.assign = {}
          (_ktype843, _vtype844, _size842 ) = iprot.readMapBegin() 
          if _size842 >= 0:
            for _i846 in range(_size842):
              _key847 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val848 = Recursive()
              _val848.read(iprot)
              self.assign[_key847] = _val848
          else: 
            while iprot.peekMap():
              _key849 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val850 = Recursive()
              _val850.read(iprot)
              self.assign[_key849] = _val850
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveField1Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.assign))
      for kiter851,viter852 in self.assign.items():
        oprot.writeString(kiter851.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter851, bytes) else oprot.writeString(kiter851)
        viter852.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = dict_cls()
      for _tmp_k853, _tmp_v854 in json_obj['assign'].items():
        _tmp_kp855 = _tmp_k853
        _struct856 = Recursive()
        _struct856.readFromJson(_tmp_v854, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.assign[_tmp_kp855] = _struct856
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveField1Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveField1Patch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveFieldPatch:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.nodes = RecursiveField1Patch()
          self.nodes.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveFieldPatch')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.STRUCT, -1)
      self.nodes.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = RecursiveField1Patch()
      self.nodes.readFromJson(json_obj['nodes'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class RecursiveEnsureStruct:
  r"""
  Attributes:
   - nodes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.MAP:
          self.nodes = {}
          (_ktype858, _vtype859, _size857 ) = iprot.readMapBegin() 
          if _size857 >= 0:
            for _i861 in range(_size857):
              _key862 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val863 = Recursive()
              _val863.read(iprot)
              self.nodes[_key862] = _val863
          else: 
            while iprot.peekMap():
              _key864 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val865 = Recursive()
              _val865.read(iprot)
              self.nodes[_key864] = _val865
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RecursiveEnsureStruct')
    if self.nodes != None:
      oprot.writeFieldBegin('nodes', TType.MAP, -1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.nodes))
      for kiter866,viter867 in self.nodes.items():
        oprot.writeString(kiter866.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter866, bytes) else oprot.writeString(kiter866)
        viter867.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'nodes' in json_obj and json_obj['nodes'] is not None:
      self.nodes = dict_cls()
      for _tmp_k868, _tmp_v869 in json_obj['nodes'].items():
        _tmp_kp870 = _tmp_k868
        _struct871 = Recursive()
        _struct871.readFromJson(_tmp_v869, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.nodes[_tmp_kp870] = _struct871

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.nodes is not None:
      value = pprint.pformat(self.nodes, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    nodes=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'nodes',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RecursiveEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RecursiveEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class BarPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
   - patchPrior: Patches any previously set values. Applies second.
   - ensure: Initialize fields, using the given defaults. Applies third.
   - patch: Patches any set value, including newly set values. Applies last.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Bar()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.patchPrior = BarFieldPatch()
          self.patchPrior.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.ensure = BarEnsureStruct()
          self.ensure.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.patch = BarFieldPatch()
          self.patch.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.patchPrior != None:
      oprot.writeFieldBegin('patchPrior', TType.STRUCT, 3)
      self.patchPrior.write(oprot)
      oprot.writeFieldEnd()
    if self.ensure != None:
      oprot.writeFieldBegin('ensure', TType.STRUCT, 5)
      self.ensure.write(oprot)
      oprot.writeFieldEnd()
    if self.patch != None:
      oprot.writeFieldBegin('patch', TType.STRUCT, 6)
      self.patch.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Bar()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'patchPrior' in json_obj and json_obj['patchPrior'] is not None:
      self.patchPrior = BarFieldPatch()
      self.patchPrior.readFromJson(json_obj['patchPrior'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'ensure' in json_obj and json_obj['ensure'] is not None:
      self.ensure = BarEnsureStruct()
      self.ensure.readFromJson(json_obj['ensure'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'patch' in json_obj and json_obj['patch'] is not None:
      self.patch = BarFieldPatch()
      self.patch.readFromJson(json_obj['patch'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.patchPrior is not None:
      value = pprint.pformat(self.patchPrior, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patchPrior=%s' % (value))
    if self.ensure is not None:
      value = pprint.pformat(self.ensure, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ensure=%s' % (value))
    if self.patch is not None:
      value = pprint.pformat(self.patch, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    patch=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'patchPrior',
      'ensure',
      'patch',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarPatch, self)

  def _to_py_deprecated(self):
    return self

class BarFieldPatch:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = LoopPatch()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarFieldPatch')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = LoopPatch()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarFieldPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarFieldPatch, self)

  def _to_py_deprecated(self):
    return self

class BarEnsureStruct:
  r"""
  Attributes:
   - loop
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == -1:
        if ftype == TType.STRUCT:
          self.loop = Loop()
          self.loop.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BarEnsureStruct')
    if self.loop != None:
      oprot.writeFieldBegin('loop', TType.STRUCT, -1)
      self.loop.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'loop' in json_obj and json_obj['loop'] is not None:
      self.loop = Loop()
      self.loop.readFromJson(json_obj['loop'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.loop is not None:
      value = pprint.pformat(self.loop, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    loop=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'loop',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BarEnsureStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BarEnsureStruct, self)

  def _to_py_deprecated(self):
    return self

class LoopPatch:
  r"""
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other operations are ignored.
  
  Note: Optional and union fields must be set before assigned.
  
   - clear: Clears a value. Applies first.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.assign = Loop()
          self.assign.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LoopPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRUCT, 1)
      self.assign.write(oprot)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = Loop()
      self.assign.readFromJson(json_obj['assign'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("test.fixtures.patch.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.LoopPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("test.fixtures.patch.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.LoopPatch, self)

  def _to_py_deprecated(self):
    return self

all_structs.append(MyData)
MyData.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 3, ), # 1
  (2, TType.I32, 'data2', None, None, 3, ), # 2
)

MyData.thrift_struct_annotations = {
}
MyData.thrift_field_annotations = {
}

def MyData__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyData.__init__ = MyData__init__

def MyData__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyData.__getstate__ = lambda self: self.__dict__.copy()
MyData.__setstate__ = MyData__setstate__

all_structs.append(MyDataWithCustomDefault)
MyDataWithCustomDefault.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, "1", 3, ), # 1
  (2, TType.I32, 'data2', None, 2, 3, ), # 2
)

MyDataWithCustomDefault.thrift_struct_annotations = {
}
MyDataWithCustomDefault.thrift_field_annotations = {
}

def MyDataWithCustomDefault__init__(self, data1=MyDataWithCustomDefault.thrift_spec[1][4], data2=MyDataWithCustomDefault.thrift_spec[2][4],):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefault.__init__ = MyDataWithCustomDefault__init__

def MyDataWithCustomDefault__setstate__(self, state):
  state.setdefault('data1', "1")
  state.setdefault('data2', 2)
  self.__dict__ = state

MyDataWithCustomDefault.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefault.__setstate__ = MyDataWithCustomDefault__setstate__

all_structs.append(InnerUnion)
InnerUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'innerOption', False, None, 2, ), # 1
)

InnerUnion.thrift_struct_annotations = {
}
InnerUnion.thrift_field_annotations = {
}

def InnerUnion__init__(self, innerOption=None,):
  self.field = 0
  self.value = None
  if innerOption is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = innerOption

InnerUnion.__init__ = InnerUnion__init__

all_structs.append(MyUnion)
MyUnion.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'option1', True, None, 2, ), # 1
  (2, TType.I32, 'option2', None, None, 2, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnion, InnerUnion.thrift_spec, True], None, 2, ), # 3
)

MyUnion.thrift_struct_annotations = {
}
MyUnion.thrift_field_annotations = {
}

def MyUnion__init__(self, option1=None, option2=None, option3=None,):
  self.field = 0
  self.value = None
  if option1 is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = option1
  if option2 is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = option2
  if option3 is not None:
    assert self.field == 0 and self.value is None
    self.field = 3
    self.value = option3

MyUnion.__init__ = MyUnion__init__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 3, ), # -32
  (-31, TType.I32, 'i32WithCustomDefault', None, 1, 3, ), # -31
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 3, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 3, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 3, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 3, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 3, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 3, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 3, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 3, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 3, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 3, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 3, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyData, MyData.thrift_spec, False], MyData(**{
    "data1" : "1",
    "data2" : 2,
  }), 3, ), # 1
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, boolVal=None, byteVal=None, i16Val=None, i32Val=None, i64Val=None, floatVal=None, doubleVal=None, stringVal=None, binaryVal=None, enumVal=None, structVal=None, unionVal=None, lateStructVal=None, optBoolVal=None, optByteVal=None, optI16Val=None, optI32Val=None, optI64Val=None, optFloatVal=None, optDoubleVal=None, optStringVal=None, optBinaryVal=None, optEnumVal=None, optStructVal=None, optLateStructVal=None, optListVal=None, optSetVal=None, optMapVal=None, listMap=None, mapMap=None, i32WithCustomDefault=MyStruct.thrift_spec[1][4], structWithCustomDefault=None, structWithFieldCustomDefault=MyStruct.thrift_spec[33][4],):
  self.boolVal = boolVal
  self.byteVal = byteVal
  self.i16Val = i16Val
  self.i32Val = i32Val
  self.i64Val = i64Val
  self.floatVal = floatVal
  self.doubleVal = doubleVal
  self.stringVal = stringVal
  self.binaryVal = binaryVal
  self.enumVal = enumVal
  self.structVal = structVal
  self.unionVal = unionVal
  self.lateStructVal = lateStructVal
  self.optBoolVal = optBoolVal
  self.optByteVal = optByteVal
  self.optI16Val = optI16Val
  self.optI32Val = optI32Val
  self.optI64Val = optI64Val
  self.optFloatVal = optFloatVal
  self.optDoubleVal = optDoubleVal
  self.optStringVal = optStringVal
  self.optBinaryVal = optBinaryVal
  self.optEnumVal = optEnumVal
  self.optStructVal = optStructVal
  self.optLateStructVal = optLateStructVal
  self.optListVal = optListVal
  self.optSetVal = optSetVal
  self.optMapVal = optMapVal
  self.listMap = listMap
  self.mapMap = mapMap
  self.i32WithCustomDefault = i32WithCustomDefault
  self.structWithCustomDefault = structWithCustomDefault
  if structWithFieldCustomDefault is self.thrift_spec[33][4]:
    structWithFieldCustomDefault = MyData(**{
    "data1" : "1",
    "data2" : 2,
  })
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('boolVal', None)
  state.setdefault('byteVal', None)
  state.setdefault('i16Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i64Val', None)
  state.setdefault('floatVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('structVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optMapVal', None)
  state.setdefault('listMap', None)
  state.setdefault('mapMap', None)
  state.setdefault('i32WithCustomDefault', 1)
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('structWithFieldCustomDefault', MyData(**{
    "data1" : "1",
    "data2" : 2,
  }))
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(LateDefStruct)
LateDefStruct.thrift_spec = (
)

LateDefStruct.thrift_struct_annotations = {
}
LateDefStruct.thrift_field_annotations = {
}

all_structs.append(Recursive)
Recursive.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 3, ), # -1
)

Recursive.thrift_struct_annotations = {
}
Recursive.thrift_field_annotations = {
}

def Recursive__init__(self, nodes=None,):
  self.nodes = nodes

Recursive.__init__ = Recursive__init__

def Recursive__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

Recursive.__getstate__ = lambda self: self.__dict__.copy()
Recursive.__setstate__ = Recursive__setstate__

all_structs.append(Bar)
Bar.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 3, ), # -1
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
  -1: {
    "cpp.ref": "1",
  },
}

def Bar__init__(self, loop=None,):
  self.loop = loop

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(Loop)
Loop.thrift_spec = (
  (-1, TType.STRUCT, 'bar', [Bar, Bar.thrift_spec, False], None, 3, ), # -1
)

Loop.thrift_struct_annotations = {
}
Loop.thrift_field_annotations = {
}

def Loop__init__(self, bar=None,):
  self.bar = bar

Loop.__init__ = Loop__init__

def Loop__setstate__(self, state):
  state.setdefault('bar', None)
  self.__dict__ = state

Loop.__getstate__ = lambda self: self.__dict__.copy()
Loop.__setstate__ = Loop__setstate__

all_structs.append(MyDataPatch)
MyDataPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyDataEnsureStruct, MyDataEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataFieldPatch, MyDataFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyDataPatch.thrift_struct_annotations = {
}
MyDataPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyDataPatch.__init__ = MyDataPatch__init__

def MyDataPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyDataPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataPatch.__setstate__ = MyDataPatch__setstate__

all_structs.append(MyDataFieldPatch)
MyDataFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
)

MyDataFieldPatch.thrift_struct_annotations = {
}
MyDataFieldPatch.thrift_field_annotations = {
}

def MyDataFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataFieldPatch.__init__ = MyDataFieldPatch__init__

def MyDataFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataFieldPatch.__setstate__ = MyDataFieldPatch__setstate__

all_structs.append(MyDataEnsureStruct)
MyDataEnsureStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 1, ), # 1
  (2, TType.I32, 'data2', None, None, 1, ), # 2
)

MyDataEnsureStruct.thrift_struct_annotations = {
}
MyDataEnsureStruct.thrift_field_annotations = {
}

def MyDataEnsureStruct__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataEnsureStruct.__init__ = MyDataEnsureStruct__init__

def MyDataEnsureStruct__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyDataEnsureStruct.__setstate__ = MyDataEnsureStruct__setstate__

all_structs.append(MyDataWithCustomDefaultPatch)
MyDataWithCustomDefaultPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyDataWithCustomDefaultFieldPatch, MyDataWithCustomDefaultFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyDataWithCustomDefaultEnsureStruct, MyDataWithCustomDefaultEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyDataWithCustomDefaultFieldPatch, MyDataWithCustomDefaultFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyDataWithCustomDefaultPatch.thrift_struct_annotations = {
}
MyDataWithCustomDefaultPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyDataWithCustomDefaultPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyDataWithCustomDefaultPatch.__init__ = MyDataWithCustomDefaultPatch__init__

def MyDataWithCustomDefaultPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyDataWithCustomDefaultPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultPatch.__setstate__ = MyDataWithCustomDefaultPatch__setstate__

all_structs.append(MyDataWithCustomDefaultFieldPatch)
MyDataWithCustomDefaultFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'data1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'data2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
)

MyDataWithCustomDefaultFieldPatch.thrift_struct_annotations = {
}
MyDataWithCustomDefaultFieldPatch.thrift_field_annotations = {
}

def MyDataWithCustomDefaultFieldPatch__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefaultFieldPatch.__init__ = MyDataWithCustomDefaultFieldPatch__init__

def MyDataWithCustomDefaultFieldPatch__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataWithCustomDefaultFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultFieldPatch.__setstate__ = MyDataWithCustomDefaultFieldPatch__setstate__

all_structs.append(MyDataWithCustomDefaultEnsureStruct)
MyDataWithCustomDefaultEnsureStruct.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'data1', True, None, 1, ), # 1
  (2, TType.I32, 'data2', None, None, 1, ), # 2
)

MyDataWithCustomDefaultEnsureStruct.thrift_struct_annotations = {
}
MyDataWithCustomDefaultEnsureStruct.thrift_field_annotations = {
}

def MyDataWithCustomDefaultEnsureStruct__init__(self, data1=None, data2=None,):
  self.data1 = data1
  self.data2 = data2

MyDataWithCustomDefaultEnsureStruct.__init__ = MyDataWithCustomDefaultEnsureStruct__init__

def MyDataWithCustomDefaultEnsureStruct__setstate__(self, state):
  state.setdefault('data1', None)
  state.setdefault('data2', None)
  self.__dict__ = state

MyDataWithCustomDefaultEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyDataWithCustomDefaultEnsureStruct.__setstate__ = MyDataWithCustomDefaultEnsureStruct__setstate__

all_structs.append(InnerUnionPatch)
InnerUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [InnerUnion, InnerUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [InnerUnion, InnerUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [InnerUnionFieldPatch, InnerUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

InnerUnionPatch.thrift_struct_annotations = {
}
InnerUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def InnerUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

InnerUnionPatch.__init__ = InnerUnionPatch__init__

def InnerUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

InnerUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionPatch.__setstate__ = InnerUnionPatch__setstate__

all_structs.append(InnerUnionFieldPatch)
InnerUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'innerOption', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # 1
)

InnerUnionFieldPatch.thrift_struct_annotations = {
}
InnerUnionFieldPatch.thrift_field_annotations = {
}

def InnerUnionFieldPatch__init__(self, innerOption=None,):
  self.innerOption = innerOption

InnerUnionFieldPatch.__init__ = InnerUnionFieldPatch__init__

def InnerUnionFieldPatch__setstate__(self, state):
  state.setdefault('innerOption', None)
  self.__dict__ = state

InnerUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
InnerUnionFieldPatch.__setstate__ = InnerUnionFieldPatch__setstate__

all_structs.append(MyUnionPatch)
MyUnionPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 3
  (4, TType.STRUCT, 'ensure', [MyUnion, MyUnion.thrift_spec, True], None, 3, ), # 4
  None, # 5
  (6, TType.STRUCT, 'patch', [MyUnionFieldPatch, MyUnionFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyUnionPatch.thrift_struct_annotations = {
}
MyUnionPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyUnionPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyUnionPatch.__init__ = MyUnionPatch__init__

def MyUnionPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyUnionPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionPatch.__setstate__ = MyUnionPatch__setstate__

all_structs.append(MyUnionFieldPatch)
MyUnionFieldPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'option1', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # 1
  (2, TType.STRUCT, 'option2', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # 2
  (3, TType.STRUCT, 'option3', [InnerUnionPatch, InnerUnionPatch.thrift_spec, False], None, 3, ), # 3
)

MyUnionFieldPatch.thrift_struct_annotations = {
}
MyUnionFieldPatch.thrift_field_annotations = {
}

def MyUnionFieldPatch__init__(self, option1=None, option2=None, option3=None,):
  self.option1 = option1
  self.option2 = option2
  self.option3 = option3

MyUnionFieldPatch.__init__ = MyUnionFieldPatch__init__

def MyUnionFieldPatch__setstate__(self, state):
  state.setdefault('option1', None)
  state.setdefault('option2', None)
  state.setdefault('option3', None)
  self.__dict__ = state

MyUnionFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyUnionFieldPatch.__setstate__ = MyUnionFieldPatch__setstate__

all_structs.append(MyStructPatch)
MyStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [MyStruct, MyStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [MyStructEnsureStruct, MyStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [MyStructFieldPatch, MyStructFieldPatch.thrift_spec, False], None, 3, ), # 6
)

MyStructPatch.thrift_struct_annotations = {
}
MyStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def MyStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

MyStructPatch.__init__ = MyStructPatch__init__

def MyStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

MyStructPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructPatch.__setstate__ = MyStructPatch__setstate__

all_structs.append(MyStructField10Patch)
MyStructField10Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField10Patch.thrift_struct_annotations = {
}
MyStructField10Patch.thrift_field_annotations = {
}

def MyStructField10Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField10Patch.__init__ = MyStructField10Patch__init__

def MyStructField10Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField10Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField10Patch.__setstate__ = MyStructField10Patch__setstate__

all_structs.append(MyStructField23Patch)
MyStructField23Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', MyEnum, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

MyStructField23Patch.thrift_struct_annotations = {
}
MyStructField23Patch.thrift_field_annotations = {
}

def MyStructField23Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

MyStructField23Patch.__init__ = MyStructField23Patch__init__

def MyStructField23Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

MyStructField23Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField23Patch.__setstate__ = MyStructField23Patch__setstate__

all_structs.append(MyStructField26Patch)
MyStructField26Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.I16,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.LIST, 'remove', (TType.I16,None), None, 3, ), # 7
  (8, TType.LIST, 'prepend', (TType.I16,None), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.I16,None), None, 3, ), # 9
)

MyStructField26Patch.thrift_struct_annotations = {
}
MyStructField26Patch.thrift_field_annotations = {
}

def MyStructField26Patch__init__(self, assign=None, clear=None, patch=None, remove=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.remove = remove
  self.prepend = prepend
  self.append = append

MyStructField26Patch.__init__ = MyStructField26Patch__init__

def MyStructField26Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField26Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField26Patch.__setstate__ = MyStructField26Patch__setstate__

all_structs.append(MyStructField27Patch)
MyStructField27Patch.thrift_spec = (
  None, # 0
  (1, TType.SET, 'assign', (TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  (8, TType.SET, 'add', (TType.STRING,True), None, 3, ), # 8
)

MyStructField27Patch.thrift_struct_annotations = {
}
MyStructField27Patch.thrift_field_annotations = {
}

def MyStructField27Patch__init__(self, assign=None, clear=None, remove=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.remove = remove
  self.add = add

MyStructField27Patch.__init__ = MyStructField27Patch__init__

def MyStructField27Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('remove', None)
  state.setdefault('add', None)
  self.__dict__ = state

MyStructField27Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField27Patch.__setstate__ = MyStructField27Patch__setstate__

all_structs.append(MyStructField28Patch)
MyStructField28Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRING,True), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.STRING,True), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.STRING,True), None, 3, ), # 9
)

MyStructField28Patch.thrift_struct_annotations = {
}
MyStructField28Patch.thrift_field_annotations = {
}

def MyStructField28Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField28Patch.__init__ = MyStructField28Patch__init__

def MyStructField28Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField28Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField28Patch.__setstate__ = MyStructField28Patch__setstate__

all_structs.append(MyStructField29Patch)
MyStructField29Patch.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'assign', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patch', (TType.I32,None,TType.STRUCT,[MyStructField29Patch1, MyStructField29Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  None, # 5
  None, # 6
  (7, TType.LIST, 'remove', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 7
  (8, TType.LIST, 'prepend', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 8
  (9, TType.LIST, 'append', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField29Patch.thrift_struct_annotations = {
}
MyStructField29Patch.thrift_field_annotations = {
}

def MyStructField29Patch__init__(self, assign=None, clear=None, patch=None, remove=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.patch = patch
  self.remove = remove
  self.prepend = prepend
  self.append = append

MyStructField29Patch.__init__ = MyStructField29Patch__init__

def MyStructField29Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

MyStructField29Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch.__setstate__ = MyStructField29Patch__setstate__

all_structs.append(MyStructField29Patch1)
MyStructField29Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField29Patch1.thrift_struct_annotations = {
}
MyStructField29Patch1.thrift_field_annotations = {
}

def MyStructField29Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField29Patch1.__init__ = MyStructField29Patch1__init__

def MyStructField29Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField29Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField29Patch1.__setstate__ = MyStructField29Patch1__setstate__

all_structs.append(MyStructField30Patch)
MyStructField30Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[MyStructField30Patch1, MyStructField30Patch1.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 3, ), # 9
)

MyStructField30Patch.thrift_struct_annotations = {
}
MyStructField30Patch.thrift_field_annotations = {
}

def MyStructField30Patch__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch.__init__ = MyStructField30Patch__init__

def MyStructField30Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch.__setstate__ = MyStructField30Patch__setstate__

all_structs.append(MyStructField30Patch1)
MyStructField30Patch1.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.I32,None), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.MAP, 'patchPrior', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 3
  None, # 4
  (5, TType.MAP, 'add', (TType.STRING,True,TType.I32,None), None, 3, ), # 5
  (6, TType.MAP, 'patch', (TType.STRING,True,TType.STRUCT,[thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False]), None, 3, ), # 6
  (7, TType.SET, 'remove', (TType.STRING,True), None, 3, ), # 7
  None, # 8
  (9, TType.MAP, 'put', (TType.STRING,True,TType.I32,None), None, 3, ), # 9
)

MyStructField30Patch1.thrift_struct_annotations = {
}
MyStructField30Patch1.thrift_field_annotations = {
}

def MyStructField30Patch1__init__(self, assign=None, clear=None, patchPrior=None, add=None, patch=None, remove=None, put=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.add = add
  self.patch = patch
  self.remove = remove
  self.put = put

MyStructField30Patch1.__init__ = MyStructField30Patch1__init__

def MyStructField30Patch1__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('add', None)
  state.setdefault('patch', None)
  state.setdefault('remove', None)
  state.setdefault('put', None)
  self.__dict__ = state

MyStructField30Patch1.__getstate__ = lambda self: self.__dict__.copy()
MyStructField30Patch1.__setstate__ = MyStructField30Patch1__setstate__

all_structs.append(MyStructFieldPatch)
MyStructFieldPatch.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefaultPatch, MyDataWithCustomDefaultPatch.thrift_spec, False], None, 3, ), # -32
  (-31, TType.STRUCT, 'i32WithCustomDefault', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -31
  (-30, TType.STRUCT, 'mapMap', [MyStructField30Patch, MyStructField30Patch.thrift_spec, False], None, 3, ), # -30
  (-29, TType.STRUCT, 'listMap', [MyStructField29Patch, MyStructField29Patch.thrift_spec, False], None, 3, ), # -29
  (-28, TType.STRUCT, 'optMapVal', [MyStructField28Patch, MyStructField28Patch.thrift_spec, False], None, 3, ), # -28
  (-27, TType.STRUCT, 'optSetVal', [MyStructField27Patch, MyStructField27Patch.thrift_spec, False], None, 3, ), # -27
  (-26, TType.STRUCT, 'optListVal', [MyStructField26Patch, MyStructField26Patch.thrift_spec, False], None, 3, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -24
  (-23, TType.STRUCT, 'optEnumVal', [MyStructField23Patch, MyStructField23Patch.thrift_spec, False], None, 3, ), # -23
  (-22, TType.STRUCT, 'optBinaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -22
  (-21, TType.STRUCT, 'optStringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -21
  (-20, TType.STRUCT, 'optDoubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -20
  (-19, TType.STRUCT, 'optFloatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -19
  (-18, TType.STRUCT, 'optI64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -18
  (-17, TType.STRUCT, 'optI32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -17
  (-16, TType.STRUCT, 'optI16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -16
  (-15, TType.STRUCT, 'optByteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -15
  (-14, TType.STRUCT, 'optBoolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStructPatch, LateDefStructPatch.thrift_spec, False], None, 3, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnionPatch, MyUnionPatch.thrift_spec, False], None, 3, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # -11
  (-10, TType.STRUCT, 'enumVal', [MyStructField10Patch, MyStructField10Patch.thrift_spec, False], None, 3, ), # -10
  (-9, TType.STRUCT, 'binaryVal', [thrift.lib.thrift.patch.ttypes.BinaryPatch, thrift.lib.thrift.patch.ttypes.BinaryPatch.thrift_spec, False], None, 3, ), # -9
  (-8, TType.STRUCT, 'stringVal', [thrift.lib.thrift.patch.ttypes.StringPatch, thrift.lib.thrift.patch.ttypes.StringPatch.thrift_spec, False], None, 3, ), # -8
  (-7, TType.STRUCT, 'doubleVal', [thrift.lib.thrift.patch.ttypes.DoublePatch, thrift.lib.thrift.patch.ttypes.DoublePatch.thrift_spec, False], None, 3, ), # -7
  (-6, TType.STRUCT, 'floatVal', [thrift.lib.thrift.patch.ttypes.FloatPatch, thrift.lib.thrift.patch.ttypes.FloatPatch.thrift_spec, False], None, 3, ), # -6
  (-5, TType.STRUCT, 'i64Val', [thrift.lib.thrift.patch.ttypes.I64Patch, thrift.lib.thrift.patch.ttypes.I64Patch.thrift_spec, False], None, 3, ), # -5
  (-4, TType.STRUCT, 'i32Val', [thrift.lib.thrift.patch.ttypes.I32Patch, thrift.lib.thrift.patch.ttypes.I32Patch.thrift_spec, False], None, 3, ), # -4
  (-3, TType.STRUCT, 'i16Val', [thrift.lib.thrift.patch.ttypes.I16Patch, thrift.lib.thrift.patch.ttypes.I16Patch.thrift_spec, False], None, 3, ), # -3
  (-2, TType.STRUCT, 'byteVal', [thrift.lib.thrift.patch.ttypes.BytePatch, thrift.lib.thrift.patch.ttypes.BytePatch.thrift_spec, False], None, 3, ), # -2
  (-1, TType.STRUCT, 'boolVal', [thrift.lib.thrift.patch.ttypes.BoolPatch, thrift.lib.thrift.patch.ttypes.BoolPatch.thrift_spec, False], None, 3, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyDataPatch, MyDataPatch.thrift_spec, False], None, 3, ), # 1
)

MyStructFieldPatch.thrift_struct_annotations = {
}
MyStructFieldPatch.thrift_field_annotations = {
}

def MyStructFieldPatch__init__(self, structWithCustomDefault=None, i32WithCustomDefault=None, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None, structWithFieldCustomDefault=None,):
  self.structWithCustomDefault = structWithCustomDefault
  self.i32WithCustomDefault = i32WithCustomDefault
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStructFieldPatch.__init__ = MyStructFieldPatch__init__

def MyStructFieldPatch__setstate__(self, state):
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('i32WithCustomDefault', None)
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  state.setdefault('structWithFieldCustomDefault', None)
  self.__dict__ = state

MyStructFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
MyStructFieldPatch.__setstate__ = MyStructFieldPatch__setstate__

all_structs.append(MyStructEnsureStruct)
MyStructEnsureStruct.thrift_spec = (
  (-32, TType.STRUCT, 'structWithCustomDefault', [MyDataWithCustomDefault, MyDataWithCustomDefault.thrift_spec, False], None, 1, ), # -32
  (-31, TType.I32, 'i32WithCustomDefault', None, None, 1, ), # -31
  (-30, TType.MAP, 'mapMap', (TType.STRING,True,TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -30
  (-29, TType.LIST, 'listMap', (TType.MAP,(TType.STRING,True,TType.I32,None)), None, 1, ), # -29
  (-28, TType.MAP, 'optMapVal', (TType.STRING,True,TType.STRING,True), None, 1, ), # -28
  (-27, TType.SET, 'optSetVal', (TType.STRING,True), None, 1, ), # -27
  (-26, TType.LIST, 'optListVal', (TType.I16,None), None, 1, ), # -26
  (-25, TType.STRUCT, 'optLateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -25
  (-24, TType.STRUCT, 'optStructVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -24
  (-23, TType.I32, 'optEnumVal', MyEnum, None, 1, ), # -23
  (-22, TType.STRING, 'optBinaryVal', False, None, 1, ), # -22
  (-21, TType.STRING, 'optStringVal', True, None, 1, ), # -21
  (-20, TType.DOUBLE, 'optDoubleVal', None, None, 1, ), # -20
  (-19, TType.FLOAT, 'optFloatVal', None, None, 1, ), # -19
  (-18, TType.I64, 'optI64Val', None, None, 1, ), # -18
  (-17, TType.I32, 'optI32Val', None, None, 1, ), # -17
  (-16, TType.I16, 'optI16Val', None, None, 1, ), # -16
  (-15, TType.BYTE, 'optByteVal', None, None, 1, ), # -15
  (-14, TType.BOOL, 'optBoolVal', None, None, 1, ), # -14
  (-13, TType.STRUCT, 'lateStructVal', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # -13
  (-12, TType.STRUCT, 'unionVal', [MyUnion, MyUnion.thrift_spec, True], None, 1, ), # -12
  (-11, TType.STRUCT, 'structVal', [MyData, MyData.thrift_spec, False], None, 1, ), # -11
  (-10, TType.I32, 'enumVal', MyEnum, None, 1, ), # -10
  (-9, TType.STRING, 'binaryVal', False, None, 1, ), # -9
  (-8, TType.STRING, 'stringVal', True, None, 1, ), # -8
  (-7, TType.DOUBLE, 'doubleVal', None, None, 1, ), # -7
  (-6, TType.FLOAT, 'floatVal', None, None, 1, ), # -6
  (-5, TType.I64, 'i64Val', None, None, 1, ), # -5
  (-4, TType.I32, 'i32Val', None, None, 1, ), # -4
  (-3, TType.I16, 'i16Val', None, None, 1, ), # -3
  (-2, TType.BYTE, 'byteVal', None, None, 1, ), # -2
  (-1, TType.BOOL, 'boolVal', None, None, 1, ), # -1
  None, # 0
  (1, TType.STRUCT, 'structWithFieldCustomDefault', [MyData, MyData.thrift_spec, False], None, 1, ), # 1
)

MyStructEnsureStruct.thrift_struct_annotations = {
}
MyStructEnsureStruct.thrift_field_annotations = {
  -32: {
    "thrift.box": "",
  },
  -25: {
    "thrift.box": "",
  },
  -24: {
    "thrift.box": "",
  },
  -13: {
    "thrift.box": "",
  },
  -12: {
    "thrift.box": "",
  },
  -11: {
    "thrift.box": "",
  },
  1: {
    "thrift.box": "",
  },
}

def MyStructEnsureStruct__init__(self, structWithCustomDefault=None, i32WithCustomDefault=None, mapMap=None, listMap=None, optMapVal=None, optSetVal=None, optListVal=None, optLateStructVal=None, optStructVal=None, optEnumVal=None, optBinaryVal=None, optStringVal=None, optDoubleVal=None, optFloatVal=None, optI64Val=None, optI32Val=None, optI16Val=None, optByteVal=None, optBoolVal=None, lateStructVal=None, unionVal=None, structVal=None, enumVal=None, binaryVal=None, stringVal=None, doubleVal=None, floatVal=None, i64Val=None, i32Val=None, i16Val=None, byteVal=None, boolVal=None, structWithFieldCustomDefault=None,):
  self.structWithCustomDefault = structWithCustomDefault
  self.i32WithCustomDefault = i32WithCustomDefault
  self.mapMap = mapMap
  self.listMap = listMap
  self.optMapVal = optMapVal
  self.optSetVal = optSetVal
  self.optListVal = optListVal
  self.optLateStructVal = optLateStructVal
  self.optStructVal = optStructVal
  self.optEnumVal = optEnumVal
  self.optBinaryVal = optBinaryVal
  self.optStringVal = optStringVal
  self.optDoubleVal = optDoubleVal
  self.optFloatVal = optFloatVal
  self.optI64Val = optI64Val
  self.optI32Val = optI32Val
  self.optI16Val = optI16Val
  self.optByteVal = optByteVal
  self.optBoolVal = optBoolVal
  self.lateStructVal = lateStructVal
  self.unionVal = unionVal
  self.structVal = structVal
  self.enumVal = enumVal
  self.binaryVal = binaryVal
  self.stringVal = stringVal
  self.doubleVal = doubleVal
  self.floatVal = floatVal
  self.i64Val = i64Val
  self.i32Val = i32Val
  self.i16Val = i16Val
  self.byteVal = byteVal
  self.boolVal = boolVal
  self.structWithFieldCustomDefault = structWithFieldCustomDefault

MyStructEnsureStruct.__init__ = MyStructEnsureStruct__init__

def MyStructEnsureStruct__setstate__(self, state):
  state.setdefault('structWithCustomDefault', None)
  state.setdefault('i32WithCustomDefault', None)
  state.setdefault('mapMap', None)
  state.setdefault('listMap', None)
  state.setdefault('optMapVal', None)
  state.setdefault('optSetVal', None)
  state.setdefault('optListVal', None)
  state.setdefault('optLateStructVal', None)
  state.setdefault('optStructVal', None)
  state.setdefault('optEnumVal', None)
  state.setdefault('optBinaryVal', None)
  state.setdefault('optStringVal', None)
  state.setdefault('optDoubleVal', None)
  state.setdefault('optFloatVal', None)
  state.setdefault('optI64Val', None)
  state.setdefault('optI32Val', None)
  state.setdefault('optI16Val', None)
  state.setdefault('optByteVal', None)
  state.setdefault('optBoolVal', None)
  state.setdefault('lateStructVal', None)
  state.setdefault('unionVal', None)
  state.setdefault('structVal', None)
  state.setdefault('enumVal', None)
  state.setdefault('binaryVal', None)
  state.setdefault('stringVal', None)
  state.setdefault('doubleVal', None)
  state.setdefault('floatVal', None)
  state.setdefault('i64Val', None)
  state.setdefault('i32Val', None)
  state.setdefault('i16Val', None)
  state.setdefault('byteVal', None)
  state.setdefault('boolVal', None)
  state.setdefault('structWithFieldCustomDefault', None)
  self.__dict__ = state

MyStructEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStructEnsureStruct.__setstate__ = MyStructEnsureStruct__setstate__

all_structs.append(LateDefStructPatch)
LateDefStructPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [LateDefStruct, LateDefStruct.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [LateDefStructEnsureStruct, LateDefStructEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [LateDefStructFieldPatch, LateDefStructFieldPatch.thrift_spec, False], None, 3, ), # 6
)

LateDefStructPatch.thrift_struct_annotations = {
}
LateDefStructPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LateDefStructPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

LateDefStructPatch.__init__ = LateDefStructPatch__init__

def LateDefStructPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

LateDefStructPatch.__getstate__ = lambda self: self.__dict__.copy()
LateDefStructPatch.__setstate__ = LateDefStructPatch__setstate__

all_structs.append(LateDefStructFieldPatch)
LateDefStructFieldPatch.thrift_spec = (
)

LateDefStructFieldPatch.thrift_struct_annotations = {
}
LateDefStructFieldPatch.thrift_field_annotations = {
}

all_structs.append(LateDefStructEnsureStruct)
LateDefStructEnsureStruct.thrift_spec = (
)

LateDefStructEnsureStruct.thrift_struct_annotations = {
}
LateDefStructEnsureStruct.thrift_field_annotations = {
}

all_structs.append(RecursivePatch)
RecursivePatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Recursive, Recursive.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [RecursiveEnsureStruct, RecursiveEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [RecursiveFieldPatch, RecursiveFieldPatch.thrift_spec, False], None, 3, ), # 6
)

RecursivePatch.thrift_struct_annotations = {
}
RecursivePatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def RecursivePatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

RecursivePatch.__init__ = RecursivePatch__init__

def RecursivePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

RecursivePatch.__getstate__ = lambda self: self.__dict__.copy()
RecursivePatch.__setstate__ = RecursivePatch__setstate__

all_structs.append(RecursiveField1Patch)
RecursiveField1Patch.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'assign', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

RecursiveField1Patch.thrift_struct_annotations = {
}
RecursiveField1Patch.thrift_field_annotations = {
}

def RecursiveField1Patch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

RecursiveField1Patch.__init__ = RecursiveField1Patch__init__

def RecursiveField1Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

RecursiveField1Patch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveField1Patch.__setstate__ = RecursiveField1Patch__setstate__

all_structs.append(RecursiveFieldPatch)
RecursiveFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'nodes', [RecursiveField1Patch, RecursiveField1Patch.thrift_spec, False], None, 3, ), # -1
)

RecursiveFieldPatch.thrift_struct_annotations = {
}
RecursiveFieldPatch.thrift_field_annotations = {
}

def RecursiveFieldPatch__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveFieldPatch.__init__ = RecursiveFieldPatch__init__

def RecursiveFieldPatch__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
RecursiveFieldPatch.__setstate__ = RecursiveFieldPatch__setstate__

all_structs.append(RecursiveEnsureStruct)
RecursiveEnsureStruct.thrift_spec = (
  (-1, TType.MAP, 'nodes', (TType.STRING,True,TType.STRUCT,[Recursive, Recursive.thrift_spec, False]), None, 1, ), # -1
)

RecursiveEnsureStruct.thrift_struct_annotations = {
}
RecursiveEnsureStruct.thrift_field_annotations = {
}

def RecursiveEnsureStruct__init__(self, nodes=None,):
  self.nodes = nodes

RecursiveEnsureStruct.__init__ = RecursiveEnsureStruct__init__

def RecursiveEnsureStruct__setstate__(self, state):
  state.setdefault('nodes', None)
  self.__dict__ = state

RecursiveEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
RecursiveEnsureStruct.__setstate__ = RecursiveEnsureStruct__setstate__

all_structs.append(BarPatch)
BarPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Bar, Bar.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  (3, TType.STRUCT, 'patchPrior', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 3
  None, # 4
  (5, TType.STRUCT, 'ensure', [BarEnsureStruct, BarEnsureStruct.thrift_spec, False], None, 3, ), # 5
  (6, TType.STRUCT, 'patch', [BarFieldPatch, BarFieldPatch.thrift_spec, False], None, 3, ), # 6
)

BarPatch.thrift_struct_annotations = {
}
BarPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def BarPatch__init__(self, assign=None, clear=None, patchPrior=None, ensure=None, patch=None,):
  self.assign = assign
  self.clear = clear
  self.patchPrior = patchPrior
  self.ensure = ensure
  self.patch = patch

BarPatch.__init__ = BarPatch__init__

def BarPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('patchPrior', None)
  state.setdefault('ensure', None)
  state.setdefault('patch', None)
  self.__dict__ = state

BarPatch.__getstate__ = lambda self: self.__dict__.copy()
BarPatch.__setstate__ = BarPatch__setstate__

all_structs.append(BarFieldPatch)
BarFieldPatch.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [LoopPatch, LoopPatch.thrift_spec, False], None, 3, ), # -1
)

BarFieldPatch.thrift_struct_annotations = {
}
BarFieldPatch.thrift_field_annotations = {
}

def BarFieldPatch__init__(self, loop=None,):
  self.loop = loop

BarFieldPatch.__init__ = BarFieldPatch__init__

def BarFieldPatch__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarFieldPatch.__getstate__ = lambda self: self.__dict__.copy()
BarFieldPatch.__setstate__ = BarFieldPatch__setstate__

all_structs.append(BarEnsureStruct)
BarEnsureStruct.thrift_spec = (
  (-1, TType.STRUCT, 'loop', [Loop, Loop.thrift_spec, False], None, 1, ), # -1
)

BarEnsureStruct.thrift_struct_annotations = {
}
BarEnsureStruct.thrift_field_annotations = {
  -1: {
    "thrift.box": "",
  },
}

def BarEnsureStruct__init__(self, loop=None,):
  self.loop = loop

BarEnsureStruct.__init__ = BarEnsureStruct__init__

def BarEnsureStruct__setstate__(self, state):
  state.setdefault('loop', None)
  self.__dict__ = state

BarEnsureStruct.__getstate__ = lambda self: self.__dict__.copy()
BarEnsureStruct.__setstate__ = BarEnsureStruct__setstate__

all_structs.append(LoopPatch)
LoopPatch.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'assign', [Loop, Loop.thrift_spec, False], None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
)

LoopPatch.thrift_struct_annotations = {
}
LoopPatch.thrift_field_annotations = {
  1: {
    "thrift.box": "",
  },
}

def LoopPatch__init__(self, assign=None, clear=None,):
  self.assign = assign
  self.clear = clear

LoopPatch.__init__ = LoopPatch__init__

def LoopPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  self.__dict__ = state

LoopPatch.__getstate__ = lambda self: self.__dict__.copy()
LoopPatch.__setstate__ = LoopPatch__setstate__

fix_spec(all_structs)
del all_structs
