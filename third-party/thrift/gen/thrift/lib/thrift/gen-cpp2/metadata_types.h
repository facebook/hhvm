/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>



namespace apache {
namespace thrift {
namespace tag {
struct valueType;
struct valueType;
struct keyType;
struct valueType;
struct name;
struct name;
struct name;
struct name;
struct underlyingType;
struct elemType;
struct initialResponseType;
struct elemType;
struct finalResponseType;
struct initialResponseType;
struct t_primitive;
struct t_list;
struct t_set;
struct t_map;
struct t_enum;
struct t_struct;
struct t_union;
struct t_typedef;
struct t_stream;
struct t_sink;
struct name;
struct elements;
struct id;
struct type;
struct name;
struct is_optional;
struct name;
struct fields;
struct is_union;
struct name;
struct fields;
struct name;
struct returnType;
struct arguments;
struct exceptions;
struct name;
struct functions;
struct parent;
struct name;
struct service_info;
struct module;
struct enums;
struct structs;
struct exceptions;
struct services;
struct context;
struct metadata;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_keyType
#define APACHE_THRIFT_ACCESSOR_keyType
APACHE_THRIFT_DEFINE_ACCESSOR(keyType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_valueType
#define APACHE_THRIFT_ACCESSOR_valueType
APACHE_THRIFT_DEFINE_ACCESSOR(valueType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_underlyingType
#define APACHE_THRIFT_ACCESSOR_underlyingType
APACHE_THRIFT_DEFINE_ACCESSOR(underlyingType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elemType
#define APACHE_THRIFT_ACCESSOR_elemType
APACHE_THRIFT_DEFINE_ACCESSOR(elemType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_initialResponseType
#define APACHE_THRIFT_ACCESSOR_initialResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(initialResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elemType
#define APACHE_THRIFT_ACCESSOR_elemType
APACHE_THRIFT_DEFINE_ACCESSOR(elemType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_finalResponseType
#define APACHE_THRIFT_ACCESSOR_finalResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(finalResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_initialResponseType
#define APACHE_THRIFT_ACCESSOR_initialResponseType
APACHE_THRIFT_DEFINE_ACCESSOR(initialResponseType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_primitive
#define APACHE_THRIFT_ACCESSOR_t_primitive
APACHE_THRIFT_DEFINE_ACCESSOR(t_primitive);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_list
#define APACHE_THRIFT_ACCESSOR_t_list
APACHE_THRIFT_DEFINE_ACCESSOR(t_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_set
#define APACHE_THRIFT_ACCESSOR_t_set
APACHE_THRIFT_DEFINE_ACCESSOR(t_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_map
#define APACHE_THRIFT_ACCESSOR_t_map
APACHE_THRIFT_DEFINE_ACCESSOR(t_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_enum
#define APACHE_THRIFT_ACCESSOR_t_enum
APACHE_THRIFT_DEFINE_ACCESSOR(t_enum);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_struct
#define APACHE_THRIFT_ACCESSOR_t_struct
APACHE_THRIFT_DEFINE_ACCESSOR(t_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_union
#define APACHE_THRIFT_ACCESSOR_t_union
APACHE_THRIFT_DEFINE_ACCESSOR(t_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_typedef
#define APACHE_THRIFT_ACCESSOR_t_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(t_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_stream
#define APACHE_THRIFT_ACCESSOR_t_stream
APACHE_THRIFT_DEFINE_ACCESSOR(t_stream);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_t_sink
#define APACHE_THRIFT_ACCESSOR_t_sink
APACHE_THRIFT_DEFINE_ACCESSOR(t_sink);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_elements
#define APACHE_THRIFT_ACCESSOR_elements
APACHE_THRIFT_DEFINE_ACCESSOR(elements);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_id
#define APACHE_THRIFT_ACCESSOR_id
APACHE_THRIFT_DEFINE_ACCESSOR(id);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_type
#define APACHE_THRIFT_ACCESSOR_type
APACHE_THRIFT_DEFINE_ACCESSOR(type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_optional
#define APACHE_THRIFT_ACCESSOR_is_optional
APACHE_THRIFT_DEFINE_ACCESSOR(is_optional);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_is_union
#define APACHE_THRIFT_ACCESSOR_is_union
APACHE_THRIFT_DEFINE_ACCESSOR(is_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fields
#define APACHE_THRIFT_ACCESSOR_fields
APACHE_THRIFT_DEFINE_ACCESSOR(fields);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_returnType
#define APACHE_THRIFT_ACCESSOR_returnType
APACHE_THRIFT_DEFINE_ACCESSOR(returnType);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_arguments
#define APACHE_THRIFT_ACCESSOR_arguments
APACHE_THRIFT_DEFINE_ACCESSOR(arguments);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptions
#define APACHE_THRIFT_ACCESSOR_exceptions
APACHE_THRIFT_DEFINE_ACCESSOR(exceptions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_functions
#define APACHE_THRIFT_ACCESSOR_functions
APACHE_THRIFT_DEFINE_ACCESSOR(functions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_parent
#define APACHE_THRIFT_ACCESSOR_parent
APACHE_THRIFT_DEFINE_ACCESSOR(parent);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_service_info
#define APACHE_THRIFT_ACCESSOR_service_info
APACHE_THRIFT_DEFINE_ACCESSOR(service_info);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_module
#define APACHE_THRIFT_ACCESSOR_module
APACHE_THRIFT_DEFINE_ACCESSOR(module);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enums
#define APACHE_THRIFT_ACCESSOR_enums
APACHE_THRIFT_DEFINE_ACCESSOR(enums);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_structs
#define APACHE_THRIFT_ACCESSOR_structs
APACHE_THRIFT_DEFINE_ACCESSOR(structs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptions
#define APACHE_THRIFT_ACCESSOR_exceptions
APACHE_THRIFT_DEFINE_ACCESSOR(exceptions);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_services
#define APACHE_THRIFT_ACCESSOR_services
APACHE_THRIFT_DEFINE_ACCESSOR(services);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_context
#define APACHE_THRIFT_ACCESSOR_context
APACHE_THRIFT_DEFINE_ACCESSOR(context);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_metadata
#define APACHE_THRIFT_ACCESSOR_metadata
APACHE_THRIFT_DEFINE_ACCESSOR(metadata);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace apache { namespace thrift { namespace metadata {

enum class ThriftPrimitiveType {
  THRIFT_BOOL_TYPE = 1,
  THRIFT_BYTE_TYPE = 2,
  THRIFT_I16_TYPE = 3,
  THRIFT_I32_TYPE = 4,
  THRIFT_I64_TYPE = 5,
  THRIFT_FLOAT_TYPE = 6,
  THRIFT_DOUBLE_TYPE = 7,
  THRIFT_BINARY_TYPE = 8,
  THRIFT_STRING_TYPE = 9,
  THRIFT_VOID_TYPE = 10
};




}}} // apache::thrift::metadata
namespace std {


template<> struct hash<typename ::apache::thrift::metadata::ThriftPrimitiveType> : public apache::thrift::detail::enum_hash<typename ::apache::thrift::metadata::ThriftPrimitiveType> {};
template<> struct equal_to<typename ::apache::thrift::metadata::ThriftPrimitiveType> : public apache::thrift::detail::enum_equal_to<typename ::apache::thrift::metadata::ThriftPrimitiveType> {};


} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::apache::thrift::metadata::ThriftPrimitiveType>;

template <> struct TEnumTraits<::apache::thrift::metadata::ThriftPrimitiveType> {
  using type = ::apache::thrift::metadata::ThriftPrimitiveType;

  static constexpr std::size_t const size = 10;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::THRIFT_BOOL_TYPE; }
  static constexpr type max() { return type::THRIFT_VOID_TYPE; }
};


}} // apache::thrift

namespace apache { namespace thrift { namespace metadata {

using _ThriftPrimitiveType_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ThriftPrimitiveType>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ThriftPrimitiveType_EnumMapFactory::ValuesToNamesMapType _ThriftPrimitiveType_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ThriftPrimitiveType_EnumMapFactory::NamesToValuesMapType _ThriftPrimitiveType_NAMES_TO_VALUES;

}}} // apache::thrift::metadata

// END declare_enums
// BEGIN struct_indirection

// END struct_indirection
// BEGIN forward_declare
namespace apache { namespace thrift { namespace metadata {
class ThriftListType;
class ThriftSetType;
class ThriftMapType;
class ThriftEnumType;
class ThriftStructType;
class ThriftUnionType;
class ThriftTypedefType;
class ThriftStreamType;
class ThriftSinkType;
class ThriftType;
class ThriftEnum;
class ThriftField;
class ThriftStruct;
class ThriftException;
class ThriftFunction;
class ThriftService;
class ThriftModuleContext;
class ThriftServiceContext;
class ThriftMetadata;
class ThriftServiceMetadataResponse;
}}} // apache::thrift::metadata
// END forward_declare
// BEGIN typedefs

// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
namespace apache { namespace thrift { namespace metadata {
class ThriftListType final : private apache::thrift::detail::st::ComparisonOperators<ThriftListType> {
 public:

  ThriftListType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftListType(apache::thrift::FragileConstructor, std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftListType(ThriftListType&&) = default;
  ThriftListType(const ThriftListType& src);

  ThriftListType& operator=(ThriftListType&&) = default;
  ThriftListType& operator=(const ThriftListType& src);
  void __clear();
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftListType& rhs) const;
  bool operator<(const ThriftListType& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftListType >;
};

void swap(ThriftListType& a, ThriftListType& b);

template <class Protocol_>
uint32_t ThriftListType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftSetType final : private apache::thrift::detail::st::ComparisonOperators<ThriftSetType> {
 public:

  ThriftSetType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftSetType(apache::thrift::FragileConstructor, std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftSetType(ThriftSetType&&) = default;
  ThriftSetType(const ThriftSetType& src);

  ThriftSetType& operator=(ThriftSetType&&) = default;
  ThriftSetType& operator=(const ThriftSetType& src);
  void __clear();
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftSetType& rhs) const;
  bool operator<(const ThriftSetType& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftSetType >;
};

void swap(ThriftSetType& a, ThriftSetType& b);

template <class Protocol_>
uint32_t ThriftSetType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftMapType final : private apache::thrift::detail::st::ComparisonOperators<ThriftMapType> {
 public:

  ThriftMapType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftMapType(apache::thrift::FragileConstructor, std::unique_ptr< ::apache::thrift::metadata::ThriftType> keyType__arg, std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType__arg);

  ThriftMapType(ThriftMapType&&) = default;
  ThriftMapType(const ThriftMapType& src);

  ThriftMapType& operator=(ThriftMapType&&) = default;
  ThriftMapType& operator=(const ThriftMapType& src);
  void __clear();
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> keyType;
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> valueType;

 public:
  bool operator==(const ThriftMapType& rhs) const;
  bool operator<(const ThriftMapType& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftMapType >;
};

void swap(ThriftMapType& a, ThriftMapType& b);

template <class Protocol_>
uint32_t ThriftMapType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftEnumType final : private apache::thrift::detail::st::ComparisonOperators<ThriftEnumType> {
 public:

  ThriftEnumType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftEnumType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftEnumType(ThriftEnumType&&) = default;

  ThriftEnumType(const ThriftEnumType&) = default;

  ThriftEnumType& operator=(ThriftEnumType&&) = default;

  ThriftEnumType& operator=(const ThriftEnumType&) = default;
  void __clear();
 public:
  ::std::string name;

 public:
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftEnumType& rhs) const;
  bool operator<(const ThriftEnumType& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftEnumType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftEnumType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftEnumType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftEnumType >;
};

void swap(ThriftEnumType& a, ThriftEnumType& b);

template <class Protocol_>
uint32_t ThriftEnumType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftStructType final : private apache::thrift::detail::st::ComparisonOperators<ThriftStructType> {
 public:

  ThriftStructType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStructType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftStructType(ThriftStructType&&) = default;

  ThriftStructType(const ThriftStructType&) = default;

  ThriftStructType& operator=(ThriftStructType&&) = default;

  ThriftStructType& operator=(const ThriftStructType&) = default;
  void __clear();
 public:
  ::std::string name;

 public:
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftStructType& rhs) const;
  bool operator<(const ThriftStructType& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftStructType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftStructType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftStructType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStructType >;
};

void swap(ThriftStructType& a, ThriftStructType& b);

template <class Protocol_>
uint32_t ThriftStructType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftUnionType final : private apache::thrift::detail::st::ComparisonOperators<ThriftUnionType> {
 public:

  ThriftUnionType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftUnionType(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftUnionType(ThriftUnionType&&) = default;

  ThriftUnionType(const ThriftUnionType&) = default;

  ThriftUnionType& operator=(ThriftUnionType&&) = default;

  ThriftUnionType& operator=(const ThriftUnionType&) = default;
  void __clear();
 public:
  ::std::string name;

 public:
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftUnionType& rhs) const;
  bool operator<(const ThriftUnionType& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftUnionType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftUnionType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftUnionType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftUnionType >;
};

void swap(ThriftUnionType& a, ThriftUnionType& b);

template <class Protocol_>
uint32_t ThriftUnionType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftTypedefType final : private apache::thrift::detail::st::ComparisonOperators<ThriftTypedefType> {
 public:

  ThriftTypedefType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftTypedefType(apache::thrift::FragileConstructor, ::std::string name__arg, std::unique_ptr< ::apache::thrift::metadata::ThriftType> underlyingType__arg);

  ThriftTypedefType(ThriftTypedefType&&) = default;
  ThriftTypedefType(const ThriftTypedefType& src);

  ThriftTypedefType& operator=(ThriftTypedefType&&) = default;
  ThriftTypedefType& operator=(const ThriftTypedefType& src);
  void __clear();
 public:
  ::std::string name;
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> underlyingType;

 public:
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftTypedefType& rhs) const;
  bool operator<(const ThriftTypedefType& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftTypedefType_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftTypedefType_name_struct_setter&& name_) {
    name = std::forward<T_ThriftTypedefType_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftTypedefType >;
};

void swap(ThriftTypedefType& a, ThriftTypedefType& b);

template <class Protocol_>
uint32_t ThriftTypedefType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftStreamType final : private apache::thrift::detail::st::ComparisonOperators<ThriftStreamType> {
 public:

  ThriftStreamType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStreamType(apache::thrift::FragileConstructor, std::unique_ptr< ::apache::thrift::metadata::ThriftType> elemType__arg, std::unique_ptr< ::apache::thrift::metadata::ThriftType> initialResponseType__arg);

  ThriftStreamType(ThriftStreamType&&) = default;
  ThriftStreamType(const ThriftStreamType& src);

  ThriftStreamType& operator=(ThriftStreamType&&) = default;
  ThriftStreamType& operator=(const ThriftStreamType& src);
  void __clear();
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> elemType;
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> initialResponseType;

 public:
  bool operator==(const ThriftStreamType& rhs) const;
  bool operator<(const ThriftStreamType& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStreamType >;
};

void swap(ThriftStreamType& a, ThriftStreamType& b);

template <class Protocol_>
uint32_t ThriftStreamType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftSinkType final : private apache::thrift::detail::st::ComparisonOperators<ThriftSinkType> {
 public:

  ThriftSinkType() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftSinkType(apache::thrift::FragileConstructor, std::unique_ptr< ::apache::thrift::metadata::ThriftType> elemType__arg, std::unique_ptr< ::apache::thrift::metadata::ThriftType> finalResponseType__arg, std::unique_ptr< ::apache::thrift::metadata::ThriftType> initialResponseType__arg);

  ThriftSinkType(ThriftSinkType&&) = default;
  ThriftSinkType(const ThriftSinkType& src);

  ThriftSinkType& operator=(ThriftSinkType&&) = default;
  ThriftSinkType& operator=(const ThriftSinkType& src);
  void __clear();
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> elemType;
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> finalResponseType;
 public:
  std::unique_ptr< ::apache::thrift::metadata::ThriftType> initialResponseType;

 public:
  bool operator==(const ThriftSinkType& rhs) const;
  bool operator<(const ThriftSinkType& rhs) const;

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftSinkType >;
};

void swap(ThriftSinkType& a, ThriftSinkType& b);

template <class Protocol_>
uint32_t ThriftSinkType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftType final : private apache::thrift::detail::st::ComparisonOperators<ThriftType> {
 public:
  enum Type : int {
    __EMPTY__ = 0,
    t_primitive = 1,
    t_list = 2,
    t_set = 3,
    t_map = 4,
    t_enum = 5,
    t_struct = 6,
    t_union = 7,
    t_typedef = 8,
    t_stream = 9,
    t_sink = 10,
  } ;

  ThriftType()
      : type_(Type::__EMPTY__) {}

  ThriftType(ThriftType&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(std::move(rhs.value_.t_primitive));
        break;
      }
      case Type::t_list:
      {
        set_t_list(std::move(rhs.value_.t_list));
        break;
      }
      case Type::t_set:
      {
        set_t_set(std::move(rhs.value_.t_set));
        break;
      }
      case Type::t_map:
      {
        set_t_map(std::move(rhs.value_.t_map));
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(std::move(rhs.value_.t_enum));
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(std::move(rhs.value_.t_struct));
        break;
      }
      case Type::t_union:
      {
        set_t_union(std::move(rhs.value_.t_union));
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(std::move(rhs.value_.t_typedef));
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(std::move(rhs.value_.t_stream));
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(std::move(rhs.value_.t_sink));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ThriftType(const ThriftType& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(rhs.value_.t_primitive);
        break;
      }
      case Type::t_list:
      {
        set_t_list(rhs.value_.t_list);
        break;
      }
      case Type::t_set:
      {
        set_t_set(rhs.value_.t_set);
        break;
      }
      case Type::t_map:
      {
        set_t_map(rhs.value_.t_map);
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(rhs.value_.t_enum);
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(rhs.value_.t_struct);
        break;
      }
      case Type::t_union:
      {
        set_t_union(rhs.value_.t_union);
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(rhs.value_.t_typedef);
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(rhs.value_.t_stream);
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(rhs.value_.t_sink);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ThriftType& operator=(ThriftType&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(std::move(rhs.value_.t_primitive));
        break;
      }
      case Type::t_list:
      {
        set_t_list(std::move(rhs.value_.t_list));
        break;
      }
      case Type::t_set:
      {
        set_t_set(std::move(rhs.value_.t_set));
        break;
      }
      case Type::t_map:
      {
        set_t_map(std::move(rhs.value_.t_map));
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(std::move(rhs.value_.t_enum));
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(std::move(rhs.value_.t_struct));
        break;
      }
      case Type::t_union:
      {
        set_t_union(std::move(rhs.value_.t_union));
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(std::move(rhs.value_.t_typedef));
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(std::move(rhs.value_.t_stream));
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(std::move(rhs.value_.t_sink));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ThriftType& operator=(const ThriftType& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::t_primitive:
      {
        set_t_primitive(rhs.value_.t_primitive);
        break;
      }
      case Type::t_list:
      {
        set_t_list(rhs.value_.t_list);
        break;
      }
      case Type::t_set:
      {
        set_t_set(rhs.value_.t_set);
        break;
      }
      case Type::t_map:
      {
        set_t_map(rhs.value_.t_map);
        break;
      }
      case Type::t_enum:
      {
        set_t_enum(rhs.value_.t_enum);
        break;
      }
      case Type::t_struct:
      {
        set_t_struct(rhs.value_.t_struct);
        break;
      }
      case Type::t_union:
      {
        set_t_union(rhs.value_.t_union);
        break;
      }
      case Type::t_typedef:
      {
        set_t_typedef(rhs.value_.t_typedef);
        break;
      }
      case Type::t_stream:
      {
        set_t_stream(rhs.value_.t_stream);
        break;
      }
      case Type::t_sink:
      {
        set_t_sink(rhs.value_.t_sink);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ThriftType() {
    __clear();
  }
  union storage_type {
     ::apache::thrift::metadata::ThriftPrimitiveType t_primitive;
     ::apache::thrift::metadata::ThriftListType t_list;
     ::apache::thrift::metadata::ThriftSetType t_set;
     ::apache::thrift::metadata::ThriftMapType t_map;
     ::apache::thrift::metadata::ThriftEnumType t_enum;
     ::apache::thrift::metadata::ThriftStructType t_struct;
     ::apache::thrift::metadata::ThriftUnionType t_union;
     ::apache::thrift::metadata::ThriftTypedefType t_typedef;
     ::apache::thrift::metadata::ThriftStreamType t_stream;
     ::apache::thrift::metadata::ThriftSinkType t_sink;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ThriftType& rhs) const;
  bool operator<(const ThriftType& rhs) const;

   ::apache::thrift::metadata::ThriftPrimitiveType& set_t_primitive( ::apache::thrift::metadata::ThriftPrimitiveType t =  ::apache::thrift::metadata::ThriftPrimitiveType()) {
    __clear();
    type_ = Type::t_primitive;
    ::new (std::addressof(value_.t_primitive))  ::apache::thrift::metadata::ThriftPrimitiveType(t);
    return value_.t_primitive;
  }

   ::apache::thrift::metadata::ThriftListType& set_t_list( ::apache::thrift::metadata::ThriftListType const &t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list))  ::apache::thrift::metadata::ThriftListType(t);
    return value_.t_list;
  }

   ::apache::thrift::metadata::ThriftListType& set_t_list( ::apache::thrift::metadata::ThriftListType&& t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list))  ::apache::thrift::metadata::ThriftListType(std::move(t));
    return value_.t_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftListType, T...>>  ::apache::thrift::metadata::ThriftListType& set_t_list(T&&... t) {
    __clear();
    type_ = Type::t_list;
    ::new (std::addressof(value_.t_list))  ::apache::thrift::metadata::ThriftListType(std::forward<T>(t)...);
    return value_.t_list;
  }

   ::apache::thrift::metadata::ThriftSetType& set_t_set( ::apache::thrift::metadata::ThriftSetType const &t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set))  ::apache::thrift::metadata::ThriftSetType(t);
    return value_.t_set;
  }

   ::apache::thrift::metadata::ThriftSetType& set_t_set( ::apache::thrift::metadata::ThriftSetType&& t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set))  ::apache::thrift::metadata::ThriftSetType(std::move(t));
    return value_.t_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftSetType, T...>>  ::apache::thrift::metadata::ThriftSetType& set_t_set(T&&... t) {
    __clear();
    type_ = Type::t_set;
    ::new (std::addressof(value_.t_set))  ::apache::thrift::metadata::ThriftSetType(std::forward<T>(t)...);
    return value_.t_set;
  }

   ::apache::thrift::metadata::ThriftMapType& set_t_map( ::apache::thrift::metadata::ThriftMapType const &t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map))  ::apache::thrift::metadata::ThriftMapType(t);
    return value_.t_map;
  }

   ::apache::thrift::metadata::ThriftMapType& set_t_map( ::apache::thrift::metadata::ThriftMapType&& t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map))  ::apache::thrift::metadata::ThriftMapType(std::move(t));
    return value_.t_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftMapType, T...>>  ::apache::thrift::metadata::ThriftMapType& set_t_map(T&&... t) {
    __clear();
    type_ = Type::t_map;
    ::new (std::addressof(value_.t_map))  ::apache::thrift::metadata::ThriftMapType(std::forward<T>(t)...);
    return value_.t_map;
  }

   ::apache::thrift::metadata::ThriftEnumType& set_t_enum( ::apache::thrift::metadata::ThriftEnumType const &t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum))  ::apache::thrift::metadata::ThriftEnumType(t);
    return value_.t_enum;
  }

   ::apache::thrift::metadata::ThriftEnumType& set_t_enum( ::apache::thrift::metadata::ThriftEnumType&& t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum))  ::apache::thrift::metadata::ThriftEnumType(std::move(t));
    return value_.t_enum;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftEnumType, T...>>  ::apache::thrift::metadata::ThriftEnumType& set_t_enum(T&&... t) {
    __clear();
    type_ = Type::t_enum;
    ::new (std::addressof(value_.t_enum))  ::apache::thrift::metadata::ThriftEnumType(std::forward<T>(t)...);
    return value_.t_enum;
  }

   ::apache::thrift::metadata::ThriftStructType& set_t_struct( ::apache::thrift::metadata::ThriftStructType const &t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct))  ::apache::thrift::metadata::ThriftStructType(t);
    return value_.t_struct;
  }

   ::apache::thrift::metadata::ThriftStructType& set_t_struct( ::apache::thrift::metadata::ThriftStructType&& t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct))  ::apache::thrift::metadata::ThriftStructType(std::move(t));
    return value_.t_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftStructType, T...>>  ::apache::thrift::metadata::ThriftStructType& set_t_struct(T&&... t) {
    __clear();
    type_ = Type::t_struct;
    ::new (std::addressof(value_.t_struct))  ::apache::thrift::metadata::ThriftStructType(std::forward<T>(t)...);
    return value_.t_struct;
  }

   ::apache::thrift::metadata::ThriftUnionType& set_t_union( ::apache::thrift::metadata::ThriftUnionType const &t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union))  ::apache::thrift::metadata::ThriftUnionType(t);
    return value_.t_union;
  }

   ::apache::thrift::metadata::ThriftUnionType& set_t_union( ::apache::thrift::metadata::ThriftUnionType&& t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union))  ::apache::thrift::metadata::ThriftUnionType(std::move(t));
    return value_.t_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftUnionType, T...>>  ::apache::thrift::metadata::ThriftUnionType& set_t_union(T&&... t) {
    __clear();
    type_ = Type::t_union;
    ::new (std::addressof(value_.t_union))  ::apache::thrift::metadata::ThriftUnionType(std::forward<T>(t)...);
    return value_.t_union;
  }

   ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef( ::apache::thrift::metadata::ThriftTypedefType const &t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef))  ::apache::thrift::metadata::ThriftTypedefType(t);
    return value_.t_typedef;
  }

   ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef( ::apache::thrift::metadata::ThriftTypedefType&& t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef))  ::apache::thrift::metadata::ThriftTypedefType(std::move(t));
    return value_.t_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftTypedefType, T...>>  ::apache::thrift::metadata::ThriftTypedefType& set_t_typedef(T&&... t) {
    __clear();
    type_ = Type::t_typedef;
    ::new (std::addressof(value_.t_typedef))  ::apache::thrift::metadata::ThriftTypedefType(std::forward<T>(t)...);
    return value_.t_typedef;
  }

   ::apache::thrift::metadata::ThriftStreamType& set_t_stream( ::apache::thrift::metadata::ThriftStreamType const &t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream))  ::apache::thrift::metadata::ThriftStreamType(t);
    return value_.t_stream;
  }

   ::apache::thrift::metadata::ThriftStreamType& set_t_stream( ::apache::thrift::metadata::ThriftStreamType&& t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream))  ::apache::thrift::metadata::ThriftStreamType(std::move(t));
    return value_.t_stream;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftStreamType, T...>>  ::apache::thrift::metadata::ThriftStreamType& set_t_stream(T&&... t) {
    __clear();
    type_ = Type::t_stream;
    ::new (std::addressof(value_.t_stream))  ::apache::thrift::metadata::ThriftStreamType(std::forward<T>(t)...);
    return value_.t_stream;
  }

   ::apache::thrift::metadata::ThriftSinkType& set_t_sink( ::apache::thrift::metadata::ThriftSinkType const &t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink))  ::apache::thrift::metadata::ThriftSinkType(t);
    return value_.t_sink;
  }

   ::apache::thrift::metadata::ThriftSinkType& set_t_sink( ::apache::thrift::metadata::ThriftSinkType&& t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink))  ::apache::thrift::metadata::ThriftSinkType(std::move(t));
    return value_.t_sink;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t< ::apache::thrift::metadata::ThriftSinkType, T...>>  ::apache::thrift::metadata::ThriftSinkType& set_t_sink(T&&... t) {
    __clear();
    type_ = Type::t_sink;
    ::new (std::addressof(value_.t_sink))  ::apache::thrift::metadata::ThriftSinkType(std::forward<T>(t)...);
    return value_.t_sink;
  }

   ::apache::thrift::metadata::ThriftPrimitiveType const & get_t_primitive() const {
    assert(type_ == Type::t_primitive);
    return value_.t_primitive;
  }

   ::apache::thrift::metadata::ThriftListType const & get_t_list() const {
    assert(type_ == Type::t_list);
    return value_.t_list;
  }

   ::apache::thrift::metadata::ThriftSetType const & get_t_set() const {
    assert(type_ == Type::t_set);
    return value_.t_set;
  }

   ::apache::thrift::metadata::ThriftMapType const & get_t_map() const {
    assert(type_ == Type::t_map);
    return value_.t_map;
  }

   ::apache::thrift::metadata::ThriftEnumType const & get_t_enum() const {
    assert(type_ == Type::t_enum);
    return value_.t_enum;
  }

   ::apache::thrift::metadata::ThriftStructType const & get_t_struct() const {
    assert(type_ == Type::t_struct);
    return value_.t_struct;
  }

   ::apache::thrift::metadata::ThriftUnionType const & get_t_union() const {
    assert(type_ == Type::t_union);
    return value_.t_union;
  }

   ::apache::thrift::metadata::ThriftTypedefType const & get_t_typedef() const {
    assert(type_ == Type::t_typedef);
    return value_.t_typedef;
  }

   ::apache::thrift::metadata::ThriftStreamType const & get_t_stream() const {
    assert(type_ == Type::t_stream);
    return value_.t_stream;
  }

   ::apache::thrift::metadata::ThriftSinkType const & get_t_sink() const {
    assert(type_ == Type::t_sink);
    return value_.t_sink;
  }

   ::apache::thrift::metadata::ThriftPrimitiveType & mutable_t_primitive() {
    assert(type_ == Type::t_primitive);
    return value_.t_primitive;
  }

   ::apache::thrift::metadata::ThriftListType & mutable_t_list() {
    assert(type_ == Type::t_list);
    return value_.t_list;
  }

   ::apache::thrift::metadata::ThriftSetType & mutable_t_set() {
    assert(type_ == Type::t_set);
    return value_.t_set;
  }

   ::apache::thrift::metadata::ThriftMapType & mutable_t_map() {
    assert(type_ == Type::t_map);
    return value_.t_map;
  }

   ::apache::thrift::metadata::ThriftEnumType & mutable_t_enum() {
    assert(type_ == Type::t_enum);
    return value_.t_enum;
  }

   ::apache::thrift::metadata::ThriftStructType & mutable_t_struct() {
    assert(type_ == Type::t_struct);
    return value_.t_struct;
  }

   ::apache::thrift::metadata::ThriftUnionType & mutable_t_union() {
    assert(type_ == Type::t_union);
    return value_.t_union;
  }

   ::apache::thrift::metadata::ThriftTypedefType & mutable_t_typedef() {
    assert(type_ == Type::t_typedef);
    return value_.t_typedef;
  }

   ::apache::thrift::metadata::ThriftStreamType & mutable_t_stream() {
    assert(type_ == Type::t_stream);
    return value_.t_stream;
  }

   ::apache::thrift::metadata::ThriftSinkType & mutable_t_sink() {
    assert(type_ == Type::t_sink);
    return value_.t_sink;
  }

   ::apache::thrift::metadata::ThriftPrimitiveType move_t_primitive() {
    assert(type_ == Type::t_primitive);
    return std::move(value_.t_primitive);
  }

   ::apache::thrift::metadata::ThriftListType move_t_list() {
    assert(type_ == Type::t_list);
    return std::move(value_.t_list);
  }

   ::apache::thrift::metadata::ThriftSetType move_t_set() {
    assert(type_ == Type::t_set);
    return std::move(value_.t_set);
  }

   ::apache::thrift::metadata::ThriftMapType move_t_map() {
    assert(type_ == Type::t_map);
    return std::move(value_.t_map);
  }

   ::apache::thrift::metadata::ThriftEnumType move_t_enum() {
    assert(type_ == Type::t_enum);
    return std::move(value_.t_enum);
  }

   ::apache::thrift::metadata::ThriftStructType move_t_struct() {
    assert(type_ == Type::t_struct);
    return std::move(value_.t_struct);
  }

   ::apache::thrift::metadata::ThriftUnionType move_t_union() {
    assert(type_ == Type::t_union);
    return std::move(value_.t_union);
  }

   ::apache::thrift::metadata::ThriftTypedefType move_t_typedef() {
    assert(type_ == Type::t_typedef);
    return std::move(value_.t_typedef);
  }

   ::apache::thrift::metadata::ThriftStreamType move_t_stream() {
    assert(type_ == Type::t_stream);
    return std::move(value_.t_stream);
  }

   ::apache::thrift::metadata::ThriftSinkType move_t_sink() {
    assert(type_ == Type::t_sink);
    return std::move(value_.t_sink);
  }

  Type getType() const { return type_; }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  Type type_;
  storage_type value_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftType >;
};

void swap(ThriftType& a, ThriftType& b);

template <class Protocol_>
uint32_t ThriftType::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftEnum final : private apache::thrift::detail::st::ComparisonOperators<ThriftEnum> {
 public:

  ThriftEnum() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftEnum(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::map<int32_t, ::std::string> elements__arg);

  ThriftEnum(ThriftEnum&&) = default;

  ThriftEnum(const ThriftEnum&) = default;

  ThriftEnum& operator=(ThriftEnum&&) = default;

  ThriftEnum& operator=(const ThriftEnum&) = default;
  void __clear();
 public:
  ::std::string name;
 public:
  ::std::map<int32_t, ::std::string> elements;

 public:
  struct __isset {
    bool name;
    bool elements;
  } __isset = {};
  bool operator==(const ThriftEnum& rhs) const;
  bool operator<(const ThriftEnum& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::map<int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> elements_ref() const& {
    return {this->elements, __isset.elements};
  }

  template <typename..., typename T = ::std::map<int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> elements_ref() const&& {
    return {std::move(this->elements), __isset.elements};
  }

  template <typename..., typename T = ::std::map<int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> elements_ref() & {
    return {this->elements, __isset.elements};
  }

  template <typename..., typename T = ::std::map<int32_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> elements_ref() && {
    return {std::move(this->elements), __isset.elements};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftEnum_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftEnum_name_struct_setter&& name_) {
    name = std::forward<T_ThriftEnum_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::map<int32_t, ::std::string>& get_elements() const&;
  ::std::map<int32_t, ::std::string> get_elements() &&;

  template <typename T_ThriftEnum_elements_struct_setter = ::std::map<int32_t, ::std::string>>
  ::std::map<int32_t, ::std::string>& set_elements(T_ThriftEnum_elements_struct_setter&& elements_) {
    elements = std::forward<T_ThriftEnum_elements_struct_setter>(elements_);
    __isset.elements = true;
    return elements;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftEnum >;
};

void swap(ThriftEnum& a, ThriftEnum& b);

template <class Protocol_>
uint32_t ThriftEnum::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftField final : private apache::thrift::detail::st::ComparisonOperators<ThriftField> {
 public:

  ThriftField() :
      id(0),
      is_optional(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftField(apache::thrift::FragileConstructor, int32_t id__arg,  ::apache::thrift::metadata::ThriftType type__arg, ::std::string name__arg, bool is_optional__arg);

  ThriftField(ThriftField&&) = default;

  ThriftField(const ThriftField&) = default;

  ThriftField& operator=(ThriftField&&) = default;

  ThriftField& operator=(const ThriftField&) = default;
  void __clear();
 public:
  int32_t id;
 public:
   ::apache::thrift::metadata::ThriftType type;
 public:
  ::std::string name;
 public:
  bool is_optional;

 public:
  struct __isset {
    bool id;
    bool type;
    bool name;
    bool is_optional;
  } __isset = {};
  bool operator==(const ThriftField& rhs) const;
  bool operator<(const ThriftField& rhs) const;

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> id_ref() const& {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> id_ref() const&& {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> id_ref() & {
    return {this->id, __isset.id};
  }

  template <typename..., typename T = int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> id_ref() && {
    return {std::move(this->id), __isset.id};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> type_ref() const& {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> type_ref() const&& {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> type_ref() & {
    return {this->type, __isset.type};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> type_ref() && {
    return {std::move(this->type), __isset.type};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_optional_ref() const& {
    return {this->is_optional, __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_optional_ref() const&& {
    return {std::move(this->is_optional), __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_optional_ref() & {
    return {this->is_optional, __isset.is_optional};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_optional_ref() && {
    return {std::move(this->is_optional), __isset.is_optional};
  }

  int32_t get_id() const {
    return id;
  }

  int32_t& set_id(int32_t id_) {
    id = id_;
    __isset.id = true;
    return id;
  }
  const  ::apache::thrift::metadata::ThriftType& get_type() const&;
   ::apache::thrift::metadata::ThriftType get_type() &&;

  template <typename T_ThriftField_type_struct_setter =  ::apache::thrift::metadata::ThriftType>
   ::apache::thrift::metadata::ThriftType& set_type(T_ThriftField_type_struct_setter&& type_) {
    type = std::forward<T_ThriftField_type_struct_setter>(type_);
    __isset.type = true;
    return type;
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftField_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftField_name_struct_setter&& name_) {
    name = std::forward<T_ThriftField_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  bool get_is_optional() const {
    return is_optional;
  }

  bool& set_is_optional(bool is_optional_) {
    is_optional = is_optional_;
    __isset.is_optional = true;
    return is_optional;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftField >;
};

void swap(ThriftField& a, ThriftField& b);

template <class Protocol_>
uint32_t ThriftField::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftStruct final : private apache::thrift::detail::st::ComparisonOperators<ThriftStruct> {
 public:

  ThriftStruct() :
      is_union(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftStruct(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector< ::apache::thrift::metadata::ThriftField> fields__arg, bool is_union__arg);

  ThriftStruct(ThriftStruct&&) = default;

  ThriftStruct(const ThriftStruct&) = default;

  ThriftStruct& operator=(ThriftStruct&&) = default;

  ThriftStruct& operator=(const ThriftStruct&) = default;
  void __clear();
 public:
  ::std::string name;
 public:
  ::std::vector< ::apache::thrift::metadata::ThriftField> fields;
 public:
  bool is_union;

 public:
  struct __isset {
    bool name;
    bool fields;
    bool is_union;
  } __isset = {};
  bool operator==(const ThriftStruct& rhs) const;
  bool operator<(const ThriftStruct& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> is_union_ref() const& {
    return {this->is_union, __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> is_union_ref() const&& {
    return {std::move(this->is_union), __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> is_union_ref() & {
    return {this->is_union, __isset.is_union};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> is_union_ref() && {
    return {std::move(this->is_union), __isset.is_union};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftStruct_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftStruct_name_struct_setter&& name_) {
    name = std::forward<T_ThriftStruct_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector< ::apache::thrift::metadata::ThriftField>& get_fields() const&;
  ::std::vector< ::apache::thrift::metadata::ThriftField> get_fields() &&;

  template <typename T_ThriftStruct_fields_struct_setter = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  ::std::vector< ::apache::thrift::metadata::ThriftField>& set_fields(T_ThriftStruct_fields_struct_setter&& fields_) {
    fields = std::forward<T_ThriftStruct_fields_struct_setter>(fields_);
    __isset.fields = true;
    return fields;
  }

  bool get_is_union() const {
    return is_union;
  }

  bool& set_is_union(bool is_union_) {
    is_union = is_union_;
    __isset.is_union = true;
    return is_union;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftStruct >;
};

void swap(ThriftStruct& a, ThriftStruct& b);

template <class Protocol_>
uint32_t ThriftStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftException final : private apache::thrift::detail::st::ComparisonOperators<ThriftException> {
 public:

  ThriftException() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftException(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector< ::apache::thrift::metadata::ThriftField> fields__arg);

  ThriftException(ThriftException&&) = default;

  ThriftException(const ThriftException&) = default;

  ThriftException& operator=(ThriftException&&) = default;

  ThriftException& operator=(const ThriftException&) = default;
  void __clear();
 public:
  ::std::string name;
 public:
  ::std::vector< ::apache::thrift::metadata::ThriftField> fields;

 public:
  struct __isset {
    bool name;
    bool fields;
  } __isset = {};
  bool operator==(const ThriftException& rhs) const;
  bool operator<(const ThriftException& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fields_ref() const& {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fields_ref() const&& {
    return {std::move(this->fields), __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fields_ref() & {
    return {this->fields, __isset.fields};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fields_ref() && {
    return {std::move(this->fields), __isset.fields};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftException_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftException_name_struct_setter&& name_) {
    name = std::forward<T_ThriftException_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector< ::apache::thrift::metadata::ThriftField>& get_fields() const&;
  ::std::vector< ::apache::thrift::metadata::ThriftField> get_fields() &&;

  template <typename T_ThriftException_fields_struct_setter = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  ::std::vector< ::apache::thrift::metadata::ThriftField>& set_fields(T_ThriftException_fields_struct_setter&& fields_) {
    fields = std::forward<T_ThriftException_fields_struct_setter>(fields_);
    __isset.fields = true;
    return fields;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftException >;
};

void swap(ThriftException& a, ThriftException& b);

template <class Protocol_>
uint32_t ThriftException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftFunction final : private apache::thrift::detail::st::ComparisonOperators<ThriftFunction> {
 public:

  ThriftFunction() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftFunction(apache::thrift::FragileConstructor, ::std::string name__arg,  ::apache::thrift::metadata::ThriftType returnType__arg, ::std::vector< ::apache::thrift::metadata::ThriftField> arguments__arg, ::std::vector< ::apache::thrift::metadata::ThriftField> exceptions__arg);

  ThriftFunction(ThriftFunction&&) = default;

  ThriftFunction(const ThriftFunction&) = default;

  ThriftFunction& operator=(ThriftFunction&&) = default;

  ThriftFunction& operator=(const ThriftFunction&) = default;
  void __clear();
 public:
  ::std::string name;
 public:
   ::apache::thrift::metadata::ThriftType returnType;
 public:
  ::std::vector< ::apache::thrift::metadata::ThriftField> arguments;
 public:
  ::std::vector< ::apache::thrift::metadata::ThriftField> exceptions;

 public:
  struct __isset {
    bool name;
    bool returnType;
    bool arguments;
    bool exceptions;
  } __isset = {};
  bool operator==(const ThriftFunction& rhs) const;
  bool operator<(const ThriftFunction& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> returnType_ref() const& {
    return {this->returnType, __isset.returnType};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> returnType_ref() const&& {
    return {std::move(this->returnType), __isset.returnType};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> returnType_ref() & {
    return {this->returnType, __isset.returnType};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> returnType_ref() && {
    return {std::move(this->returnType), __isset.returnType};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> arguments_ref() const& {
    return {this->arguments, __isset.arguments};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> arguments_ref() const&& {
    return {std::move(this->arguments), __isset.arguments};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> arguments_ref() & {
    return {this->arguments, __isset.arguments};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> arguments_ref() && {
    return {std::move(this->arguments), __isset.arguments};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exceptions_ref() const& {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exceptions_ref() const&& {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exceptions_ref() & {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exceptions_ref() && {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftFunction_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftFunction_name_struct_setter&& name_) {
    name = std::forward<T_ThriftFunction_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const  ::apache::thrift::metadata::ThriftType& get_returnType() const&;
   ::apache::thrift::metadata::ThriftType get_returnType() &&;

  template <typename T_ThriftFunction_returnType_struct_setter =  ::apache::thrift::metadata::ThriftType>
   ::apache::thrift::metadata::ThriftType& set_returnType(T_ThriftFunction_returnType_struct_setter&& returnType_) {
    returnType = std::forward<T_ThriftFunction_returnType_struct_setter>(returnType_);
    __isset.returnType = true;
    return returnType;
  }
  const ::std::vector< ::apache::thrift::metadata::ThriftField>& get_arguments() const&;
  ::std::vector< ::apache::thrift::metadata::ThriftField> get_arguments() &&;

  template <typename T_ThriftFunction_arguments_struct_setter = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  ::std::vector< ::apache::thrift::metadata::ThriftField>& set_arguments(T_ThriftFunction_arguments_struct_setter&& arguments_) {
    arguments = std::forward<T_ThriftFunction_arguments_struct_setter>(arguments_);
    __isset.arguments = true;
    return arguments;
  }
  const ::std::vector< ::apache::thrift::metadata::ThriftField>& get_exceptions() const&;
  ::std::vector< ::apache::thrift::metadata::ThriftField> get_exceptions() &&;

  template <typename T_ThriftFunction_exceptions_struct_setter = ::std::vector< ::apache::thrift::metadata::ThriftField>>
  ::std::vector< ::apache::thrift::metadata::ThriftField>& set_exceptions(T_ThriftFunction_exceptions_struct_setter&& exceptions_) {
    exceptions = std::forward<T_ThriftFunction_exceptions_struct_setter>(exceptions_);
    __isset.exceptions = true;
    return exceptions;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftFunction >;
};

void swap(ThriftFunction& a, ThriftFunction& b);

template <class Protocol_>
uint32_t ThriftFunction::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftService final : private apache::thrift::detail::st::ComparisonOperators<ThriftService> {
 public:

  ThriftService() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftService(apache::thrift::FragileConstructor, ::std::string name__arg, ::std::vector< ::apache::thrift::metadata::ThriftFunction> functions__arg, ::std::string parent__arg);

  ThriftService(ThriftService&&) = default;

  ThriftService(const ThriftService&) = default;

  ThriftService& operator=(ThriftService&&) = default;

  ThriftService& operator=(const ThriftService&) = default;
  void __clear();
 public:
  ::std::string name;
 public:
  ::std::vector< ::apache::thrift::metadata::ThriftFunction> functions;
 private:
  ::std::string parent;

 public:
  struct __isset {
    bool name;
    bool functions;
    bool parent;
  } __isset = {};
  bool operator==(const ThriftService& rhs) const;
  bool operator<(const ThriftService& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> functions_ref() const& {
    return {this->functions, __isset.functions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> functions_ref() const&& {
    return {std::move(this->functions), __isset.functions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> functions_ref() & {
    return {this->functions, __isset.functions};
  }

  template <typename..., typename T = ::std::vector< ::apache::thrift::metadata::ThriftFunction>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> functions_ref() && {
    return {std::move(this->functions), __isset.functions};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&> parent_ref() const& {
    return {parent, __isset.parent};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<const ::std::string&&> parent_ref() const&& {
    return {std::move(parent), __isset.parent};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&> parent_ref() & {
    return {parent, __isset.parent};
  }

  FOLLY_ERASE ::apache::thrift::optional_field_ref<::std::string&&> parent_ref() && {
    return {std::move(parent), __isset.parent};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftService_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftService_name_struct_setter&& name_) {
    name = std::forward<T_ThriftService_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }
  const ::std::vector< ::apache::thrift::metadata::ThriftFunction>& get_functions() const&;
  ::std::vector< ::apache::thrift::metadata::ThriftFunction> get_functions() &&;

  template <typename T_ThriftService_functions_struct_setter = ::std::vector< ::apache::thrift::metadata::ThriftFunction>>
  ::std::vector< ::apache::thrift::metadata::ThriftFunction>& set_functions(T_ThriftService_functions_struct_setter&& functions_) {
    functions = std::forward<T_ThriftService_functions_struct_setter>(functions_);
    __isset.functions = true;
    return functions;
  }

  const ::std::string* get_parent() const& {
    return __isset.parent ? std::addressof(parent) : nullptr;
  }

  ::std::string* get_parent() & {
    return __isset.parent ? std::addressof(parent) : nullptr;
  }
  ::std::string* get_parent() && = delete;

  template <typename T_ThriftService_parent_struct_setter = ::std::string>
  ::std::string& set_parent(T_ThriftService_parent_struct_setter&& parent_) {
    parent = std::forward<T_ThriftService_parent_struct_setter>(parent_);
    __isset.parent = true;
    return parent;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftService >;
};

void swap(ThriftService& a, ThriftService& b);

template <class Protocol_>
uint32_t ThriftService::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftModuleContext final : private apache::thrift::detail::st::ComparisonOperators<ThriftModuleContext> {
 public:

  ThriftModuleContext() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftModuleContext(apache::thrift::FragileConstructor, ::std::string name__arg);

  ThriftModuleContext(ThriftModuleContext&&) = default;

  ThriftModuleContext(const ThriftModuleContext&) = default;

  ThriftModuleContext& operator=(ThriftModuleContext&&) = default;

  ThriftModuleContext& operator=(const ThriftModuleContext&) = default;
  void __clear();
 public:
  ::std::string name;

 public:
  struct __isset {
    bool name;
  } __isset = {};
  bool operator==(const ThriftModuleContext& rhs) const;
  bool operator<(const ThriftModuleContext& rhs) const;

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  const ::std::string& get_name() const& {
    return name;
  }

  ::std::string get_name() && {
    return std::move(name);
  }

  template <typename T_ThriftModuleContext_name_struct_setter = ::std::string>
  ::std::string& set_name(T_ThriftModuleContext_name_struct_setter&& name_) {
    name = std::forward<T_ThriftModuleContext_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftModuleContext >;
};

void swap(ThriftModuleContext& a, ThriftModuleContext& b);

template <class Protocol_>
uint32_t ThriftModuleContext::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftServiceContext final : private apache::thrift::detail::st::ComparisonOperators<ThriftServiceContext> {
 public:

  ThriftServiceContext() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftServiceContext(apache::thrift::FragileConstructor,  ::apache::thrift::metadata::ThriftService service_info__arg,  ::apache::thrift::metadata::ThriftModuleContext module__arg);

  ThriftServiceContext(ThriftServiceContext&&) = default;

  ThriftServiceContext(const ThriftServiceContext&) = default;

  ThriftServiceContext& operator=(ThriftServiceContext&&) = default;

  ThriftServiceContext& operator=(const ThriftServiceContext&) = default;
  void __clear();
 public:
   ::apache::thrift::metadata::ThriftService service_info;
 public:
   ::apache::thrift::metadata::ThriftModuleContext module;

 public:
  struct __isset {
    bool service_info;
    bool module;
  } __isset = {};
  bool operator==(const ThriftServiceContext& rhs) const;
  bool operator<(const ThriftServiceContext& rhs) const;

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> service_info_ref() const& {
    return {this->service_info, __isset.service_info};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> service_info_ref() const&& {
    return {std::move(this->service_info), __isset.service_info};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> service_info_ref() & {
    return {this->service_info, __isset.service_info};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftService>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> service_info_ref() && {
    return {std::move(this->service_info), __isset.service_info};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> module_ref() const& {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> module_ref() const&& {
    return {std::move(this->module), __isset.module};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> module_ref() & {
    return {this->module, __isset.module};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftModuleContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> module_ref() && {
    return {std::move(this->module), __isset.module};
  }
  const  ::apache::thrift::metadata::ThriftService& get_service_info() const&;
   ::apache::thrift::metadata::ThriftService get_service_info() &&;

  template <typename T_ThriftServiceContext_service_info_struct_setter =  ::apache::thrift::metadata::ThriftService>
   ::apache::thrift::metadata::ThriftService& set_service_info(T_ThriftServiceContext_service_info_struct_setter&& service_info_) {
    service_info = std::forward<T_ThriftServiceContext_service_info_struct_setter>(service_info_);
    __isset.service_info = true;
    return service_info;
  }
  const  ::apache::thrift::metadata::ThriftModuleContext& get_module() const&;
   ::apache::thrift::metadata::ThriftModuleContext get_module() &&;

  template <typename T_ThriftServiceContext_module_struct_setter =  ::apache::thrift::metadata::ThriftModuleContext>
   ::apache::thrift::metadata::ThriftModuleContext& set_module(T_ThriftServiceContext_module_struct_setter&& module_) {
    module = std::forward<T_ThriftServiceContext_module_struct_setter>(module_);
    __isset.module = true;
    return module;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftServiceContext >;
};

void swap(ThriftServiceContext& a, ThriftServiceContext& b);

template <class Protocol_>
uint32_t ThriftServiceContext::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftMetadata final : private apache::thrift::detail::st::ComparisonOperators<ThriftMetadata> {
 public:

  ThriftMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftMetadata(apache::thrift::FragileConstructor, ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum> enums__arg, ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct> structs__arg, ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException> exceptions__arg, ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService> services__arg);

  ThriftMetadata(ThriftMetadata&&) = default;

  ThriftMetadata(const ThriftMetadata&) = default;

  ThriftMetadata& operator=(ThriftMetadata&&) = default;

  ThriftMetadata& operator=(const ThriftMetadata&) = default;
  void __clear();
 public:
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum> enums;
 public:
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct> structs;
 public:
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException> exceptions;
 public:
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService> services;

 public:
  struct __isset {
    bool enums;
    bool structs;
    bool exceptions;
    bool services;
  } __isset = {};
  bool operator==(const ThriftMetadata& rhs) const;
  bool operator<(const ThriftMetadata& rhs) const;

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enums_ref() const& {
    return {this->enums, __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enums_ref() const&& {
    return {std::move(this->enums), __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enums_ref() & {
    return {this->enums, __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enums_ref() && {
    return {std::move(this->enums), __isset.enums};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> structs_ref() const& {
    return {this->structs, __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> structs_ref() const&& {
    return {std::move(this->structs), __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> structs_ref() & {
    return {this->structs, __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> structs_ref() && {
    return {std::move(this->structs), __isset.structs};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exceptions_ref() const& {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exceptions_ref() const&& {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exceptions_ref() & {
    return {this->exceptions, __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exceptions_ref() && {
    return {std::move(this->exceptions), __isset.exceptions};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> services_ref() const& {
    return {this->services, __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> services_ref() const&& {
    return {std::move(this->services), __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> services_ref() & {
    return {this->services, __isset.services};
  }

  template <typename..., typename T = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> services_ref() && {
    return {std::move(this->services), __isset.services};
  }
  const ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>& get_enums() const&;
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum> get_enums() &&;

  template <typename T_ThriftMetadata_enums_struct_setter = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>>
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftEnum>& set_enums(T_ThriftMetadata_enums_struct_setter&& enums_) {
    enums = std::forward<T_ThriftMetadata_enums_struct_setter>(enums_);
    __isset.enums = true;
    return enums;
  }
  const ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>& get_structs() const&;
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct> get_structs() &&;

  template <typename T_ThriftMetadata_structs_struct_setter = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>>
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftStruct>& set_structs(T_ThriftMetadata_structs_struct_setter&& structs_) {
    structs = std::forward<T_ThriftMetadata_structs_struct_setter>(structs_);
    __isset.structs = true;
    return structs;
  }
  const ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>& get_exceptions() const&;
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException> get_exceptions() &&;

  template <typename T_ThriftMetadata_exceptions_struct_setter = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>>
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftException>& set_exceptions(T_ThriftMetadata_exceptions_struct_setter&& exceptions_) {
    exceptions = std::forward<T_ThriftMetadata_exceptions_struct_setter>(exceptions_);
    __isset.exceptions = true;
    return exceptions;
  }
  const ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>& get_services() const&;
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService> get_services() &&;

  template <typename T_ThriftMetadata_services_struct_setter = ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>>
  ::std::map<::std::string,  ::apache::thrift::metadata::ThriftService>& set_services(T_ThriftMetadata_services_struct_setter&& services_) {
    services = std::forward<T_ThriftMetadata_services_struct_setter>(services_);
    __isset.services = true;
    return services;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftMetadata >;
};

void swap(ThriftMetadata& a, ThriftMetadata& b);

template <class Protocol_>
uint32_t ThriftMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
namespace apache { namespace thrift { namespace metadata {
class ThriftServiceMetadataResponse final : private apache::thrift::detail::st::ComparisonOperators<ThriftServiceMetadataResponse> {
 public:

  ThriftServiceMetadataResponse() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ThriftServiceMetadataResponse(apache::thrift::FragileConstructor,  ::apache::thrift::metadata::ThriftServiceContext context__arg,  ::apache::thrift::metadata::ThriftMetadata metadata__arg);

  ThriftServiceMetadataResponse(ThriftServiceMetadataResponse&&) = default;

  ThriftServiceMetadataResponse(const ThriftServiceMetadataResponse&) = default;

  ThriftServiceMetadataResponse& operator=(ThriftServiceMetadataResponse&&) = default;

  ThriftServiceMetadataResponse& operator=(const ThriftServiceMetadataResponse&) = default;
  void __clear();
 public:
   ::apache::thrift::metadata::ThriftServiceContext context;
 public:
   ::apache::thrift::metadata::ThriftMetadata metadata;

 public:
  struct __isset {
    bool context;
    bool metadata;
  } __isset = {};
  bool operator==(const ThriftServiceMetadataResponse& rhs) const;
  bool operator<(const ThriftServiceMetadataResponse& rhs) const;

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> context_ref() const& {
    return {this->context, __isset.context};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> context_ref() const&& {
    return {std::move(this->context), __isset.context};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> context_ref() & {
    return {this->context, __isset.context};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftServiceContext>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> context_ref() && {
    return {std::move(this->context), __isset.context};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> metadata_ref() const& {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> metadata_ref() const&& {
    return {std::move(this->metadata), __isset.metadata};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> metadata_ref() & {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T =  ::apache::thrift::metadata::ThriftMetadata>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> metadata_ref() && {
    return {std::move(this->metadata), __isset.metadata};
  }
  const  ::apache::thrift::metadata::ThriftServiceContext& get_context() const&;
   ::apache::thrift::metadata::ThriftServiceContext get_context() &&;

  template <typename T_ThriftServiceMetadataResponse_context_struct_setter =  ::apache::thrift::metadata::ThriftServiceContext>
   ::apache::thrift::metadata::ThriftServiceContext& set_context(T_ThriftServiceMetadataResponse_context_struct_setter&& context_) {
    context = std::forward<T_ThriftServiceMetadataResponse_context_struct_setter>(context_);
    __isset.context = true;
    return context;
  }
  const  ::apache::thrift::metadata::ThriftMetadata& get_metadata() const&;
   ::apache::thrift::metadata::ThriftMetadata get_metadata() &&;

  template <typename T_ThriftServiceMetadataResponse_metadata_struct_setter =  ::apache::thrift::metadata::ThriftMetadata>
   ::apache::thrift::metadata::ThriftMetadata& set_metadata(T_ThriftServiceMetadataResponse_metadata_struct_setter&& metadata_) {
    metadata = std::forward<T_ThriftServiceMetadataResponse_metadata_struct_setter>(metadata_);
    __isset.metadata = true;
    return metadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ThriftServiceMetadataResponse >;
};

void swap(ThriftServiceMetadataResponse& a, ThriftServiceMetadataResponse& b);

template <class Protocol_>
uint32_t ThriftServiceMetadataResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}}} // apache::thrift::metadata
