#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

import enum as _python_std_enum
import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
import thrift.python.types
import thrift.py3.exceptions
import typing as _typing

import sys
import itertools
import includes.types as _includes_types
import module.thrift_types


MyEnumA = module.thrift_types.MyEnumA
AnnotatedEnum = module.thrift_types.AnnotatedEnum
AnnotatedEnum2 = module.thrift_types.AnnotatedEnum2
MyEnumB = module.thrift_types.MyEnumB

class Empty(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        pass


    def __init__(
        self, 
    ) -> None: ...

    def __call__(
        self, 
    ) -> Empty: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['Empty'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'Empty') -> bool: ...
    def __gt__(self, other: 'Empty') -> bool: ...
    def __le__(self, other: 'Empty') -> bool: ...
    def __ge__(self, other: 'Empty') -> bool: ...

    def _to_python(self) -> module.thrift_types.Empty: ...
    def _to_py3(self) -> Empty: ...
    def _to_py_deprecated(self) -> "module.ttypes.Empty": ...   # type: ignore

class ASimpleStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        boolField: bool
        pass

    boolField: _typing.Final[int] = ...

    def __init__(
        self, *,
        boolField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, None]=None
    ) -> ASimpleStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ASimpleStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def _to_python(self) -> module.thrift_types.ASimpleStruct: ...
    def _to_py3(self) -> ASimpleStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.ASimpleStruct": ...   # type: ignore

class ASimpleStructNoexcept(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        boolField: bool
        pass

    boolField: _typing.Final[int] = ...

    def __init__(
        self, *,
        boolField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        boolField: _typing.Union[int, None]=None
    ) -> ASimpleStructNoexcept: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ASimpleStructNoexcept'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __gt__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __le__(self, other: 'ASimpleStructNoexcept') -> bool: ...
    def __ge__(self, other: 'ASimpleStructNoexcept') -> bool: ...

    def _to_python(self) -> module.thrift_types.ASimpleStructNoexcept: ...
    def _to_py3(self) -> ASimpleStructNoexcept: ...
    def _to_py_deprecated(self) -> "module.ttypes.ASimpleStructNoexcept": ...   # type: ignore

class MyStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        MyBoolField: bool
        MyIntField: bool
        MyStringField: bool
        MyStringField2: bool
        MyBinaryField: bool
        MyBinaryField2: bool
        MyBinaryField3: bool
        MyBinaryListField4: bool
        MyMapEnumAndInt: bool
        MyCustomField: bool
        MyOptCustomField: bool
        pass

    MyBoolField: _typing.Final[bool] = ...
    MyIntField: _typing.Final[int] = ...
    MyStringField: _typing.Final[str] = ...
    MyStringField2: _typing.Final[str] = ...
    MyBinaryField: _typing.Final[bytes] = ...
    MyBinaryField2: _typing.Final[_typing.Optional[bytes]] = ...
    MyBinaryField3: _typing.Final[bytes] = ...
    MyBinaryListField4: _typing.Final[_typing.Sequence[bytes]] = ...
    MyMapEnumAndInt: _typing.Final[_typing.Mapping[MyEnumA, str]] = ...
    MyCustomField: _typing.Final[_fbthrift_iobuf.IOBuf] = ...
    MyOptCustomField: _typing.Final[_typing.Optional[_fbthrift_iobuf.IOBuf]] = ...

    def __init__(
        self, *,
        MyBoolField: _typing.Optional[bool]=None,
        MyIntField: _typing.Optional[int]=None,
        MyStringField: _typing.Optional[str]=None,
        MyStringField2: _typing.Optional[str]=None,
        MyBinaryField: _typing.Optional[bytes]=None,
        MyBinaryField2: _typing.Optional[bytes]=None,
        MyBinaryField3: _typing.Optional[bytes]=None,
        MyBinaryListField4: _typing.Optional[_typing.Sequence[bytes]]=None,
        MyMapEnumAndInt: _typing.Optional[_typing.Mapping[MyEnumA, str]]=None,
        MyCustomField: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        MyOptCustomField: _typing.Optional[_fbthrift_iobuf.IOBuf]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyBoolField: _typing.Union[bool, None]=None,
        MyIntField: _typing.Union[int, None]=None,
        MyStringField: _typing.Union[str, None]=None,
        MyStringField2: _typing.Union[str, None]=None,
        MyBinaryField: _typing.Union[bytes, None]=None,
        MyBinaryField2: _typing.Union[bytes, None]=None,
        MyBinaryField3: _typing.Union[bytes, None]=None,
        MyBinaryListField4: _typing.Union[_typing.Sequence[bytes], None]=None,
        MyMapEnumAndInt: _typing.Union[_typing.Mapping[MyEnumA, str], None]=None,
        MyCustomField: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None,
        MyOptCustomField: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None
    ) -> MyStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyStruct') -> bool: ...
    def __gt__(self, other: 'MyStruct') -> bool: ...
    def __le__(self, other: 'MyStruct') -> bool: ...
    def __ge__(self, other: 'MyStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.MyStruct: ...
    def _to_py3(self) -> MyStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.MyStruct": ...   # type: ignore

_SimpleUnionValueType = _typing.Union[None, int, str]

class SimpleUnion(thrift.py3.types.Union, _typing.Hashable):
    class __fbthrift_IsSet:
        intValue: bool
        stringValue: bool
        pass

    intValue: _typing.Final[int] = ...
    stringValue: _typing.Final[str] = ...

    def __init__(
        self, *,
        intValue: _typing.Optional[int]=None,
        stringValue: _typing.Optional[str]=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'SimpleUnion') -> bool: ...
    def __gt__(self, other: 'SimpleUnion') -> bool: ...
    def __le__(self, other: 'SimpleUnion') -> bool: ...
    def __ge__(self, other: 'SimpleUnion') -> bool: ...

    class Type(_python_std_enum.Enum):
        EMPTY: SimpleUnion.Type = ...
        intValue: SimpleUnion.Type = ...
        stringValue: SimpleUnion.Type = ...

    @staticmethod
    def fromValue(value: _SimpleUnionValueType) -> SimpleUnion: ...
    type: _typing.Final[SimpleUnion.Type]
    value: _typing.Final[_SimpleUnionValueType]
    def get_type(self) -> SimpleUnion.Type: ...

    def _to_python(self) -> module.thrift_types.SimpleUnion: ...
    def _to_py3(self) -> SimpleUnion: ...
    def _to_py_deprecated(self) -> "module.ttypes.SimpleUnion": ...   # type: ignore

_ComplexUnionValueType = _typing.Union[None, int, int, str, str, int, int, float, bool, _typing.Sequence[int], _typing.AbstractSet[int], _typing.Mapping[str, int], _typing.Mapping[str, int], MyEnumA, _typing.Sequence[MyEnumA], MyStruct, _typing.AbstractSet[MyStruct], SimpleUnion, SimpleUnion, _typing.Sequence[SimpleUnion], _typing.AbstractSet[SimpleUnion], _typing.Sequence[_typing.AbstractSet[SimpleUnion]], bytes, bytes, _typing.Sequence[bytes], MyStruct, MyStruct, AnException, _fbthrift_iobuf.IOBuf]

class ComplexUnion(thrift.py3.types.Union, _typing.Hashable):
    class __fbthrift_IsSet:
        intValue: bool
        opt_intValue: bool
        stringValue: bool
        opt_stringValue: bool
        intValue2: bool
        intValue3: bool
        doubelValue: bool
        boolValue: bool
        union_list: bool
        union_set: bool
        union_map: bool
        opt_union_map: bool
        enum_field: bool
        enum_container: bool
        a_struct: bool
        a_set_struct: bool
        a_union: bool
        opt_a_union: bool
        a_union_list: bool
        a_union_typedef: bool
        a_union_typedef_list: bool
        MyBinaryField: bool
        MyBinaryField2: bool
        MyBinaryListField4: bool
        excp_field: bool
        MyCustomField: bool
        pass

    intValue: _typing.Final[int] = ...
    opt_intValue: _typing.Final[int] = ...
    stringValue: _typing.Final[str] = ...
    opt_stringValue: _typing.Final[str] = ...
    intValue2: _typing.Final[int] = ...
    intValue3: _typing.Final[int] = ...
    doubelValue: _typing.Final[float] = ...
    boolValue: _typing.Final[bool] = ...
    union_list: _typing.Final[_typing.Sequence[int]] = ...
    union_set: _typing.Final[_typing.AbstractSet[int]] = ...
    union_map: _typing.Final[_typing.Mapping[str, int]] = ...
    opt_union_map: _typing.Final[_typing.Mapping[str, int]] = ...
    enum_field: _typing.Final[MyEnumA] = ...
    enum_container: _typing.Final[_typing.Sequence[MyEnumA]] = ...
    a_struct: _typing.Final[MyStruct] = ...
    a_set_struct: _typing.Final[_typing.AbstractSet[MyStruct]] = ...
    a_union: _typing.Final[SimpleUnion] = ...
    opt_a_union: _typing.Final[SimpleUnion] = ...
    a_union_list: _typing.Final[_typing.Sequence[SimpleUnion]] = ...
    a_union_typedef: _typing.Final[_typing.AbstractSet[SimpleUnion]] = ...
    a_union_typedef_list: _typing.Final[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]] = ...
    MyBinaryField: _typing.Final[bytes] = ...
    MyBinaryField2: _typing.Final[bytes] = ...
    MyBinaryListField4: _typing.Final[_typing.Sequence[bytes]] = ...
    ref_field: _typing.Final[_typing.Optional[MyStruct]] = ...
    ref_field2: _typing.Final[_typing.Optional[MyStruct]] = ...
    excp_field: _typing.Final[AnException] = ...
    MyCustomField: _typing.Final[_fbthrift_iobuf.IOBuf] = ...

    def __init__(
        self, *,
        intValue: _typing.Optional[int]=None,
        opt_intValue: _typing.Optional[int]=None,
        stringValue: _typing.Optional[str]=None,
        opt_stringValue: _typing.Optional[str]=None,
        intValue2: _typing.Optional[int]=None,
        intValue3: _typing.Optional[int]=None,
        doubelValue: _typing.Optional[float]=None,
        boolValue: _typing.Optional[bool]=None,
        union_list: _typing.Optional[_typing.Sequence[int]]=None,
        union_set: _typing.Optional[_typing.AbstractSet[int]]=None,
        union_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        opt_union_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        enum_field: _typing.Optional[MyEnumA]=None,
        enum_container: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        a_struct: _typing.Optional[MyStruct]=None,
        a_set_struct: _typing.Optional[_typing.AbstractSet[MyStruct]]=None,
        a_union: _typing.Optional[SimpleUnion]=None,
        opt_a_union: _typing.Optional[SimpleUnion]=None,
        a_union_list: _typing.Optional[_typing.Sequence[SimpleUnion]]=None,
        a_union_typedef: _typing.Optional[_typing.AbstractSet[SimpleUnion]]=None,
        a_union_typedef_list: _typing.Optional[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]]=None,
        MyBinaryField: _typing.Optional[bytes]=None,
        MyBinaryField2: _typing.Optional[bytes]=None,
        MyBinaryListField4: _typing.Optional[_typing.Sequence[bytes]]=None,
        ref_field: _typing.Optional[MyStruct]=None,
        ref_field2: _typing.Optional[MyStruct]=None,
        excp_field: _typing.Optional[AnException]=None,
        MyCustomField: _typing.Optional[_fbthrift_iobuf.IOBuf]=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexUnion') -> bool: ...
    def __gt__(self, other: 'ComplexUnion') -> bool: ...
    def __le__(self, other: 'ComplexUnion') -> bool: ...
    def __ge__(self, other: 'ComplexUnion') -> bool: ...

    class Type(_python_std_enum.Enum):
        EMPTY: ComplexUnion.Type = ...
        intValue: ComplexUnion.Type = ...
        opt_intValue: ComplexUnion.Type = ...
        stringValue: ComplexUnion.Type = ...
        opt_stringValue: ComplexUnion.Type = ...
        intValue2: ComplexUnion.Type = ...
        intValue3: ComplexUnion.Type = ...
        doubelValue: ComplexUnion.Type = ...
        boolValue: ComplexUnion.Type = ...
        union_list: ComplexUnion.Type = ...
        union_set: ComplexUnion.Type = ...
        union_map: ComplexUnion.Type = ...
        opt_union_map: ComplexUnion.Type = ...
        enum_field: ComplexUnion.Type = ...
        enum_container: ComplexUnion.Type = ...
        a_struct: ComplexUnion.Type = ...
        a_set_struct: ComplexUnion.Type = ...
        a_union: ComplexUnion.Type = ...
        opt_a_union: ComplexUnion.Type = ...
        a_union_list: ComplexUnion.Type = ...
        a_union_typedef: ComplexUnion.Type = ...
        a_union_typedef_list: ComplexUnion.Type = ...
        MyBinaryField: ComplexUnion.Type = ...
        MyBinaryField2: ComplexUnion.Type = ...
        MyBinaryListField4: ComplexUnion.Type = ...
        ref_field: ComplexUnion.Type = ...
        ref_field2: ComplexUnion.Type = ...
        excp_field: ComplexUnion.Type = ...
        MyCustomField: ComplexUnion.Type = ...

    @staticmethod
    def fromValue(value: _ComplexUnionValueType) -> ComplexUnion: ...
    type: _typing.Final[ComplexUnion.Type]
    value: _typing.Final[_ComplexUnionValueType]
    def get_type(self) -> ComplexUnion.Type: ...

    def _to_python(self) -> module.thrift_types.ComplexUnion: ...
    def _to_py3(self) -> ComplexUnion: ...
    def _to_py_deprecated(self) -> "module.ttypes.ComplexUnion": ...   # type: ignore

class AnException(thrift.py3.exceptions.GeneratedError, _typing.Hashable):
    class __fbthrift_IsSet:
        code: bool
        req_code: bool
        message2: bool
        req_message: bool
        exception_list: bool
        exception_set: bool
        exception_map: bool
        req_exception_map: bool
        enum_field: bool
        enum_container: bool
        a_struct: bool
        a_set_struct: bool
        a_union_list: bool
        union_typedef: bool
        a_union_typedef_list: bool
        MyCustomField: bool
        MyOptCustomField: bool
        pass

    code: _typing.Final[int] = ...
    req_code: _typing.Final[int] = ...
    message2: _typing.Final[str] = ...
    req_message: _typing.Final[str] = ...
    exception_list: _typing.Final[_typing.Sequence[int]] = ...
    exception_set: _typing.Final[_typing.AbstractSet[int]] = ...
    exception_map: _typing.Final[_typing.Mapping[str, int]] = ...
    req_exception_map: _typing.Final[_typing.Mapping[str, int]] = ...
    enum_field: _typing.Final[MyEnumA] = ...
    enum_container: _typing.Final[_typing.Sequence[MyEnumA]] = ...
    a_struct: _typing.Final[MyStruct] = ...
    a_set_struct: _typing.Final[_typing.AbstractSet[MyStruct]] = ...
    a_union_list: _typing.Final[_typing.Sequence[SimpleUnion]] = ...
    union_typedef: _typing.Final[_typing.AbstractSet[SimpleUnion]] = ...
    a_union_typedef_list: _typing.Final[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]] = ...
    MyCustomField: _typing.Final[_fbthrift_iobuf.IOBuf] = ...
    MyOptCustomField: _typing.Final[_typing.Optional[_fbthrift_iobuf.IOBuf]] = ...

    def __init__(
        self, *,
        code: _typing.Optional[int]=None,
        req_code: _typing.Optional[int]=None,
        message2: _typing.Optional[str]=None,
        req_message: _typing.Optional[str]=None,
        exception_list: _typing.Optional[_typing.Sequence[int]]=None,
        exception_set: _typing.Optional[_typing.AbstractSet[int]]=None,
        exception_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        req_exception_map: _typing.Optional[_typing.Mapping[str, int]]=None,
        enum_field: _typing.Optional[MyEnumA]=None,
        enum_container: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        a_struct: _typing.Optional[MyStruct]=None,
        a_set_struct: _typing.Optional[_typing.AbstractSet[MyStruct]]=None,
        a_union_list: _typing.Optional[_typing.Sequence[SimpleUnion]]=None,
        union_typedef: _typing.Optional[_typing.AbstractSet[SimpleUnion]]=None,
        a_union_typedef_list: _typing.Optional[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]]=None,
        MyCustomField: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        MyOptCustomField: _typing.Optional[_fbthrift_iobuf.IOBuf]=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AnException') -> bool: ...
    def __gt__(self, other: 'AnException') -> bool: ...
    def __le__(self, other: 'AnException') -> bool: ...
    def __ge__(self, other: 'AnException') -> bool: ...

    def _to_python(self) -> module.thrift_types.AnException: ...
    def _to_py3(self) -> AnException: ...
    def _to_py_deprecated(self) -> "module.ttypes.AnException": ...   # type: ignore

class AnotherException(thrift.py3.exceptions.GeneratedError, _typing.Hashable):
    class __fbthrift_IsSet:
        code: bool
        req_code: bool
        message: bool
        pass

    code: _typing.Final[int] = ...
    req_code: _typing.Final[int] = ...
    message: _typing.Final[str] = ...

    def __init__(
        self, *,
        code: _typing.Optional[int]=None,
        req_code: _typing.Optional[int]=None,
        message: _typing.Optional[str]=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AnotherException') -> bool: ...
    def __gt__(self, other: 'AnotherException') -> bool: ...
    def __le__(self, other: 'AnotherException') -> bool: ...
    def __ge__(self, other: 'AnotherException') -> bool: ...

    def _to_python(self) -> module.thrift_types.AnotherException: ...
    def _to_py3(self) -> AnotherException: ...
    def _to_py_deprecated(self) -> "module.ttypes.AnotherException": ...   # type: ignore

class containerStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        fieldA: bool
        req_fieldA: bool
        opt_fieldA: bool
        fieldB: bool
        req_fieldB: bool
        opt_fieldB: bool
        fieldC: bool
        req_fieldC: bool
        opt_fieldC: bool
        fieldD: bool
        fieldE: bool
        req_fieldE: bool
        opt_fieldE: bool
        fieldF: bool
        fieldG: bool
        fieldH: bool
        fieldI: bool
        fieldJ: bool
        fieldK: bool
        fieldL: bool
        fieldM: bool
        fieldN: bool
        fieldO: bool
        fieldP: bool
        fieldQ: bool
        fieldR: bool
        req_fieldR: bool
        opt_fieldR: bool
        fieldS: bool
        fieldT: bool
        fieldU: bool
        fieldV: bool
        req_fieldV: bool
        opt_fieldV: bool
        fieldW: bool
        fieldX: bool
        req_fieldX: bool
        opt_fieldX: bool
        fieldY: bool
        fieldZ: bool
        fieldAA: bool
        fieldAC: bool
        fieldAD: bool
        fieldAE: bool
        pass

    fieldA: _typing.Final[bool] = ...
    req_fieldA: _typing.Final[bool] = ...
    opt_fieldA: _typing.Final[_typing.Optional[bool]] = ...
    fieldB: _typing.Final[_typing.Mapping[str, bool]] = ...
    req_fieldB: _typing.Final[_typing.Mapping[str, bool]] = ...
    opt_fieldB: _typing.Final[_typing.Optional[_typing.Mapping[str, bool]]] = ...
    fieldC: _typing.Final[_typing.AbstractSet[int]] = ...
    req_fieldC: _typing.Final[_typing.AbstractSet[int]] = ...
    opt_fieldC: _typing.Final[_typing.AbstractSet[int]] = ...
    fieldD: _typing.Final[str] = ...
    fieldE: _typing.Final[str] = ...
    req_fieldE: _typing.Final[str] = ...
    opt_fieldE: _typing.Final[str] = ...
    fieldF: _typing.Final[_typing.Sequence[_typing.Sequence[int]]] = ...
    fieldG: _typing.Final[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]] = ...
    fieldH: _typing.Final[_typing.Sequence[_typing.AbstractSet[int]]] = ...
    fieldI: _typing.Final[bool] = ...
    fieldJ: _typing.Final[_typing.Mapping[str, _typing.Sequence[int]]] = ...
    fieldK: _typing.Final[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]] = ...
    fieldL: _typing.Final[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]] = ...
    fieldM: _typing.Final[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]] = ...
    fieldN: _typing.Final[int] = ...
    fieldO: _typing.Final[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]] = ...
    fieldP: _typing.Final[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]] = ...
    fieldQ: _typing.Final[MyEnumA] = ...
    fieldR: _typing.Final[MyEnumA] = ...
    req_fieldR: _typing.Final[MyEnumA] = ...
    opt_fieldR: _typing.Final[MyEnumA] = ...
    fieldS: _typing.Final[MyEnumA] = ...
    fieldT: _typing.Final[_typing.Sequence[MyEnumA]] = ...
    fieldU: _typing.Final[_typing.Sequence[MyEnumA]] = ...
    fieldV: _typing.Final[MyStruct] = ...
    req_fieldV: _typing.Final[MyStruct] = ...
    opt_fieldV: _typing.Final[_typing.Optional[MyStruct]] = ...
    fieldW: _typing.Final[_typing.AbstractSet[MyStruct]] = ...
    fieldX: _typing.Final[ComplexUnion] = ...
    req_fieldX: _typing.Final[ComplexUnion] = ...
    opt_fieldX: _typing.Final[_typing.Optional[ComplexUnion]] = ...
    fieldY: _typing.Final[_typing.Sequence[ComplexUnion]] = ...
    fieldZ: _typing.Final[_typing.AbstractSet[SimpleUnion]] = ...
    fieldAA: _typing.Final[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]] = ...
    fieldAC: _typing.Final[MyEnumB] = ...
    fieldAD: _typing.Final[_includes_types.AnEnum] = ...
    fieldAE: _typing.Final[_typing.Mapping[str, int]] = ...

    def __init__(
        self, *,
        fieldA: _typing.Optional[bool]=None,
        req_fieldA: _typing.Optional[bool]=None,
        opt_fieldA: _typing.Optional[bool]=None,
        fieldB: _typing.Optional[_typing.Mapping[str, bool]]=None,
        req_fieldB: _typing.Optional[_typing.Mapping[str, bool]]=None,
        opt_fieldB: _typing.Optional[_typing.Mapping[str, bool]]=None,
        fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        req_fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        opt_fieldC: _typing.Optional[_typing.AbstractSet[int]]=None,
        fieldD: _typing.Optional[str]=None,
        fieldE: _typing.Optional[str]=None,
        req_fieldE: _typing.Optional[str]=None,
        opt_fieldE: _typing.Optional[str]=None,
        fieldF: _typing.Optional[_typing.Sequence[_typing.Sequence[int]]]=None,
        fieldG: _typing.Optional[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]]=None,
        fieldH: _typing.Optional[_typing.Sequence[_typing.AbstractSet[int]]]=None,
        fieldI: _typing.Optional[bool]=None,
        fieldJ: _typing.Optional[_typing.Mapping[str, _typing.Sequence[int]]]=None,
        fieldK: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]]=None,
        fieldL: _typing.Optional[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]]=None,
        fieldM: _typing.Optional[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]]=None,
        fieldN: _typing.Optional[int]=None,
        fieldO: _typing.Optional[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]=None,
        fieldP: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]]=None,
        fieldQ: _typing.Optional[MyEnumA]=None,
        fieldR: _typing.Optional[MyEnumA]=None,
        req_fieldR: _typing.Optional[MyEnumA]=None,
        opt_fieldR: _typing.Optional[MyEnumA]=None,
        fieldS: _typing.Optional[MyEnumA]=None,
        fieldT: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        fieldU: _typing.Optional[_typing.Sequence[MyEnumA]]=None,
        fieldV: _typing.Optional[MyStruct]=None,
        req_fieldV: _typing.Optional[MyStruct]=None,
        opt_fieldV: _typing.Optional[MyStruct]=None,
        fieldW: _typing.Optional[_typing.AbstractSet[MyStruct]]=None,
        fieldX: _typing.Optional[ComplexUnion]=None,
        req_fieldX: _typing.Optional[ComplexUnion]=None,
        opt_fieldX: _typing.Optional[ComplexUnion]=None,
        fieldY: _typing.Optional[_typing.Sequence[ComplexUnion]]=None,
        fieldZ: _typing.Optional[_typing.AbstractSet[SimpleUnion]]=None,
        fieldAA: _typing.Optional[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]]=None,
        fieldAC: _typing.Optional[MyEnumB]=None,
        fieldAD: _typing.Optional[_includes_types.AnEnum]=None,
        fieldAE: _typing.Optional[_typing.Mapping[str, int]]=None
    ) -> None: ...

    def __call__(
        self, *,
        fieldA: _typing.Union[bool, None]=None,
        req_fieldA: _typing.Union[bool, None]=None,
        opt_fieldA: _typing.Union[bool, None]=None,
        fieldB: _typing.Union[_typing.Mapping[str, bool], None]=None,
        req_fieldB: _typing.Union[_typing.Mapping[str, bool], None]=None,
        opt_fieldB: _typing.Union[_typing.Mapping[str, bool], None]=None,
        fieldC: _typing.Union[_typing.AbstractSet[int], None]=None,
        req_fieldC: _typing.Union[_typing.AbstractSet[int], None]=None,
        opt_fieldC: _typing.Union[_typing.AbstractSet[int], None]=None,
        fieldD: _typing.Union[str, None]=None,
        fieldE: _typing.Union[str, None]=None,
        req_fieldE: _typing.Union[str, None]=None,
        opt_fieldE: _typing.Union[str, None]=None,
        fieldF: _typing.Union[_typing.Sequence[_typing.Sequence[int]], None]=None,
        fieldG: _typing.Union[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], None]=None,
        fieldH: _typing.Union[_typing.Sequence[_typing.AbstractSet[int]], None]=None,
        fieldI: _typing.Union[bool, None]=None,
        fieldJ: _typing.Union[_typing.Mapping[str, _typing.Sequence[int]], None]=None,
        fieldK: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], None]=None,
        fieldL: _typing.Union[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], None]=None,
        fieldM: _typing.Union[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], None]=None,
        fieldN: _typing.Union[int, None]=None,
        fieldO: _typing.Union[_typing.Sequence[_typing.Mapping[Empty, MyStruct]], None]=None,
        fieldP: _typing.Union[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]], None]=None,
        fieldQ: _typing.Union[MyEnumA, None]=None,
        fieldR: _typing.Union[MyEnumA, None]=None,
        req_fieldR: _typing.Union[MyEnumA, None]=None,
        opt_fieldR: _typing.Union[MyEnumA, None]=None,
        fieldS: _typing.Union[MyEnumA, None]=None,
        fieldT: _typing.Union[_typing.Sequence[MyEnumA], None]=None,
        fieldU: _typing.Union[_typing.Sequence[MyEnumA], None]=None,
        fieldV: _typing.Union[MyStruct, None]=None,
        req_fieldV: _typing.Union[MyStruct, None]=None,
        opt_fieldV: _typing.Union[MyStruct, None]=None,
        fieldW: _typing.Union[_typing.AbstractSet[MyStruct], None]=None,
        fieldX: _typing.Union[ComplexUnion, None]=None,
        req_fieldX: _typing.Union[ComplexUnion, None]=None,
        opt_fieldX: _typing.Union[ComplexUnion, None]=None,
        fieldY: _typing.Union[_typing.Sequence[ComplexUnion], None]=None,
        fieldZ: _typing.Union[_typing.AbstractSet[SimpleUnion], None]=None,
        fieldAA: _typing.Union[_typing.Sequence[_typing.AbstractSet[SimpleUnion]], None]=None,
        fieldAC: _typing.Union[MyEnumB, None]=None,
        fieldAD: _typing.Union[_includes_types.AnEnum, None]=None,
        fieldAE: _typing.Union[_typing.Mapping[str, int], None]=None
    ) -> containerStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['containerStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'containerStruct') -> bool: ...
    def __gt__(self, other: 'containerStruct') -> bool: ...
    def __le__(self, other: 'containerStruct') -> bool: ...
    def __ge__(self, other: 'containerStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.containerStruct: ...
    def _to_py3(self) -> containerStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.containerStruct": ...   # type: ignore

class MyIncludedStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        MyIncludedInt: bool
        MyIncludedStruct: bool
        ARequiredField: bool
        pass

    MyIncludedInt: _typing.Final[int] = ...
    MyIncludedStruct: _typing.Final[_includes_types.AStruct] = ...
    ARefField: _typing.Final[_typing.Optional[_includes_types.AStruct]] = ...
    ARequiredField: _typing.Final[_includes_types.AStruct] = ...

    def __init__(
        self, *,
        MyIncludedInt: _typing.Optional[int]=None,
        MyIncludedStruct: _typing.Optional[_includes_types.AStruct]=None,
        ARefField: _typing.Optional[_includes_types.AStruct]=None,
        ARequiredField: _typing.Optional[_includes_types.AStruct]=None
    ) -> None: ...

    def __call__(
        self, *,
        MyIncludedInt: _typing.Union[int, None]=None,
        MyIncludedStruct: _typing.Union[_includes_types.AStruct, None]=None,
        ARefField: _typing.Union[_includes_types.AStruct, None]=None,
        ARequiredField: _typing.Union[_includes_types.AStruct, None]=None
    ) -> MyIncludedStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['MyIncludedStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'MyIncludedStruct') -> bool: ...
    def __gt__(self, other: 'MyIncludedStruct') -> bool: ...
    def __le__(self, other: 'MyIncludedStruct') -> bool: ...
    def __ge__(self, other: 'MyIncludedStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.MyIncludedStruct: ...
    def _to_py3(self) -> MyIncludedStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.MyIncludedStruct": ...   # type: ignore

class AnnotatedStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        no_annotation: bool
        base_type: bool
        list_type: bool
        set_type: bool
        map_type: bool
        map_struct_type: bool
        iobuf_type: bool
        iobuf_ptr: bool
        list_i32_template: bool
        list_string_template: bool
        set_template: bool
        map_template: bool
        typedef_list_template: bool
        typedef_deque_template: bool
        typedef_set_template: bool
        typedef_map_template: bool
        iobuf_type_val: bool
        iobuf_ptr_val: bool
        struct_struct: bool
        pass

    no_annotation: _typing.Final[containerStruct] = ...
    cpp_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    cpp2_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    container_with_ref: _typing.Final[_typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]] = ...
    req_cpp_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    req_cpp2_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    req_container_with_ref: _typing.Final[_typing.Optional[_typing.Sequence[str]]] = ...
    opt_cpp_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    opt_cpp2_unique_ref: _typing.Final[_typing.Optional[containerStruct]] = ...
    opt_container_with_ref: _typing.Final[_typing.Optional[_typing.AbstractSet[int]]] = ...
    ref_type_unique: _typing.Final[_typing.Optional[containerStruct]] = ...
    ref_type_shared: _typing.Final[_typing.Optional[containerStruct]] = ...
    ref_type_const: _typing.Final[_typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]] = ...
    req_ref_type_shared: _typing.Final[_typing.Optional[containerStruct]] = ...
    req_ref_type_const: _typing.Final[_typing.Optional[containerStruct]] = ...
    req_ref_type_unique: _typing.Final[_typing.Optional[_typing.Sequence[str]]] = ...
    opt_ref_type_const: _typing.Final[_typing.Optional[containerStruct]] = ...
    opt_ref_type_unique: _typing.Final[_typing.Optional[containerStruct]] = ...
    opt_ref_type_shared: _typing.Final[_typing.Optional[_typing.AbstractSet[int]]] = ...
    base_type: _typing.Final[int] = ...
    list_type: _typing.Final[_typing.Sequence[int]] = ...
    set_type: _typing.Final[_typing.AbstractSet[str]] = ...
    map_type: _typing.Final[_typing.Mapping[int, float]] = ...
    map_struct_type: _typing.Final[_typing.Mapping[str, containerStruct]] = ...
    iobuf_type: _typing.Final[_fbthrift_iobuf.IOBuf] = ...
    iobuf_ptr: _typing.Final[_typing.Optional[_fbthrift_iobuf.IOBuf]] = ...
    list_i32_template: _typing.Final[_typing.Sequence[int]] = ...
    list_string_template: _typing.Final[_typing.Sequence[str]] = ...
    set_template: _typing.Final[_typing.AbstractSet[str]] = ...
    map_template: _typing.Final[_typing.Mapping[int, str]] = ...
    typedef_list_template: _typing.Final[_typing.Sequence[int]] = ...
    typedef_deque_template: _typing.Final[_typing.Sequence[str]] = ...
    typedef_set_template: _typing.Final[_typing.AbstractSet[str]] = ...
    typedef_map_template: _typing.Final[_typing.Mapping[int, str]] = ...
    iobuf_type_val: _typing.Final[_fbthrift_iobuf.IOBuf] = ...
    iobuf_ptr_val: _typing.Final[_typing.Optional[_fbthrift_iobuf.IOBuf]] = ...
    struct_struct: _typing.Final[containerStruct] = ...

    def __init__(
        self, *,
        no_annotation: _typing.Optional[containerStruct]=None,
        cpp_unique_ref: _typing.Optional[containerStruct]=None,
        cpp2_unique_ref: _typing.Optional[containerStruct]=None,
        container_with_ref: _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]=None,
        req_cpp_unique_ref: _typing.Optional[containerStruct]=None,
        req_cpp2_unique_ref: _typing.Optional[containerStruct]=None,
        req_container_with_ref: _typing.Optional[_typing.Sequence[str]]=None,
        opt_cpp_unique_ref: _typing.Optional[containerStruct]=None,
        opt_cpp2_unique_ref: _typing.Optional[containerStruct]=None,
        opt_container_with_ref: _typing.Optional[_typing.AbstractSet[int]]=None,
        ref_type_unique: _typing.Optional[containerStruct]=None,
        ref_type_shared: _typing.Optional[containerStruct]=None,
        ref_type_const: _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]=None,
        req_ref_type_shared: _typing.Optional[containerStruct]=None,
        req_ref_type_const: _typing.Optional[containerStruct]=None,
        req_ref_type_unique: _typing.Optional[_typing.Sequence[str]]=None,
        opt_ref_type_const: _typing.Optional[containerStruct]=None,
        opt_ref_type_unique: _typing.Optional[containerStruct]=None,
        opt_ref_type_shared: _typing.Optional[_typing.AbstractSet[int]]=None,
        base_type: _typing.Optional[int]=None,
        list_type: _typing.Optional[_typing.Sequence[int]]=None,
        set_type: _typing.Optional[_typing.AbstractSet[str]]=None,
        map_type: _typing.Optional[_typing.Mapping[int, float]]=None,
        map_struct_type: _typing.Optional[_typing.Mapping[str, containerStruct]]=None,
        iobuf_type: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        iobuf_ptr: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        list_i32_template: _typing.Optional[_typing.Sequence[int]]=None,
        list_string_template: _typing.Optional[_typing.Sequence[str]]=None,
        set_template: _typing.Optional[_typing.AbstractSet[str]]=None,
        map_template: _typing.Optional[_typing.Mapping[int, str]]=None,
        typedef_list_template: _typing.Optional[_typing.Sequence[int]]=None,
        typedef_deque_template: _typing.Optional[_typing.Sequence[str]]=None,
        typedef_set_template: _typing.Optional[_typing.AbstractSet[str]]=None,
        typedef_map_template: _typing.Optional[_typing.Mapping[int, str]]=None,
        iobuf_type_val: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        iobuf_ptr_val: _typing.Optional[_fbthrift_iobuf.IOBuf]=None,
        struct_struct: _typing.Optional[containerStruct]=None
    ) -> None: ...

    def __call__(
        self, *,
        no_annotation: _typing.Union[containerStruct, None]=None,
        cpp_unique_ref: _typing.Union[containerStruct, None]=None,
        cpp2_unique_ref: _typing.Union[containerStruct, None]=None,
        container_with_ref: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], None]=None,
        req_cpp_unique_ref: _typing.Union[containerStruct, None]=None,
        req_cpp2_unique_ref: _typing.Union[containerStruct, None]=None,
        req_container_with_ref: _typing.Union[_typing.Sequence[str], None]=None,
        opt_cpp_unique_ref: _typing.Union[containerStruct, None]=None,
        opt_cpp2_unique_ref: _typing.Union[containerStruct, None]=None,
        opt_container_with_ref: _typing.Union[_typing.AbstractSet[int], None]=None,
        ref_type_unique: _typing.Union[containerStruct, None]=None,
        ref_type_shared: _typing.Union[containerStruct, None]=None,
        ref_type_const: _typing.Union[_typing.Mapping[int, _typing.Sequence[str]], None]=None,
        req_ref_type_shared: _typing.Union[containerStruct, None]=None,
        req_ref_type_const: _typing.Union[containerStruct, None]=None,
        req_ref_type_unique: _typing.Union[_typing.Sequence[str], None]=None,
        opt_ref_type_const: _typing.Union[containerStruct, None]=None,
        opt_ref_type_unique: _typing.Union[containerStruct, None]=None,
        opt_ref_type_shared: _typing.Union[_typing.AbstractSet[int], None]=None,
        base_type: _typing.Union[int, None]=None,
        list_type: _typing.Union[_typing.Sequence[int], None]=None,
        set_type: _typing.Union[_typing.AbstractSet[str], None]=None,
        map_type: _typing.Union[_typing.Mapping[int, float], None]=None,
        map_struct_type: _typing.Union[_typing.Mapping[str, containerStruct], None]=None,
        iobuf_type: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None,
        iobuf_ptr: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None,
        list_i32_template: _typing.Union[_typing.Sequence[int], None]=None,
        list_string_template: _typing.Union[_typing.Sequence[str], None]=None,
        set_template: _typing.Union[_typing.AbstractSet[str], None]=None,
        map_template: _typing.Union[_typing.Mapping[int, str], None]=None,
        typedef_list_template: _typing.Union[_typing.Sequence[int], None]=None,
        typedef_deque_template: _typing.Union[_typing.Sequence[str], None]=None,
        typedef_set_template: _typing.Union[_typing.AbstractSet[str], None]=None,
        typedef_map_template: _typing.Union[_typing.Mapping[int, str], None]=None,
        iobuf_type_val: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None,
        iobuf_ptr_val: _typing.Union[_fbthrift_iobuf.IOBuf, None]=None,
        struct_struct: _typing.Union[containerStruct, None]=None
    ) -> AnnotatedStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AnnotatedStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    def _to_python(self) -> module.thrift_types.AnnotatedStruct: ...
    def _to_py3(self) -> AnnotatedStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.AnnotatedStruct": ...   # type: ignore

class ComplexContainerStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        map_of_iobufs: bool
        map_of_iobuf_ptrs: bool
        pass

    map_of_iobufs: _typing.Final[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]] = ...
    map_of_iobuf_ptrs: _typing.Final[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]] = ...

    def __init__(
        self, *,
        map_of_iobufs: _typing.Optional[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]]=None,
        map_of_iobuf_ptrs: _typing.Optional[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]]=None
    ) -> None: ...

    def __call__(
        self, *,
        map_of_iobufs: _typing.Union[_typing.Mapping[str, _fbthrift_iobuf.IOBuf], None]=None,
        map_of_iobuf_ptrs: _typing.Union[_typing.Mapping[str, _fbthrift_iobuf.IOBuf], None]=None
    ) -> ComplexContainerStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['ComplexContainerStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __gt__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __le__(self, other: 'ComplexContainerStruct') -> bool: ...
    def __ge__(self, other: 'ComplexContainerStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.ComplexContainerStruct: ...
    def _to_py3(self) -> ComplexContainerStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.ComplexContainerStruct": ...   # type: ignore

class FloatStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        floatField: bool
        doubleField: bool
        pass

    floatField: _typing.Final[float] = ...
    doubleField: _typing.Final[float] = ...

    def __init__(
        self, *,
        floatField: _typing.Optional[float]=None,
        doubleField: _typing.Optional[float]=None
    ) -> None: ...

    def __call__(
        self, *,
        floatField: _typing.Union[float, None]=None,
        doubleField: _typing.Union[float, None]=None
    ) -> FloatStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['FloatStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'FloatStruct') -> bool: ...
    def __gt__(self, other: 'FloatStruct') -> bool: ...
    def __le__(self, other: 'FloatStruct') -> bool: ...
    def __ge__(self, other: 'FloatStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.FloatStruct: ...
    def _to_py3(self) -> FloatStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.FloatStruct": ...   # type: ignore

_FloatUnionValueType = _typing.Union[None, float, float]

class FloatUnion(thrift.py3.types.Union, _typing.Hashable):
    class __fbthrift_IsSet:
        floatSide: bool
        doubleSide: bool
        pass

    floatSide: _typing.Final[float] = ...
    doubleSide: _typing.Final[float] = ...

    def __init__(
        self, *,
        floatSide: _typing.Optional[float]=None,
        doubleSide: _typing.Optional[float]=None
    ) -> None: ...

    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'FloatUnion') -> bool: ...
    def __gt__(self, other: 'FloatUnion') -> bool: ...
    def __le__(self, other: 'FloatUnion') -> bool: ...
    def __ge__(self, other: 'FloatUnion') -> bool: ...

    class Type(_python_std_enum.Enum):
        EMPTY: FloatUnion.Type = ...
        floatSide: FloatUnion.Type = ...
        doubleSide: FloatUnion.Type = ...

    @staticmethod
    def fromValue(value: _FloatUnionValueType) -> FloatUnion: ...
    type: _typing.Final[FloatUnion.Type]
    value: _typing.Final[_FloatUnionValueType]
    def get_type(self) -> FloatUnion.Type: ...

    def _to_python(self) -> module.thrift_types.FloatUnion: ...
    def _to_py3(self) -> FloatUnion: ...
    def _to_py_deprecated(self) -> "module.ttypes.FloatUnion": ...   # type: ignore

class AllRequiredNoExceptMoveCtrStruct(thrift.py3.types.Struct, _typing.Hashable):
    class __fbthrift_IsSet:
        intField: bool
        pass

    intField: _typing.Final[int] = ...

    def __init__(
        self, *,
        intField: _typing.Optional[int]=None
    ) -> None: ...

    def __call__(
        self, *,
        intField: _typing.Union[int, None]=None
    ) -> AllRequiredNoExceptMoveCtrStruct: ...

    def __reduce__(self) -> _typing.Tuple[_typing.Callable, _typing.Tuple[_typing.Type['AllRequiredNoExceptMoveCtrStruct'], bytes]]: ...
    def __hash__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __lt__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __gt__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __le__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...
    def __ge__(self, other: 'AllRequiredNoExceptMoveCtrStruct') -> bool: ...

    def _to_python(self) -> module.thrift_types.AllRequiredNoExceptMoveCtrStruct: ...
    def _to_py3(self) -> AllRequiredNoExceptMoveCtrStruct: ...
    def _to_py_deprecated(self) -> "module.ttypes.AllRequiredNoExceptMoveCtrStruct": ...   # type: ignore

class Map__string_i64(_typing.Mapping[str, int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, int]: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__Empty_MyStruct(_typing.Mapping[Empty, MyStruct], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[Empty, MyStruct]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[Empty, MyStruct]: ...
    def __getitem__(self, key: Empty) -> MyStruct: ...
    def __iter__(self) -> _typing.Iterator[Empty]: ...


_List__Map__Empty_MyStructT = _typing.TypeVar('_List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Mapping[Empty, MyStruct]])


class List__Map__Empty_MyStruct(_typing.Sequence[_typing.Mapping[Empty, MyStruct]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[Empty, MyStruct]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[Empty, MyStruct]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[Empty, MyStruct]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> 'List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _typing.Sequence[_typing.Mapping[Empty, MyStruct]]) -> 'List__Map__Empty_MyStruct': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[Empty, MyStruct]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[Empty, MyStruct]]: ...


_List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]])


class List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Mapping[Empty, MyStruct]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> 'List__List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]) -> 'List__List__Map__Empty_MyStruct': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...


_List__List__List__Map__Empty_MyStructT = _typing.TypeVar('_List__List__List__Map__Empty_MyStructT', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]])


class List__List__List__Map__Empty_MyStruct(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'List__List__List__Map__Empty_MyStruct': ...
    def __radd__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'List__List__List__Map__Empty_MyStruct': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...


_List__MyEnumAT = _typing.TypeVar('_List__MyEnumAT', bound=_typing.Sequence[MyEnumA])


class List__MyEnumA(_typing.Sequence[MyEnumA], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[MyEnumA]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[MyEnumA]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> MyEnumA: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[MyEnumA]: ...
    def __add__(self, other: _typing.Sequence[MyEnumA]) -> 'List__MyEnumA': ...
    def __radd__(self, other: _typing.Sequence[MyEnumA]) -> 'List__MyEnumA': ...
    def __reversed__(self) -> _typing.Iterator[MyEnumA]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...


class Set__MyStruct(_typing.AbstractSet[MyStruct], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[MyStruct]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[MyStruct]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[MyStruct]) -> 'Set__MyStruct': ...
    def intersection(self, other: _typing.AbstractSet[MyStruct]) -> 'Set__MyStruct': ...
    def difference(self, other: _typing.AbstractSet[MyStruct]) -> 'Set__MyStruct': ...
    def symmetric_difference(self, other: _typing.AbstractSet[MyStruct]) -> 'Set__MyStruct': ...
    def issubset(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[MyStruct]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[MyStruct]: ...


_List__ComplexUnionT = _typing.TypeVar('_List__ComplexUnionT', bound=_typing.Sequence[ComplexUnion])


class List__ComplexUnion(_typing.Sequence[ComplexUnion], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[ComplexUnion]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[ComplexUnion]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> ComplexUnion: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[ComplexUnion]: ...
    def __add__(self, other: _typing.Sequence[ComplexUnion]) -> 'List__ComplexUnion': ...
    def __radd__(self, other: _typing.Sequence[ComplexUnion]) -> 'List__ComplexUnion': ...
    def __reversed__(self) -> _typing.Iterator[ComplexUnion]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[ComplexUnion]: ...


_List__stringT = _typing.TypeVar('_List__stringT', bound=_typing.Sequence[str])


class List__string(_typing.Sequence[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[str]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> str: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[str]: ...
    def __add__(self, other: _typing.Sequence[str]) -> 'List__string': ...
    def __radd__(self, other: _typing.Sequence[str]) -> 'List__string': ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[str]: ...


class Set__List__string(_typing.AbstractSet[_typing.Sequence[str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[_typing.Sequence[str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[str]]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> 'Set__List__string': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[str]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[str]]: ...


class Set__List__List__Map__Empty_MyStruct(_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> 'Set__List__List__Map__Empty_MyStruct': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Mapping[Empty, MyStruct]]]]: ...


class Map__i32_List__string(_typing.Mapping[int, _typing.Sequence[str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, _typing.Sequence[str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, _typing.Sequence[str]]: ...
    def __getitem__(self, key: int) -> _typing.Sequence[str]: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__boolT = _typing.TypeVar('_List__boolT', bound=_typing.Sequence[bool])


class List__bool(_typing.Sequence[bool], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[bool]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[bool]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> bool: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[bool]: ...
    def __add__(self, other: _typing.Sequence[bool]) -> 'List__bool': ...
    def __radd__(self, other: _typing.Sequence[bool]) -> 'List__bool': ...
    def __reversed__(self) -> _typing.Iterator[bool]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[bool]: ...


_List__i32T = _typing.TypeVar('_List__i32T', bound=_typing.Sequence[int])


class List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'List__i32': ...
    def __radd__(self, other: _typing.Sequence[int]) -> 'List__i32': ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__List__i32T = _typing.TypeVar('_List__List__i32T', bound=_typing.Sequence[_typing.Sequence[int]])


class List__List__i32(_typing.Sequence[_typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[int]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> 'List__List__i32': ...
    def __radd__(self, other: _typing.Sequence[_typing.Sequence[int]]) -> 'List__List__i32': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...


_List__List__List__i32T = _typing.TypeVar('_List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]])


class List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[int]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> 'List__List__List__i32': ...
    def __radd__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]) -> 'List__List__List__i32': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[int]]]: ...


_List__List__List__List__i32T = _typing.TypeVar('_List__List__List__List__i32T', bound=_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]])


class List__List__List__List__i32(_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> 'List__List__List__List__i32': ...
    def __radd__(self, other: _typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]) -> 'List__List__List__List__i32': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]: ...


class Set__List__i32(_typing.AbstractSet[_typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[_typing.Sequence[int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.Sequence[int]]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def intersection(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> 'Set__List__i32': ...
    def issubset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.Sequence[int]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[int]]: ...


class Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__Set__stringT = _typing.TypeVar('_List__Set__stringT', bound=_typing.Sequence[_typing.AbstractSet[str]])


class List__Set__string(_typing.Sequence[_typing.AbstractSet[str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.AbstractSet[str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet[str]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet[str]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet[str]]: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> 'List__Set__string': ...
    def __radd__(self, other: _typing.Sequence[_typing.AbstractSet[str]]) -> 'List__Set__string': ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[str]]: ...


class Map__List__Set__string_string(_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __getitem__(self, key: _typing.Sequence[_typing.AbstractSet[str]]) -> str: ...
    def __iter__(self) -> _typing.Iterator[_typing.Sequence[_typing.AbstractSet[str]]]: ...


class Map__Set__List__i32_Map__List__Set__string_string(_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]: ...
    def __getitem__(self, key: _typing.AbstractSet[_typing.Sequence[int]]) -> _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.Sequence[int]]]: ...


class Set__i32(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__i32': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_folly_small_vector_int64_t_8__List__i64T = _typing.TypeVar('_folly_small_vector_int64_t_8__List__i64T', bound=_typing.Sequence[int])


class folly_small_vector_int64_t_8__List__i64(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'folly_small_vector_int64_t_8__List__i64': ...
    def __radd__(self, other: _typing.Sequence[int]) -> 'folly_small_vector_int64_t_8__List__i64': ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[int]: ...


class folly_sorted_vector_set_std_string__Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set_std_string__Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class FakeMap__Map__i64_double(_typing.Mapping[int, float], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, float]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, float]: ...
    def __getitem__(self, key: int) -> float: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class std_unordered_map_std_string_containerStruct__Map__string_containerStruct(_typing.Mapping[str, containerStruct], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, containerStruct]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, containerStruct]: ...
    def __getitem__(self, key: str) -> containerStruct: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__i64_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_list__List__i32T = _typing.TypeVar('_std_list__List__i32T', bound=_typing.Sequence[int])


class std_list__List__i32(_typing.Sequence[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[int]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> int: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[int]: ...
    def __add__(self, other: _typing.Sequence[int]) -> 'std_list__List__i32': ...
    def __radd__(self, other: _typing.Sequence[int]) -> 'std_list__List__i32': ...
    def __reversed__(self) -> _typing.Iterator[int]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[int]: ...


_std_deque__List__stringT = _typing.TypeVar('_std_deque__List__stringT', bound=_typing.Sequence[str])


class std_deque__List__string(_typing.Sequence[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[str]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> str: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[str]: ...
    def __add__(self, other: _typing.Sequence[str]) -> 'std_deque__List__string': ...
    def __radd__(self, other: _typing.Sequence[str]) -> 'std_deque__List__string': ...
    def __reversed__(self) -> _typing.Iterator[str]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[str]: ...


class folly_sorted_vector_set__Set__string(_typing.AbstractSet[str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[str]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def intersection(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def symmetric_difference(self, other: _typing.AbstractSet[str]) -> 'folly_sorted_vector_set__Set__string': ...
    def issubset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[str]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class folly_sorted_vector_map__Map__i64_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__binaryT = _typing.TypeVar('_List__binaryT', bound=_typing.Sequence[bytes])


class List__binary(_typing.Sequence[bytes], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[bytes]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[bytes]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> bytes: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[bytes]: ...
    def __add__(self, other: _typing.Sequence[bytes]) -> 'List__binary': ...
    def __radd__(self, other: _typing.Sequence[bytes]) -> 'List__binary': ...
    def __reversed__(self) -> _typing.Iterator[bytes]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[bytes]: ...


class Map__MyEnumA_string(_typing.Mapping[MyEnumA, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[MyEnumA, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[MyEnumA, str]: ...
    def __getitem__(self, key: MyEnumA) -> str: ...
    def __iter__(self) -> _typing.Iterator[MyEnumA]: ...


class Set__i64(_typing.AbstractSet[int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[int]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def intersection(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def difference(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def symmetric_difference(self, other: _typing.AbstractSet[int]) -> 'Set__i64': ...
    def issubset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[int]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


class Map__string_i32(_typing.Mapping[str, int], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, int]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, int]: ...
    def __getitem__(self, key: str) -> int: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__SimpleUnionT = _typing.TypeVar('_List__SimpleUnionT', bound=_typing.Sequence[SimpleUnion])


class List__SimpleUnion(_typing.Sequence[SimpleUnion], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[SimpleUnion]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[SimpleUnion]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> SimpleUnion: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[SimpleUnion]: ...
    def __add__(self, other: _typing.Sequence[SimpleUnion]) -> 'List__SimpleUnion': ...
    def __radd__(self, other: _typing.Sequence[SimpleUnion]) -> 'List__SimpleUnion': ...
    def __reversed__(self) -> _typing.Iterator[SimpleUnion]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[SimpleUnion]: ...


class Set__SimpleUnion(_typing.AbstractSet[SimpleUnion], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[SimpleUnion]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[SimpleUnion]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[SimpleUnion]) -> 'Set__SimpleUnion': ...
    def intersection(self, other: _typing.AbstractSet[SimpleUnion]) -> 'Set__SimpleUnion': ...
    def difference(self, other: _typing.AbstractSet[SimpleUnion]) -> 'Set__SimpleUnion': ...
    def symmetric_difference(self, other: _typing.AbstractSet[SimpleUnion]) -> 'Set__SimpleUnion': ...
    def issubset(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[SimpleUnion]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[SimpleUnion]: ...


_List__Set__SimpleUnionT = _typing.TypeVar('_List__Set__SimpleUnionT', bound=_typing.Sequence[_typing.AbstractSet[SimpleUnion]])


class List__Set__SimpleUnion(_typing.Sequence[_typing.AbstractSet[SimpleUnion]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.AbstractSet[SimpleUnion]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet[SimpleUnion]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet[SimpleUnion]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet[SimpleUnion]]: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]) -> 'List__Set__SimpleUnion': ...
    def __radd__(self, other: _typing.Sequence[_typing.AbstractSet[SimpleUnion]]) -> 'List__Set__SimpleUnion': ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[SimpleUnion]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[SimpleUnion]]: ...


class Map__string_bool(_typing.Mapping[str, bool], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, bool]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, bool]: ...
    def __getitem__(self, key: str) -> bool: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _typing.Mapping[str, int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_Map__string_Map__string_i32(_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Mapping[str, _typing.Mapping[str, int]]]: ...
    def __getitem__(self, key: str) -> _typing.Mapping[str, _typing.Mapping[str, int]]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


_List__Set__i32T = _typing.TypeVar('_List__Set__i32T', bound=_typing.Sequence[_typing.AbstractSet[int]])


class List__Set__i32(_typing.Sequence[_typing.AbstractSet[int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.AbstractSet[int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.AbstractSet[int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.AbstractSet[int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.AbstractSet[int]]: ...
    def __add__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> 'List__Set__i32': ...
    def __radd__(self, other: _typing.Sequence[_typing.AbstractSet[int]]) -> 'List__Set__i32': ...
    def __reversed__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[int]]: ...


class Map__string_List__i32(_typing.Mapping[str, _typing.Sequence[int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _typing.Sequence[int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _typing.Sequence[int]]: ...
    def __getitem__(self, key: str) -> _typing.Sequence[int]: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Set__bool(_typing.AbstractSet[bool], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[bool]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[bool]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def difference(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[bool]) -> 'Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[bool]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[bool]: ...


class Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[bool]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[_typing.AbstractSet[bool]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.AbstractSet[bool]]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> 'Set__Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[bool]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[bool]]: ...


class Set__Set__Set__bool(_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]: ...
    def __contains__(self, x: object) -> bool: ...
    def union(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def intersection(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def symmetric_difference(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> 'Set__Set__Set__bool': ...
    def issubset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def issuperset(self, other: _typing.AbstractSet[_typing.AbstractSet[_typing.AbstractSet[bool]]]) -> bool: ...
    def __iter__(self) -> _typing.Iterator[_typing.AbstractSet[_typing.AbstractSet[bool]]]: ...


class Map__string_folly_IOBuf__binary(_typing.Mapping[str, _fbthrift_iobuf.IOBuf], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _fbthrift_iobuf.IOBuf]: ...
    def __getitem__(self, key: str) -> _fbthrift_iobuf.IOBuf: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__string_std_unique_ptr_folly_IOBuf__binary(_typing.Mapping[str, _fbthrift_iobuf.IOBuf], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[str, _fbthrift_iobuf.IOBuf]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[str, _fbthrift_iobuf.IOBuf]: ...
    def __getitem__(self, key: str) -> _fbthrift_iobuf.IOBuf: ...
    def __iter__(self) -> _typing.Iterator[str]: ...


class Map__i32_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__Map__string_i32T = _typing.TypeVar('_List__Map__string_i32T', bound=_typing.Sequence[_typing.Mapping[str, int]])


class List__Map__string_i32(_typing.Sequence[_typing.Mapping[str, int]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Mapping[str, int]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[str, int]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[str, int]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[str, int]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[str, int]]) -> 'List__Map__string_i32': ...
    def __radd__(self, other: _typing.Sequence[_typing.Mapping[str, int]]) -> 'List__Map__string_i32': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[str, int]]: ...


class Map__i16_string(_typing.Mapping[int, str], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Mapping[int, str]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Mapping[int, str]: ...
    def __getitem__(self, key: int) -> str: ...
    def __iter__(self) -> _typing.Iterator[int]: ...


_List__Map__i16_stringT = _typing.TypeVar('_List__Map__i16_stringT', bound=_typing.Sequence[_typing.Mapping[int, str]])


class List__Map__i16_string(_typing.Sequence[_typing.Mapping[int, str]], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[_typing.Mapping[int, str]]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> _typing.Mapping[int, str]: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[_typing.Mapping[int, str]]: ...
    def __add__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> 'List__Map__i16_string': ...
    def __radd__(self, other: _typing.Sequence[_typing.Mapping[int, str]]) -> 'List__Map__i16_string': ...
    def __reversed__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[_typing.Mapping[int, str]]: ...


_List__MyStructT = _typing.TypeVar('_List__MyStructT', bound=_typing.Sequence[MyStruct])


class List__MyStruct(_typing.Sequence[MyStruct], _typing.Hashable):
    def __init__(self, items: _typing.Optional[_typing.Sequence[MyStruct]]=None) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __copy__(self) -> _typing.Sequence[MyStruct]: ...
    @_typing.overload
    def __getitem__(self, i: int) -> MyStruct: ...
    @_typing.overload
    def __getitem__(self, s: slice) -> _typing.Sequence[MyStruct]: ...
    def __add__(self, other: _typing.Sequence[MyStruct]) -> 'List__MyStruct': ...
    def __radd__(self, other: _typing.Sequence[MyStruct]) -> 'List__MyStruct': ...
    def __reversed__(self) -> _typing.Iterator[MyStruct]: ...
    #pyre-ignore[14]: no idea what pyre is on about
    def __iter__(self) -> _typing.Iterator[MyStruct]: ...


aBool: bool = ...
aByte: int = ...
a16BitInt: int = ...
a32BitInt: int = ...
a64BitInt: int = ...
aFloat: float = ...
aDouble: float = ...
aString: str = ...
aList: List__bool = ...
anEmptyMap: Map__string_i32 = ...
aMap: Map__i32_string = ...
aSet: Set__string = ...
aListOfLists: List__List__i32 = ...
states: List__Map__string_i32 = ...
AConstList: List__MyEnumA = ...
AnIntegerEnum2: int = ...
ListOfIntsFromEnums: List__i32 = ...
constEnumA: MyEnumA = ...
constEnumB: MyEnumA = ...
AStruct = _includes_types.AStruct
CustomProtocolType = _fbthrift_iobuf.IOBuf
simpleTypeDef = int
containerTypeDef = Map__i16_string
complexContainerTypeDef = List__Map__i16_string
unionTypeDef = Set__SimpleUnion
structTypeDef = List__MyStruct
complexStructTypeDef = List__Map__Empty_MyStruct
mostComplexTypeDef = List__List__Map__Empty_MyStruct
CppFakeI32 = int
FollySmallVectorI64 = folly_small_vector_int64_t_8__List__i64
SortedVectorSetString = folly_sorted_vector_set_std_string__Set__string
FakeMap = FakeMap__Map__i64_double
UnorderedMapStruct = std_unordered_map_std_string_containerStruct__Map__string_containerStruct
std_list = std_list__List__i32
std_deque = std_deque__List__string
folly_set = folly_sorted_vector_set__Set__string
folly_map = folly_sorted_vector_map__Map__i64_string
IOBuf = _fbthrift_iobuf.IOBuf
IOBufPtr = _fbthrift_iobuf.IOBuf
