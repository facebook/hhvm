// @generated by Thrift for thrift/compiler/test/fixtures/optionals/src/module.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, clippy::redundant_closure, clippy::type_complexity)]

#[allow(unused_imports)]
pub(crate) use crate as types;



    
    pub type PersonID = ::std::primitive::i64;

    
    #[derive(Clone, PartialEq)]
    pub struct Color {
        pub red: ::std::primitive::f64,
        pub green: ::std::primitive::f64,
        pub blue: ::std::primitive::f64,
        pub alpha: ::std::primitive::f64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }
    
    #[derive(Clone, PartialEq)]
    pub struct Vehicle {
        pub color: crate::types::Color,
        pub licensePlate: ::std::option::Option<::std::string::String>,
        pub description: ::std::option::Option<::std::string::String>,
        pub name: ::std::option::Option<::std::string::String>,
        pub hasAC: ::std::option::Option<::std::primitive::bool>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }
    
    #[derive(Clone, PartialEq)]
    pub struct Person {
        pub id: crate::types::PersonID,
        pub name: ::std::string::String,
        pub age: ::std::option::Option<::std::primitive::i16>,
        pub address: ::std::option::Option<::std::string::String>,
        pub favoriteColor: ::std::option::Option<crate::types::Color>,
        pub friends: ::std::option::Option<::std::collections::BTreeSet<crate::types::PersonID>>,
        pub bestFriend: ::std::option::Option<crate::types::PersonID>,
        pub petNames: ::std::option::Option<::std::collections::BTreeMap<crate::types::Animal, ::std::string::String>>,
        pub afraidOfAnimal: ::std::option::Option<crate::types::Animal>,
        pub vehicles: ::std::option::Option<::std::vec::Vec<crate::types::Vehicle>>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `@rust.Exhaustive` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }


#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
pub struct Animal(pub ::std::primitive::i32);

impl Animal {
    pub const DOG: Self = Animal(1i32);
    pub const CAT: Self = Animal(2i32);
    pub const TARANTULA: Self = Animal(3i32);
}

impl ::fbthrift::ThriftEnum for Animal {
    fn enumerate() -> &'static [(Self, &'static ::std::primitive::str)] {
        &[
            (Self::DOG, "DOG"),
            (Self::CAT, "CAT"),
            (Self::TARANTULA, "TARANTULA"),
        ]
    }

    fn variants() -> &'static [&'static ::std::primitive::str] {
        &[
            "DOG",
            "CAT",
            "TARANTULA",
        ]
    }

    fn variant_values() -> &'static [Self] {
        &[
            Self::DOG,
            Self::CAT,
            Self::TARANTULA,
        ]
    }

    fn inner_value(&self) -> i32 {
        self.0
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for Animal {
    fn default() -> Self {
        Self(0)
    }
}

impl<'a> ::std::convert::From<&'a Animal> for ::std::primitive::i32 {
    #[inline]
    fn from(x: &'a Animal) -> Self {
        x.0
    }
}

impl ::std::convert::From<Animal> for ::std::primitive::i32 {
    #[inline]
    fn from(x: Animal) -> Self {
        x.0
    }
}

impl ::std::convert::From<::std::primitive::i32> for Animal {
    #[inline]
    fn from(x: ::std::primitive::i32) -> Self {
        Self(x)
    }
}

impl ::std::fmt::Display for Animal {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("DOG", 1),
            ("CAT", 2),
            ("TARANTULA", 3),
        ];
        ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
    }
}

impl ::std::fmt::Debug for Animal {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(fmt, "Animal::{}", self)
    }
}

impl ::std::str::FromStr for Animal {
    type Err = ::anyhow::Error;

    fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
        static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
            ("CAT", 2),
            ("DOG", 1),
            ("TARANTULA", 3),
        ];
        ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Animal").map(Self)
    }
}

impl ::fbthrift::GetTType for Animal {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
}

impl<P> ::fbthrift::Serialize<P> for Animal
where
    P: ::fbthrift::ProtocolWriter,
{
    #[inline]
    fn rs_thrift_write(&self, p: &mut P) {
        p.write_i32(self.into())
    }
}

impl<P> ::fbthrift::Deserialize<P> for Animal
where
    P: ::fbthrift::ProtocolReader,
{
    #[inline]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        ::std::result::Result::Ok(Self::from(::anyhow::Context::context(p.read_i32(), "Expected a number indicating enum variant")?))
    }
}
    
    
    #[allow(clippy::derivable_impls)]
    impl ::std::default::Default for self::Color {
        fn default() -> Self {
            Self {
                red: ::std::default::Default::default(),
                green: ::std::default::Default::default(),
                blue: ::std::default::Default::default(),
                alpha: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }
    
    impl ::std::fmt::Debug for self::Color {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Color")
                .field("red", &self.red)
                .field("green", &self.green)
                .field("blue", &self.blue)
                .field("alpha", &self.alpha)
                .finish()
        }
    }
    
    unsafe impl ::std::marker::Send for self::Color {}
    unsafe impl ::std::marker::Sync for self::Color {}
    impl ::std::marker::Unpin for self::Color {}
    impl ::std::panic::RefUnwindSafe for self::Color {}
    impl ::std::panic::UnwindSafe for self::Color {}
    
    impl ::fbthrift::GetTType for self::Color {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }
    
    impl ::fbthrift::GetTypeNameType for self::Color {
        fn type_name_type() -> fbthrift::TypeNameType {
            ::fbthrift::TypeNameType::StructType
        }
    }
    
    impl<P> ::fbthrift::Serialize<P> for self::Color
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn rs_thrift_write(&self, p: &mut P) {
            p.write_struct_begin("Color");
            p.write_field_begin("red", ::fbthrift::TType::Double, 1);
            ::fbthrift::Serialize::rs_thrift_write(&self.red, p);
            p.write_field_end();
            p.write_field_begin("green", ::fbthrift::TType::Double, 2);
            ::fbthrift::Serialize::rs_thrift_write(&self.green, p);
            p.write_field_end();
            p.write_field_begin("blue", ::fbthrift::TType::Double, 3);
            ::fbthrift::Serialize::rs_thrift_write(&self.blue, p);
            p.write_field_end();
            p.write_field_begin("alpha", ::fbthrift::TType::Double, 4);
            ::fbthrift::Serialize::rs_thrift_write(&self.alpha, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    
    impl<P> ::fbthrift::Deserialize<P> for self::Color
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("alpha", ::fbthrift::TType::Double, 4),
                ::fbthrift::Field::new("blue", ::fbthrift::TType::Double, 3),
                ::fbthrift::Field::new("green", ::fbthrift::TType::Double, 2),
                ::fbthrift::Field::new("red", ::fbthrift::TType::Double, 1),
            ];
    
            #[allow(unused_mut)]
            let mut output = Color::default();
            let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Color")?;
            let (_, mut fty, mut fid) = p.read_field_begin(|_| (), FIELDS)?;
            #[allow(unused_labels)]
            let fallback  = 'fastpath: {
                if (fty, fid) == (::fbthrift::TType::Double, 1) {
                    output.red = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "red", strct: "Color"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Double, 2) {
                    output.green = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "green", strct: "Color"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Double, 3) {
                    output.blue = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "blue", strct: "Color"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Double, 4) {
                    output.alpha = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "alpha", strct: "Color"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
    
                fty != ::fbthrift::TType::Stop
            };
    
            if fallback {
                loop {
                    match (fty, fid) {
                        (::fbthrift::TType::Stop, _) => break,
                        (::fbthrift::TType::Double, 1) => output.red = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "red", strct: "Color"})?,
                        (::fbthrift::TType::Double, 2) => output.green = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "green", strct: "Color"})?,
                        (::fbthrift::TType::Double, 3) => output.blue = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "blue", strct: "Color"})?,
                        (::fbthrift::TType::Double, 4) => output.alpha = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "alpha", strct: "Color"})?,
                        (fty, _) => p.skip(fty)?,
                    }
                    p.read_field_end()?;
                    (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                }
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(output)
    
        }
    }
    
    
    impl ::fbthrift::metadata::ThriftAnnotations for Color {
        fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            ::std::option::Option::None
        }
    
        fn get_field_structured_annotation<T: Sized + 'static>(field_id: ::std::primitive::i16) -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            #[allow(clippy::match_single_binding)]
            match field_id {
                1 => {
                },
                2 => {
                },
                3 => {
                },
                4 => {
                },
                _ => {}
            }
    
            ::std::option::Option::None
        }
    }
    
    
    #[allow(clippy::derivable_impls)]
    impl ::std::default::Default for self::Vehicle {
        fn default() -> Self {
            Self {
                color: ::std::default::Default::default(),
                licensePlate: ::std::option::Option::None,
                description: ::std::option::Option::None,
                name: ::std::option::Option::None,
                hasAC: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }
    
    impl ::std::fmt::Debug for self::Vehicle {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Vehicle")
                .field("color", &self.color)
                .field("licensePlate", &self.licensePlate)
                .field("description", &self.description)
                .field("name", &self.name)
                .field("hasAC", &self.hasAC)
                .finish()
        }
    }
    
    unsafe impl ::std::marker::Send for self::Vehicle {}
    unsafe impl ::std::marker::Sync for self::Vehicle {}
    impl ::std::marker::Unpin for self::Vehicle {}
    impl ::std::panic::RefUnwindSafe for self::Vehicle {}
    impl ::std::panic::UnwindSafe for self::Vehicle {}
    
    impl ::fbthrift::GetTType for self::Vehicle {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }
    
    impl ::fbthrift::GetTypeNameType for self::Vehicle {
        fn type_name_type() -> fbthrift::TypeNameType {
            ::fbthrift::TypeNameType::StructType
        }
    }
    
    impl<P> ::fbthrift::Serialize<P> for self::Vehicle
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn rs_thrift_write(&self, p: &mut P) {
            p.write_struct_begin("Vehicle");
            p.write_field_begin("color", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::rs_thrift_write(&self.color, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.licensePlate {
                p.write_field_begin("licensePlate", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.description {
                p.write_field_begin("description", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.name {
                p.write_field_begin("name", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.hasAC {
                p.write_field_begin("hasAC", ::fbthrift::TType::Bool, 5);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    
    impl<P> ::fbthrift::Deserialize<P> for self::Vehicle
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("color", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("description", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("hasAC", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("licensePlate", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 4),
            ];
    
            #[allow(unused_mut)]
            let mut output = Vehicle::default();
            let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Vehicle")?;
            let (_, mut fty, mut fid) = p.read_field_begin(|_| (), FIELDS)?;
            #[allow(unused_labels)]
            let fallback  = 'fastpath: {
                if (fty, fid) == (::fbthrift::TType::Struct, 1) {
                    output.color = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "color", strct: "Vehicle"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::String, 2) {
                    output.licensePlate = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "licensePlate", strct: "Vehicle"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::String, 3) {
                    output.description = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "description", strct: "Vehicle"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::String, 4) {
                    output.name = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "name", strct: "Vehicle"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Bool, 5) {
                    output.hasAC = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "hasAC", strct: "Vehicle"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
    
                fty != ::fbthrift::TType::Stop
            };
    
            if fallback {
                loop {
                    match (fty, fid) {
                        (::fbthrift::TType::Stop, _) => break,
                        (::fbthrift::TType::Struct, 1) => output.color = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "color", strct: "Vehicle"})?,
                        (::fbthrift::TType::String, 2) => output.licensePlate = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "licensePlate", strct: "Vehicle"})?),
                        (::fbthrift::TType::String, 3) => output.description = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "description", strct: "Vehicle"})?),
                        (::fbthrift::TType::String, 4) => output.name = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "name", strct: "Vehicle"})?),
                        (::fbthrift::TType::Bool, 5) => output.hasAC = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "hasAC", strct: "Vehicle"})?),
                        (fty, _) => p.skip(fty)?,
                    }
                    p.read_field_end()?;
                    (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                }
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(output)
    
        }
    }
    
    
    impl ::fbthrift::metadata::ThriftAnnotations for Vehicle {
        fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            ::std::option::Option::None
        }
    
        fn get_field_structured_annotation<T: Sized + 'static>(field_id: ::std::primitive::i16) -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            #[allow(clippy::match_single_binding)]
            match field_id {
                1 => {
                },
                2 => {
                },
                3 => {
                },
                4 => {
                },
                5 => {
    
                    if type_id == ::std::any::TypeId::of::<thrift__types::AllowUnsafeOptionalCustomDefaultValue>() {
                        let mut tmp = ::std::option::Option::Some(thrift__types::AllowUnsafeOptionalCustomDefaultValue {
                            ..::std::default::Default::default()
                        });
                        let r: &mut dyn ::std::any::Any = &mut tmp;
                        let r: &mut ::std::option::Option<T> = r.downcast_mut().unwrap();
                        return r.take();
                    }
                },
                _ => {}
            }
    
            ::std::option::Option::None
        }
    }
    
    
    #[allow(clippy::derivable_impls)]
    impl ::std::default::Default for self::Person {
        fn default() -> Self {
            Self {
                id: ::std::default::Default::default(),
                name: ::std::default::Default::default(),
                age: ::std::option::Option::None,
                address: ::std::option::Option::None,
                favoriteColor: ::std::option::Option::None,
                friends: ::std::option::Option::None,
                bestFriend: ::std::option::Option::None,
                petNames: ::std::option::Option::None,
                afraidOfAnimal: ::std::option::Option::None,
                vehicles: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }
    
    impl ::std::fmt::Debug for self::Person {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Person")
                .field("id", &self.id)
                .field("name", &self.name)
                .field("age", &self.age)
                .field("address", &self.address)
                .field("favoriteColor", &self.favoriteColor)
                .field("friends", &self.friends)
                .field("bestFriend", &self.bestFriend)
                .field("petNames", &self.petNames)
                .field("afraidOfAnimal", &self.afraidOfAnimal)
                .field("vehicles", &self.vehicles)
                .finish()
        }
    }
    
    unsafe impl ::std::marker::Send for self::Person {}
    unsafe impl ::std::marker::Sync for self::Person {}
    impl ::std::marker::Unpin for self::Person {}
    impl ::std::panic::RefUnwindSafe for self::Person {}
    impl ::std::panic::UnwindSafe for self::Person {}
    
    impl ::fbthrift::GetTType for self::Person {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }
    
    impl ::fbthrift::GetTypeNameType for self::Person {
        fn type_name_type() -> fbthrift::TypeNameType {
            ::fbthrift::TypeNameType::StructType
        }
    }
    
    impl<P> ::fbthrift::Serialize<P> for self::Person
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn rs_thrift_write(&self, p: &mut P) {
            p.write_struct_begin("Person");
            p.write_field_begin("id", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::rs_thrift_write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::rs_thrift_write(&self.name, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.age {
                p.write_field_begin("age", ::fbthrift::TType::I16, 3);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.address {
                p.write_field_begin("address", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.favoriteColor {
                p.write_field_begin("favoriteColor", ::fbthrift::TType::Struct, 5);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.friends {
                p.write_field_begin("friends", ::fbthrift::TType::Set, 6);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.bestFriend {
                p.write_field_begin("bestFriend", ::fbthrift::TType::I64, 7);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.petNames {
                p.write_field_begin("petNames", ::fbthrift::TType::Map, 8);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.afraidOfAnimal {
                p.write_field_begin("afraidOfAnimal", ::fbthrift::TType::I32, 9);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vehicles {
                p.write_field_begin("vehicles", ::fbthrift::TType::List, 10);
                ::fbthrift::Serialize::rs_thrift_write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    
    impl<P> ::fbthrift::Deserialize<P> for self::Person
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("address", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("afraidOfAnimal", ::fbthrift::TType::I32, 9),
                ::fbthrift::Field::new("age", ::fbthrift::TType::I16, 3),
                ::fbthrift::Field::new("bestFriend", ::fbthrift::TType::I64, 7),
                ::fbthrift::Field::new("favoriteColor", ::fbthrift::TType::Struct, 5),
                ::fbthrift::Field::new("friends", ::fbthrift::TType::Set, 6),
                ::fbthrift::Field::new("id", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("petNames", ::fbthrift::TType::Map, 8),
                ::fbthrift::Field::new("vehicles", ::fbthrift::TType::List, 10),
            ];
    
            #[allow(unused_mut)]
            let mut output = Person::default();
            let _ = ::anyhow::Context::context(p.read_struct_begin(|_| ()), "Expected a Person")?;
            let (_, mut fty, mut fid) = p.read_field_begin(|_| (), FIELDS)?;
            #[allow(unused_labels)]
            let fallback  = 'fastpath: {
                if (fty, fid) == (::fbthrift::TType::I64, 1) {
                    output.id = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "id", strct: "Person"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::String, 2) {
                    output.name = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "name", strct: "Person"})?;
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::I16, 3) {
                    output.age = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "age", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::String, 4) {
                    output.address = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "address", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Struct, 5) {
                    output.favoriteColor = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "favoriteColor", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Set, 6) {
                    output.friends = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "friends", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::I64, 7) {
                    output.bestFriend = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "bestFriend", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::Map, 8) {
                    output.petNames = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "petNames", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::I32, 9) {
                    output.afraidOfAnimal = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "afraidOfAnimal", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                if (fty, fid) == (::fbthrift::TType::List, 10) {
                    output.vehicles = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "vehicles", strct: "Person"})?);
                    p.read_field_end()?;
                } else {
                    break 'fastpath true;
                }
                (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
    
                fty != ::fbthrift::TType::Stop
            };
    
            if fallback {
                loop {
                    match (fty, fid) {
                        (::fbthrift::TType::Stop, _) => break,
                        (::fbthrift::TType::I64, 1) => output.id = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "id", strct: "Person"})?,
                        (::fbthrift::TType::String, 2) => output.name = ::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "name", strct: "Person"})?,
                        (::fbthrift::TType::I16, 3) => output.age = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "age", strct: "Person"})?),
                        (::fbthrift::TType::String, 4) => output.address = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "address", strct: "Person"})?),
                        (::fbthrift::TType::Struct, 5) => output.favoriteColor = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "favoriteColor", strct: "Person"})?),
                        (::fbthrift::TType::Set, 6) => output.friends = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "friends", strct: "Person"})?),
                        (::fbthrift::TType::I64, 7) => output.bestFriend = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "bestFriend", strct: "Person"})?),
                        (::fbthrift::TType::Map, 8) => output.petNames = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "petNames", strct: "Person"})?),
                        (::fbthrift::TType::I32, 9) => output.afraidOfAnimal = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "afraidOfAnimal", strct: "Person"})?),
                        (::fbthrift::TType::List, 10) => output.vehicles = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingFieldError { field: "vehicles", strct: "Person"})?),
                        (fty, _) => p.skip(fty)?,
                    }
                    p.read_field_end()?;
                    (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                }
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(output)
    
        }
    }
    
    
    impl ::fbthrift::metadata::ThriftAnnotations for Person {
        fn get_structured_annotation<T: Sized + 'static>() -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            ::std::option::Option::None
        }
    
        fn get_field_structured_annotation<T: Sized + 'static>(field_id: ::std::primitive::i16) -> ::std::option::Option<T> {
            #[allow(unused_variables)]
            let type_id = ::std::any::TypeId::of::<T>();
    
            #[allow(clippy::match_single_binding)]
            match field_id {
                1 => {
                },
                2 => {
                },
                3 => {
                },
                4 => {
                },
                5 => {
                },
                6 => {
                },
                7 => {
                },
                8 => {
                },
                9 => {
                },
                10 => {
                },
                _ => {}
            }
    
            ::std::option::Option::None
        }
    }
    

mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}

pub(crate) mod r#impl {
    use ::ref_cast::RefCast;

    #[derive(RefCast)]
    #[repr(transparent)]
    pub(crate) struct LocalImpl<T>(T);

    #[allow(unused)]
    pub(crate) fn rs_thrift_write<T, P>(value: &T, p: &mut P)
    where
        LocalImpl<T>: ::fbthrift::Serialize<P>,
        P: ::fbthrift::ProtocolWriter,
    {
        ::fbthrift::Serialize::rs_thrift_write(LocalImpl::ref_cast(value), p);
    }

    #[allow(unused)]
    pub(crate) fn rs_thrift_read<T, P>(p: &mut P) -> ::anyhow::Result<T>
    where
        LocalImpl<T>: ::fbthrift::Deserialize<P>,
        P: ::fbthrift::ProtocolReader,
    {
        let value: LocalImpl<T> = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        ::std::result::Result::Ok(value.0)
    }
}


#[doc(hidden)]
#[deprecated]
#[allow(hidden_glob_reexports)]
pub mod __constructors {
    mod Animal {
        pub use crate::Animal;
    }
    pub use self::Animal::*;
}




