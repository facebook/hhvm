#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/interactions/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libc.stdint cimport (
    int8_t as cint8_t,
    int16_t as cint16_t,
    int32_t as cint32_t,
    int64_t as cint64_t,
)
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from libcpp.utility cimport move as cmove
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper, cClientWrapper
from thrift.py3.exceptions cimport unwrap_exception
from thrift.python.exceptions cimport create_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from folly.cast cimport down_cast_ptr
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
from thrift.py3.types cimport (
    make_unique,
    deref_const as __deref_const,
)
import thrift.py3.client
cimport thrift.py3.client
from thrift.python.common cimport (
    RpcOptions as __RpcOptions,
    cThriftServiceMetadataResponse as __fbthrift_cThriftServiceMetadataResponse,
    ServiceMetadata,
    MetadataBox as __MetadataBox,
)

from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport folly.iobuf as _fbthrift_iobuf
import folly.iobuf as _fbthrift_iobuf
from folly.iobuf cimport move as move_iobuf
cimport cython

import sys
import types as _py_types
from asyncio import get_event_loop as asyncio_get_event_loop, shield as asyncio_shield, InvalidStateError as asyncio_InvalidStateError

cimport test.fixtures.interactions.module.types as _test_fixtures_interactions_module_types
cimport test.fixtures.interactions.module.cbindings as _test_fixtures_interactions_module_cbindings
cimport test.fixtures.interactions.module.thrift_converter as _test_fixtures_interactions_module_thrift_converter
import test.fixtures.interactions.module.types as _test_fixtures_interactions_module_types
from thrift.py3.stream cimport cResponseAndClientBufferedStream, cClientBufferedStream
cimport test.fixtures.another_interactions.shared.types as _test_fixtures_another_interactions_shared_types
cimport test.fixtures.another_interactions.shared.cbindings as _test_fixtures_another_interactions_shared_cbindings
cimport test.fixtures.another_interactions.shared.thrift_converter as _test_fixtures_another_interactions_shared_thrift_converter
import test.fixtures.another_interactions.shared.types as _test_fixtures_another_interactions_shared_types
cimport test.fixtures.another_interactions.shared.clients as _test_fixtures_another_interactions_shared_clients
import test.fixtures.another_interactions.shared.clients as _test_fixtures_another_interactions_shared_clients

cimport test.fixtures.interactions.module.services_interface as _fbthrift_services_interface

from test.fixtures.interactions.module.clients_wrapper cimport cMyServiceAsyncClient, cMyServiceClientWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cMyServiceClientWrapper_MyInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cMyServiceClientWrapper_MyInteractionFastInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cMyServiceClientWrapper_SerialInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cFactoriesAsyncClient, cFactoriesClientWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cPerformAsyncClient, cPerformClientWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cPerformClientWrapper_MyInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cPerformClientWrapper_MyInteractionFastInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cPerformClientWrapper_SerialInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cInteractWithSharedAsyncClient, cInteractWithSharedClientWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cInteractWithSharedClientWrapper_MyInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cInteractWithSharedClientWrapper_SharedInteractionInteractionWrapper
from test.fixtures.interactions.module.clients_wrapper cimport cBoxServiceAsyncClient, cBoxServiceClientWrapper


cdef void MyService_foo_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_interact_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_interactFast_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_serialize_callback(
    cFollyTry[cResponseAndClientBufferedStream[cint32_t,cint32_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ResponseAndClientBufferedStream__i32_i32._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteraction_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException[_test_fixtures_interactions_module_cbindings.cCustomException]():
        try:
            exc = _test_fixtures_interactions_module_types.CustomException.from_python(_test_fixtures_interactions_module_thrift_converter.CustomException_from_cpp(
                unwrap_exception[_test_fixtures_interactions_module_cbindings.cCustomException](result.exception())
            ))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))
        else:
            pyfuture.set_exception(exc)
    elif result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteraction_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteraction_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteractionFast_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteractionFast_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_MyInteractionFast_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void MyService_SerialInteraction_frobnicate_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_foo_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_interact_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_interactFast_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_serialize_callback(
    cFollyTry[cResponseAndClientBufferedStream[cint32_t,cint32_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ResponseAndClientBufferedStream__i32_i32._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteraction_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException[_test_fixtures_interactions_module_cbindings.cCustomException]():
        try:
            exc = _test_fixtures_interactions_module_types.CustomException.from_python(_test_fixtures_interactions_module_thrift_converter.CustomException_from_cpp(
                unwrap_exception[_test_fixtures_interactions_module_cbindings.cCustomException](result.exception())
            ))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))
        else:
            pyfuture.set_exception(exc)
    elif result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteraction_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteraction_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteractionFast_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteractionFast_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_MyInteractionFast_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Factories_SerialInteraction_frobnicate_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_foo_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteraction_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException[_test_fixtures_interactions_module_cbindings.cCustomException]():
        try:
            exc = _test_fixtures_interactions_module_types.CustomException.from_python(_test_fixtures_interactions_module_thrift_converter.CustomException_from_cpp(
                unwrap_exception[_test_fixtures_interactions_module_cbindings.cCustomException](result.exception())
            ))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))
        else:
            pyfuture.set_exception(exc)
    elif result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteraction_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteraction_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteractionFast_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteractionFast_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_MyInteractionFast_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void Perform_SerialInteraction_frobnicate_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_do_some_similar_things_callback(
    cFollyTry[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_another_interactions_shared_types.DoSomethingResult.from_python(_test_fixtures_another_interactions_shared_thrift_converter.DoSomethingResult_from_cpp(__deref_const[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult](result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_MyInteraction_frobnicate_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException[_test_fixtures_interactions_module_cbindings.cCustomException]():
        try:
            exc = _test_fixtures_interactions_module_types.CustomException.from_python(_test_fixtures_interactions_module_thrift_converter.CustomException_from_cpp(
                unwrap_exception[_test_fixtures_interactions_module_cbindings.cCustomException](result.exception())
            ))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))
        else:
            pyfuture.set_exception(exc)
    elif result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_MyInteraction_ping_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_MyInteraction_truthify_callback(
    cFollyTry[cClientBufferedStream[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ClientBufferedStream__bool._fbthrift_create(result.value(), options))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_SharedInteraction_init_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_SharedInteraction_do_something_callback(
    cFollyTry[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_another_interactions_shared_types.DoSomethingResult.from_python(_test_fixtures_another_interactions_shared_thrift_converter.DoSomethingResult_from_cpp(__deref_const[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult](result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void InteractWithShared_SharedInteraction_tear_down_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void BoxService_getABoxSession_callback(
    cFollyTry[_test_fixtures_interactions_module_cbindings.cShouldBeBoxed]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ShouldBeBoxed.from_python(_test_fixtures_interactions_module_thrift_converter.ShouldBeBoxed_from_cpp(__deref_const[_test_fixtures_interactions_module_cbindings.cShouldBeBoxed](result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void BoxService_BoxedInteraction_getABox_callback(
    cFollyTry[_test_fixtures_interactions_module_cbindings.cShouldBeBoxed]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_test_fixtures_interactions_module_types.ShouldBeBoxed.from_python(_test_fixtures_interactions_module_thrift_converter.ShouldBeBoxed_from_cpp(__deref_const[_test_fixtures_interactions_module_cbindings.cShouldBeBoxed](result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))


cdef object _MyService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class MyService(thrift.py3.client.Client):
    annotations = _MyService_annotations

    cdef const type_info* _typeid(MyService self):
        return &typeid(cMyServiceAsyncClient)

    cdef bind_client(MyService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cMyServiceAsyncClient, cMyServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_foo = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def foo(
            MyService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).foo(rpc_options._cpp_obj, 
            ),
            MyService_foo_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_interact = {
        'return': 'None',
        'arg': 'int', 
    }

    @cython.always_allow_keywords(True)
    def interact(
            MyService self,
            arg not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(arg, int):
            raise TypeError(f'arg is not a {int !r}.')
        else:
            arg = <cint32_t> arg
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).interact(rpc_options._cpp_obj, 
                arg,
            ),
            MyService_interact_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_interactFast = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def interactFast(
            MyService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).interactFast(rpc_options._cpp_obj, 
            ),
            MyService_interactFast_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_serialize = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def serialize(
            MyService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cResponseAndClientBufferedStream[cint32_t,cint32_t]](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).serialize(rpc_options._cpp_obj, 
            ),
            MyService_serialize_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    def createMyInteraction(
            MyService self
    ):
        interaction = MyService_MyInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).createMyInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createMyInteraction(
            MyService self
    ):
        return self.createMyInteraction()

    def createMyInteractionFast(
            MyService self
    ):
        interaction = MyService_MyInteractionFast()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).createMyInteractionFast(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createMyInteractionFast(
            MyService self
    ):
        return self.createMyInteractionFast()

    def createSerialInteraction(
            MyService self
    ):
        interaction = MyService_SerialInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cMyServiceClientWrapper, cClientWrapper](self._client.get()).createSerialInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createSerialInteraction(
            MyService self
    ):
        return self.createSerialInteraction()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cMyServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyService"

@cython.auto_pickle(False)
cdef class MyService_MyInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            MyService_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            MyService_MyInteraction_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def ping(
            MyService_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).ping(rpc_options._cpp_obj, 
            ),
            MyService_MyInteraction_ping_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def truthify(
            MyService_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cClientBufferedStream[cbool]](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).truthify(rpc_options._cpp_obj, 
            ),
            MyService_MyInteraction_truthify_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

@cython.auto_pickle(False)
cdef class MyService_MyInteractionFast(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            MyService_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            MyService_MyInteractionFast_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def ping(
            MyService_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).ping(rpc_options._cpp_obj, 
            ),
            MyService_MyInteractionFast_ping_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def truthify(
            MyService_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cClientBufferedStream[cbool]](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).truthify(rpc_options._cpp_obj, 
            ),
            MyService_MyInteractionFast_truthify_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

@cython.auto_pickle(False)
cdef class MyService_SerialInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            MyService_SerialInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cMyServiceClientWrapper_SerialInteractionInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            MyService_SerialInteraction_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

cdef object _Factories_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class Factories(thrift.py3.client.Client):
    annotations = _Factories_annotations

    cdef const type_info* _typeid(Factories self):
        return &typeid(cFactoriesAsyncClient)

    cdef bind_client(Factories self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cFactoriesAsyncClient, cFactoriesClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_foo = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def foo(
            Factories self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cFactoriesClientWrapper, cClientWrapper](self._client.get()).foo(rpc_options._cpp_obj, 
            ),
            Factories_foo_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_interact = {
        'return': 'None',
        'arg': 'int', 
    }

    @cython.always_allow_keywords(True)
    def interact(
            Factories self,
            arg not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(arg, int):
            raise TypeError(f'arg is not a {int !r}.')
        else:
            arg = <cint32_t> arg
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cFactoriesClientWrapper, cClientWrapper](self._client.get()).interact(rpc_options._cpp_obj, 
                arg,
            ),
            Factories_interact_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_interactFast = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def interactFast(
            Factories self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cFactoriesClientWrapper, cClientWrapper](self._client.get()).interactFast(rpc_options._cpp_obj, 
            ),
            Factories_interactFast_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_serialize = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def serialize(
            Factories self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cResponseAndClientBufferedStream[cint32_t,cint32_t]](
            self._executor,
            down_cast_ptr[cFactoriesClientWrapper, cClientWrapper](self._client.get()).serialize(rpc_options._cpp_obj, 
            ),
            Factories_serialize_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cFactoriesSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.Factories"

cdef object _Perform_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class Perform(thrift.py3.client.Client):
    annotations = _Perform_annotations

    cdef const type_info* _typeid(Perform self):
        return &typeid(cPerformAsyncClient)

    cdef bind_client(Perform self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cPerformAsyncClient, cPerformClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_foo = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def foo(
            Perform self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cPerformClientWrapper, cClientWrapper](self._client.get()).foo(rpc_options._cpp_obj, 
            ),
            Perform_foo_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    def createMyInteraction(
            Perform self
    ):
        interaction = Perform_MyInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cPerformClientWrapper, cClientWrapper](self._client.get()).createMyInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createMyInteraction(
            Perform self
    ):
        return self.createMyInteraction()

    def createMyInteractionFast(
            Perform self
    ):
        interaction = Perform_MyInteractionFast()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cPerformClientWrapper, cClientWrapper](self._client.get()).createMyInteractionFast(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createMyInteractionFast(
            Perform self
    ):
        return self.createMyInteractionFast()

    def createSerialInteraction(
            Perform self
    ):
        interaction = Perform_SerialInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cPerformClientWrapper, cClientWrapper](self._client.get()).createSerialInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createSerialInteraction(
            Perform self
    ):
        return self.createSerialInteraction()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cPerformSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.Perform"

@cython.auto_pickle(False)
cdef class Perform_MyInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            Perform_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            Perform_MyInteraction_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def ping(
            Perform_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).ping(rpc_options._cpp_obj, 
            ),
            Perform_MyInteraction_ping_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def truthify(
            Perform_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cClientBufferedStream[cbool]](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).truthify(rpc_options._cpp_obj, 
            ),
            Perform_MyInteraction_truthify_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

@cython.auto_pickle(False)
cdef class Perform_MyInteractionFast(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            Perform_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            Perform_MyInteractionFast_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def ping(
            Perform_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).ping(rpc_options._cpp_obj, 
            ),
            Perform_MyInteractionFast_ping_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def truthify(
            Perform_MyInteractionFast self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cClientBufferedStream[cbool]](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_MyInteractionFastInteractionWrapper, cClientWrapper](self._client.get()).truthify(rpc_options._cpp_obj, 
            ),
            Perform_MyInteractionFast_truthify_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

@cython.auto_pickle(False)
cdef class Perform_SerialInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            Perform_SerialInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cPerformClientWrapper_SerialInteractionInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            Perform_SerialInteraction_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

cdef object _InteractWithShared_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class InteractWithShared(thrift.py3.client.Client):
    annotations = _InteractWithShared_annotations

    cdef const type_info* _typeid(InteractWithShared self):
        return &typeid(cInteractWithSharedAsyncClient)

    cdef bind_client(InteractWithShared self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cInteractWithSharedAsyncClient, cInteractWithSharedClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_do_some_similar_things = {
        'return': 'test.fixtures.another_interactions.shared.types.DoSomethingResult',
        
    }

    @cython.always_allow_keywords(True)
    def do_some_similar_things(
            InteractWithShared self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper, cClientWrapper](self._client.get()).do_some_similar_things(rpc_options._cpp_obj, 
            ),
            InteractWithShared_do_some_similar_things_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    def createMyInteraction(
            InteractWithShared self
    ):
        interaction = InteractWithShared_MyInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper, cClientWrapper](self._client.get()).createMyInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createMyInteraction(
            InteractWithShared self
    ):
        return self.createMyInteraction()

    def createSharedInteraction(
            InteractWithShared self
    ):
        interaction = InteractWithShared_SharedInteraction()
        bridgeFutureWith[unique_ptr[cClientWrapper]](
            interaction._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper, cClientWrapper](self._client.get()).createSharedInteraction(),
            thrift.py3.client.interactions_callback,
            <PyObject *> interaction
        )
        return interaction

    async def async_createSharedInteraction(
            InteractWithShared self
    ):
        return self.createSharedInteraction()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cInteractWithSharedSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.InteractWithShared"

@cython.auto_pickle(False)
cdef class InteractWithShared_MyInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def frobnicate(
            InteractWithShared_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).frobnicate(rpc_options._cpp_obj, 
            ),
            InteractWithShared_MyInteraction_frobnicate_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def ping(
            InteractWithShared_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).ping(rpc_options._cpp_obj, 
            ),
            InteractWithShared_MyInteraction_ping_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def truthify(
            InteractWithShared_MyInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cClientBufferedStream[cbool]](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_MyInteractionInteractionWrapper, cClientWrapper](self._client.get()).truthify(rpc_options._cpp_obj, 
            ),
            InteractWithShared_MyInteraction_truthify_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

@cython.auto_pickle(False)
cdef class InteractWithShared_SharedInteraction(thrift.py3.client.Client):

    @cython.always_allow_keywords(True)
    def init(
            InteractWithShared_SharedInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_SharedInteractionInteractionWrapper, cClientWrapper](self._client.get()).init(rpc_options._cpp_obj, 
            ),
            InteractWithShared_SharedInteraction_init_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def do_something(
            InteractWithShared_SharedInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_test_fixtures_another_interactions_shared_cbindings.cDoSomethingResult](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_SharedInteractionInteractionWrapper, cClientWrapper](self._client.get()).do_something(rpc_options._cpp_obj, 
            ),
            InteractWithShared_SharedInteraction_do_something_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    @cython.always_allow_keywords(True)
    def tear_down(
            InteractWithShared_SharedInteraction self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cInteractWithSharedClientWrapper_SharedInteractionInteractionWrapper, cClientWrapper](self._client.get()).tear_down(rpc_options._cpp_obj, 
            ),
            InteractWithShared_SharedInteraction_tear_down_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

cdef object _BoxService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class BoxService(thrift.py3.client.Client):
    annotations = _BoxService_annotations

    cdef const type_info* _typeid(BoxService self):
        return &typeid(cBoxServiceAsyncClient)

    cdef bind_client(BoxService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cBoxServiceAsyncClient, cBoxServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_getABoxSession = {
        'return': 'test.fixtures.interactions.module.types.ShouldBeBoxed',
        'req': 'test.fixtures.interactions.module.types.ShouldBeBoxed', 
    }

    @cython.always_allow_keywords(True)
    def getABoxSession(
            BoxService self,
            req not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_test_fixtures_interactions_module_cbindings.cShouldBeBoxed](
            self._executor,
            down_cast_ptr[cBoxServiceClientWrapper, cClientWrapper](self._client.get()).getABoxSession(rpc_options._cpp_obj, 
                _test_fixtures_interactions_module_thrift_converter.ShouldBeBoxed_convert_to_cpp(req._to_python()),
            ),
            BoxService_getABoxSession_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cBoxServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.BoxService"

