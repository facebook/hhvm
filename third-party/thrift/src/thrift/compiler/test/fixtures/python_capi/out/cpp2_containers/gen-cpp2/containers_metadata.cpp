/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/python_capi/src/containers.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include <thrift/lib/cpp2/gen/module_metadata_cpp.h>
#include "thrift/compiler/test/fixtures/python_capi/gen-cpp2/containers_metadata.h"

// some of these functions can be so large that the compiler gives up optimizing
// them - and issues a warning which may be treated as an error!
//
// these functions are so rarely called that it is probably okay for them not to
// be optimized in practice
FOLLY_CLANG_DISABLE_WARNING("-Wignored-optimization-argument")

namespace apache {
namespace thrift {
namespace detail {
namespace md {
using ThriftMetadata = ::apache::thrift::metadata::ThriftMetadata;
using ThriftPrimitiveType = ::apache::thrift::metadata::ThriftPrimitiveType;
using ThriftType = ::apache::thrift::metadata::ThriftType;
using ThriftService = ::apache::thrift::metadata::ThriftService;
using ThriftServiceContext = ::apache::thrift::metadata::ThriftServiceContext;
using ThriftFunctionGenerator = void (*)(ThriftMetadata&, ThriftService&);


const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateLists>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.TemplateLists", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateLists = res.first->second;
  containers_TemplateLists.name() = "containers.TemplateLists";
  containers_TemplateLists.is_union() = false;
  static const auto* const
  containers_TemplateLists_fields = new std::array<EncodedThriftField, 5>{ {
    { 1, "std_string", true, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::vector") } }).cv_struct_ref(), }},    { 2, "deque_string", false, std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::deque") } }).cv_struct_ref(), }},    { 3, "small_vector_iobuf", false, std::make_unique<Typedef>("containers.small_vector_iobuf", std::make_unique<List>(std::make_unique<Typedef>("containers.IOBuf", std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"name", cvString("folly::IOBuf") } }).cv_struct_ref(),  })), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"template", cvString("folly::small_vector") } }).cv_struct_ref(),  }), std::vector<ThriftConstStruct>{ }},    { 4, "nested_small_vector", false, std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_string", std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct_ref(),  })), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::small_vector") } }).cv_struct_ref(), }},    { 5, "small_vector_tensor", false, std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_fbvector_string", std::make_unique<List>(std::make_unique<Typedef>("containers.fbvector_string", std::make_unique<List>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct_ref(),  })), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct_ref(),  })), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::fbvector") } }).cv_struct_ref(), }},  }};
  for (const auto& f : *containers_TemplateLists_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_TemplateLists.fields()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateSets>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.TemplateSets", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateSets = res.first->second;
  containers_TemplateSets.name() = "containers.TemplateSets";
  containers_TemplateSets.is_union() = false;
  static const auto* const
  containers_TemplateSets_fields = new std::array<EncodedThriftField, 7>{ {
    { 1, "std_set", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::set") } }).cv_struct_ref(), }},    { 2, "std_unordered", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::unordered_set") } }).cv_struct_ref(), }},    { 3, "folly_fast", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14FastSet") } }).cv_struct_ref(), }},    { 4, "folly_node", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14NodeSet") } }).cv_struct_ref(), }},    { 5, "folly_value", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14ValueSet") } }).cv_struct_ref(), }},    { 6, "folly_vector", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14VectorSet") } }).cv_struct_ref(), }},    { 7, "folly_sorted_vector", false, std::make_unique<Set>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::sorted_vector_set") } }).cv_struct_ref(), }},  }};
  for (const auto& f : *containers_TemplateSets_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_TemplateSets.fields()->push_back(std::move(field));
  }
  containers_TemplateSets.structured_annotations()->push_back(*cvStruct("cpp.EnableCustomTypeOrdering", {  }).cv_struct_ref());
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TemplateMaps>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.TemplateMaps", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TemplateMaps = res.first->second;
  containers_TemplateMaps.name() = "containers.TemplateMaps";
  containers_TemplateMaps.is_union() = false;
  static const auto* const
  containers_TemplateMaps_fields = new std::array<EncodedThriftField, 7>{ {
    { 1, "std_map", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::map") } }).cv_struct_ref(), }},    { 2, "std_unordered", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("std::unordered_map") } }).cv_struct_ref(), }},    { 3, "folly_fast", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14FastMap") } }).cv_struct_ref(), }},    { 4, "folly_node", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14NodeMap") } }).cv_struct_ref(), }},    { 5, "folly_value", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14ValueMap") } }).cv_struct_ref(), }},    { 6, "folly_vector", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::F14VectorMap") } }).cv_struct_ref(), }},    { 7, "folly_sorted_vector", false, std::make_unique<Map>(std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE)), std::vector<ThriftConstStruct>{ *cvStruct("cpp.Type", { {"template", cvString("folly::sorted_vector_map") } }).cv_struct_ref(), }},  }};
  for (const auto& f : *containers_TemplateMaps_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_TemplateMaps.fields()->push_back(std::move(field));
  }
  containers_TemplateMaps.structured_annotations()->push_back(*cvStruct("cpp.EnableCustomTypeOrdering", {  }).cv_struct_ref());
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::TWrapped>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.TWrapped", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_TWrapped = res.first->second;
  containers_TWrapped.name() = "containers.TWrapped";
  containers_TWrapped.is_union() = false;
  static const auto* const
  containers_TWrapped_fields = new std::array<EncodedThriftField, 2>{ {
    { 1, "fieldA", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_STRING_TYPE), std::vector<ThriftConstStruct>{ }},    { 2, "fieldB", false, std::make_unique<Primitive>(ThriftPrimitiveType::THRIFT_BINARY_TYPE), std::vector<ThriftConstStruct>{ }},  }};
  for (const auto& f : *containers_TWrapped_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_TWrapped.fields()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionA>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.IndirectionA", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionA = res.first->second;
  containers_IndirectionA.name() = "containers.IndirectionA";
  containers_IndirectionA.is_union() = false;
  static const auto* const
  containers_IndirectionA_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.ListOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(),  }), std::vector<ThriftConstStruct>{ }},  }};
  for (const auto& f : *containers_IndirectionA_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_IndirectionA.fields()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionB>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.IndirectionB", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionB = res.first->second;
  containers_IndirectionB.name() = "containers.IndirectionB";
  containers_IndirectionB.is_union() = false;
  static const auto* const
  containers_IndirectionB_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.VecOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(), *cvStruct("cpp.Type", { {"template", cvString("std::vector") } }).cv_struct_ref(),  }), std::vector<ThriftConstStruct>{ }},  }};
  for (const auto& f : *containers_IndirectionB_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_IndirectionB.fields()->push_back(std::move(field));
  }
  return res.first->second;
}
const ::apache::thrift::metadata::ThriftStruct&
StructMetadata<::test::fixtures::python_capi::IndirectionC>::gen(ThriftMetadata& metadata) {
  auto res = metadata.structs()->emplace("containers.IndirectionC", ::apache::thrift::metadata::ThriftStruct{});
  if (!res.second) {
    return res.first->second;
  }
  ::apache::thrift::metadata::ThriftStruct& containers_IndirectionC = res.first->second;
  containers_IndirectionC.name() = "containers.IndirectionC";
  containers_IndirectionC.is_union() = false;
  static const auto* const
  containers_IndirectionC_fields = new std::array<EncodedThriftField, 1>{ {
    { 1, "lst", false, std::make_unique<Typedef>("containers.ListOfWrappedAlias", std::make_unique<Typedef>("containers.ListOfWrapped", std::make_unique<List>(std::make_unique<Struct<::test::fixtures::python_capi::TWrapped>>("containers.TWrapped")), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(),  }), std::vector<ThriftConstStruct>{ *cvStruct("thrift.AllowLegacyTypedefUri", {  }).cv_struct_ref(),  }), std::vector<ThriftConstStruct>{ }},  }};
  for (const auto& f : *containers_IndirectionC_fields) {
    ::apache::thrift::metadata::ThriftField field;
    field.id() = f.id;
    field.name() = f.name;
    field.is_optional() = f.is_optional;
    f.metadata_type_interface->writeAndGenType(*field.type(), metadata);
    field.structured_annotations() = f.structured_annotations;
    containers_IndirectionC.fields()->push_back(std::move(field));
  }
  return res.first->second;
}

} // namespace md
} // namespace detail
} // namespace thrift
} // namespace apache
