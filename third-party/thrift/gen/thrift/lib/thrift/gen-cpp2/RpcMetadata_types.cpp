/**
 * Autogenerated by Thrift for /home/fbthrift/thrift/lib/thrift/RpcMetadata.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_types.h"
#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/lib/thrift/gen-cpp2/RpcMetadata_data.h"


namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ProtocolId>::size;
folly::Range<::apache::thrift::ProtocolId const*> const TEnumTraits<::apache::thrift::ProtocolId>::values = folly::range(TEnumDataStorage<::apache::thrift::ProtocolId>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ProtocolId>::names = folly::range(TEnumDataStorage<::apache::thrift::ProtocolId>::names);

char const* TEnumTraits<::apache::thrift::ProtocolId>::findName(type value) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ProtocolId>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ProtocolId_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ProtocolId_EnumMapFactory::ValuesToNamesMapType _ProtocolId_VALUES_TO_NAMES = _ProtocolId_EnumMapFactory::makeValuesToNamesMap();
const _ProtocolId_EnumMapFactory::NamesToValuesMapType _ProtocolId_NAMES_TO_VALUES = _ProtocolId_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcKind>::size;
folly::Range<::apache::thrift::RpcKind const*> const TEnumTraits<::apache::thrift::RpcKind>::values = folly::range(TEnumDataStorage<::apache::thrift::RpcKind>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcKind>::names = folly::range(TEnumDataStorage<::apache::thrift::RpcKind>::names);

char const* TEnumTraits<::apache::thrift::RpcKind>::findName(type value) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcKind_EnumMapFactory::ValuesToNamesMapType _RpcKind_VALUES_TO_NAMES = _RpcKind_EnumMapFactory::makeValuesToNamesMap();
const _RpcKind_EnumMapFactory::NamesToValuesMapType _RpcKind_NAMES_TO_VALUES = _RpcKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RpcPriority>::size;
folly::Range<::apache::thrift::RpcPriority const*> const TEnumTraits<::apache::thrift::RpcPriority>::values = folly::range(TEnumDataStorage<::apache::thrift::RpcPriority>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RpcPriority>::names = folly::range(TEnumDataStorage<::apache::thrift::RpcPriority>::names);

char const* TEnumTraits<::apache::thrift::RpcPriority>::findName(type value) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RpcPriority>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RpcPriority_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RpcPriority_EnumMapFactory::ValuesToNamesMapType _RpcPriority_VALUES_TO_NAMES = _RpcPriority_EnumMapFactory::makeValuesToNamesMap();
const _RpcPriority_EnumMapFactory::NamesToValuesMapType _RpcPriority_NAMES_TO_VALUES = _RpcPriority_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::CompressionAlgorithm>::size;
folly::Range<::apache::thrift::CompressionAlgorithm const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::values = folly::range(TEnumDataStorage<::apache::thrift::CompressionAlgorithm>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::CompressionAlgorithm>::names = folly::range(TEnumDataStorage<::apache::thrift::CompressionAlgorithm>::names);

char const* TEnumTraits<::apache::thrift::CompressionAlgorithm>::findName(type value) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::CompressionAlgorithm>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_CompressionAlgorithm_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _CompressionAlgorithm_EnumMapFactory::ValuesToNamesMapType _CompressionAlgorithm_VALUES_TO_NAMES = _CompressionAlgorithm_EnumMapFactory::makeValuesToNamesMap();
const _CompressionAlgorithm_EnumMapFactory::NamesToValuesMapType _CompressionAlgorithm_NAMES_TO_VALUES = _CompressionAlgorithm_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::size;
folly::Range<::apache::thrift::RequestRpcMetadataFlags const*> const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::values = folly::range(TEnumDataStorage<::apache::thrift::RequestRpcMetadataFlags>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::names = folly::range(TEnumDataStorage<::apache::thrift::RequestRpcMetadataFlags>::names);

char const* TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::findName(type value) {
  using factory = ::apache::thrift::_RequestRpcMetadataFlags_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::RequestRpcMetadataFlags>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_RequestRpcMetadataFlags_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _RequestRpcMetadataFlags_EnumMapFactory::ValuesToNamesMapType _RequestRpcMetadataFlags_VALUES_TO_NAMES = _RequestRpcMetadataFlags_EnumMapFactory::makeValuesToNamesMap();
const _RequestRpcMetadataFlags_EnumMapFactory::NamesToValuesMapType _RequestRpcMetadataFlags_NAMES_TO_VALUES = _RequestRpcMetadataFlags_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::size;
folly::Range<::apache::thrift::ResponseRpcErrorCategory const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::values = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCategory>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::names = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCategory>::names);

char const* TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::findName(type value) {
  using factory = ::apache::thrift::_ResponseRpcErrorCategory_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ResponseRpcErrorCategory>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ResponseRpcErrorCategory_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ResponseRpcErrorCategory_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCategory_VALUES_TO_NAMES = _ResponseRpcErrorCategory_EnumMapFactory::makeValuesToNamesMap();
const _ResponseRpcErrorCategory_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCategory_NAMES_TO_VALUES = _ResponseRpcErrorCategory_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::size;
folly::Range<::apache::thrift::ResponseRpcErrorCode const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::values = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCode>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::names = folly::range(TEnumDataStorage<::apache::thrift::ResponseRpcErrorCode>::names);

char const* TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::findName(type value) {
  using factory = ::apache::thrift::_ResponseRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::ResponseRpcErrorCode>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_ResponseRpcErrorCode_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _ResponseRpcErrorCode_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCode_VALUES_TO_NAMES = _ResponseRpcErrorCode_EnumMapFactory::makeValuesToNamesMap();
const _ResponseRpcErrorCode_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCode_NAMES_TO_VALUES = _ResponseRpcErrorCode_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::InterfaceKind>::size;
folly::Range<::apache::thrift::InterfaceKind const*> const TEnumTraits<::apache::thrift::InterfaceKind>::values = folly::range(TEnumDataStorage<::apache::thrift::InterfaceKind>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::InterfaceKind>::names = folly::range(TEnumDataStorage<::apache::thrift::InterfaceKind>::names);

char const* TEnumTraits<::apache::thrift::InterfaceKind>::findName(type value) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::InterfaceKind>::findValue(char const* name, type* out) {
  using factory = ::apache::thrift::_InterfaceKind_EnumMapFactory;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}

}} // apache::thrift

namespace apache { namespace thrift {
FOLLY_PUSH_WARNING
FOLLY_GNU_DISABLE_WARNING("-Wdeprecated-declarations")
const _InterfaceKind_EnumMapFactory::ValuesToNamesMapType _InterfaceKind_VALUES_TO_NAMES = _InterfaceKind_EnumMapFactory::makeValuesToNamesMap();
const _InterfaceKind_EnumMapFactory::NamesToValuesMapType _InterfaceKind_NAMES_TO_VALUES = _InterfaceKind_EnumMapFactory::makeNamesToValuesMap();
FOLLY_POP_WARNING

}} // apache::thrift

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ZlibCompressionCodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ZlibCompressionCodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ZlibCompressionCodecConfig::ZlibCompressionCodecConfig(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ZlibCompressionCodecConfig::__clear() {
  // clear all fields
}

bool ZlibCompressionCodecConfig::operator==(const ZlibCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ZlibCompressionCodecConfig::operator<(const ZlibCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ZlibCompressionCodecConfig& a, ZlibCompressionCodecConfig& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ZlibCompressionCodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ZlibCompressionCodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ZlibCompressionCodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ZlibCompressionCodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ZlibCompressionCodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ZstdCompressionCodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ZstdCompressionCodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ZstdCompressionCodecConfig::ZstdCompressionCodecConfig(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ZstdCompressionCodecConfig::__clear() {
  // clear all fields
}

bool ZstdCompressionCodecConfig::operator==(const ZstdCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ZstdCompressionCodecConfig::operator<(const ZstdCompressionCodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ZstdCompressionCodecConfig& a, ZstdCompressionCodecConfig& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ZstdCompressionCodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ZstdCompressionCodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ZstdCompressionCodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ZstdCompressionCodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ZstdCompressionCodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::CodecConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::CodecConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::CodecConfig::Type>::size;
folly::Range<::apache::thrift::CodecConfig::Type const*> const TEnumTraits<::apache::thrift::CodecConfig::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::CodecConfig::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::CodecConfig::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::CodecConfig::Type>::names);

char const* TEnumTraits<::apache::thrift::CodecConfig::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::CodecConfig::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::CodecConfig::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::CodecConfig::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void CodecConfig::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::zlibConfig:
      destruct(value_.zlibConfig);
      break;
    case Type::zstdConfig:
      destruct(value_.zstdConfig);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool CodecConfig::operator==(const CodecConfig& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::zlibConfig:
      return value_.zlibConfig == rhs.value_.zlibConfig;
    case Type::zstdConfig:
      return value_.zstdConfig == rhs.value_.zstdConfig;
    default:
      return true;
  }
}

bool CodecConfig::operator<(const CodecConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::zlibConfig:
      return lhs.value_.zlibConfig < rhs.value_.zlibConfig;
    case Type::zstdConfig:
      return lhs.value_.zstdConfig < rhs.value_.zstdConfig;
    default:
      return false;
  }
}

void swap(CodecConfig& a, CodecConfig& b) {
  CodecConfig temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void CodecConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CodecConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CodecConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CodecConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CodecConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CodecConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CodecConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CodecConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CodecConfig,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ZlibCompressionCodecConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CodecConfig,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ZstdCompressionCodecConfig>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CodecConfig,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ZlibCompressionCodecConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CodecConfig,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ZstdCompressionCodecConfig>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::CompressionConfig>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::CompressionConfig>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
CompressionConfig::CompressionConfig(apache::thrift::FragileConstructor,  ::apache::thrift::CodecConfig codecConfig__arg, int64_t compressionSizeLimit__arg) :
    codecConfig(std::move(codecConfig__arg)),
    compressionSizeLimit(std::move(compressionSizeLimit__arg)) {
  __isset.codecConfig = true;
  __isset.compressionSizeLimit = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void CompressionConfig::__clear() {
  // clear all fields
  codecConfig.__clear();
  compressionSizeLimit = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool CompressionConfig::operator==(const CompressionConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.codecConfig_ref() != rhs.codecConfig_ref()) {
    return false;
  }
  if (lhs.compressionSizeLimit_ref() != rhs.compressionSizeLimit_ref()) {
    return false;
  }
  return true;
}

bool CompressionConfig::operator<(const CompressionConfig& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.codecConfig_ref() != rhs.codecConfig_ref()) {
    return lhs.codecConfig_ref() < rhs.codecConfig_ref();
  }
  if (lhs.compressionSizeLimit_ref() != rhs.compressionSizeLimit_ref()) {
    return lhs.compressionSizeLimit_ref() < rhs.compressionSizeLimit_ref();
  }
  return false;
}

const  ::apache::thrift::CodecConfig* CompressionConfig::get_codecConfig() const& {
  return codecConfig_ref().has_value() ? std::addressof(codecConfig) : nullptr;
}

 ::apache::thrift::CodecConfig* CompressionConfig::get_codecConfig() & {
  return codecConfig_ref().has_value() ? std::addressof(codecConfig) : nullptr;
}


void swap(CompressionConfig& a, CompressionConfig& b) {
  using ::std::swap;
  swap(a.codecConfig_ref().value_unchecked(), b.codecConfig_ref().value_unchecked());
  swap(a.compressionSizeLimit_ref().value_unchecked(), b.compressionSizeLimit_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void CompressionConfig::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t CompressionConfig::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t CompressionConfig::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t CompressionConfig::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void CompressionConfig::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t CompressionConfig::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t CompressionConfig::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t CompressionConfig::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        CompressionConfig,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::CodecConfig>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        CompressionConfig,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::CodecConfig>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::NegotiationParameters>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::NegotiationParameters>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
NegotiationParameters::NegotiationParameters(apache::thrift::FragileConstructor, std::uint64_t compressionAlgos__arg, bool useStopTLS__arg) :
    compressionAlgos(std::move(compressionAlgos__arg)),
    useStopTLS(std::move(useStopTLS__arg)) {
  __isset.compressionAlgos = true;
  __isset.useStopTLS = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void NegotiationParameters::__clear() {
  // clear all fields
  compressionAlgos = 0;
  useStopTLS = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool NegotiationParameters::operator==(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compressionAlgos_ref() != rhs.compressionAlgos_ref()) {
    return false;
  }
  if (lhs.useStopTLS_ref() != rhs.useStopTLS_ref()) {
    return false;
  }
  return true;
}

bool NegotiationParameters::operator<(const NegotiationParameters& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compressionAlgos_ref() != rhs.compressionAlgos_ref()) {
    return lhs.compressionAlgos_ref() < rhs.compressionAlgos_ref();
  }
  if (lhs.useStopTLS_ref() != rhs.useStopTLS_ref()) {
    return lhs.useStopTLS_ref() < rhs.useStopTLS_ref();
  }
  return false;
}


void swap(NegotiationParameters& a, NegotiationParameters& b) {
  using ::std::swap;
  swap(a.compressionAlgos_ref().value_unchecked(), b.compressionAlgos_ref().value_unchecked());
  swap(a.useStopTLS_ref().value_unchecked(), b.useStopTLS_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void NegotiationParameters::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void NegotiationParameters::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t NegotiationParameters::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t NegotiationParameters::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t NegotiationParameters::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::InteractionCreate>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::InteractionCreate>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionCreate::InteractionCreate(apache::thrift::FragileConstructor, int64_t interactionId__arg, ::std::string interactionName__arg) :
    interactionId(std::move(interactionId__arg)),
    interactionName(std::move(interactionName__arg)) {
  __isset.interactionId = true;
  __isset.interactionName = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void InteractionCreate::__clear() {
  // clear all fields
  interactionId = 0;
  interactionName = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool InteractionCreate::operator==(const InteractionCreate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return false;
  }
  if (!(lhs.interactionName == rhs.interactionName)) {
    return false;
  }
  return true;
}

bool InteractionCreate::operator<(const InteractionCreate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return lhs.interactionId < rhs.interactionId;
  }
  if (!(lhs.interactionName == rhs.interactionName)) {
    return lhs.interactionName < rhs.interactionName;
  }
  return false;
}


void swap(InteractionCreate& a, InteractionCreate& b) {
  using ::std::swap;
  swap(a.interactionId_ref().value(), b.interactionId_ref().value());
  swap(a.interactionName_ref().value(), b.interactionName_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void InteractionCreate::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t InteractionCreate::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t InteractionCreate::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t InteractionCreate::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void InteractionCreate::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t InteractionCreate::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t InteractionCreate::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t InteractionCreate::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::InteractionTerminate>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::InteractionTerminate>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
InteractionTerminate::InteractionTerminate(apache::thrift::FragileConstructor, int64_t interactionId__arg) :
    interactionId(std::move(interactionId__arg)) {
  __isset.interactionId = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void InteractionTerminate::__clear() {
  // clear all fields
  interactionId = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool InteractionTerminate::operator==(const InteractionTerminate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return false;
  }
  return true;
}

bool InteractionTerminate::operator<(const InteractionTerminate& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (!(lhs.interactionId == rhs.interactionId)) {
    return lhs.interactionId < rhs.interactionId;
  }
  return false;
}


void swap(InteractionTerminate& a, InteractionTerminate& b) {
  using ::std::swap;
  swap(a.interactionId_ref().value(), b.interactionId_ref().value());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void InteractionTerminate::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t InteractionTerminate::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t InteractionTerminate::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t InteractionTerminate::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void InteractionTerminate::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t InteractionTerminate::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t InteractionTerminate::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t InteractionTerminate::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::RequestRpcMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::RequestRpcMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      kind( ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE),
      seqId(0),
      clientTimeoutMs(0),
      queueTimeoutMs(0),
      priority( ::apache::thrift::RpcPriority::HIGH_IMPORTANT),
      crc32c(0),
      flags(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE),
      interactionId(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


RequestRpcMetadata::~RequestRpcMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestRpcMetadata::RequestRpcMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::ProtocolId protocol__arg, ::std::string name__arg,  ::apache::thrift::RpcKind kind__arg, int32_t seqId__arg, int32_t clientTimeoutMs__arg, int32_t queueTimeoutMs__arg,  ::apache::thrift::RpcPriority priority__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, ::std::string host__arg, ::std::string url__arg, std::uint32_t crc32c__arg, std::uint64_t flags__arg, ::std::string loadMetric__arg,  ::apache::thrift::CompressionAlgorithm compression__arg,  ::apache::thrift::CompressionConfig compressionConfig__arg, int64_t interactionId__arg,  ::apache::thrift::InteractionCreate interactionCreate__arg) :
    protocol(std::move(protocol__arg)),
    name(std::move(name__arg)),
    kind(std::move(kind__arg)),
    seqId(std::move(seqId__arg)),
    clientTimeoutMs(std::move(clientTimeoutMs__arg)),
    queueTimeoutMs(std::move(queueTimeoutMs__arg)),
    priority(std::move(priority__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    host(std::move(host__arg)),
    url(std::move(url__arg)),
    crc32c(std::move(crc32c__arg)),
    flags(std::move(flags__arg)),
    loadMetric(std::move(loadMetric__arg)),
    compression(std::move(compression__arg)),
    compressionConfig(std::move(compressionConfig__arg)),
    interactionId(std::move(interactionId__arg)),
    interactionCreate(std::move(interactionCreate__arg)) {
  __isset.protocol = true;
  __isset.name = true;
  __isset.kind = true;
  __isset.seqId = true;
  __isset.clientTimeoutMs = true;
  __isset.queueTimeoutMs = true;
  __isset.priority = true;
  __isset.otherMetadata = true;
  __isset.host = true;
  __isset.url = true;
  __isset.crc32c = true;
  __isset.flags = true;
  __isset.loadMetric = true;
  __isset.compression = true;
  __isset.compressionConfig = true;
  __isset.interactionId = true;
  __isset.interactionCreate = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RequestRpcMetadata::__clear() {
  // clear all fields
  protocol =  ::apache::thrift::ProtocolId::BINARY;
  name = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  kind =  ::apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE;
  seqId = 0;
  clientTimeoutMs = 0;
  queueTimeoutMs = 0;
  priority =  ::apache::thrift::RpcPriority::HIGH_IMPORTANT;
  otherMetadata.clear();
  host = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  url = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  crc32c = 0;
  flags = 0;
  loadMetric = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  compressionConfig.__clear();
  interactionId = 0;
  interactionCreate.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RequestRpcMetadata::operator==(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return false;
  }
  if (lhs.name_ref() != rhs.name_ref()) {
    return false;
  }
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return false;
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return false;
  }
  if (lhs.clientTimeoutMs_ref() != rhs.clientTimeoutMs_ref()) {
    return false;
  }
  if (lhs.queueTimeoutMs_ref() != rhs.queueTimeoutMs_ref()) {
    return false;
  }
  if (lhs.priority_ref() != rhs.priority_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  if (lhs.host_ref() != rhs.host_ref()) {
    return false;
  }
  if (lhs.url_ref() != rhs.url_ref()) {
    return false;
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return false;
  }
  if (lhs.flags_ref() != rhs.flags_ref()) {
    return false;
  }
  if (lhs.loadMetric_ref() != rhs.loadMetric_ref()) {
    return false;
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.compressionConfig_ref() != rhs.compressionConfig_ref()) {
    return false;
  }
  if (lhs.interactionId_ref() != rhs.interactionId_ref()) {
    return false;
  }
  if (lhs.interactionCreate_ref() != rhs.interactionCreate_ref()) {
    return false;
  }
  return true;
}

bool RequestRpcMetadata::operator<(const RequestRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return lhs.protocol_ref() < rhs.protocol_ref();
  }
  if (lhs.name_ref() != rhs.name_ref()) {
    return lhs.name_ref() < rhs.name_ref();
  }
  if (lhs.kind_ref() != rhs.kind_ref()) {
    return lhs.kind_ref() < rhs.kind_ref();
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return lhs.seqId_ref() < rhs.seqId_ref();
  }
  if (lhs.clientTimeoutMs_ref() != rhs.clientTimeoutMs_ref()) {
    return lhs.clientTimeoutMs_ref() < rhs.clientTimeoutMs_ref();
  }
  if (lhs.queueTimeoutMs_ref() != rhs.queueTimeoutMs_ref()) {
    return lhs.queueTimeoutMs_ref() < rhs.queueTimeoutMs_ref();
  }
  if (lhs.priority_ref() != rhs.priority_ref()) {
    return lhs.priority_ref() < rhs.priority_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  if (lhs.host_ref() != rhs.host_ref()) {
    return lhs.host_ref() < rhs.host_ref();
  }
  if (lhs.url_ref() != rhs.url_ref()) {
    return lhs.url_ref() < rhs.url_ref();
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return lhs.crc32c_ref() < rhs.crc32c_ref();
  }
  if (lhs.flags_ref() != rhs.flags_ref()) {
    return lhs.flags_ref() < rhs.flags_ref();
  }
  if (lhs.loadMetric_ref() != rhs.loadMetric_ref()) {
    return lhs.loadMetric_ref() < rhs.loadMetric_ref();
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.compressionConfig_ref() != rhs.compressionConfig_ref()) {
    return lhs.compressionConfig_ref() < rhs.compressionConfig_ref();
  }
  if (lhs.interactionId_ref() != rhs.interactionId_ref()) {
    return lhs.interactionId_ref() < rhs.interactionId_ref();
  }
  if (lhs.interactionCreate_ref() != rhs.interactionCreate_ref()) {
    return lhs.interactionCreate_ref() < rhs.interactionCreate_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* RequestRpcMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

const  ::apache::thrift::CompressionConfig* RequestRpcMetadata::get_compressionConfig() const& {
  return compressionConfig_ref().has_value() ? std::addressof(compressionConfig) : nullptr;
}

 ::apache::thrift::CompressionConfig* RequestRpcMetadata::get_compressionConfig() & {
  return compressionConfig_ref().has_value() ? std::addressof(compressionConfig) : nullptr;
}

const  ::apache::thrift::InteractionCreate* RequestRpcMetadata::get_interactionCreate() const& {
  return interactionCreate_ref().has_value() ? std::addressof(interactionCreate) : nullptr;
}

 ::apache::thrift::InteractionCreate* RequestRpcMetadata::get_interactionCreate() & {
  return interactionCreate_ref().has_value() ? std::addressof(interactionCreate) : nullptr;
}


void swap(RequestRpcMetadata& a, RequestRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.name_ref().value_unchecked(), b.name_ref().value_unchecked());
  swap(a.kind_ref().value_unchecked(), b.kind_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.clientTimeoutMs_ref().value_unchecked(), b.clientTimeoutMs_ref().value_unchecked());
  swap(a.queueTimeoutMs_ref().value_unchecked(), b.queueTimeoutMs_ref().value_unchecked());
  swap(a.priority_ref().value_unchecked(), b.priority_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.host_ref().value_unchecked(), b.host_ref().value_unchecked());
  swap(a.url_ref().value_unchecked(), b.url_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.flags_ref().value_unchecked(), b.flags_ref().value_unchecked());
  swap(a.loadMetric_ref().value_unchecked(), b.loadMetric_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.compressionConfig_ref().value_unchecked(), b.compressionConfig_ref().value_unchecked());
  swap(a.interactionId_ref().value_unchecked(), b.interactionId_ref().value_unchecked());
  swap(a.interactionCreate_ref().value_unchecked(), b.interactionCreate_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RequestRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::CompressionConfig>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::InteractionCreate>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::CompressionConfig>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        RequestRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::InteractionCreate>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadResponseMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadResponseMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadResponseMetadata::PayloadResponseMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadResponseMetadata::__clear() {
  // clear all fields
}

bool PayloadResponseMetadata::operator==(const PayloadResponseMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadResponseMetadata::operator<(const PayloadResponseMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadResponseMetadata& a, PayloadResponseMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadResponseMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadResponseMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadResponseMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadResponseMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadResponseMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadResponseMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadResponseMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadResponseMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadDeclaredExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadDeclaredExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadDeclaredExceptionMetadata::PayloadDeclaredExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadDeclaredExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadDeclaredExceptionMetadata::operator==(const PayloadDeclaredExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadDeclaredExceptionMetadata::operator<(const PayloadDeclaredExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadDeclaredExceptionMetadata& a, PayloadDeclaredExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadDeclaredExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadDeclaredExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadDeclaredExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadDeclaredExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadDeclaredExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadProxyExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadProxyExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadProxyExceptionMetadata::PayloadProxyExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadProxyExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadProxyExceptionMetadata::operator==(const PayloadProxyExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadProxyExceptionMetadata::operator<(const PayloadProxyExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadProxyExceptionMetadata& a, PayloadProxyExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadProxyExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadProxyExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadProxyExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadProxyExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadProxyExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadProxiedExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadProxiedExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadProxiedExceptionMetadata::PayloadProxiedExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadProxiedExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadProxiedExceptionMetadata::operator==(const PayloadProxiedExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadProxiedExceptionMetadata::operator<(const PayloadProxiedExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadProxiedExceptionMetadata& a, PayloadProxiedExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadProxiedExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadProxiedExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadProxiedExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadProxiedExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadProxiedExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadAppClientExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadAppClientExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadAppClientExceptionMetadata::PayloadAppClientExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadAppClientExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadAppClientExceptionMetadata::operator==(const PayloadAppClientExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadAppClientExceptionMetadata::operator<(const PayloadAppClientExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadAppClientExceptionMetadata& a, PayloadAppClientExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadAppClientExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadAppClientExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadAppClientExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadAppClientExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadAppClientExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadAppServerExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadAppServerExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadAppServerExceptionMetadata::PayloadAppServerExceptionMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadAppServerExceptionMetadata::__clear() {
  // clear all fields
}

bool PayloadAppServerExceptionMetadata::operator==(const PayloadAppServerExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool PayloadAppServerExceptionMetadata::operator<(const PayloadAppServerExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(PayloadAppServerExceptionMetadata& a, PayloadAppServerExceptionMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void PayloadAppServerExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadAppServerExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadAppServerExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadAppServerExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadAppServerExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadExceptionMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadExceptionMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::size;
folly::Range<::apache::thrift::PayloadExceptionMetadata::Type const*> const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::PayloadExceptionMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::PayloadExceptionMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadExceptionMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadExceptionMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void PayloadExceptionMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::declaredException:
      destruct(value_.declaredException);
      break;
    case Type::proxyException:
      destruct(value_.proxyException);
      break;
    case Type::proxiedException:
      destruct(value_.proxiedException);
      break;
    case Type::appClientException:
      destruct(value_.appClientException);
      break;
    case Type::appServerException:
      destruct(value_.appServerException);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool PayloadExceptionMetadata::operator==(const PayloadExceptionMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::declaredException:
      return value_.declaredException == rhs.value_.declaredException;
    case Type::proxyException:
      return value_.proxyException == rhs.value_.proxyException;
    case Type::proxiedException:
      return value_.proxiedException == rhs.value_.proxiedException;
    case Type::appClientException:
      return value_.appClientException == rhs.value_.appClientException;
    case Type::appServerException:
      return value_.appServerException == rhs.value_.appServerException;
    default:
      return true;
  }
}

bool PayloadExceptionMetadata::operator<(const PayloadExceptionMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::declaredException:
      return lhs.value_.declaredException < rhs.value_.declaredException;
    case Type::proxyException:
      return lhs.value_.proxyException < rhs.value_.proxyException;
    case Type::proxiedException:
      return lhs.value_.proxiedException < rhs.value_.proxiedException;
    case Type::appClientException:
      return lhs.value_.appClientException < rhs.value_.appClientException;
    case Type::appServerException:
      return lhs.value_.appServerException < rhs.value_.appServerException;
    default:
      return false;
  }
}

void swap(PayloadExceptionMetadata& a, PayloadExceptionMetadata& b) {
  PayloadExceptionMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void PayloadExceptionMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadExceptionMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadExceptionMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadExceptionMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadExceptionMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadExceptionMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadDeclaredExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadProxyExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadProxiedExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadAppClientExceptionMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadAppServerExceptionMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadDeclaredExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadProxyExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadProxiedExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadAppClientExceptionMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadAppServerExceptionMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadExceptionMetadataBase>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadExceptionMetadataBase>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
PayloadExceptionMetadataBase::PayloadExceptionMetadataBase(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg,  ::apache::thrift::PayloadExceptionMetadata metadata__arg) :
    name_utf8(std::move(name_utf8__arg)),
    what_utf8(std::move(what_utf8__arg)),
    metadata(std::move(metadata__arg)) {
  __isset.name_utf8 = true;
  __isset.what_utf8 = true;
  __isset.metadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void PayloadExceptionMetadataBase::__clear() {
  // clear all fields
  name_utf8 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  what_utf8 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  metadata.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool PayloadExceptionMetadataBase::operator==(const PayloadExceptionMetadataBase& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return false;
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return false;
  }
  if (lhs.metadata_ref() != rhs.metadata_ref()) {
    return false;
  }
  return true;
}

bool PayloadExceptionMetadataBase::operator<(const PayloadExceptionMetadataBase& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return lhs.name_utf8_ref() < rhs.name_utf8_ref();
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return lhs.what_utf8_ref() < rhs.what_utf8_ref();
  }
  if (lhs.metadata_ref() != rhs.metadata_ref()) {
    return lhs.metadata_ref() < rhs.metadata_ref();
  }
  return false;
}

const  ::apache::thrift::PayloadExceptionMetadata* PayloadExceptionMetadataBase::get_metadata() const& {
  return metadata_ref().has_value() ? std::addressof(metadata) : nullptr;
}

 ::apache::thrift::PayloadExceptionMetadata* PayloadExceptionMetadataBase::get_metadata() & {
  return metadata_ref().has_value() ? std::addressof(metadata) : nullptr;
}


void swap(PayloadExceptionMetadataBase& a, PayloadExceptionMetadataBase& b) {
  using ::std::swap;
  swap(a.name_utf8_ref().value_unchecked(), b.name_utf8_ref().value_unchecked());
  swap(a.what_utf8_ref().value_unchecked(), b.what_utf8_ref().value_unchecked());
  swap(a.metadata_ref().value_unchecked(), b.metadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void PayloadExceptionMetadataBase::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadExceptionMetadataBase::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadExceptionMetadataBase::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadExceptionMetadataBase::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadExceptionMetadataBase::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadExceptionMetadataBase,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::PayloadExceptionMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadExceptionMetadataBase,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::PayloadExceptionMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::PayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::PayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

constexpr std::size_t const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::size;
folly::Range<::apache::thrift::PayloadMetadata::Type const*> const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::values = folly::range(TEnumDataStorage<::apache::thrift::PayloadMetadata::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::apache::thrift::PayloadMetadata::Type>::names = folly::range(TEnumDataStorage<::apache::thrift::PayloadMetadata::Type>::names);

char const* TEnumTraits<::apache::thrift::PayloadMetadata::Type>::findName(type value) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadMetadata::Type>;
  static folly::Indestructible<factory::ValuesToNamesMapType> const map{
      factory::makeValuesToNamesMap()};
  auto found = map->find(value);
  return found == map->end() ? nullptr : found->second;
}

bool TEnumTraits<::apache::thrift::PayloadMetadata::Type>::findValue(char const* name, type* out) {
  using factory = detail::TEnumMapFactory<::apache::thrift::PayloadMetadata::Type>;
  static folly::Indestructible<factory::NamesToValuesMapType> const map{
      factory::makeNamesToValuesMap()};
  auto found = map->find(name);
  return found == map->end() ? false : (*out = found->second, true);
}
}} // apache::thrift
namespace apache { namespace thrift {

void PayloadMetadata::__clear() {
  // clear all fields
  if (type_ == Type::__EMPTY__) { return; }
  switch(type_) {
    case Type::responseMetadata:
      destruct(value_.responseMetadata);
      break;
    case Type::exceptionMetadata:
      destruct(value_.exceptionMetadata);
      break;
    default:
      assert(false);
      break;
  }
  type_ = Type::__EMPTY__;
}

bool PayloadMetadata::operator==(const PayloadMetadata& rhs) const {
  if (type_ != rhs.type_) { return false; }
  switch(type_) {
    case Type::responseMetadata:
      return value_.responseMetadata == rhs.value_.responseMetadata;
    case Type::exceptionMetadata:
      return value_.exceptionMetadata == rhs.value_.exceptionMetadata;
    default:
      return true;
  }
}

bool PayloadMetadata::operator<(const PayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.type_ != rhs.type_) {
    return lhs.type_ < rhs.type_;
  }
  switch (lhs.type_) {
    case Type::responseMetadata:
      return lhs.value_.responseMetadata < rhs.value_.responseMetadata;
    case Type::exceptionMetadata:
      return lhs.value_.exceptionMetadata < rhs.value_.exceptionMetadata;
    default:
      return false;
  }
}

void swap(PayloadMetadata& a, PayloadMetadata& b) {
  PayloadMetadata temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void PayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t PayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t PayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t PayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void PayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t PayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t PayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t PayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadResponseMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadExceptionMetadataBase>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadResponseMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        PayloadMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::PayloadExceptionMetadataBase>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ProxiedPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ProxiedPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ProxiedPayloadMetadata::ProxiedPayloadMetadata(apache::thrift::FragileConstructor) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ProxiedPayloadMetadata::__clear() {
  // clear all fields
}

bool ProxiedPayloadMetadata::operator==(const ProxiedPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return true;
}

bool ProxiedPayloadMetadata::operator<(const ProxiedPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  return false;
}


void swap(ProxiedPayloadMetadata& a, ProxiedPayloadMetadata& b) {
  using ::std::swap;
  (void)a;
  (void)b;
}

template void ProxiedPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ProxiedPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ProxiedPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ProxiedPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ProxiedPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ProxiedPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ProxiedPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ProxiedPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ResponseRpcMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ResponseRpcMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata() :
      protocol( ::apache::thrift::ProtocolId::BINARY),
      seqId(0),
      load(0),
      crc32c(0),
      compression( ::apache::thrift::CompressionAlgorithm::NONE) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ResponseRpcMetadata::~ResponseRpcMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcMetadata::ResponseRpcMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::ProtocolId protocol__arg, int32_t seqId__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, int64_t load__arg, std::uint32_t crc32c__arg,  ::apache::thrift::CompressionAlgorithm compression__arg,  ::apache::thrift::PayloadMetadata payloadMetadata__arg,  ::apache::thrift::ProxiedPayloadMetadata proxiedPayloadMetadata__arg) :
    protocol(std::move(protocol__arg)),
    seqId(std::move(seqId__arg)),
    otherMetadata(std::move(otherMetadata__arg)),
    load(std::move(load__arg)),
    crc32c(std::move(crc32c__arg)),
    compression(std::move(compression__arg)),
    payloadMetadata(std::move(payloadMetadata__arg)),
    proxiedPayloadMetadata(std::move(proxiedPayloadMetadata__arg)) {
  __isset.protocol = true;
  __isset.seqId = true;
  __isset.otherMetadata = true;
  __isset.load = true;
  __isset.crc32c = true;
  __isset.compression = true;
  __isset.payloadMetadata = true;
  __isset.proxiedPayloadMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ResponseRpcMetadata::__clear() {
  // clear all fields
  protocol =  ::apache::thrift::ProtocolId::BINARY;
  seqId = 0;
  otherMetadata.clear();
  load = 0;
  crc32c = 0;
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  payloadMetadata.__clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ResponseRpcMetadata::operator==(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return false;
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return false;
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return false;
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return false;
  }
  if (lhs.proxiedPayloadMetadata_ref() != rhs.proxiedPayloadMetadata_ref()) {
    return false;
  }
  return true;
}

bool ResponseRpcMetadata::operator<(const ResponseRpcMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.protocol_ref() != rhs.protocol_ref()) {
    return lhs.protocol_ref() < rhs.protocol_ref();
  }
  if (lhs.seqId_ref() != rhs.seqId_ref()) {
    return lhs.seqId_ref() < rhs.seqId_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return lhs.load_ref() < rhs.load_ref();
  }
  if (lhs.crc32c_ref() != rhs.crc32c_ref()) {
    return lhs.crc32c_ref() < rhs.crc32c_ref();
  }
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.payloadMetadata_ref() != rhs.payloadMetadata_ref()) {
    return lhs.payloadMetadata_ref() < rhs.payloadMetadata_ref();
  }
  if (lhs.proxiedPayloadMetadata_ref() != rhs.proxiedPayloadMetadata_ref()) {
    return lhs.proxiedPayloadMetadata_ref() < rhs.proxiedPayloadMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* ResponseRpcMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

const  ::apache::thrift::PayloadMetadata* ResponseRpcMetadata::get_payloadMetadata() const& {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}

 ::apache::thrift::PayloadMetadata* ResponseRpcMetadata::get_payloadMetadata() & {
  return payloadMetadata_ref().has_value() ? std::addressof(payloadMetadata) : nullptr;
}

const  ::apache::thrift::ProxiedPayloadMetadata* ResponseRpcMetadata::get_proxiedPayloadMetadata() const& {
  return proxiedPayloadMetadata_ref().has_value() ? std::addressof(proxiedPayloadMetadata) : nullptr;
}

 ::apache::thrift::ProxiedPayloadMetadata* ResponseRpcMetadata::get_proxiedPayloadMetadata() & {
  return proxiedPayloadMetadata_ref().has_value() ? std::addressof(proxiedPayloadMetadata) : nullptr;
}


void swap(ResponseRpcMetadata& a, ResponseRpcMetadata& b) {
  using ::std::swap;
  swap(a.protocol_ref().value_unchecked(), b.protocol_ref().value_unchecked());
  swap(a.seqId_ref().value_unchecked(), b.seqId_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
  swap(a.load_ref().value_unchecked(), b.load_ref().value_unchecked());
  swap(a.crc32c_ref().value_unchecked(), b.crc32c_ref().value_unchecked());
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.payloadMetadata_ref().value_unchecked(), b.payloadMetadata_ref().value_unchecked());
  swap(a.proxiedPayloadMetadata_ref().value_unchecked(), b.proxiedPayloadMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseRpcMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseRpcMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseRpcMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseRpcMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::PayloadMetadata>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ProxiedPayloadMetadata>,
    "inconsistent use of json option");

static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::variant,
         ::apache::thrift::PayloadMetadata>,
    "inconsistent use of nimble option");
static_assert(
    ::apache::thrift::detail::st::gen_check_nimble<
        ResponseRpcMetadata,
        ::apache::thrift::type_class::structure,
         ::apache::thrift::ProxiedPayloadMetadata>,
    "inconsistent use of nimble option");

}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::ResponseRpcError>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::ResponseRpcError>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError() :
      category( ::apache::thrift::ResponseRpcErrorCategory::INTERNAL_ERROR),
      code( ::apache::thrift::ResponseRpcErrorCode::UNKNOWN),
      load(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


ResponseRpcError::~ResponseRpcError() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
ResponseRpcError::ResponseRpcError(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg,  ::apache::thrift::ResponseRpcErrorCategory category__arg,  ::apache::thrift::ResponseRpcErrorCode code__arg, int64_t load__arg) :
    name_utf8(std::move(name_utf8__arg)),
    what_utf8(std::move(what_utf8__arg)),
    category(std::move(category__arg)),
    code(std::move(code__arg)),
    load(std::move(load__arg)) {
  __isset.name_utf8 = true;
  __isset.what_utf8 = true;
  __isset.category = true;
  __isset.code = true;
  __isset.load = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void ResponseRpcError::__clear() {
  // clear all fields
  name_utf8 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  what_utf8 = apache::thrift::StringTraits< std::string>::fromStringLiteral("");
  category =  ::apache::thrift::ResponseRpcErrorCategory::INTERNAL_ERROR;
  code =  ::apache::thrift::ResponseRpcErrorCode::UNKNOWN;
  load = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool ResponseRpcError::operator==(const ResponseRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return false;
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return false;
  }
  if (lhs.category_ref() != rhs.category_ref()) {
    return false;
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return false;
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return false;
  }
  return true;
}

bool ResponseRpcError::operator<(const ResponseRpcError& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.name_utf8_ref() != rhs.name_utf8_ref()) {
    return lhs.name_utf8_ref() < rhs.name_utf8_ref();
  }
  if (lhs.what_utf8_ref() != rhs.what_utf8_ref()) {
    return lhs.what_utf8_ref() < rhs.what_utf8_ref();
  }
  if (lhs.category_ref() != rhs.category_ref()) {
    return lhs.category_ref() < rhs.category_ref();
  }
  if (lhs.code_ref() != rhs.code_ref()) {
    return lhs.code_ref() < rhs.code_ref();
  }
  if (lhs.load_ref() != rhs.load_ref()) {
    return lhs.load_ref() < rhs.load_ref();
  }
  return false;
}


void swap(ResponseRpcError& a, ResponseRpcError& b) {
  using ::std::swap;
  swap(a.name_utf8_ref().value_unchecked(), b.name_utf8_ref().value_unchecked());
  swap(a.what_utf8_ref().value_unchecked(), b.what_utf8_ref().value_unchecked());
  swap(a.category_ref().value_unchecked(), b.category_ref().value_unchecked());
  swap(a.code_ref().value_unchecked(), b.code_ref().value_unchecked());
  swap(a.load_ref().value_unchecked(), b.load_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void ResponseRpcError::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t ResponseRpcError::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t ResponseRpcError::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t ResponseRpcError::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void ResponseRpcError::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t ResponseRpcError::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t ResponseRpcError::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t ResponseRpcError::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::StreamPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::StreamPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
StreamPayloadMetadata::StreamPayloadMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::CompressionAlgorithm compression__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    compression(std::move(compression__arg)),
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.compression = true;
  __isset.otherMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void StreamPayloadMetadata::__clear() {
  // clear all fields
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
  otherMetadata.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool StreamPayloadMetadata::operator==(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  return true;
}

bool StreamPayloadMetadata::operator<(const StreamPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* StreamPayloadMetadata::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}


void swap(StreamPayloadMetadata& a, StreamPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void StreamPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t StreamPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t StreamPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t StreamPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::RequestSetupMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::RequestSetupMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata() :
      interfaceKind( ::apache::thrift::InterfaceKind::USER),
      minVersion(0),
      maxVersion(0),
      dscpToReflect(0),
      markToReflect(0) {}
THRIFT_IGNORE_ISSET_USE_WARNING_END


RequestSetupMetadata::~RequestSetupMetadata() {}

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
RequestSetupMetadata::RequestSetupMetadata(apache::thrift::FragileConstructor, apache::thrift::MetadataOpaqueMap<::std::string, ::std::string> opaque__arg,  ::apache::thrift::InterfaceKind interfaceKind__arg, int32_t minVersion__arg, int32_t maxVersion__arg, int32_t dscpToReflect__arg, int32_t markToReflect__arg) :
    opaque(std::move(opaque__arg)),
    interfaceKind(std::move(interfaceKind__arg)),
    minVersion(std::move(minVersion__arg)),
    maxVersion(std::move(maxVersion__arg)),
    dscpToReflect(std::move(dscpToReflect__arg)),
    markToReflect(std::move(markToReflect__arg)) {
  __isset.opaque = true;
  __isset.interfaceKind = true;
  __isset.minVersion = true;
  __isset.maxVersion = true;
  __isset.dscpToReflect = true;
  __isset.markToReflect = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void RequestSetupMetadata::__clear() {
  // clear all fields
  opaque.clear();
  interfaceKind =  ::apache::thrift::InterfaceKind::USER;
  minVersion = 0;
  maxVersion = 0;
  dscpToReflect = 0;
  markToReflect = 0;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool RequestSetupMetadata::operator==(const RequestSetupMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.opaque_ref() != rhs.opaque_ref()) {
    return false;
  }
  if (lhs.interfaceKind_ref() != rhs.interfaceKind_ref()) {
    return false;
  }
  if (lhs.minVersion_ref() != rhs.minVersion_ref()) {
    return false;
  }
  if (lhs.maxVersion_ref() != rhs.maxVersion_ref()) {
    return false;
  }
  if (lhs.dscpToReflect_ref() != rhs.dscpToReflect_ref()) {
    return false;
  }
  if (lhs.markToReflect_ref() != rhs.markToReflect_ref()) {
    return false;
  }
  return true;
}

const apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() const& {
  return opaque_ref().has_value() ? std::addressof(opaque) : nullptr;
}

apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* RequestSetupMetadata::get_opaque() & {
  return opaque_ref().has_value() ? std::addressof(opaque) : nullptr;
}


void swap(RequestSetupMetadata& a, RequestSetupMetadata& b) {
  using ::std::swap;
  swap(a.opaque_ref().value_unchecked(), b.opaque_ref().value_unchecked());
  swap(a.interfaceKind_ref().value_unchecked(), b.interfaceKind_ref().value_unchecked());
  swap(a.minVersion_ref().value_unchecked(), b.minVersion_ref().value_unchecked());
  swap(a.maxVersion_ref().value_unchecked(), b.maxVersion_ref().value_unchecked());
  swap(a.dscpToReflect_ref().value_unchecked(), b.dscpToReflect_ref().value_unchecked());
  swap(a.markToReflect_ref().value_unchecked(), b.markToReflect_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void RequestSetupMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void RequestSetupMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t RequestSetupMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t RequestSetupMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t RequestSetupMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::HeadersPayloadContent>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::HeadersPayloadContent>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadContent::HeadersPayloadContent(apache::thrift::FragileConstructor, ::std::map<::std::string, ::std::string> otherMetadata__arg) :
    otherMetadata(std::move(otherMetadata__arg)) {
  __isset.otherMetadata = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HeadersPayloadContent::__clear() {
  // clear all fields
  otherMetadata.clear();
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HeadersPayloadContent::operator==(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return false;
  }
  return true;
}

bool HeadersPayloadContent::operator<(const HeadersPayloadContent& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.otherMetadata_ref() != rhs.otherMetadata_ref()) {
    return lhs.otherMetadata_ref() < rhs.otherMetadata_ref();
  }
  return false;
}

const ::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() const& {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}

::std::map<::std::string, ::std::string>* HeadersPayloadContent::get_otherMetadata() & {
  return otherMetadata_ref().has_value() ? std::addressof(otherMetadata) : nullptr;
}


void swap(HeadersPayloadContent& a, HeadersPayloadContent& b) {
  using ::std::swap;
  swap(a.otherMetadata_ref().value_unchecked(), b.otherMetadata_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HeadersPayloadContent::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadContent::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadContent::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadContent::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadContent::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::apache::thrift::HeadersPayloadMetadata>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::apache::thrift::HeadersPayloadMetadata>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
HeadersPayloadMetadata::HeadersPayloadMetadata(apache::thrift::FragileConstructor,  ::apache::thrift::CompressionAlgorithm compression__arg) :
    compression(std::move(compression__arg)) {
  __isset.compression = true;
}
THRIFT_IGNORE_ISSET_USE_WARNING_END
void HeadersPayloadMetadata::__clear() {
  // clear all fields
  compression =  ::apache::thrift::CompressionAlgorithm::NONE;
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  __isset = {};
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

bool HeadersPayloadMetadata::operator==(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return false;
  }
  return true;
}

bool HeadersPayloadMetadata::operator<(const HeadersPayloadMetadata& rhs) const {
  (void)rhs;
  auto& lhs = *this;
  (void)lhs;
  if (lhs.compression_ref() != rhs.compression_ref()) {
    return lhs.compression_ref() < rhs.compression_ref();
  }
  return false;
}


void swap(HeadersPayloadMetadata& a, HeadersPayloadMetadata& b) {
  using ::std::swap;
  swap(a.compression_ref().value_unchecked(), b.compression_ref().value_unchecked());
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
  swap(a.__isset, b.__isset);
THRIFT_IGNORE_ISSET_USE_WARNING_END
}

template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void HeadersPayloadMetadata::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t HeadersPayloadMetadata::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t HeadersPayloadMetadata::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t HeadersPayloadMetadata::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;



}} // apache::thrift
