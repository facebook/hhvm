<?php
/**
 * Automatically generated by running "php schema.php mb".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "mb_list_encodings",
    'desc'   => "Returns an array containing all supported encodings.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => StringVec,
      'desc'   => "Returns a numerically indexed array.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_list_encodings_alias_names",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "name",
        'type'   => String,
        'value'  => "null_string",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_list_mime_names",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "name",
        'type'   => String,
        'value'  => "null_string",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_check_encoding",
    'desc'   => "Checks if the specified byte stream is valid for the specified encoding. It is useful to prevent so-called \"Invalid Encoding Attack\".",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "var",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The byte stream to check. If it is omitted, this function checks all the input from the beginning of the request.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The expected encoding.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_convert_case",
    'desc'   => "Performs case folding on a string, converted in the way specified by mode.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "A case folded version of string converted in the way specified by mode.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being converted.",
      ),
      array(
        'name'   => "mode",
        'type'   => Int32,
        'desc'   => "The mode of the conversion. It can be one of MB_CASE_UPPER, MB_CASE_LOWER, or MB_CASE_TITLE.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_convert_encoding",
    'desc'   => "Converts the character encoding of string str to to_encoding from optionally from_encoding.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The encoded string.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being encoded.",
      ),
      array(
        'name'   => "to_encoding",
        'type'   => String,
        'desc'   => "The type of encoding that str is being converted to.",
      ),
      array(
        'name'   => "from_encoding",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "Is specified by character code names before conversion. It is either an array, or a comma separated enumerated list. If from_encoding is not specified, the internal encoding will be used.\n\n\"auto\" may be used, which expands to \"ASCII,JIS,UTF-8,EUC-JP,SJIS\".",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_convert_kana",
    'desc'   => "Performs a \"han-kaku\" - \"zen-kaku\" conversion for string str. This function is only useful for Japanese.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The converted string.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being converted.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The conversion option.\n\nSpecify with a combination of following options. Applicable Conversion Options Option Meaning r Convert \"zen-kaku\" alphabets to \"han-kaku\" R Convert \"han-kaku\" alphabets to \"zen-kaku\" n Convert \"zen-kaku\" numbers to \"han-kaku\" N Convert \"han-kaku\" numbers to \"zen-kaku\" a Convert \"zen-kaku\" alphabets and numbers to \"han-kaku\" A Convert \"han-kaku\" alphabets and numbers to \"zen-kaku\" (Characters included in \"a\", \"A\" options are U+0021 - U+007E excluding U+0022, U+0027, U+005C, U+007E) s Convert \"zen-kaku\" space to \"han-kaku\" (U+3000 -> U+0020) S Convert \"han-kaku\" space to \"zen-kaku\" (U+0020 -> U+3000) k Convert \"zen-kaku kata-kana\" to \"han-kaku kata-kana\" K Convert \"han-kaku kata-kana\" to \"zen-kaku kata-kana\" h Convert \"zen-kaku hira-gana\" to \"han-kaku kata-kana\" H Convert \"han-kaku kata-kana\" to \"zen-kaku hira-gana\" c Convert \"zen-kaku kata-kana\" to \"zen-kaku hira-gana\" C Convert \"zen-kaku hira-gana\" to \"zen-kaku kata-kana\" V Collapse voiced sound notation and convert them into a character. Use with \"K\",\"H\"",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_convert_variables",
    'desc'   => "Converts character encoding of variables vars in encoding from_encoding to encoding to_encoding.\n\nmb_convert_variables() join strings in Array or Object to detect encoding, since encoding detection tends to fail for short strings. Therefore, it is impossible to mix encoding in single array or object.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The character encoding before conversion for success, or FALSE for failure.",
    ),
    'args'   => array(
      array(
        'name'   => "to_encoding",
        'type'   => String,
        'desc'   => "The encoding that the string is being converted to.",
      ),
      array(
        'name'   => "from_encoding",
        'type'   => Variant,
        'desc'   => "from_encoding is specified as an array or comma separated string, it tries to detect encoding from from-coding. When from_encoding is omitted, detect_order is used.",
      ),
      array(
        'name'   => "vars",
        'type'   => Variant | Reference,
        'desc'   => "vars is the reference to the variable being converted. String, Array and Object are accepted. mb_convert_variables() assumes all parameters have the same encoding.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_decode_mimeheader",
    'desc'   => "Decodes encoded-word string str in MIME header.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The decoded string in internal character encoding.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being decoded.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_decode_numericentity",
    'desc'   => "Convert numeric string reference of string str in a specified block to character.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The converted string.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being decoded.",
      ),
      array(
        'name'   => "convmap",
        'type'   => Variant,
        'desc'   => "convmap is an array that specifies the code area to convert.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_detect_encoding",
    'desc'   => "Detects character encoding in string str.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The detected character encoding or FALSE if the encoding cannot be detected from the given string.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being detected.",
      ),
      array(
        'name'   => "encoding_list",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "encoding_list is list of character encoding. Encoding order may be specified by array or comma separated list string.\n\nIf encoding_list is omitted, detect_order is used.",
      ),
      array(
        'name'   => "strict",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "strict specifies whether to use the strict encoding detection or not. Default is FALSE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_detect_order",
    'desc'   => "Sets the automatic character encoding detection order to encoding_list.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding_list",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "encoding_list is an array or comma separated list of character encoding. (\"auto\" is expanded to \"ASCII, JIS, UTF-8, EUC-JP, SJIS\")\n\nIf encoding_list is omitted, it returns the current character encoding detection order as array.\n\nThis setting affects mb_detect_encoding() and mb_send_mail().\n\nmbstring currently implements the following encoding detection filters. If there is an invalid byte sequence for the following encodings, encoding detection will fail. UTF-8, UTF-7, ASCII, EUC-JP,SJIS, eucJP-win, SJIS-win, JIS, ISO-2022-JP\n\nFor ISO-8859-*, mbstring always detects as ISO-8859-*.\n\nFor UTF-16, UTF-32, UCS2 and UCS4, encoding detection will fail always.\n\nExample #1 Useless detect order example",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_encode_mimeheader",
    'desc'   => "Encodes a given string str by the MIME header encoding scheme.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "A converted version of the string represented in ASCII.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being encoded.",
      ),
      array(
        'name'   => "charset",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "charset specifies the name of the character set in which str is represented in. The default value is determined by the current NLS setting (mbstring.language). mb_internal_encoding() should be set to same encoding.",
      ),
      array(
        'name'   => "transfer_encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "transfer_encoding specifies the scheme of MIME encoding. It should be either \"B\" (Base64) or \"Q\" (Quoted-Printable). Falls back to \"B\" if not given.",
      ),
      array(
        'name'   => "linefeed",
        'type'   => String,
        'value'  => "\"\\r\\n\"",
        'desc'   => "linefeed specifies the EOL (end-of-line) marker with which mb_encode_mimeheader() performs line-folding (a » RFC term, the act of breaking a line longer than a certain length into multiple lines. The length is currently hard-coded to 74 characters). Falls back to \"\\r\\n\" (CRLF) if not given.",
      ),
      array(
        'name'   => "indent",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "Indentation of the first line (number of characters in the header before str).",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_encode_numericentity",
    'desc'   => "Converts specified character codes in string str from HTML numeric character reference to character code.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The converted string.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being encoded.",
      ),
      array(
        'name'   => "convmap",
        'type'   => Variant,
        'desc'   => "convmap is array specifies code area to convert.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_match",
    'desc'   => "A regular expression match for a multibyte string",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE if string matches the regular expression pattern, FALSE if not.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => String,
        'desc'   => "The regular expression pattern.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being evaluated.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_replace",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The resultant string on success, or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => Variant,
        'desc'   => "The regular expression pattern.\n\nMultibyte characters may be used in pattern.",
      ),
      array(
        'name'   => "replacement",
        'type'   => String,
        'desc'   => "The replacement text.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being checked.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Matching condition can be set by option parameter. If i is specified for this parameter, the case will be ignored. If x is specified, white space will be ignored. If m is specified, match will be executed in multiline mode and line break will be included in '.'. If p is specified, match will be executed in POSIX mode, line break will be considered as normal character. If e is specified, replacement string will be evaluated as PHP expression.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_getpos",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Int64,
      'desc'   => "mb_ereg_search_getpos() returns the point to start regular expression match for mb_ereg_search(), mb_ereg_search_pos(), mb_ereg_search_regs(). The position is represented by bytes from the head of string.",
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_getregs",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array including the sub-string of matched part by last mb_ereg_search(), mb_ereg_search_pos(), mb_ereg_search_regs(). If there are some matches, the first element will have the matched sub-string, the second element will have the first part grouped with brackets, the third element will have the second part grouped with brackets, and so on. It returns FALSE on error;",
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_init",
    'desc'   => "mb_ereg_search_init() sets string and pattern for a multibyte regular expression. These values are used for mb_ereg_search(), mb_ereg_search_pos(), and mb_ereg_search_regs().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The search string.",
      ),
      array(
        'name'   => "pattern",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search pattern.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search option.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_pos",
    'desc'   => "Returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string\n\nThe string for match is specified by mb_ereg_search_init(). If it is not specified, the previous one will be used.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array including the position of a matched part for a multibyte regular expression. The first element of the array will be the beginning of matched part, the second element will be length (bytes) of matched part. It returns FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search pattern.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search option.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_regs",
    'desc'   => "Returns the matched part of a multibyte regular expression.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "mb_ereg_search_regs() executes the multibyte regular expression match, and if there are some matched part, it returns an array including substring of matched part as first element, the first grouped part with brackets as second element, the second grouped part as third element, and so on. It returns FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search pattern.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search option.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search_setpos",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "position",
        'type'   => Int32,
        'desc'   => "The position to set.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg_search",
    'desc'   => "Performs a multibyte regular expression match for a predefined multibyte string.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "mb_ereg_search() returns TRUE if the multibyte string matches with the regular expression, or FALSE otherwise. The string for matching is set by mb_ereg_search_init(). If pattern is not specified, the previous one is used.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search pattern.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The search option.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_ereg",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Executes the regular expression match with multibyte support, and returns 1 if matches are found. If the optional regs parameter was specified, the function returns the byte length of matched part, and the array regs will contain the substring of matched string. The function returns 1 if it matches with the empty string. If no matches are found or an error happens, FALSE will be returned.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => Variant,
        'desc'   => "The search pattern.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The search string.",
      ),
      array(
        'name'   => "regs",
        'type'   => Variant | Reference,
        'value'  => "null",
        'desc'   => "Contains a substring of the matched string.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_eregi_replace",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The resultant string or FALSE on error.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => Variant,
        'desc'   => "The regular expression pattern. Multibyte characters may be used. The case will be ignored.",
      ),
      array(
        'name'   => "replacement",
        'type'   => String,
        'desc'   => "The replacement text.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The searched string.",
      ),
      array(
        'name'   => "option",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "option has the same meaning as in mb_ereg_replace().",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_eregi",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Executes the regular expression match with multibyte support, and returns 1 if matches are found. If the optional regs parameter was specified, the function returns the byte length of matched part, and the array regs will contain the substring of matched string. The function returns 1 if it matches with the empty string. If no matches are found or an error happens, FALSE will be returned.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => Variant,
        'desc'   => "The regular expression pattern.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being searched.",
      ),
      array(
        'name'   => "regs",
        'type'   => Variant | Reference,
        'value'  => "null",
        'desc'   => "Contains a substring of the matched string.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_get_info",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array of type information if type is not specified, otherwise a specific type.",
    ),
    'args'   => array(
      array(
        'name'   => "type",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If type isn't specified or is specified to \"all\", an array having the elements \"internal_encoding\", \"http_output\", \"http_input\", \"func_overload\", \"mail_charset\", \"mail_header_encoding\", \"mail_body_encoding\" will be returned.\n\nIf type is specified as \"http_output\", \"http_input\", \"internal_encoding\", \"func_overload\", the specified setting parameter will be returned.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_http_input",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The character encoding name, as per the type. If mb_http_input() does not process specified HTTP input, it returns FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "type",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Input string specifies the input type. \"G\" for GET, \"P\" for POST, \"C\" for COOKIE, \"S\" for string, \"L\" for list, and \"I\" for the whole list (will return array). If type is omitted, it returns the last input type processed.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_http_output",
    'desc'   => "Set/Get the HTTP output character encoding. Output after this function is converted to encoding.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "If encoding is omitted, mb_http_output() returns the current HTTP output character encoding. Otherwise, Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "If encoding is set, mb_http_output() sets the HTTP output character encoding to encoding.\n\nIf encoding is omitted, mb_http_output() returns the current HTTP output character encoding.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_internal_encoding",
    'desc'   => "Set/Get the internal character encoding",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "If encoding is set, then Returns TRUE on success or FALSE on failure. If encoding is omitted, then the current character encoding name is returned.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding is the character encoding name used for the HTTP input character encoding conversion, HTTP output character encoding conversion, and the default character encoding for string functions defined by the mbstring module.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_language",
    'desc'   => "Set/Get the current language.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "If language is set and language is valid, it returns TRUE. Otherwise, it returns FALSE. When language is omitted, it returns the language name as a string. If no language is set previously, it then returns FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "language",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Used for encoding e-mail messages. Valid languages are \"Japanese\", \"ja\",\"English\",\"en\" and \"uni\" (UTF-8). mb_send_mail() uses this setting to encode e-mail.\n\nLanguage and its setting is ISO-2022-JP/Base64 for Japanese, UTF-8/Base64 for uni, ISO-8859-1/quoted printable for English.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_output_handler",
    'desc'   => "mb_output_handler() is ob_start() callback function. mb_output_handler() converts characters in the output buffer from internal character encoding to HTTP output character encoding.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "The converted string.",
    ),
    'args'   => array(
      array(
        'name'   => "contents",
        'type'   => String,
        'desc'   => "The contents of the output buffer.",
      ),
      array(
        'name'   => "status",
        'type'   => Int32,
        'desc'   => "The status of the output buffer.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_parse_str",
    'desc'   => "Parses GET/POST/COOKIE data and sets global variables. Since PHP does not provide raw POST/COOKIE data, it can only be used for GET data for now. It parses URL encoded data, detects encoding, converts coding to internal encoding and set values to the result array or global variables.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "encoded_string",
        'type'   => String,
        'desc'   => "The URL encoded data.",
      ),
      array(
        'name'   => "result",
        'type'   => Variant | Reference,
        'value'  => "null",
        'desc'   => "An array containing decoded and character encoded converted values.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_preferred_mime_name",
    'desc'   => "Get a MIME charset string for a specific encoding.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The MIME charset string for character encoding encoding.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'desc'   => "The encoding being checked.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_regex_encoding",
    'desc'   => "Returns the current encoding for a multibyte regex as a string.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the character encoding used by multibyte regex functions.",
    ),
    'args'   => array(
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_regex_set_options",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
      'desc'   => "The previous options. If options is omitted, it returns the string that describes the current options.",
    ),
    'args'   => array(
      array(
        'name'   => "options",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "The options to set. This is a a string where each character is an option. To set a mode, the mode character must be the last one set, however there can only be set one mode but multiple options. Regex options Option Meaning i Ambiguity match on x Enables extended pattern form m '.' matches with newlines s '^' -> '\\A', '\$' -> '\\Z' p Same as both the m and s options l Finds longest matches n Ignores empty matches e eval() resulting code Regex syntax modes Mode Meaning j Java (Sun java.util.regex) u GNU regex g grep c Emacs r Ruby z Perl b POSIX Basic regex d POSIX Extended regex",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_send_mail",
    'desc'   => "Sends email. Headers and messages are converted and encoded according to the mb_language() setting. It's a wrapper function for mail(), so see also mail() for details.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "to",
        'type'   => String,
        'desc'   => "The mail addresses being sent to. Multiple recipients may be specified by putting a comma between each address in to. This parameter is not automatically encoded.",
      ),
      array(
        'name'   => "subject",
        'type'   => String,
        'desc'   => "The subject of the mail.",
      ),
      array(
        'name'   => "message",
        'type'   => String,
        'desc'   => "The message of the mail.",
      ),
      array(
        'name'   => "headers",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "additional_headers is inserted at the end of the header. This is typically used to add extra headers. Multiple extra headers are separated with a newline (\"\\n\").",
      ),
      array(
        'name'   => "extra_cmd",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "additional_parameter is a MTA command line parameter. It is useful when setting the correct Return-Path header when using sendmail.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_split",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The result as an array.",
    ),
    'args'   => array(
      array(
        'name'   => "pattern",
        'type'   => String,
        'desc'   => "The regular expression pattern.",
      ),
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being split.",
      ),
      array(
        'name'   => "count",
        'type'   => Int32,
        'value'  => "-1",
        'desc'   => "If optional parameter limit is specified, it will be split in limit elements as maximum.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strcut",
    'desc'   => "mb_strcut() performs equivalent operation as mb_substr() with different method. If start position is multi-byte character's second byte or larger, it starts from first byte of multi-byte character.\n\nIt subtracts string from str that is shorter than length AND character that is not part of multi-byte string or not being middle of shift sequence.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "mb_strcut() returns the portion of str specified by the start and length parameters.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being cut.",
      ),
      array(
        'name'   => "start",
        'type'   => Int32,
        'desc'   => "The position that begins the cut.",
      ),
      array(
        'name'   => "length",
        'type'   => Int32,
        'value'  => "0x7FFFFFFF",
        'desc'   => "The string being decoded.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strimwidth",
    'desc'   => "Truncates string str to specified width.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The truncated string. If trimmarker is set, trimmarker is appended to the return value.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being decoded.",
      ),
      array(
        'name'   => "start",
        'type'   => Int32,
        'desc'   => "The start position offset. Number of characters from the beginning of string. (First character is 0)",
      ),
      array(
        'name'   => "width",
        'type'   => Int32,
        'desc'   => "The width of the desired trim.",
      ),
      array(
        'name'   => "trimmarker",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "A string that is added to the end of string when string is truncated.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_stripos",
    'desc'   => "mb_stripos() returns the numeric position of the first occurrence of needle in the haystack string. Unlike mb_strpos(), mb_stripos() is case-insensitive. If needle is not found, it returns FALSE.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Return the numeric position of the first occurrence of needle in the haystack string, or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the position of the first occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The position in haystack to start searching",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_stristr",
    'desc'   => "mb_stristr() finds the first occurrence of needle in haystack and returns the portion of haystack. Unlike mb_strstr(), mb_stristr() is case-insensitive. If needle is not found, it returns FALSE.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the portion of haystack, or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the first occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "part",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Determines which portion of haystack this function returns. If set to TRUE, it returns all of haystack from the beginning to the first occurrence of needle. If set to FALSE, it returns all of haystack from the first occurrence of needle to the end,",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strlen",
    'desc'   => "Gets the length of a string.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the number of characters in string str having character encoding encoding. A multi-byte character is counted as 1.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being checked for length.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strpos",
    'desc'   => "Finds position of the first occurrence of a string in a string.\n\nPerforms a multi-byte safe strpos() operation based on number of characters. The first character's position is 0, the second character position is 1, and so on.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the numeric position of the first occurrence of needle in the haystack string. If needle is not found, it returns FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string being checked.",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The position counted from the beginning of haystack.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The search offset. If it is not specified, 0 is used.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strrchr",
    'desc'   => "mb_strrchr() finds the last occurrence of needle in haystack and returns the portion of haystack. If needle is not found, it returns FALSE.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the portion of haystack. or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the last occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "part",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Determines which portion of haystack this function returns. If set to TRUE, it returns all of haystack from the beginning to the last occurrence of needle. If set to FALSE, it returns all of haystack from the last occurrence of needle to the end,",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strrichr",
    'desc'   => "mb_strrichr() finds the last occurrence of needle in haystack and returns the portion of haystack. Unlike mb_strrchr(), mb_strrichr() is case-insensitive. If needle is not found, it returns FALSE.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the portion of haystack. or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the last occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "part",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Determines which portion of haystack this function returns. If set to TRUE, it returns all of haystack from the beginning to the last occurrence of needle. If set to FALSE, it returns all of haystack from the last occurrence of needle to the end,",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strripos",
    'desc'   => "mb_strripos() performs multi-byte safe strripos() operation based on number of characters. needle position is counted from the beginning of haystack. First character's position is 0. Second character position is 1. Unlike mb_strrpos(), mb_strripos() is case-insensitive.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Return the numeric position of the last occurrence of needle in the haystack string, or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the position of the last occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The position in haystack to start searching",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strrpos",
    'desc'   => "Performs a multibyte safe strrpos() operation based on the number of characters. needle position is counted from the beginning of haystack. First character's position is 0. Second character position is 1.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the numeric position of the last occurrence of needle in the haystack string. If needle is not found, it returns FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string being checked, for the last occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack.",
      ),
      array(
        'name'   => "offset",
        'type'   => Variant,
        'value'  => "0",
        'desc'   => "May be specified to begin searching an arbitrary number of characters into the string. Negative values will stop searching at an arbitrary point prior to the end of the string.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strstr",
    'desc'   => "mb_strstr() finds the first occurrence of needle in haystack and returns the portion of haystack. If needle is not found, it returns FALSE.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the portion of haystack, or FALSE if needle is not found.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string from which to get the first occurrence of needle",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string to find in haystack",
      ),
      array(
        'name'   => "part",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Determines which portion of haystack this function returns. If set to TRUE, it returns all of haystack from the beginning to the first occurrence of needle. If set to FALSE, it returns all of haystack from the first occurrence of needle to the end,",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "Character encoding name to use. If it is omitted, internal character encoding is used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strtolower",
    'desc'   => "Returns str with all alphabetic characters converted to lowercase.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "str with all alphabetic characters converted to lowercase.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being lowercased.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strtoupper",
    'desc'   => "Returns str with all alphabetic characters converted to uppercase.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "str with all alphabetic characters converted to uppercase.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being uppercased.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_strwidth",
    'desc'   => "Returns the width of string str.\n\nMulti-byte characters are usually twice the width of single byte characters.\n\nCharacters width Chars Width U+0000 - U+0019 0 U+0020 - U+1FFF 1 U+2000 - U+FF60 2 U+FF61 - U+FF9F 1 U+FFA0 - 2",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The width of string str.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being decoded.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_substitute_character",
    'desc'   => "Specifies a substitution character when input character encoding is invalid or character code does not exist in output character encoding. Invalid characters may be substituted NULL (no output), string or integer value (Unicode character code value).\n\nThis setting affects mb_convert_encoding(), mb_convert_variables(), mb_output_handler(), and mb_send_mail().",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "If substchar is set, it returns TRUE for success, otherwise returns FALSE. If substchar is not set, it returns the Unicode value, or \"none\" or \"long\".",
    ),
    'args'   => array(
      array(
        'name'   => "substrchar",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "Specify the Unicode value as an integer, or as one of the following strings: \"none\" : no output \"long\" : Output character code value (Example: U+3000, JIS+7E7E) \"entity\" : Output character entity (Example: È)",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_substr_count",
    'desc'   => "Counts the number of times the needle substring occurs in the haystack string.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The number of times the needle substring occurs in the haystack string.",
    ),
    'args'   => array(
      array(
        'name'   => "haystack",
        'type'   => String,
        'desc'   => "The string being checked.",
      ),
      array(
        'name'   => "needle",
        'type'   => String,
        'desc'   => "The string being found.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "mb_substr",
    'desc'   => "Performs a multi-byte safe substr() operation based on number of characters. Position is counted from the beginning of str. First character's position is 0. Second character position is 1, and so on.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "mb_substr() returns the portion of str specified by the start and length parameters.",
    ),
    'args'   => array(
      array(
        'name'   => "str",
        'type'   => String,
        'desc'   => "The string being checked.",
      ),
      array(
        'name'   => "start",
        'type'   => Int32,
        'desc'   => "The first position used in str.",
      ),
      array(
        'name'   => "length",
        'type'   => Int32,
        'value'  => "0x7FFFFFFF",
        'desc'   => "The maximum length of the returned string.",
      ),
      array(
        'name'   => "encoding",
        'type'   => String,
        'value'  => "null_string",
        'desc'   => "encoding parameter is the character encoding. If it is omitted, the internal character encoding value will be used.",
      ),
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

