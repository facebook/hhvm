// @generated by Thrift for thrift/compiler/test/fixtures/interactions/src/module.thrift
// This file is probably not the place you want to edit!

//! Server definitions for `module`.

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies, unused_imports, clippy::all)]


#[doc(inline)]
pub use :: as types;

pub mod errors {
    #[doc(inline)]
    pub use ::::services::my_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_service::*;

    #[doc(inline)]
    pub use ::::services::factories;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::factories::*;

    #[doc(inline)]
    pub use ::::services::perform;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::perform::*;

    #[doc(inline)]
    pub use ::::services::interact_with_shared;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::interact_with_shared::*;

    #[doc(inline)]
    pub use ::::services::box_service;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::box_service::*;
    #[doc(inline)]
    pub use ::::services::my_interaction;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_interaction::*;
    #[doc(inline)]
    pub use ::::services::my_interaction_fast;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::my_interaction_fast::*;
    #[doc(inline)]
    pub use ::::services::serial_interaction;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::serial_interaction::*;
    #[doc(inline)]
    pub use ::::services::boxed_interaction;
    #[doc(inline)]
    #[allow(ambiguous_glob_reexports)]
    pub use ::::services::boxed_interaction::*;
}

pub(crate) use crate as server;
pub(crate) use ::::services;

#[::async_trait::async_trait]
pub trait MyInteraction: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction::FrobnicateExn> {
        ::std::result::Result::Err(crate::services::my_interaction::FrobnicateExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteraction",
                "frobnicate",
            ),
        ))
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction::PingExn> {
        ::std::result::Result::Err(crate::services::my_interaction::PingExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteraction",
                "ping",
            ),
        ))
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction::TruthifyStreamExn>>
, crate::services::my_interaction::TruthifyExn> {
        ::std::result::Result::Err(crate::services::my_interaction::TruthifyExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteraction",
                "truthify",
            ),
        ))
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction::EncodeSinkResult, crate::services::my_interaction::EncodeExn> {
        ::std::result::Result::Err(crate::services::my_interaction::EncodeExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteraction",
                "encode",
            ),
        ))
    }
    async fn on_termination(&self) {}
}

#[::async_trait::async_trait]
impl<T> MyInteraction for ::std::boxed::Box<T>
where
    T: MyInteraction + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction::PingExn> {
        (**self).ping(
        ).await
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction::TruthifyStreamExn>>
, crate::services::my_interaction::TruthifyExn> {
        (**self).truthify(
        ).await
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction::EncodeSinkResult, crate::services::my_interaction::EncodeExn> {
        (**self).encode(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

#[::async_trait::async_trait]
impl<T> MyInteraction for ::std::sync::Arc<T>
where
    T: MyInteraction + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction::PingExn> {
        (**self).ping(
        ).await
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction::TruthifyStreamExn>>
, crate::services::my_interaction::TruthifyExn> {
        (**self).truthify(
        ).await
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction::EncodeSinkResult, crate::services::my_interaction::EncodeExn> {
        (**self).encode(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

struct Args_MyInteraction_frobnicate {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteraction_frobnicate {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteraction.frobnicate"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteraction_ping {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteraction_ping {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteraction.ping"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteraction_truthify {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteraction_truthify {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteraction.truthify"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteraction_encode {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteraction_encode {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteraction.encode"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

#[::async_trait::async_trait]
pub trait MyInteractionFast: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction_fast::FrobnicateExn> {
        ::std::result::Result::Err(crate::services::my_interaction_fast::FrobnicateExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteractionFast",
                "frobnicate",
            ),
        ))
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction_fast::PingExn> {
        ::std::result::Result::Err(crate::services::my_interaction_fast::PingExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteractionFast",
                "ping",
            ),
        ))
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction_fast::TruthifyStreamExn>>
, crate::services::my_interaction_fast::TruthifyExn> {
        ::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteractionFast",
                "truthify",
            ),
        ))
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction_fast::EncodeSinkResult, crate::services::my_interaction_fast::EncodeExn> {
        ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyInteractionFast",
                "encode",
            ),
        ))
    }
    async fn on_termination(&self) {}
}

#[::async_trait::async_trait]
impl<T> MyInteractionFast for ::std::boxed::Box<T>
where
    T: MyInteractionFast + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction_fast::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction_fast::PingExn> {
        (**self).ping(
        ).await
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction_fast::TruthifyStreamExn>>
, crate::services::my_interaction_fast::TruthifyExn> {
        (**self).truthify(
        ).await
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction_fast::EncodeSinkResult, crate::services::my_interaction_fast::EncodeExn> {
        (**self).encode(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

#[::async_trait::async_trait]
impl<T> MyInteractionFast for ::std::sync::Arc<T>
where
    T: MyInteractionFast + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<::std::primitive::i32, crate::services::my_interaction_fast::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn ping(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_interaction_fast::PingExn> {
        (**self).ping(
        ).await
    }
    async fn truthify(
        &self,
    ) -> ::std::result::Result<
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::bool, crate::services::my_interaction_fast::TruthifyStreamExn>>
, crate::services::my_interaction_fast::TruthifyExn> {
        (**self).truthify(
        ).await
    }
    async fn encode(
        &self,
    ) -> ::std::result::Result<crate::services::my_interaction_fast::EncodeSinkResult, crate::services::my_interaction_fast::EncodeExn> {
        (**self).encode(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

struct Args_MyInteractionFast_frobnicate {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteractionFast_frobnicate {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteractionFast.frobnicate"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteractionFast_ping {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteractionFast_ping {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteractionFast.ping"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteractionFast_truthify {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteractionFast_truthify {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteractionFast.truthify"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyInteractionFast_encode {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyInteractionFast_encode {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyInteractionFast.encode"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

#[::async_trait::async_trait]
pub trait SerialInteraction: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<(), crate::services::serial_interaction::FrobnicateExn> {
        ::std::result::Result::Err(crate::services::serial_interaction::FrobnicateExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "SerialInteraction",
                "frobnicate",
            ),
        ))
    }
    async fn on_termination(&self) {}
}

#[::async_trait::async_trait]
impl<T> SerialInteraction for ::std::boxed::Box<T>
where
    T: SerialInteraction + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<(), crate::services::serial_interaction::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

#[::async_trait::async_trait]
impl<T> SerialInteraction for ::std::sync::Arc<T>
where
    T: SerialInteraction + Send + Sync + ?Sized,
{
    async fn frobnicate(
        &self,
    ) -> ::std::result::Result<(), crate::services::serial_interaction::FrobnicateExn> {
        (**self).frobnicate(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

struct Args_SerialInteraction_frobnicate {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_SerialInteraction_frobnicate {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "SerialInteraction.frobnicate"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

#[::async_trait::async_trait]
pub trait BoxedInteraction: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn getABox(
        &self,
    ) -> ::std::result::Result<crate::types::ShouldBeBoxed, crate::services::boxed_interaction::GetABoxExn> {
        ::std::result::Result::Err(crate::services::boxed_interaction::GetABoxExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "BoxedInteraction",
                "getABox",
            ),
        ))
    }
    async fn on_termination(&self) {}
}

#[::async_trait::async_trait]
impl<T> BoxedInteraction for ::std::boxed::Box<T>
where
    T: BoxedInteraction + Send + Sync + ?Sized,
{
    async fn getABox(
        &self,
    ) -> ::std::result::Result<crate::types::ShouldBeBoxed, crate::services::boxed_interaction::GetABoxExn> {
        (**self).getABox(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

#[::async_trait::async_trait]
impl<T> BoxedInteraction for ::std::sync::Arc<T>
where
    T: BoxedInteraction + Send + Sync + ?Sized,
{
    async fn getABox(
        &self,
    ) -> ::std::result::Result<crate::types::ShouldBeBoxed, crate::services::boxed_interaction::GetABoxExn> {
        (**self).getABox(
        ).await
    }
    async fn on_termination(&self) {
        (**self).on_termination().await;
    }
}

struct Args_BoxedInteraction_getABox {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_BoxedInteraction_getABox {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "BoxedInteraction.getABox"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


pub mod my_service {
    use super::*;

    
    
    
    /// Processor for MyInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.frobnicate", exn);
                    ::tracing::error!(method = "MyInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteraction.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.ping", exn);
                    ::tracing::error!(method = "MyInteraction.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteraction.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                    ::tracing::error!(method = "MyInteraction.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteraction.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteraction.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteraction.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                    ::tracing::error!(method = "MyInteraction.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteraction.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteraction.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteraction.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteraction.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteraction.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for MyInteractionFast's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionFastProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteractionFast.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.frobnicate", exn);
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteractionFast.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.ping", exn);
                    ::tracing::error!(method = "MyInteractionFast.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteractionFast.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                    ::tracing::error!(method = "MyInteractionFast.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteractionFast.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteractionFast.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.MyInteractionFast.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                    ::tracing::error!(method = "MyInteractionFast.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction_fast::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction_fast::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction_fast::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction_fast::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteractionFast.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction_fast::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteractionFast.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteractionFast.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteractionFast.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteractionFast.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteractionFast.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteractionFast"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteractionFast:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for SerialInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct SerialInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SerialInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
            const METHOD_NAME: &::std::ffi::CStr = c"SerialInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.SerialInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SerialInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SerialInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SerialInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SerialInteraction.frobnicate", exn);
                    ::tracing::error!(method = "SerialInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::serial_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::serial_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"SerialInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "SerialInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.SerialInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    

}

#[::async_trait::async_trait]
pub trait MyService: ::std::marker::Send + ::std::marker::Sync + 'static {
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        ::anyhow::bail!("MyService.createMyInteraction not implemented");
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        ::anyhow::bail!("MyService.createMyInteractionFast not implemented");
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        ::anyhow::bail!("MyService.createSerialInteraction not implemented");
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::FooExn> {
        ::std::result::Result::Err(crate::services::my_service::FooExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "foo",
            ),
        ))
    }
    async fn interact(
        &self,
        _arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::my_service::InteractExn> {
        ::std::result::Result::Err(crate::services::my_service::InteractExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "interact",
            ),
        ))
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::my_service::InteractFastExn> {
        ::std::result::Result::Err(crate::services::my_service::InteractFastExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "interactFast",
            ),
        ))
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::my_service::SerializeStreamExn>>
)
), crate::services::my_service::SerializeExn> {
        ::std::result::Result::Err(crate::services::my_service::SerializeExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "MyService",
                "serialize",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> MyService for ::std::boxed::Box<T>
where
    T: MyService + Send + Sync + ?Sized,
{
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        (**self).createMyInteractionFast()
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        (**self).createSerialInteraction()
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::FooExn> {
        (**self).foo(
        ).await
    }
    async fn interact(
        &self,
        arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::my_service::InteractExn> {
        (**self).interact(
            arg,
        ).await
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::my_service::InteractFastExn> {
        (**self).interactFast(
        ).await
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::my_service::SerializeStreamExn>>
)
), crate::services::my_service::SerializeExn> {
        (**self).serialize(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> MyService for ::std::sync::Arc<T>
where
    T: MyService + Send + Sync + ?Sized,
{
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        (**self).createMyInteractionFast()
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        (**self).createSerialInteraction()
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::my_service::FooExn> {
        (**self).foo(
        ).await
    }
    async fn interact(
        &self,
        arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::my_service::InteractExn> {
        (**self).interact(
            arg,
        ).await
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::my_service::InteractFastExn> {
        (**self).interactFast(
        ).await
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::my_service::SerializeStreamExn>>
)
), crate::services::my_service::SerializeExn> {
        (**self).serialize(
        ).await
    }
}
/// Processor for MyService's methods.
#[derive(Clone, Debug)]
pub struct MyServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_MyService_foo {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_foo {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.foo"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyService_interact {
    arg: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_interact {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.interact"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("arg", ::fbthrift::TType::I32, 1),
        ];
        let mut field_arg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_arg = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "arg", function: "interact"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            arg: field_arg.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "MyService.interact", "arg"))?,
        })
    }
}


struct Args_MyService_interactFast {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_interactFast {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.interactFast"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_MyService_serialize {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_MyService_serialize {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "MyService.serialize"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

impl<P, H, R, RS> MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    fn handle_createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        self.service.createMyInteraction()
    }

    fn handle_createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        self.service.createMyInteractionFast()
    }

    fn handle_createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        self.service.createSerialInteraction()
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.foo"))]
    async fn handle_foo<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
        const METHOD_NAME: &::std::ffi::CStr = c"foo";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.foo";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_foo = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.foo(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.foo", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "MyService.foo", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.foo", exn);
                ::tracing::error!(method = "MyService.foo", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::my_service::FooExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_service::FooExn>(
            "foo",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.interact"))]
    async fn handle_interact<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
        const METHOD_NAME: &::std::ffi::CStr = c"interact";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.interact";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_interact = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.interact(
                _args.arg,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.interact", "success");
                let (interaction_handler, res) = (res, ());
                let interaction_processor = ::std::sync::Arc::new(crate::server::my_service::MyInteractionProcessor::<P, ::std::boxed::Box<dyn MyInteraction>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "MyService.interact", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.interact", exn);
                ::tracing::error!(method = "MyService.interact", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::my_service::InteractExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_service::InteractExn>(
            "interact",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.interactFast"))]
    async fn handle_interactFast<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
        const METHOD_NAME: &::std::ffi::CStr = c"interactFast";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.interactFast";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_interactFast = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.interactFast(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.interactFast", "success");
                let (interaction_handler, res) = res;
                let interaction_processor = ::std::sync::Arc::new(crate::server::my_service::MyInteractionFastProcessor::<P, ::std::boxed::Box<dyn MyInteractionFast>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "MyService.interactFast", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.interactFast", exn);
                ::tracing::error!(method = "MyService.interactFast", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::my_service::InteractFastExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_service::InteractFastExn>(
            "interactFast",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyService.serialize"))]
    async fn handle_serialize<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"MyService";
        const METHOD_NAME: &::std::ffi::CStr = c"serialize";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"MyService.serialize";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_MyService_serialize = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.serialize(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "MyService.serialize", "success");
                let (interaction_handler, res) = res;
                let interaction_processor = ::std::sync::Arc::new(crate::server::my_service::SerialInteractionProcessor::<P, ::std::boxed::Box<dyn SerialInteraction>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.serialize", exn);
                ::tracing::error!(method = "MyService.serialize", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::my_service::SerializeExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let (response, stream) = res;
                let response = ::std::result::Result::Ok(response);

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_service::SerializeStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "serialize",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_service::SerializeStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="MyService.serialize", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyService.serialize", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyService.serialize", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_service::SerializeExn>(
            "serialize",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        reply_state.set_stream_context_stack(ctx_stack);
        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: MyService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"foo" => ::std::result::Result::Ok(3usize),
            b"interact" => ::std::result::Result::Ok(4usize),
            b"interactFast" => ::std::result::Result::Ok(5usize),
            b"serialize" => ::std::result::Result::Ok(6usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            3usize => {
                self.handle_foo(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            4usize => {
                self.handle_interact(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            5usize => {
                self.handle_interactFast(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            6usize => {
                self.handle_serialize(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            "MyInteraction" => ::std::result::Result::Ok(0usize),
            "MyInteractionFast" => ::std::result::Result::Ok(1usize),
            "SerialInteraction" => ::std::result::Result::Ok(2usize),
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            0usize => {
                let handler = self.handle_createMyInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::my_service::MyInteractionProcessor::<P, ::std::boxed::Box<dyn MyInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            1usize => {
                let handler = self.handle_createMyInteractionFast()?;
                let server = ::std::sync::Arc::new(crate::server::my_service::MyInteractionFastProcessor::<P, ::std::boxed::Box<dyn MyInteractionFast>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            2usize => {
                let handler = self.handle_createSerialInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::my_service::SerialInteractionProcessor::<P, ::std::boxed::Box<dyn SerialInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "MyServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "MyService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.MyService:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "foo",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "interact",
              starts_interaction: true,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "interactFast",
              starts_interaction: true,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "serialize",
              starts_interaction: true,
              interaction_name: Some("SerialInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteraction.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteraction.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteraction.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteractionFast.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteractionFast.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteractionFast.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteractionFast.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SerialInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("SerialInteraction"),
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a MyService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_MyService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: MyService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(MyServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "MyService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

pub mod factories {
    use super::*;

    
    
    
    /// Processor for MyInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.frobnicate", exn);
                    ::tracing::error!(method = "MyInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteraction.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.ping", exn);
                    ::tracing::error!(method = "MyInteraction.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteraction.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                    ::tracing::error!(method = "MyInteraction.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteraction.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteraction.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteraction.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                    ::tracing::error!(method = "MyInteraction.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteraction.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteraction.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteraction.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteraction.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteraction.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for MyInteractionFast's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionFastProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteractionFast.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.frobnicate", exn);
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteractionFast.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.ping", exn);
                    ::tracing::error!(method = "MyInteractionFast.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteractionFast.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                    ::tracing::error!(method = "MyInteractionFast.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteractionFast.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteractionFast.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.MyInteractionFast.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                    ::tracing::error!(method = "MyInteractionFast.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction_fast::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction_fast::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction_fast::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction_fast::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteractionFast.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction_fast::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteractionFast.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteractionFast.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteractionFast.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteractionFast.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteractionFast.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteractionFast"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteractionFast:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for SerialInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct SerialInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SerialInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
            const METHOD_NAME: &::std::ffi::CStr = c"SerialInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.SerialInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SerialInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SerialInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SerialInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SerialInteraction.frobnicate", exn);
                    ::tracing::error!(method = "SerialInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::serial_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::serial_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"SerialInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "SerialInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.SerialInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    

}

#[::async_trait::async_trait]
pub trait Factories: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::factories::FooExn> {
        ::std::result::Result::Err(crate::services::factories::FooExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "Factories",
                "foo",
            ),
        ))
    }
    async fn interact(
        &self,
        _arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::factories::InteractExn> {
        ::std::result::Result::Err(crate::services::factories::InteractExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "Factories",
                "interact",
            ),
        ))
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::factories::InteractFastExn> {
        ::std::result::Result::Err(crate::services::factories::InteractFastExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "Factories",
                "interactFast",
            ),
        ))
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::factories::SerializeStreamExn>>
)
), crate::services::factories::SerializeExn> {
        ::std::result::Result::Err(crate::services::factories::SerializeExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "Factories",
                "serialize",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> Factories for ::std::boxed::Box<T>
where
    T: Factories + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::factories::FooExn> {
        (**self).foo(
        ).await
    }
    async fn interact(
        &self,
        arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::factories::InteractExn> {
        (**self).interact(
            arg,
        ).await
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::factories::InteractFastExn> {
        (**self).interactFast(
        ).await
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::factories::SerializeStreamExn>>
)
), crate::services::factories::SerializeExn> {
        (**self).serialize(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> Factories for ::std::sync::Arc<T>
where
    T: Factories + Send + Sync + ?Sized,
{
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::factories::FooExn> {
        (**self).foo(
        ).await
    }
    async fn interact(
        &self,
        arg: ::std::primitive::i32,
    ) -> ::std::result::Result<::std::boxed::Box<dyn MyInteraction>, crate::services::factories::InteractExn> {
        (**self).interact(
            arg,
        ).await
    }
    async fn interactFast(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn MyInteractionFast>, ::std::primitive::i32), crate::services::factories::InteractFastExn> {
        (**self).interactFast(
        ).await
    }
    async fn serialize(
        &self,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn SerialInteraction>, 
(
    ::std::primitive::i32,
    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::services::factories::SerializeStreamExn>>
)
), crate::services::factories::SerializeExn> {
        (**self).serialize(
        ).await
    }
}
/// Processor for Factories's methods.
#[derive(Clone, Debug)]
pub struct FactoriesProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_Factories_foo {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_Factories_foo {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "Factories.foo"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_Factories_interact {
    arg: ::std::primitive::i32,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_Factories_interact {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "Factories.interact"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("arg", ::fbthrift::TType::I32, 1),
        ];
        let mut field_arg = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::I32, 1) => field_arg = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "arg", function: "interact"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            arg: field_arg.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "Factories.interact", "arg"))?,
        })
    }
}


struct Args_Factories_interactFast {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_Factories_interactFast {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "Factories.interactFast"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}


struct Args_Factories_serialize {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_Factories_serialize {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "Factories.serialize"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

impl<P, H, R, RS> FactoriesProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: Factories,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "Factories.foo"))]
    async fn handle_foo<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
        const METHOD_NAME: &::std::ffi::CStr = c"foo";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.foo";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_Factories_foo = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.foo(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "Factories.foo", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "Factories.foo", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("Factories.foo", exn);
                ::tracing::error!(method = "Factories.foo", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::factories::FooExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::factories::FooExn>(
            "foo",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "Factories.interact"))]
    async fn handle_interact<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
        const METHOD_NAME: &::std::ffi::CStr = c"interact";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.interact";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_Factories_interact = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.interact(
                _args.arg,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "Factories.interact", "success");
                let (interaction_handler, res) = (res, ());
                let interaction_processor = ::std::sync::Arc::new(crate::server::factories::MyInteractionProcessor::<P, ::std::boxed::Box<dyn MyInteraction>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "Factories.interact", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("Factories.interact", exn);
                ::tracing::error!(method = "Factories.interact", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::factories::InteractExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::factories::InteractExn>(
            "interact",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "Factories.interactFast"))]
    async fn handle_interactFast<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
        const METHOD_NAME: &::std::ffi::CStr = c"interactFast";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.interactFast";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_Factories_interactFast = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.interactFast(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "Factories.interactFast", "success");
                let (interaction_handler, res) = res;
                let interaction_processor = ::std::sync::Arc::new(crate::server::factories::MyInteractionFastProcessor::<P, ::std::boxed::Box<dyn MyInteractionFast>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "Factories.interactFast", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("Factories.interactFast", exn);
                ::tracing::error!(method = "Factories.interactFast", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::factories::InteractFastExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::factories::InteractFastExn>(
            "interactFast",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "Factories.serialize"))]
    async fn handle_serialize<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"Factories";
        const METHOD_NAME: &::std::ffi::CStr = c"serialize";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Factories.serialize";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_Factories_serialize = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.serialize(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "Factories.serialize", "success");
                let (interaction_handler, res) = res;
                let interaction_processor = ::std::sync::Arc::new(crate::server::factories::SerialInteractionProcessor::<P, ::std::boxed::Box<dyn SerialInteraction>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("Factories.serialize", exn);
                ::tracing::error!(method = "Factories.serialize", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::factories::SerializeExn::ApplicationException(aexn))
            }
        };

        use ::futures::StreamExt as _;

        let (response, stream) = match res {
            ::std::result::Result::Ok(res) => {
                let (response, stream) = res;
                let response = ::std::result::Result::Ok(response);

                let stream = ::std::panic::AssertUnwindSafe(stream)
                    .catch_unwind()
                    .map(|item| {
                        match item {
                            ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::factories::SerializeStreamExn>(
                                    ::std::result::Result::Ok(success),
                                    "serialize",
                                );
                                ::fbthrift::SerializedStreamElement::Success(payload)
                            }
                            ::std::result::Result::Ok(::std::result::Result::Err(crate::services::factories::SerializeStreamExn::ApplicationException(aexn))) => {
                                tracing::info!(?aexn, method="Factories.serialize", "Streaming ApplicationException");
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="Factories.serialize", "Streaming unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("Factories.serialize", exn);
                                ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                            }
                        }
                    })
                    .boxed();
                (response, ::std::option::Option::Some(stream))
            },
            ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
        };

        let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::factories::SerializeExn>(
            "serialize",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            response,
        )?;

        reply_state.set_stream_context_stack(ctx_stack);
        let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for FactoriesProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: Factories,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"foo" => ::std::result::Result::Ok(0usize),
            b"interact" => ::std::result::Result::Ok(1usize),
            b"interactFast" => ::std::result::Result::Ok(2usize),
            b"serialize" => ::std::result::Result::Ok(3usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_foo(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            1usize => {
                self.handle_interact(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            2usize => {
                self.handle_interactFast(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            3usize => {
                self.handle_serialize(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "FactoriesProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "FactoriesProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for FactoriesProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: Factories,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "Factories"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.Factories:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "foo",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "interact",
              starts_interaction: true,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "interactFast",
              starts_interaction: true,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "serialize",
              starts_interaction: true,
              interaction_name: Some("SerialInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteraction.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteraction.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteraction.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteractionFast.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteractionFast.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteractionFast.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteractionFast.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SerialInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("SerialInteraction"),
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a Factories service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_Factories_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: Factories,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(FactoriesProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(FactoriesProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "Factories.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

pub mod perform {
    use super::*;

    
    
    
    /// Processor for MyInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.frobnicate", exn);
                    ::tracing::error!(method = "MyInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteraction.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.ping", exn);
                    ::tracing::error!(method = "MyInteraction.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteraction.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                    ::tracing::error!(method = "MyInteraction.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteraction.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteraction.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteraction.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                    ::tracing::error!(method = "MyInteraction.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteraction.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteraction.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteraction.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteraction.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteraction.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for MyInteractionFast's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionFastProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteractionFast.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.frobnicate", exn);
                    ::tracing::error!(method = "MyInteractionFast.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteractionFast.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.ping", exn);
                    ::tracing::error!(method = "MyInteractionFast.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteractionFast.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                    ::tracing::error!(method = "MyInteractionFast.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction_fast::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteractionFast.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteractionFast.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteractionFast.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteractionFast.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.MyInteractionFast.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteractionFast_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteractionFast.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteractionFast.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                    ::tracing::error!(method = "MyInteractionFast.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction_fast::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction_fast::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction_fast::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction_fast::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction_fast::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteractionFast.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction_fast::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteractionFast.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction_fast::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction_fast::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction_fast::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteractionFast.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteractionFast,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteractionFast.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteractionFast.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteractionFast.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteractionFast.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionFastProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionFastProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteractionFast,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteractionFast"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteractionFast:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for SerialInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct SerialInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SerialInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
            const METHOD_NAME: &::std::ffi::CStr = c"SerialInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.SerialInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SerialInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SerialInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SerialInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SerialInteraction.frobnicate", exn);
                    ::tracing::error!(method = "SerialInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::serial_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::serial_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SerialInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"SerialInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SerialInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for SerialInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: SerialInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "SerialInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.SerialInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    

}

#[::async_trait::async_trait]
pub trait Perform: ::std::marker::Send + ::std::marker::Sync + 'static {
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        ::anyhow::bail!("Perform.createMyInteraction not implemented");
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        ::anyhow::bail!("Perform.createMyInteractionFast not implemented");
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        ::anyhow::bail!("Perform.createSerialInteraction not implemented");
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::perform::FooExn> {
        ::std::result::Result::Err(crate::services::perform::FooExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "Perform",
                "foo",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> Perform for ::std::boxed::Box<T>
where
    T: Perform + Send + Sync + ?Sized,
{
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        (**self).createMyInteractionFast()
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        (**self).createSerialInteraction()
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::perform::FooExn> {
        (**self).foo(
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> Perform for ::std::sync::Arc<T>
where
    T: Perform + Send + Sync + ?Sized,
{
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        (**self).createMyInteractionFast()
    }
    fn createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        (**self).createSerialInteraction()
    }
    async fn foo(
        &self,
    ) -> ::std::result::Result<(), crate::services::perform::FooExn> {
        (**self).foo(
        ).await
    }
}
/// Processor for Perform's methods.
#[derive(Clone, Debug)]
pub struct PerformProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_Perform_foo {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_Perform_foo {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "Perform.foo"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

impl<P, H, R, RS> PerformProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: Perform,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    fn handle_createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        self.service.createMyInteraction()
    }

    fn handle_createMyInteractionFast(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteractionFast>> {
        self.service.createMyInteractionFast()
    }

    fn handle_createSerialInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SerialInteraction>> {
        self.service.createSerialInteraction()
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "Perform.foo"))]
    async fn handle_foo<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"Perform";
        const METHOD_NAME: &::std::ffi::CStr = c"foo";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"Perform.foo";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_Perform_foo = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.foo(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "Perform.foo", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "Perform.foo", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("Perform.foo", exn);
                ::tracing::error!(method = "Perform.foo", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::perform::FooExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::perform::FooExn>(
            "foo",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for PerformProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: Perform,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"foo" => ::std::result::Result::Ok(3usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            3usize => {
                self.handle_foo(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "PerformProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            "MyInteraction" => ::std::result::Result::Ok(0usize),
            "MyInteractionFast" => ::std::result::Result::Ok(1usize),
            "SerialInteraction" => ::std::result::Result::Ok(2usize),
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            0usize => {
                let handler = self.handle_createMyInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::perform::MyInteractionProcessor::<P, ::std::boxed::Box<dyn MyInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            1usize => {
                let handler = self.handle_createMyInteractionFast()?;
                let server = ::std::sync::Arc::new(crate::server::perform::MyInteractionFastProcessor::<P, ::std::boxed::Box<dyn MyInteractionFast>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            2usize => {
                let handler = self.handle_createSerialInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::perform::SerialInteractionProcessor::<P, ::std::boxed::Box<dyn SerialInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "PerformProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for PerformProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: Perform,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "Perform"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.Perform:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "foo",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteraction.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteraction.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteraction.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteractionFast.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteractionFast.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteractionFast.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteractionFast.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteractionFast"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SerialInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("SerialInteraction"),
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a Perform service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_Perform_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: Perform,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(PerformProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(PerformProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "Perform.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

pub mod interact_with_shared {
    use super::*;

    
    
    
    /// Processor for MyInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct MyInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.frobnicate"))]
        async fn handle_frobnicate<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.frobnicate";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.MyInteraction.frobnicate";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_frobnicate = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.frobnicate(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.frobnicate", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.frobnicate", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.frobnicate", exn);
                    ::tracing::error!(method = "MyInteraction.frobnicate", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::FrobnicateExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::FrobnicateExn>(
                "frobnicate",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.ping"))]
        async fn handle_ping<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.ping";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.MyInteraction.ping";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_ping = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.ping(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.ping", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.ping", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.ping", exn);
                    ::tracing::error!(method = "MyInteraction.ping", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::PingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::PingExn>(
                "ping",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.truthify"))]
        async fn handle_truthify<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.truthify";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.MyInteraction.truthify";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_truthify = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.truthify(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.truthify", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                    ::tracing::error!(method = "MyInteraction.truthify", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::TruthifyExn::ApplicationException(aexn))
                }
            };
    
            use ::futures::StreamExt as _;
    
            let (response, stream) = match res {
                ::std::result::Result::Ok(res) => {
                    let response = ::std::result::Result::Ok(());
                    let stream = res;
    
                    let stream = ::std::panic::AssertUnwindSafe(stream)
                        .catch_unwind()
                        .map(|item| {
                            match item {
                                ::std::result::Result::Ok(::std::result::Result::Ok(success)) => {
                                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::TruthifyStreamExn>(
                                        ::std::result::Result::Ok(success),
                                        "truthify",
                                    );
                                    ::fbthrift::SerializedStreamElement::Success(payload)
                                }
                                ::std::result::Result::Ok(::std::result::Result::Err(crate::services::my_interaction::TruthifyStreamExn::ApplicationException(aexn))) => {
                                    tracing::info!(?aexn, method="MyInteraction.truthify", "Streaming ApplicationException");
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                                ::std::result::Result::Err(exn) => {
                                    tracing::error!(?exn, method="MyInteraction.truthify", "Streaming unwind");
                                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.truthify", exn);
                                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                                }
                            }
                        })
                        .boxed();
                    (response, ::std::option::Option::Some(stream))
                },
                ::std::result::Result::Err(exn) => (::std::result::Result::Err(exn), ::std::option::Option::None),
            };
    
            let response = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::TruthifyExn>(
                "truthify",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                response,
            )?;
    
            reply_state.set_stream_context_stack(ctx_stack);
            let _ = reply_state.send_stream_reply(response, stream, P::PROTOCOL_ID);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "MyInteraction.encode"))]
        async fn handle_encode<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"MyInteraction.encode";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.MyInteraction.encode";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_MyInteraction_encode = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.encode(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "MyInteraction.encode", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "MyInteraction.encode", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                    ::tracing::error!(method = "MyInteraction.encode", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeExn::ApplicationException(aexn))
                }
            };
    
            // Process the Thrift SINK encoded request
    
            use ::futures::StreamExt as _;
    
            let (first_result, stream_fn, buffer_size, chunk_timeout): (
                ::std::result::Result::<::std::collections::BTreeSet<::std::primitive::i32>, crate::services::my_interaction::EncodeExn>,
                ::std::boxed::Box<dyn ::std::ops::FnOnce(
                    ::futures::stream::BoxStream<'static, ::std::result::Result<::std::string::String, crate::services::my_interaction::EncodeSinkExn>>
                ) -> ::futures::future::BoxFuture<'static,
                    ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::my_interaction::EncodeSinkFinalExn>
                > + Send>,
                _,
                _,
            ) = match res {
                Ok(crate::errors::my_interaction::EncodeSinkResult {
                    initial_response,
                    stream_handler,
                    buffer_size,
                    chunk_timeout,
                }) => (::std::result::Result::Ok(initial_response), stream_handler, buffer_size, chunk_timeout),
                Err(e) => (::std::result::Result::Err(e), Box::new(|_stream| async move {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new("Stream function builder failed to execute"));
                    ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn))
                }.boxed()), 100, ::std::time::Duration::ZERO),
            };
    
            let first_result_enc = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::my_interaction::EncodeExn>(
                "encode",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                first_result,
            )?;
            reply_state.set_stream_context_stack(ctx_stack);
            let (input_stream, final_result_callback) = reply_state.send_sink_reply(first_result_enc, buffer_size, chunk_timeout, P::PROTOCOL_ID);
            let stream =
                ::std::panic::AssertUnwindSafe(input_stream)
                    .catch_unwind()
                    .map(|item| // item is a Result<_payload_, String> wrapped in a assert unwind handler
                        match item {
                            ::std::result::Result::Err(exn) => {
                                tracing::error!(?exn, method="MyInteraction.encode", "Sink stream unwind");
                                let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", exn);
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            },
                            ::std::result::Result::Ok(::std::result::Result::Ok(item_enc)) => {
                                let mut de = P::deserializer(item_enc);
                                let res = <crate::errors::my_interaction::EncodeSinkReader as ::fbthrift::help::DeserializeExn>::read_result(&mut de);
                                match res {
                                    Ok(r) => r,
                                    Err(exn) => {
                                        let aexn = ::fbthrift::ApplicationException::handler_panic("MyInteraction.encode", Box::new(exn));
                                        ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                                    }
                                }
                            },
                            ::std::result::Result::Ok(::std::result::Result::Err(aexn)) => {
                                ::std::result::Result::Err(crate::errors::my_interaction::EncodeSinkExn::ApplicationException(aexn))
                            }
                        }
                    )
                    .boxed();
            let final_result = stream_fn(stream).await;
            let enc_final_result = match final_result {
                ::std::result::Result::Ok(ok_result) => {
                    let payload = ::fbthrift::help::serialize_stream_item::<P, crate::services::my_interaction::EncodeSinkFinalExn>(
                        ::std::result::Result::Ok(ok_result),
                        "encode",
                    );
                    ::fbthrift::SerializedStreamElement::Success(payload)
                }
                ::std::result::Result::Err(crate::services::my_interaction::EncodeSinkFinalExn::ApplicationException(aexn)) => {
                    tracing::info!(?aexn, method="MyInteraction.encode", "Sink Final ApplicationException");
                    ::fbthrift::SerializedStreamElement::ApplicationException(aexn)
                }
                
            };
            final_result_callback(enc_final_result);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: MyInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"MyInteraction.frobnicate" => ::std::result::Result::Ok(0usize),
                b"MyInteraction.ping" => ::std::result::Result::Ok(1usize),
                b"MyInteraction.truthify" => ::std::result::Result::Ok(2usize),
                b"MyInteraction.encode" => ::std::result::Result::Ok(3usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_frobnicate(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_ping(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_truthify(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                3usize => {
                    self.handle_encode(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "MyInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for MyInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: MyInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "MyInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.MyInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    
    
    
    
    /// Processor for SharedInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct SharedInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> SharedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SharedInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SharedInteraction.init"))]
        async fn handle_init<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"SharedInteraction.init";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.SharedInteraction.init";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SharedInteraction_init = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.init(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SharedInteraction.init", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SharedInteraction.init", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SharedInteraction.init", exn);
                    ::tracing::error!(method = "SharedInteraction.init", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::shared_interaction::InitExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::shared_interaction::InitExn>(
                "init",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SharedInteraction.do_something"))]
        async fn handle_do_something<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"SharedInteraction.do_something";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.SharedInteraction.do_something";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SharedInteraction_do_something = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.do_something(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SharedInteraction.do_something", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SharedInteraction.do_something", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SharedInteraction.do_something", exn);
                    ::tracing::error!(method = "SharedInteraction.do_something", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::shared_interaction::DoSomethingExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::shared_interaction::DoSomethingExn>(
                "do_something",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "SharedInteraction.tear_down"))]
        async fn handle_tear_down<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
            const METHOD_NAME: &::std::ffi::CStr = c"SharedInteraction.tear_down";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.SharedInteraction.tear_down";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_SharedInteraction_tear_down = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.tear_down(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "SharedInteraction.tear_down", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "SharedInteraction.tear_down", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("SharedInteraction.tear_down", exn);
                    ::tracing::error!(method = "SharedInteraction.tear_down", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::shared_interaction::TearDownExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::shared_interaction::TearDownExn>(
                "tear_down",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for SharedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: SharedInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"SharedInteraction.init" => ::std::result::Result::Ok(0usize),
                b"SharedInteraction.do_something" => ::std::result::Result::Ok(1usize),
                b"SharedInteraction.tear_down" => ::std::result::Result::Ok(2usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_init(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                1usize => {
                    self.handle_do_something(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                2usize => {
                    self.handle_tear_down(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SharedInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "SharedInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for SharedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: SharedInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "SharedInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From shared.SharedInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    

}

#[::async_trait::async_trait]
pub trait InteractWithShared: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn do_some_similar_things(
        &self,
    ) -> ::std::result::Result<shared__types::DoSomethingResult, crate::services::interact_with_shared::DoSomeSimilarThingsExn> {
        ::std::result::Result::Err(crate::services::interact_with_shared::DoSomeSimilarThingsExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "InteractWithShared",
                "do_some_similar_things",
            ),
        ))
    }
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        ::anyhow::bail!("InteractWithShared.createMyInteraction not implemented");
    }
    fn createshared.SharedInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SharedInteraction>> {
        ::anyhow::bail!("InteractWithShared.createshared.SharedInteraction not implemented");
    }
}

#[::async_trait::async_trait]
impl<T> InteractWithShared for ::std::boxed::Box<T>
where
    T: InteractWithShared + Send + Sync + ?Sized,
{
    async fn do_some_similar_things(
        &self,
    ) -> ::std::result::Result<shared__types::DoSomethingResult, crate::services::interact_with_shared::DoSomeSimilarThingsExn> {
        (**self).do_some_similar_things(
        ).await
    }
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createshared.SharedInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SharedInteraction>> {
        (**self).createshared.SharedInteraction()
    }
}

#[::async_trait::async_trait]
impl<T> InteractWithShared for ::std::sync::Arc<T>
where
    T: InteractWithShared + Send + Sync + ?Sized,
{
    async fn do_some_similar_things(
        &self,
    ) -> ::std::result::Result<shared__types::DoSomethingResult, crate::services::interact_with_shared::DoSomeSimilarThingsExn> {
        (**self).do_some_similar_things(
        ).await
    }
    fn createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        (**self).createMyInteraction()
    }
    fn createshared.SharedInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SharedInteraction>> {
        (**self).createshared.SharedInteraction()
    }
}
/// Processor for InteractWithShared's methods.
#[derive(Clone, Debug)]
pub struct InteractWithSharedProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_InteractWithShared_do_some_similar_things {
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_InteractWithShared_do_some_similar_things {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "InteractWithShared.do_some_similar_things"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
        ];
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
        })
    }
}

impl<P, H, R, RS> InteractWithSharedProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: InteractWithShared,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "InteractWithShared.do_some_similar_things"))]
    async fn handle_do_some_similar_things<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"InteractWithShared";
        const METHOD_NAME: &::std::ffi::CStr = c"do_some_similar_things";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"InteractWithShared.do_some_similar_things";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_InteractWithShared_do_some_similar_things = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.do_some_similar_things(
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "InteractWithShared.do_some_similar_things", "success");
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "InteractWithShared.do_some_similar_things", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("InteractWithShared.do_some_similar_things", exn);
                ::tracing::error!(method = "InteractWithShared.do_some_similar_things", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::interact_with_shared::DoSomeSimilarThingsExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::interact_with_shared::DoSomeSimilarThingsExn>(
            "do_some_similar_things",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }

    fn handle_createMyInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn MyInteraction>> {
        self.service.createMyInteraction()
    }

    fn handle_createshared.SharedInteraction(
        &self,
    ) -> ::anyhow::Result<::std::boxed::Box<dyn SharedInteraction>> {
        self.service.createshared.SharedInteraction()
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for InteractWithSharedProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: InteractWithShared,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"do_some_similar_things" => ::std::result::Result::Ok(0usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_do_some_similar_things(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "InteractWithSharedProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            "MyInteraction" => ::std::result::Result::Ok(1usize),
            "SharedInteraction" => ::std::result::Result::Ok(2usize),
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            1usize => {
                let handler = self.handle_createMyInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::interact_with_shared::MyInteractionProcessor::<P, ::std::boxed::Box<dyn MyInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            2usize => {
                let handler = self.handle_createshared.SharedInteraction()?;
                let server = ::std::sync::Arc::new(crate::server::interact_with_shared::SharedInteractionProcessor::<P, ::std::boxed::Box<dyn SharedInteraction>, R, RS>::new(handler));
                ::std::result::Result::Ok(server)
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "InteractWithSharedProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for InteractWithSharedProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: InteractWithShared,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "InteractWithShared"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.InteractWithShared:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "do_some_similar_things",
              starts_interaction: false,
              interaction_name: None,
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "MyInteraction.frobnicate",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_NO_RESPONSE,
              name: "MyInteraction.ping",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
              name: "MyInteraction.truthify",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINK,
              name: "MyInteraction.encode",
              starts_interaction: false,
              interaction_name: Some("MyInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SharedInteraction.init",
              starts_interaction: false,
              interaction_name: Some("SharedInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SharedInteraction.do_something",
              starts_interaction: false,
              interaction_name: Some("SharedInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "SharedInteraction.tear_down",
              starts_interaction: false,
              interaction_name: Some("SharedInteraction"),
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a InteractWithShared service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_InteractWithShared_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: InteractWithShared,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(InteractWithSharedProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(InteractWithSharedProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "InteractWithShared.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

pub mod box_service {
    use super::*;

    
    
    
    /// Processor for BoxedInteraction's methods.
    #[derive(Clone, Debug)]
    pub struct BoxedInteractionProcessor<P, H, R, RS> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
        _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
    }
    
    impl<P, H, R, RS> BoxedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Frame: ::std::marker::Send + 'static,
        P::Deserializer: ::std::marker::Send,
        H: BoxedInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }
    
        pub fn into_inner(self) -> H {
            self.service
        }
    
        #[::tracing::instrument(skip_all, name = "handler", fields(method = "BoxedInteraction.getABox"))]
        async fn handle_getABox<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            use ::futures::FutureExt as _;
            use ::fbthrift::ExceptionInfo;
    
            const SERVICE_NAME: &::std::ffi::CStr = c"BoxService";
            const METHOD_NAME: &::std::ffi::CStr = c"BoxedInteraction.getABox";
            const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"BoxService.BoxedInteraction.getABox";
            let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
            ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
            let _args: self::Args_BoxedInteraction_getABox = ::fbthrift::Deserialize::rs_thrift_read(p)?;
            let bytes_read = ::fbthrift::help::buf_len(&req)?;
            ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
                protocol: P::PROTOCOL_ID,
                method_name: METHOD_NAME,
                buffer: req,
            })?;
            ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;
    
            let res = ::std::panic::AssertUnwindSafe(
                self.service.getABox(
                )
            )
            .catch_unwind()
            .await;
    
            // nested results - panic catch on the outside, method on the inside
            let res = match res {
                ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                    ::tracing::trace!(method = "BoxedInteraction.getABox", "success");
                    ::std::result::Result::Ok(res)
                }
                ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                    ::tracing::error!(method = "BoxedInteraction.getABox", exception = ?exn, error = exn.exn_value());
                    ::std::result::Result::Err(exn)
                }
                ::std::result::Result::Err(exn) => {
                    let aexn = ::fbthrift::ApplicationException::handler_panic("BoxedInteraction.getABox", exn);
                    ::tracing::error!(method = "BoxedInteraction.getABox", panic = ?aexn, error = aexn.exn_value());
                    ::std::result::Result::Err(crate::services::boxed_interaction::GetABoxExn::ApplicationException(aexn))
                }
            };
    
            let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::boxed_interaction::GetABoxExn>(
                "getABox",
                METHOD_NAME,
                _seqid,
                req_ctxt,
                &mut ctx_stack,
                res,
            )?;
            reply_state.send_reply(env);
            ::std::result::Result::Ok(())
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for BoxedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: BoxedInteraction,
        P::Frame: ::std::marker::Send + 'static,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        type RequestContext = R;
        type ReplyState = RS;
    
        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"BoxedInteraction.getABox" => ::std::result::Result::Ok(0usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _req: ::fbthrift::ProtocolDecoded<P>,
            _req_ctxt: &R,
            _reply_state: ::std::sync::Arc<RS>,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<()> {
            match idx {
                0usize => {
                    self.handle_getABox(_p, _req, _req_ctxt, _reply_state, _seqid).await
                }
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "BoxedInteractionProcessor",
                    bad
                ),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        #[inline]
        fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
            match name {
                _ => ::anyhow::bail!("Unknown interaction"),
            }
        }
    
        #[allow(clippy::match_single_binding)]
        fn handle_create_interaction(
            &self,
            idx: ::std::primitive::usize,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
        > {
            match idx {
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "BoxedInteractionProcessor",
                    bad
                ),
            }
        }
    
        async fn handle_on_termination(&self) {
            self.service.on_termination().await
        }
    }
    
    #[::async_trait::async_trait]
    impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for BoxedInteractionProcessor<P, H, R, RS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: BoxedInteraction,
        R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
        <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
            + ::std::marker::Send + ::std::marker::Sync + 'static,
        RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
        ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
        ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
    {
        // Interactions have () as their handler associated type
        // to make `create_interaction` have a common return type.
        type Handler = ();
        type RequestContext = R;
        type ReplyState = RS;
    
        #[tracing::instrument(level="trace", skip_all, fields(service = "BoxedInteraction"))]
        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
            reply_state: ::std::sync::Arc<RS>,
        ) -> ::anyhow::Result<()> {
            use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req.clone());
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    return self.supa.call(req, req_ctxt, reply_state).await;
                }
            };
            self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
            p.read_message_end()?;
    
            ::std::result::Result::Ok(())
        }
    
        fn create_interaction(
            &self,
            name: &::std::primitive::str,
        ) -> ::anyhow::Result<
            ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
        > {
            use ::fbthrift::{ServiceProcessor as _};
            let idx = self.create_interaction_idx(name);
            let idx = match idx {
                ::anyhow::Result::Ok(idx) => idx,
                ::anyhow::Result::Err(_) => {
                    return self.supa.create_interaction(name);
                }
            };
            self.handle_create_interaction(idx)
        }
    
        fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
            &[
                // From module.BoxedInteraction:
                // Interaction's method names are never queried directly.
                // They are always queried from the "main" processor.
            ]
        }
    
        async fn on_termination(&self) {
            use ::fbthrift::{ServiceProcessor as _};
            self.handle_on_termination().await
        }
    }
    

}

#[::async_trait::async_trait]
pub trait BoxService: ::std::marker::Send + ::std::marker::Sync + 'static {
    async fn getABoxSession(
        &self,
        _req: crate::types::ShouldBeBoxed,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn BoxedInteraction>, crate::types::ShouldBeBoxed), crate::services::box_service::GetABoxSessionExn> {
        ::std::result::Result::Err(crate::services::box_service::GetABoxSessionExn::ApplicationException(
            ::fbthrift::ApplicationException::unimplemented_method(
                "BoxService",
                "getABoxSession",
            ),
        ))
    }
}

#[::async_trait::async_trait]
impl<T> BoxService for ::std::boxed::Box<T>
where
    T: BoxService + Send + Sync + ?Sized,
{
    async fn getABoxSession(
        &self,
        req: crate::types::ShouldBeBoxed,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn BoxedInteraction>, crate::types::ShouldBeBoxed), crate::services::box_service::GetABoxSessionExn> {
        (**self).getABoxSession(
            req,
        ).await
    }
}

#[::async_trait::async_trait]
impl<T> BoxService for ::std::sync::Arc<T>
where
    T: BoxService + Send + Sync + ?Sized,
{
    async fn getABoxSession(
        &self,
        req: crate::types::ShouldBeBoxed,
    ) -> ::std::result::Result<(::std::boxed::Box<dyn BoxedInteraction>, crate::types::ShouldBeBoxed), crate::services::box_service::GetABoxSessionExn> {
        (**self).getABoxSession(
            req,
        ).await
    }
}
/// Processor for BoxService's methods.
#[derive(Clone, Debug)]
pub struct BoxServiceProcessor<P, H, R, RS> {
    service: H,
    supa: ::fbthrift::NullServiceProcessor<P, R, RS>,
    _phantom: ::std::marker::PhantomData<(P, H, R, RS)>,
}


struct Args_BoxService_getABoxSession {
    req: crate::types::ShouldBeBoxed,
}

impl<P: ::fbthrift::ProtocolReader> ::fbthrift::Deserialize<P> for self::Args_BoxService_getABoxSession {
    #[inline]
    #[::tracing::instrument(skip_all, level = "trace", name = "deserialize_args", fields(method = "BoxService.getABoxSession"))]
    fn rs_thrift_read(p: &mut P) -> ::anyhow::Result<Self> {
        static ARGS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("req", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_req = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), ARGS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_req = ::std::option::Option::Some(::anyhow::Context::context(::fbthrift::Deserialize::rs_thrift_read(p), ::fbthrift::errors::DeserializingArgError { arg: "req", function: "getABoxSession"})?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            req: field_req.ok_or_else(|| ::anyhow::anyhow!("`{}` missing arg `{}`", "BoxService.getABoxSession", "req"))?,
        })
    }
}

impl<P, H, R, RS> BoxServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Frame: ::std::marker::Send + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BoxService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    pub fn new(service: H) -> Self {
        Self {
            service,
            supa: ::fbthrift::NullServiceProcessor::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }

    pub fn into_inner(self) -> H {
        self.service
    }

    #[::tracing::instrument(skip_all, name = "handler", fields(method = "BoxService.getABoxSession"))]
    async fn handle_getABoxSession<'a>(
        &'a self,
        p: &'a mut P::Deserializer,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        use ::futures::FutureExt as _;
        use ::fbthrift::ExceptionInfo;

        const SERVICE_NAME: &::std::ffi::CStr = c"BoxService";
        const METHOD_NAME: &::std::ffi::CStr = c"getABoxSession";
        const SERVICE_METHOD_NAME: &::std::ffi::CStr = c"BoxService.getABoxSession";
        let mut ctx_stack = req_ctxt.get_context_stack(SERVICE_NAME, SERVICE_METHOD_NAME)?;
        ::fbthrift::ContextStack::pre_read(&mut ctx_stack)?;
        let _args: self::Args_BoxService_getABoxSession = ::fbthrift::Deserialize::rs_thrift_read(p)?;
        let bytes_read = ::fbthrift::help::buf_len(&req)?;
        ::fbthrift::ContextStack::on_read_data(&mut ctx_stack, ::fbthrift::SerializedMessage {
            protocol: P::PROTOCOL_ID,
            method_name: METHOD_NAME,
            buffer: req,
        })?;
        ::fbthrift::ContextStack::post_read(&mut ctx_stack, bytes_read)?;

        let res = ::std::panic::AssertUnwindSafe(
            self.service.getABoxSession(
                _args.req,
            )
        )
        .catch_unwind()
        .await;

        // nested results - panic catch on the outside, method on the inside
        let res = match res {
            ::std::result::Result::Ok(::std::result::Result::Ok(res)) => {
                ::tracing::trace!(method = "BoxService.getABoxSession", "success");
                let (interaction_handler, res) = res;
                let interaction_processor = ::std::sync::Arc::new(crate::server::box_service::BoxedInteractionProcessor::<P, ::std::boxed::Box<dyn BoxedInteraction>, R, RS>::new(interaction_handler));
                reply_state.set_interaction_processor(interaction_processor)?;
                ::std::result::Result::Ok(res)
            }
            ::std::result::Result::Ok(::std::result::Result::Err(exn)) => {
                ::tracing::error!(method = "BoxService.getABoxSession", exception = ?exn, error = exn.exn_value());
                ::std::result::Result::Err(exn)
            }
            ::std::result::Result::Err(exn) => {
                let aexn = ::fbthrift::ApplicationException::handler_panic("BoxService.getABoxSession", exn);
                ::tracing::error!(method = "BoxService.getABoxSession", panic = ?aexn, error = aexn.exn_value());
                ::std::result::Result::Err(crate::services::box_service::GetABoxSessionExn::ApplicationException(aexn))
            }
        };

        let env = ::fbthrift::help::serialize_result_envelope::<P, R, crate::services::box_service::GetABoxSessionExn>(
            "getABoxSession",
            METHOD_NAME,
            _seqid,
            req_ctxt,
            &mut ctx_stack,
            res,
        )?;
        reply_state.send_reply(env);
        ::std::result::Result::Ok(())
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ServiceProcessor<P> for BoxServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    H: BoxService,
    P::Frame: ::std::marker::Send + 'static,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type RequestContext = R;
    type ReplyState = RS;

    #[inline]
    fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
        match name {
            b"getABoxSession" => ::std::result::Result::Ok(0usize),
            _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
        }
    }

    #[allow(clippy::match_single_binding)]
    async fn handle_method(
        &self,
        idx: ::std::primitive::usize,
        _p: &mut P::Deserializer,
        _req: ::fbthrift::ProtocolDecoded<P>,
        _req_ctxt: &R,
        _reply_state: ::std::sync::Arc<RS>,
        _seqid: ::std::primitive::u32,
    ) -> ::anyhow::Result<()> {
        match idx {
            0usize => {
                self.handle_getABoxSession(_p, _req, _req_ctxt, _reply_state, _seqid).await
            }
            bad => panic!(
                "{}: unexpected method idx {}",
                "BoxServiceProcessor",
                bad
            ),
        }
    }

    #[allow(clippy::match_single_binding)]
    #[inline]
    fn create_interaction_idx(&self, name: &::std::primitive::str) -> ::anyhow::Result<::std::primitive::usize> {
        match name {
            _ => ::anyhow::bail!("Unknown interaction"),
        }
    }

    #[allow(clippy::match_single_binding)]
    fn handle_create_interaction(
        &self,
        idx: ::std::primitive::usize,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = Self::RequestContext, ReplyState = Self::ReplyState> + ::std::marker::Send + 'static>
    > {
        match idx {
            bad => panic!(
                "{}: unexpected method idx {}",
                "BoxServiceProcessor",
                bad
            ),
        }
    }

    async fn handle_on_termination(&self) {
    }
}

#[::async_trait::async_trait]
impl<P, H, R, RS> ::fbthrift::ThriftService<P::Frame> for BoxServiceProcessor<P, H, R, RS>
where
    P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
    P::Deserializer: ::std::marker::Send,
    P::Frame: ::std::marker::Send + 'static,
    H: BoxService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = <P as ::fbthrift::Protocol>::Frame>
        + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<P::Frame, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::ProtocolDecoded<P>: ::std::clone::Clone,
    ::fbthrift::ProtocolEncodedFinal<P>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    type Handler = H;
    type RequestContext = R;
    type ReplyState = RS;

    #[tracing::instrument(level="trace", skip_all, fields(service = "BoxService"))]
    async fn call(
        &self,
        req: ::fbthrift::ProtocolDecoded<P>,
        req_ctxt: &R,
        reply_state: ::std::sync::Arc<RS>,
    ) -> ::anyhow::Result<()> {
        use ::fbthrift::{ProtocolReader as _, ServiceProcessor as _};
        let mut p = P::deserializer(req.clone());
        let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
        if mty != ::fbthrift::MessageType::Call {
            return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                format!("message type {:?} not handled", mty)
            )));
        }
        let idx = match idx {
            ::std::result::Result::Ok(idx) => idx,
            ::std::result::Result::Err(_) => {
                return self.supa.call(req, req_ctxt, reply_state).await;
            }
        };
        self.handle_method(idx, &mut p, req, req_ctxt, reply_state, seqid).await?;
        p.read_message_end()?;

        ::std::result::Result::Ok(())
    }

    fn create_interaction(
        &self,
        name: &::std::primitive::str,
    ) -> ::anyhow::Result<
        ::std::sync::Arc<dyn ::fbthrift::ThriftService<P::Frame, Handler = (), RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>
    > {
        use ::fbthrift::{ServiceProcessor as _};
        let idx = self.create_interaction_idx(name);
        let idx = match idx {
            ::anyhow::Result::Ok(idx) => idx,
            ::anyhow::Result::Err(_) => {
                return self.supa.create_interaction(name);
            }
        };
        self.handle_create_interaction(idx)
    }

    fn get_method_metadata(&self) -> &'static [::fbthrift::processor::MethodMetadata] {
        &[
            // From module.BoxService:
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::None,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "getABoxSession",
              starts_interaction: true,
              interaction_name: Some("BoxedInteraction"),
            },
            ::fbthrift::processor::MethodMetadata{
              interaction_type: ::fbthrift::processor::InteractionType::InteractionV1,
              rpc_kind: ::fbthrift::processor::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
              name: "BoxedInteraction.getABox",
              starts_interaction: false,
              interaction_name: Some("BoxedInteraction"),
            },
        ]
    }

    async fn on_termination(&self) {
        use ::fbthrift::{ServiceProcessor as _};
        self.handle_on_termination().await
    }
}

/// Construct a new instance of a BoxService service.
///
/// This is called when a new instance of a Thrift service Processor
/// is needed for a particular Thrift protocol.
#[::tracing::instrument(level="debug", skip_all, fields(proto = ?proto))]
pub fn make_BoxService_server<F, H, R, RS>(
    proto: ::fbthrift::ProtocolID,
    handler: H,
) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R, ReplyState = RS> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
where
    F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
    H: BoxService,
    R: ::fbthrift::RequestContext<Name = ::std::ffi::CStr> + ::std::marker::Send + ::std::marker::Sync + 'static,
    <R as ::fbthrift::RequestContext>::ContextStack: ::fbthrift::ContextStack<Name = R::Name, Frame = F> + ::std::marker::Send + ::std::marker::Sync + 'static,
    RS: ::fbthrift::ReplyState<F, RequestContext = R> + ::std::marker::Send + ::std::marker::Sync + 'static,
    ::fbthrift::FramingDecoded<F>: ::std::clone::Clone,
    ::fbthrift::FramingEncodedFinal<F>: ::std::clone::Clone + ::fbthrift::BufExt,
{
    match proto {
        ::fbthrift::ProtocolID::BinaryProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(BoxServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, RS>::new(handler)))
        }
        ::fbthrift::ProtocolID::CompactProtocol => {
            ::std::result::Result::Ok(::std::boxed::Box::new(BoxServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, RS>::new(handler)))
        }
        bad => {
            ::tracing::error!(method = "BoxService.", invalid_protocol = ?bad);
            ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad))
        }
    }
}

