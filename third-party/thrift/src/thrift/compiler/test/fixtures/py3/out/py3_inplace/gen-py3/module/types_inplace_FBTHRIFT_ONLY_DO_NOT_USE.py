#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/py3/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib
from builtins import property as _python__property

import typing as _typing
import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
from thrift.py3.types import (
    _fbthrift__round_float32,
    _fbthrift__is_float32,
    _fbthrift__filter_kwargs,
)
import thrift.py3.exceptions
import thrift.python.exceptions
import thrift.python.types
import module.thrift_types as _fbthrift_python_types
import module.thrift_enums as _fbthrift_python_enums



def get_types_reflection():
    return importlib.import_module(
        "module.types_reflection"
    )

def _get_py_deprecated_module():
    import thrift.util.converter # needed by _to_py_deprecated() call
    return importlib.import_module("module.ttypes")

_fbthrift__module_name__ = "module.types"

__all__ = []

### Enums ###

AnEnum = _fbthrift_python_enums.AnEnum

__all__.append("AnEnum")


AnEnumRenamed = _fbthrift_python_enums.AnEnumRenamed

__all__.append("AnEnumRenamed")


Flags = _fbthrift_python_enums.Flags

__all__.append("Flags")


### Union Enums ###

class __BinaryUnionType(enum.Enum):
    iobuf_val = 1
    EMPTY = 0

    __module__ = _fbthrift__module_name__
    __slots__ = ()

_fbthrift__BinaryUnionType = __BinaryUnionType

__all__.append("__BinaryUnionType")


### Containers ###
class List__i16(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i16):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i16._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i16)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i16()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i16:
        _items = list(python_list)
        return List__i16(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i16)


__all__.append("List__i16")

class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i32:
        _items = list(python_list)
        return List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i32)


__all__.append("List__i32")

class List__i64(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i64):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i64._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i64()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i64:
        _items = list(python_list)
        return List__i64(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i64)


__all__.append("List__i64")

class List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[str] field, explicitly convert it first.")
            check_method = List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__string:
        _items = list(python_list)
        return List__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__string)


__all__.append("List__string")

class List__SimpleStruct(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__SimpleStruct):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__SimpleStruct._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__SimpleStruct)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, SimpleStruct)
        ):
            raise TypeError(f"{item!r} is not of type SimpleStruct")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, SimpleStruct):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__SimpleStruct()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__SimpleStruct:
        _items = [
            SimpleStruct.from_python(item)
            for item in python_list
        ]
        return List__SimpleStruct(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__SimpleStruct)


__all__.append("List__SimpleStruct")

class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__i32:
        _items = frozenset(python_set)
        return Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__i32)


__all__.append("Set__i32")

class Set__string(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__string):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[str] field, explicitly convert it first.")
            check_method = Set__string._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, str):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__string()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__string:
        _items = frozenset(python_set)
        return Set__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__string)


__all__.append("Set__string")

class Map__string_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_string._check_key_type_or_raise
            check_val = Map__string_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_string)

__all__.append("Map__string_string")

class Map__string_SimpleStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_SimpleStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_SimpleStruct._check_key_type_or_raise
            check_val = Map__string_SimpleStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_SimpleStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, SimpleStruct)
        ):
            raise TypeError(f"{item!r} is not of type SimpleStruct")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_SimpleStruct()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_SimpleStruct:
        _keys = python_map.keys()
        _values = (
            SimpleStruct.from_python(item)
            for item in python_map.values()
        )
        return Map__string_SimpleStruct(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_SimpleStruct)

__all__.append("Map__string_SimpleStruct")

class Map__string_i16(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i16):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i16._check_key_type_or_raise
            check_val = Map__string_i16._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i16)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i16()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_i16:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_i16(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_i16)

__all__.append("Map__string_i16")

class List__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[int]")
        if not isinstance(item, List__i32):
            item = List__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, List__i32):
            return item
        try:
            return List__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__List__i32:
        _items = [
            List__i32.from_python(item)
            for item in python_list
        ]
        return List__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__List__i32)


__all__.append("List__List__i32")

class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_i32)

__all__.append("Map__string_i32")

class Map__string_Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_Map__string_i32._check_key_type_or_raise
            check_val = Map__string_Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, int]")
        if not isinstance(item, Map__string_i32):
            item = Map__string_i32(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_Map__string_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_Map__string_i32:
        _keys = python_map.keys()
        _values = (
            Map__string_i32.from_python(item)
            for item in python_map.values()
        )
        return Map__string_Map__string_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_Map__string_i32)

__all__.append("Map__string_Map__string_i32")

class List__Set__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[str]")
        if not isinstance(item, Set__string):
            item = Set__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Set__string):
            return item
        try:
            return Set__string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Set__string:
        _items = [
            Set__string.from_python(item)
            for item in python_list
        ]
        return List__Set__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Set__string)


__all__.append("List__Set__string")

class Map__string_List__SimpleStruct(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_List__SimpleStruct):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_List__SimpleStruct._check_key_type_or_raise
            check_val = Map__string_List__SimpleStruct._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_List__SimpleStruct)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[SimpleStruct]")
        if not isinstance(item, List__SimpleStruct):
            item = List__SimpleStruct(item)
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_List__SimpleStruct()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_List__SimpleStruct:
        _keys = python_map.keys()
        _values = (
            List__SimpleStruct.from_python(item)
            for item in python_map.values()
        )
        return Map__string_List__SimpleStruct(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_List__SimpleStruct)

__all__.append("Map__string_List__SimpleStruct")

class List__List__string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__List__string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__List__string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__List__string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Sequence[str]")
        if not isinstance(item, List__string):
            item = List__string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, List__string):
            return item
        try:
            return List__string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__List__string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__List__string:
        _items = [
            List__string.from_python(item)
            for item in python_list
        ]
        return List__List__string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__List__string)


__all__.append("List__List__string")

class List__Set__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Set__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Set__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.AbstractSet[int]")
        if not isinstance(item, Set__i32):
            item = Set__i32(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Set__i32):
            return item
        try:
            return Set__i32(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Set__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Set__i32:
        _items = [
            Set__i32.from_python(item)
            for item in python_list
        ]
        return List__Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Set__i32)


__all__.append("List__Set__i32")

class List__Map__string_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__string_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__string_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__string_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[str, str]")
        if not isinstance(item, Map__string_string):
            item = Map__string_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Map__string_string):
            return item
        try:
            return Map__string_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__string_string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Map__string_string:
        _items = [
            Map__string_string.from_python(item)
            for item in python_list
        ]
        return List__Map__string_string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Map__string_string)


__all__.append("List__Map__string_string")

class List__binary(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__binary):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.Sequence[bytes] field, explicitly convert it first.")
            check_method = List__binary._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__binary)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bytes)
        ):
            raise TypeError(f"{item!r} is not of type bytes")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bytes):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__binary()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__binary:
        _items = list(python_list)
        return List__binary(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__binary)


__all__.append("List__binary")

class Set__binary(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__binary):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            if isinstance(items, str):
                raise TypeError("If you really want to pass a string into a _typing.AbstractSet[bytes] field, explicitly convert it first.")
            check_method = Set__binary._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__binary)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, bytes)
        ):
            raise TypeError(f"{item!r} is not of type bytes")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, bytes):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__binary()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__binary:
        _items = frozenset(python_set)
        return Set__binary(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__binary)


__all__.append("Set__binary")

class List__AnEnum(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__AnEnum):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__AnEnum._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__AnEnum)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, AnEnum) or
            isinstance(item, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{item!r} is not of type AnEnum")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, AnEnum):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__AnEnum()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__AnEnum:
        _items = list(python_list)
        return List__AnEnum(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__AnEnum)


__all__.append("List__AnEnum")

class _std_unordered_map__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _std_unordered_map__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _std_unordered_map__Map__i32_i32._check_key_type_or_raise
            check_val = _std_unordered_map__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _std_unordered_map__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___std_unordered_map__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> _std_unordered_map__Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return _std_unordered_map__Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(_std_unordered_map__Map__i32_i32)

__all__.append("_std_unordered_map__Map__i32_i32")

class _MyType__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _MyType__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _MyType__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> _MyType__List__i32:
        _items = list(python_list)
        return _MyType__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(_MyType__List__i32)


__all__.append("_MyType__List__i32")

class _MyType__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = _MyType__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, _MyType__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> _MyType__Set__i32:
        _items = frozenset(python_set)
        return _MyType__Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(_MyType__Set__i32)


__all__.append("_MyType__Set__i32")

class _MyType__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _MyType__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _MyType__Map__i32_i32._check_key_type_or_raise
            check_val = _MyType__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _MyType__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___MyType__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> _MyType__Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return _MyType__Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(_MyType__Map__i32_i32)

__all__.append("_MyType__Map__i32_i32")

class _py3_simple_AdaptedList__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedList__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _py3_simple_AdaptedList__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _py3_simple_AdaptedList__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedList__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> _py3_simple_AdaptedList__List__i32:
        _items = list(python_list)
        return _py3_simple_AdaptedList__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(_py3_simple_AdaptedList__List__i32)


__all__.append("_py3_simple_AdaptedList__List__i32")

class _py3_simple_AdaptedSet__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedSet__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = _py3_simple_AdaptedSet__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, _py3_simple_AdaptedSet__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedSet__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> _py3_simple_AdaptedSet__Set__i32:
        _items = frozenset(python_set)
        return _py3_simple_AdaptedSet__Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(_py3_simple_AdaptedSet__Set__i32)


__all__.append("_py3_simple_AdaptedSet__Set__i32")

class _py3_simple_AdaptedMap__Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, _py3_simple_AdaptedMap__Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = _py3_simple_AdaptedMap__Map__i32_i32._check_key_type_or_raise
            check_val = _py3_simple_AdaptedMap__Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, _py3_simple_AdaptedMap__Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___py3_simple_AdaptedMap__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> _py3_simple_AdaptedMap__Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return _py3_simple_AdaptedMap__Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(_py3_simple_AdaptedMap__Map__i32_i32)

__all__.append("_py3_simple_AdaptedMap__Map__i32_i32")

class Map__i32_double(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_double):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_double._check_key_type_or_raise
            check_val = Map__i32_double._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_double)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, (float, int))
        ):
            raise TypeError(f"{item!r} is not of type float")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_double()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_double:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_double(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_double)

__all__.append("Map__i32_double")

class List__Map__i32_double(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__Map__i32_double):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__Map__i32_double._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__Map__i32_double)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, float]")
        if not isinstance(item, Map__i32_double):
            item = Map__i32_double(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, Map__i32_double):
            return item
        try:
            return Map__i32_double(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__Map__i32_double()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__Map__i32_double:
        _items = [
            Map__i32_double.from_python(item)
            for item in python_list
        ]
        return List__Map__i32_double(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__Map__i32_double)


__all__.append("List__Map__i32_double")

class Map__AnEnumRenamed_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__AnEnumRenamed_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__AnEnumRenamed_i32._check_key_type_or_raise
            check_val = Map__AnEnumRenamed_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__AnEnumRenamed_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, AnEnumRenamed) or
            isinstance(key, thrift.py3.types.BadEnum)
        ):
            raise TypeError(f"{key!r} is not of type AnEnumRenamed")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, AnEnumRenamed):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__AnEnumRenamed_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__AnEnumRenamed_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__AnEnumRenamed_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__AnEnumRenamed_i32)

__all__.append("Map__AnEnumRenamed_i32")


### Structured Types ###
class SimpleException(thrift.py3.exceptions.GeneratedError):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.SimpleException
    _FBTHRIFT__FIELD_NAMES = (
        "err_code",
    )
    _fbthrift__inner : _fbthrift_python_types.SimpleException


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.SimpleException(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.SimpleException(*args, **kwargs)

        super(thrift.python.exceptions.Error, self).__init__(*(val for _, val in self))

    def __new__(_fbthrift__cls, *args, **kwargs) -> SimpleException:
        instance = super().__new__(_fbthrift__cls)
        return instance

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.SimpleException) -> SimpleException:
        inst = SimpleException.__new__(SimpleException)
        inst._fbthrift__inner = thrift_python_inner
        super(thrift.python.exceptions.Error, inst).__init__(*(val for _, val in inst))
        return inst

    def _to_py3(self) -> SimpleException:
        return self

    def _to_python(self) -> _fbthrift_python_types.SimpleException:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.SimpleException, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__SimpleException()

    @staticmethod
    def __get_metadata__():
        return SimpleException._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.SimpleException"

    @_python__property
    def err_code(self) -> int:
        return self._fbthrift__inner.err_code


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, SimpleException):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, SimpleException):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __str__(self):
        return super().__str__()

    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("SimpleException")

class OptionalRefStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.OptionalRefStruct
    _FBTHRIFT__FIELD_NAMES = (
        "optional_blob",
    )
    _fbthrift__inner : _fbthrift_python_types.OptionalRefStruct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.OptionalRefStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.OptionalRefStruct(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> OptionalRefStruct:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> OptionalRefStruct:
        return OptionalRefStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.OptionalRefStruct) -> OptionalRefStruct:
        inst = OptionalRefStruct.__new__(OptionalRefStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> OptionalRefStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.OptionalRefStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.OptionalRefStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__OptionalRefStruct()

    @staticmethod
    def __get_metadata__():
        return OptionalRefStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.OptionalRefStruct"

    @_python__property
    def optional_blob(self) -> _typing.Optional[_fbthrift_iobuf.IOBuf]:
        return self._fbthrift__inner.optional_blob


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, OptionalRefStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, OptionalRefStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("OptionalRefStruct")

class SimpleStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__smaller_real",
        "_fbthrift_inner__something",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.SimpleStruct
    _FBTHRIFT__FIELD_NAMES = (
        "is_on",
        "tiny_int",
        "small_int",
        "nice_sized_int",
        "big_int",
        "real",
        "smaller_real",
        "something",
        "opt_default_int",
        "opt_default_str",
        "opt_default_enum",
    )
    _fbthrift__inner : _fbthrift_python_types.SimpleStruct
    _fbthrift_inner__smaller_real : float | None
    _fbthrift_inner__something : _typing.Mapping[int, int] | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.SimpleStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.SimpleStruct(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> SimpleStruct:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__smaller_real = None
        instance._fbthrift_inner__something = None
        return instance

    def __call__(self, **kwargs) -> SimpleStruct:
        return SimpleStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.SimpleStruct) -> SimpleStruct:
        inst = SimpleStruct.__new__(SimpleStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> SimpleStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.SimpleStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.SimpleStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__SimpleStruct()

    @staticmethod
    def __get_metadata__():
        return SimpleStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.SimpleStruct"

    @_python__property
    def is_on(self) -> bool:
        return self._fbthrift__inner.is_on

    @_python__property
    def tiny_int(self) -> int:
        return self._fbthrift__inner.tiny_int

    @_python__property
    def small_int(self) -> int:
        return self._fbthrift__inner.small_int

    @_python__property
    def nice_sized_int(self) -> int:
        return self._fbthrift__inner.nice_sized_int

    @_python__property
    def big_int(self) -> int:
        return self._fbthrift__inner.big_int

    @_python__property
    def real(self) -> float:
        return self._fbthrift__inner.real

    @_python__property
    def smaller_real(self) -> float:
        if self._fbthrift_inner__smaller_real is None:
            __python_val = self._fbthrift__inner.smaller_real
            self._fbthrift_inner__smaller_real = _fbthrift__round_float32(__python_val)

        return self._fbthrift_inner__smaller_real

    @_python__property
    def something(self) -> _typing.Mapping[int, int]:
        if self._fbthrift_inner__something is None:
            __python_val = self._fbthrift__inner.something
            self._fbthrift_inner__something = _std_unordered_map__Map__i32_i32.from_python(__python_val)

        return self._fbthrift_inner__something

    @_python__property
    def opt_default_int(self) -> int:
        __python_val = self._fbthrift__inner.opt_default_int
        if __python_val is None:
            return 2
        return __python_val

    @_python__property
    def opt_default_str(self) -> str:
        __python_val = self._fbthrift__inner.opt_default_str
        if __python_val is None:
            return "2"
        return __python_val

    @_python__property
    def opt_default_enum(self) -> AnEnum:
        __python_val = self._fbthrift__inner.opt_default_enum
        if __python_val is None:
            return AnEnum.THREE
        return __python_val


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 11

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("SimpleStruct")

class HiddenTypeFieldsStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.HiddenTypeFieldsStruct
    _FBTHRIFT__FIELD_NAMES = (
    )
    _fbthrift__inner : _fbthrift_python_types.HiddenTypeFieldsStruct


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.HiddenTypeFieldsStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.HiddenTypeFieldsStruct(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> HiddenTypeFieldsStruct:
        instance = super().__new__(_fbthrift__cls)
        return instance

    def __call__(self, **kwargs) -> HiddenTypeFieldsStruct:
        return HiddenTypeFieldsStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.HiddenTypeFieldsStruct) -> HiddenTypeFieldsStruct:
        inst = HiddenTypeFieldsStruct.__new__(HiddenTypeFieldsStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> HiddenTypeFieldsStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.HiddenTypeFieldsStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.HiddenTypeFieldsStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__HiddenTypeFieldsStruct()

    @staticmethod
    def __get_metadata__():
        return HiddenTypeFieldsStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.HiddenTypeFieldsStruct"


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 0

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("HiddenTypeFieldsStruct")

class ComplexStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__structOne",
        "_fbthrift_inner__structTwo",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.ComplexStruct
    _FBTHRIFT__FIELD_NAMES = (
        "structOne",
        "structTwo",
        "an_integer",
        "name",
        "an_enum",
        "some_bytes",
        "sender",
        "cdef_",
        "bytes_with_cpp_type",
    )
    _fbthrift__inner : _fbthrift_python_types.ComplexStruct
    _fbthrift_inner__structOne : SimpleStruct | None
    _fbthrift_inner__structTwo : SimpleStruct | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.ComplexStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.ComplexStruct(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> ComplexStruct:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__structOne = None
        instance._fbthrift_inner__structTwo = None
        return instance

    def __call__(self, **kwargs) -> ComplexStruct:
        return ComplexStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.ComplexStruct) -> ComplexStruct:
        inst = ComplexStruct.__new__(ComplexStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> ComplexStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.ComplexStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.ComplexStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__ComplexStruct()

    @staticmethod
    def __get_metadata__():
        return ComplexStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.ComplexStruct"

    @_python__property
    def structOne(self) -> SimpleStruct:
        if self._fbthrift_inner__structOne is None:
            __python_val = self._fbthrift__inner.structOne
            self._fbthrift_inner__structOne = SimpleStruct.from_python(__python_val)

        return self._fbthrift_inner__structOne

    @_python__property
    def structTwo(self) -> SimpleStruct:
        if self._fbthrift_inner__structTwo is None:
            __python_val = self._fbthrift__inner.structTwo
            self._fbthrift_inner__structTwo = SimpleStruct.from_python(__python_val)

        return self._fbthrift_inner__structTwo

    @_python__property
    def an_integer(self) -> int:
        return self._fbthrift__inner.an_integer

    @_python__property
    def name(self) -> str:
        return self._fbthrift__inner.name

    @_python__property
    def an_enum(self) -> AnEnum:
        return self._fbthrift__inner.an_enum

    @_python__property
    def some_bytes(self) -> bytes:
        return self._fbthrift__inner.some_bytes

    @_python__property
    def sender(self) -> str:
        return self._fbthrift__inner.sender

    @_python__property
    def cdef_(self) -> str:
        return self._fbthrift__inner.cdef_

    @_python__property
    def bytes_with_cpp_type(self) -> bytes:
        return self._fbthrift__inner.bytes_with_cpp_type


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 9

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("ComplexStruct")

class BinaryUnion(thrift.py3.types.Union):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__type",
        "_fbthrift_inner__value",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.BinaryUnion
    _FBTHRIFT__FIELD_NAMES = (
        "iobuf_val",
    )
    Type = _fbthrift__BinaryUnionType
    _fbthrift__inner : _fbthrift_python_types.BinaryUnion
    _fbthrift_inner__type: Type
    _fbthrift_inner__value: _fbthrift_iobuf.IOBuf | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.BinaryUnion(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.BinaryUnion(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> BinaryUnion:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__type = None
        instance._fbthrift_inner__value = None
        return instance

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.BinaryUnion) -> BinaryUnion:
        inst = BinaryUnion.__new__(BinaryUnion)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> BinaryUnion:
        return self

    def _to_python(self) -> _fbthrift_python_types.BinaryUnion:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.BinaryUnion, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__BinaryUnion()

    @staticmethod
    def __get_metadata__():
        return BinaryUnion._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.BinaryUnion"

    @_python__property
    def iobuf_val(self) -> _fbthrift_iobuf.IOBuf:
        return self._fbthrift__inner.iobuf_val

    @_python__property
    def type(self) -> _fbthrift_python_types.BinaryUnion.Type:
        if self._fbthrift_inner__type is None:
            self._fbthrift_inner__type = self.Type(self._fbthrift__inner.type.value)
        return self._fbthrift_inner__type

    @_python__property
    def value(self) -> _fbthrift_iobuf.IOBuf | None:
        match self._fbthrift__inner.type:
            case _:
                return self._fbthrift__inner.value


    @staticmethod
    def fromValue(value) -> BinaryUnion:
        if value is None:
            return BinaryUnion()
        if isinstance(value, _fbthrift_iobuf.IOBuf):
            return BinaryUnion(iobuf_val=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        return self.type == other.type and self.value == other.value


    def __lt__(self, other):
        if not isinstance(other, BinaryUnion):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, BinaryUnion):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("BinaryUnion")

class BinaryUnionStruct(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__u",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.BinaryUnionStruct
    _FBTHRIFT__FIELD_NAMES = (
        "u",
    )
    _fbthrift__inner : _fbthrift_python_types.BinaryUnionStruct
    _fbthrift_inner__u : BinaryUnion | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.BinaryUnionStruct(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.BinaryUnionStruct(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> BinaryUnionStruct:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__u = None
        return instance

    def __call__(self, **kwargs) -> BinaryUnionStruct:
        return BinaryUnionStruct.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.BinaryUnionStruct) -> BinaryUnionStruct:
        inst = BinaryUnionStruct.__new__(BinaryUnionStruct)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> BinaryUnionStruct:
        return self

    def _to_python(self) -> _fbthrift_python_types.BinaryUnionStruct:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.BinaryUnionStruct, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__BinaryUnionStruct()

    @staticmethod
    def __get_metadata__():
        return BinaryUnionStruct._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.BinaryUnionStruct"

    @_python__property
    def u(self) -> BinaryUnion:
        if self._fbthrift_inner__u is None:
            __python_val = self._fbthrift__inner.u
            self._fbthrift_inner__u = BinaryUnion.from_python(__python_val)

        return self._fbthrift_inner__u


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 1

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True


    def __lt__(self, other):
        if not isinstance(other, BinaryUnionStruct):
            return NotImplemented
        return self._fbthrift__inner < other._fbthrift__inner

    def __le__(self, other):
        if not isinstance(other, BinaryUnionStruct):
            return NotImplemented
        return self._fbthrift__inner <= other._fbthrift__inner


    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("BinaryUnionStruct")

class CustomFields(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__list_field",
        "_fbthrift_inner__set_field",
        "_fbthrift_inner__map_field",
        "_fbthrift_inner__struct_field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CustomFields
    _FBTHRIFT__FIELD_NAMES = (
        "bool_field",
        "integer_field",
        "double_field",
        "string_field",
        "binary_field",
        "list_field",
        "set_field",
        "map_field",
        "struct_field",
    )
    _fbthrift__inner : _fbthrift_python_types.CustomFields
    _fbthrift_inner__list_field : _typing.Sequence[int] | None
    _fbthrift_inner__set_field : _typing.AbstractSet[int] | None
    _fbthrift_inner__map_field : _typing.Mapping[int, int] | None
    _fbthrift_inner__struct_field : SimpleStruct | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CustomFields(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CustomFields(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> CustomFields:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__list_field = None
        instance._fbthrift_inner__set_field = None
        instance._fbthrift_inner__map_field = None
        instance._fbthrift_inner__struct_field = None
        return instance

    def __call__(self, **kwargs) -> CustomFields:
        return CustomFields.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CustomFields) -> CustomFields:
        inst = CustomFields.__new__(CustomFields)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CustomFields:
        return self

    def _to_python(self) -> _fbthrift_python_types.CustomFields:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CustomFields, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CustomFields()

    @staticmethod
    def __get_metadata__():
        return CustomFields._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CustomFields"

    @_python__property
    def bool_field(self) -> bool:
        return self._fbthrift__inner.bool_field

    @_python__property
    def integer_field(self) -> int:
        return self._fbthrift__inner.integer_field

    @_python__property
    def double_field(self) -> float:
        return self._fbthrift__inner.double_field

    @_python__property
    def string_field(self) -> str:
        return self._fbthrift__inner.string_field

    @_python__property
    def binary_field(self) -> bytes:
        return self._fbthrift__inner.binary_field

    @_python__property
    def list_field(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__list_field is None:
            __python_val = self._fbthrift__inner.list_field
            self._fbthrift_inner__list_field = _MyType__List__i32.from_python(__python_val)

        return self._fbthrift_inner__list_field

    @_python__property
    def set_field(self) -> _typing.AbstractSet[int]:
        if self._fbthrift_inner__set_field is None:
            __python_val = self._fbthrift__inner.set_field
            self._fbthrift_inner__set_field = _MyType__Set__i32.from_python(__python_val)

        return self._fbthrift_inner__set_field

    @_python__property
    def map_field(self) -> _typing.Mapping[int, int]:
        if self._fbthrift_inner__map_field is None:
            __python_val = self._fbthrift__inner.map_field
            self._fbthrift_inner__map_field = _MyType__Map__i32_i32.from_python(__python_val)

        return self._fbthrift_inner__map_field

    @_python__property
    def struct_field(self) -> SimpleStruct:
        if self._fbthrift_inner__struct_field is None:
            __python_val = self._fbthrift__inner.struct_field
            self._fbthrift_inner__struct_field = SimpleStruct.from_python(__python_val)

        return self._fbthrift_inner__struct_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 9

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CustomFields")

class CustomTypedefFields(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__list_field",
        "_fbthrift_inner__set_field",
        "_fbthrift_inner__map_field",
        "_fbthrift_inner__struct_field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.CustomTypedefFields
    _FBTHRIFT__FIELD_NAMES = (
        "bool_field",
        "integer_field",
        "double_field",
        "string_field",
        "binary_field",
        "list_field",
        "set_field",
        "map_field",
        "struct_field",
    )
    _fbthrift__inner : _fbthrift_python_types.CustomTypedefFields
    _fbthrift_inner__list_field : _typing.Sequence[int] | None
    _fbthrift_inner__set_field : _typing.AbstractSet[int] | None
    _fbthrift_inner__map_field : _typing.Mapping[int, int] | None
    _fbthrift_inner__struct_field : SimpleStruct | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.CustomTypedefFields(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.CustomTypedefFields(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> CustomTypedefFields:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__list_field = None
        instance._fbthrift_inner__set_field = None
        instance._fbthrift_inner__map_field = None
        instance._fbthrift_inner__struct_field = None
        return instance

    def __call__(self, **kwargs) -> CustomTypedefFields:
        return CustomTypedefFields.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.CustomTypedefFields) -> CustomTypedefFields:
        inst = CustomTypedefFields.__new__(CustomTypedefFields)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> CustomTypedefFields:
        return self

    def _to_python(self) -> _fbthrift_python_types.CustomTypedefFields:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.CustomTypedefFields, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__CustomTypedefFields()

    @staticmethod
    def __get_metadata__():
        return CustomTypedefFields._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.CustomTypedefFields"

    @_python__property
    def bool_field(self) -> bool:
        return self._fbthrift__inner.bool_field

    @_python__property
    def integer_field(self) -> int:
        return self._fbthrift__inner.integer_field

    @_python__property
    def double_field(self) -> float:
        return self._fbthrift__inner.double_field

    @_python__property
    def string_field(self) -> str:
        return self._fbthrift__inner.string_field

    @_python__property
    def binary_field(self) -> bytes:
        return self._fbthrift__inner.binary_field

    @_python__property
    def list_field(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__list_field is None:
            __python_val = self._fbthrift__inner.list_field
            self._fbthrift_inner__list_field = _MyType__List__i32.from_python(__python_val)

        return self._fbthrift_inner__list_field

    @_python__property
    def set_field(self) -> _typing.AbstractSet[int]:
        if self._fbthrift_inner__set_field is None:
            __python_val = self._fbthrift__inner.set_field
            self._fbthrift_inner__set_field = _MyType__Set__i32.from_python(__python_val)

        return self._fbthrift_inner__set_field

    @_python__property
    def map_field(self) -> _typing.Mapping[int, int]:
        if self._fbthrift_inner__map_field is None:
            __python_val = self._fbthrift__inner.map_field
            self._fbthrift_inner__map_field = _MyType__Map__i32_i32.from_python(__python_val)

        return self._fbthrift_inner__map_field

    @_python__property
    def struct_field(self) -> SimpleStruct:
        if self._fbthrift_inner__struct_field is None:
            __python_val = self._fbthrift__inner.struct_field
            self._fbthrift_inner__struct_field = SimpleStruct.from_python(__python_val)

        return self._fbthrift_inner__struct_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 9

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("CustomTypedefFields")

class AdaptedTypedefFields(thrift.py3.types.Struct):
    __module__ = _fbthrift__module_name__
    __slots__ = (
        "_fbthrift__inner",
        "_fbthrift_inner__list_field",
        "_fbthrift_inner__set_field",
        "_fbthrift_inner__map_field",
        "_fbthrift_inner__struct_field",
    )
    _FBTHRIFT__PYTHON_CLASS = _fbthrift_python_types.AdaptedTypedefFields
    _FBTHRIFT__FIELD_NAMES = (
        "bool_field",
        "integer_field",
        "double_field",
        "string_field",
        "binary_field",
        "list_field",
        "set_field",
        "map_field",
        "struct_field",
    )
    _fbthrift__inner : _fbthrift_python_types.AdaptedTypedefFields
    _fbthrift_inner__list_field : _typing.Sequence[int] | None
    _fbthrift_inner__set_field : _typing.AbstractSet[int] | None
    _fbthrift_inner__map_field : _typing.Mapping[int, int] | None
    _fbthrift_inner__struct_field : SimpleStruct | None


    def __init__(self, *args, **kwargs) -> None:
        try:
            self._fbthrift__inner = _fbthrift_python_types.AdaptedTypedefFields(*args, **kwargs)
        except TypeError:
            kwargs = _fbthrift__filter_kwargs(kwargs, self._FBTHRIFT__FIELD_NAMES)
            self._fbthrift__inner = _fbthrift_python_types.AdaptedTypedefFields(*args, **kwargs)


    def __new__(_fbthrift__cls, *args, **kwargs) -> AdaptedTypedefFields:
        instance = super().__new__(_fbthrift__cls)
        instance._fbthrift_inner__list_field = None
        instance._fbthrift_inner__set_field = None
        instance._fbthrift_inner__map_field = None
        instance._fbthrift_inner__struct_field = None
        return instance

    def __call__(self, **kwargs) -> AdaptedTypedefFields:
        return AdaptedTypedefFields.from_python(self._fbthrift__inner(**kwargs))

    @staticmethod
    def from_python(thrift_python_inner: _fbthrift_python_types.AdaptedTypedefFields) -> AdaptedTypedefFields:
        inst = AdaptedTypedefFields.__new__(AdaptedTypedefFields)
        inst._fbthrift__inner = thrift_python_inner
        return inst

    def _to_py3(self) -> AdaptedTypedefFields:
        return self

    def _to_python(self) -> _fbthrift_python_types.AdaptedTypedefFields:
        return self._fbthrift__inner

    def _to_py_deprecated(self):
        py_deprecated_types = _get_py_deprecated_module()
        return thrift.util.converter.to_py_struct(py_deprecated_types.AdaptedTypedefFields, self)

    def _fbthrift__isset(self) -> dict[str, bool]:
        return thrift.python.types.isset(self._fbthrift__inner)

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__AdaptedTypedefFields()

    @staticmethod
    def __get_metadata__():
        return AdaptedTypedefFields._FBTHRIFT__PYTHON_CLASS.__get_metadata__()

    @staticmethod
    def __get_thrift_name__():
        return "module.AdaptedTypedefFields"

    @_python__property
    def bool_field(self) -> bool:
        return self._fbthrift__inner.bool_field

    @_python__property
    def integer_field(self) -> int:
        return self._fbthrift__inner.integer_field

    @_python__property
    def double_field(self) -> float:
        return self._fbthrift__inner.double_field

    @_python__property
    def string_field(self) -> str:
        return self._fbthrift__inner.string_field

    @_python__property
    def binary_field(self) -> bytes:
        return self._fbthrift__inner.binary_field

    @_python__property
    def list_field(self) -> _typing.Sequence[int]:
        if self._fbthrift_inner__list_field is None:
            __python_val = self._fbthrift__inner.list_field
            self._fbthrift_inner__list_field = _py3_simple_AdaptedList__List__i32.from_python(__python_val)

        return self._fbthrift_inner__list_field

    @_python__property
    def set_field(self) -> _typing.AbstractSet[int]:
        if self._fbthrift_inner__set_field is None:
            __python_val = self._fbthrift__inner.set_field
            self._fbthrift_inner__set_field = _py3_simple_AdaptedSet__Set__i32.from_python(__python_val)

        return self._fbthrift_inner__set_field

    @_python__property
    def map_field(self) -> _typing.Mapping[int, int]:
        if self._fbthrift_inner__map_field is None:
            __python_val = self._fbthrift__inner.map_field
            self._fbthrift_inner__map_field = _py3_simple_AdaptedMap__Map__i32_i32.from_python(__python_val)

        return self._fbthrift_inner__map_field

    @_python__property
    def struct_field(self) -> SimpleStruct:
        if self._fbthrift_inner__struct_field is None:
            __python_val = self._fbthrift__inner.struct_field
            self._fbthrift_inner__struct_field = SimpleStruct.from_python(__python_val)

        return self._fbthrift_inner__struct_field


    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx: int) -> str:
        return cls._FBTHRIFT__FIELD_NAMES[idx]

    @classmethod
    def _fbthrift_get_struct_size(cls) -> int:
        return 9

    def __eq__(self, other):
        if type(self) != type(other):
            return False

        for (_, self_val), (_, other_val) in zip(self, other):
            if self_val != other_val:
                return False
        return True



    def __hash__(self):
        return super().__hash__()

    def __copy__(self):
        return self


__all__.append("AdaptedTypedefFields")


### Constants
A_BOOL = True
A_BYTE = 8
THE_ANSWER = 42
A_NUMBER = 84
A_BIG_NUMBER = 102
A_REAL_NUMBER = 3.14
A_FAKE_NUMBER = 3.0
A_WORD = "Good word"
SOME_BYTES = b"bytes"
A_STRUCT = SimpleStruct(is_on=True, tiny_int=5, small_int=6, nice_sized_int=7, big_int=8, real=9.9)
EMPTY = SimpleStruct()
WORD_LIST = List__string(("the", "quick", "brown", "fox", "jumps", "over", "the", "lazy", "dog", ))
SOME_MAP = List__Map__i32_double((Map__i32_double( { 1: 1.1, 2: 2.2 }), Map__i32_double( { 3: 3.3 }), ))
DIGITS = Set__i32((1, 2, 3, 4, 5, ))
A_CONST_MAP = Map__string_SimpleStruct( { "simple": SimpleStruct(is_on=False, tiny_int=50, small_int=61, nice_sized_int=72, big_int=83, real=99.9) })
ANOTHER_CONST_MAP = Map__AnEnumRenamed_i32( { AnEnumRenamed.name_: 0, AnEnumRenamed.value_: 1, AnEnumRenamed.renamed_: 2 })
