<?php
// @generated


// default base
class stdClass {
}

// used in unserialize() for unknown classes
class __PHP_Incomplete_Class {
  public $__PHP_Incomplete_Class_Name;
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.exception.php )
 *
 * Exception is the base class for all Exceptions.
 *
 */
class Exception {
  protected $message = '';  // exception message
  protected $code = 0;      // user defined exception code
  protected $previous = null;
  protected $file;          // source filename of exception
  protected $line;          // source line of exception
  protected $trace;         // full stacktrace
  private $inited = false;

  private static $traceOpts = false;

  /**
   * This cannot be implemented in __construct, because a derived class may
   * implement its own __construct, losing the stacktrace. The runtime has
   * special logic to call the __init__ method on instances of Exception before
   * calling __construct just to make sure $this->trace is always populated.
   */
  final function __init__() {
    if ($this->inited) {
      return;
    }
    $this->initTrace();
    $this->inited = true;
  }

  function __construct($message = '', $code = 0, Exception $previous = null) {
    $this->message = $message;
    $this->code = $code;
    $this->previous = $previous;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.getmessage.php )
 *
 * Returns the Exception message.
 *
 * @return     mixed   Returns the Exception message as a string.
 */
  function getMessage() {
    return $this->message;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.getprevious.php )
 *
 * Returns the previous Exception.
 *
 * @return     mixed   Returns the previous Exception if available or NULL otherwise.
 */
  final function getPrevious() {
    return $this->previous;
  }

  final function setPrevious(Exception $previous) {
    $this->previous = $previous;
  }

  final function setPreviousChain(Exception $previous) {
    $cur = $this;
    $next = $cur->getPrevious();
    while ($next instanceof Exception) {
      $cur = $next;
      $next = $cur->getPrevious;
    }
    $cur->setPrevious($previous);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.getcode.php )
 *
 * Returns the Exception code.
 *
 * @return     mixed   Returns the Exception code as a integer.
 */
  function getCode() {
    return $this->code;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.getfile.php )
 *
 * Get the name of the file the exception was thrown from.
 *
 * @return     mixed   Returns the filename in which the exception was
 *                     thrown.
 */
  final function getFile() {
    return $this->file;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.getline.php )
 *
 * Returns line number where the exception was thrown.
 *
 * @return     mixed   Returns the line number where the exception was
 *                     thrown.
 */
  final function getLine() {
    return $this->line;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.gettrace.php )
 *
 * Returns the Exception stack trace.
 *
 * @return     mixed   Returns the Exception stack trace as an array.
 */
  final function getTrace() {
    return $this->trace;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/exception.gettraceasstring.php )
 *
 * Returns the Exception stack trace as a string.
 *
 * @return     mixed   Returns the Exception stack trace as a string.
 */
  final function getTraceAsString() {
    $i = 0;
    $s = "";
    foreach ($this->getTrace() as $frame) {
      if (!is_array($frame)) continue;
      $s .= "#$i " .
        (isset($frame['file']) ? $frame['file'] : "") . "(" .
        (isset($frame['line']) ? $frame['line'] : "") . "): " .
        (isset($frame['class']) ? $frame['class'] . $frame['type'] : "") .
        $frame['function'] . "()\n";
      $i++;
    }
    $s .= "#$i {main}";
    return $s;
  }

  /* Overrideable */
  // formated string for display
  function __toString() {
    return "exception '" . get_class($this) . "' with message '" .
      $this->getMessage() . "' in " . $this->getFile() . ":" .
      $this->getLine() . "\nStack trace:\n" . $this->getTraceAsString();
  }

  /**
   * Derived classes may override the methods below if different behavior
   * for initializing the trace is desired
   */
  protected function initTrace() {
    $this->trace = debug_backtrace(static::getTraceOptions());
    // Remove top stack frames up to and including Exception::__init__,
    // set the 'file' and 'line' properties appropriately
    while (!empty($this->trace)) {
      $top = array_shift($this->trace);
      if (isset($top['class']) && isset($top['function']) &&
          strcasecmp($top['class'], 'exception') === 0 &&
          strcasecmp($top['function'], '__init__') === 0) {
        if (isset($top['file'])) $this->file = $top['file'];
        if (isset($top['line'])) $this->line = $top['line'];
        return;
      }
    }
  }

  public static function getTraceOptions() {
    return self::$traceOpts;
  }

  public static function setTraceOptions($opts) {
    self::$traceOpts = $opts;
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.logicexception.php )
 *
 * Exception thrown if a logic expression is invalid
 *
 */
class LogicException extends Exception {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.badfunctioncallexception.php )
 *
 * Exception thrown if a callback refers to an undefined function or if
 * some arguments are missing
 *
 */
  class BadFunctionCallException extends LogicException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.badmethodcallexception.php
 * )
 *
 * Exception thrown if a callback refers to an undefined method or if some
 * arguments are missing
 *
 */
    class BadMethodCallException extends BadFunctionCallException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.domainexception.php )
 *
 * Exception thrown if a value does not adhere to a defined valid data
 * domain
 *
 */
  class DomainException          extends LogicException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.invalidargumentexception.php )
 *
 * Exception thrown if an argument does not match with the expected value
 *
 */
  class InvalidArgumentException extends LogicException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.lengthexception.php )
 *
 * Exception thrown if a length is invalid
 *
 */
  class LengthException          extends LogicException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.outofrangeexception.php )
 *
 * Exception thrown when a value does not match with a range
 *
 */
  class OutOfRangeException      extends LogicException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.runtimeexception.php )
 *
 * Exception thrown if an error which can only be found on runtime occurs
 *
 */
class RuntimeException extends Exception {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.outofboundsexception.php )
 *
 * Exception thrown if a value is not a valid key
 *
 */
  class OutOfBoundsException     extends RuntimeException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.overflowexception.php )
 *
 * Exception thrown when you add an element into a full container
 *
 */
  class OverflowException        extends RuntimeException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.rangeexception.php )
 *
 * Exception thrown when an invalid range is given.
 *
 */
  class RangeException           extends RuntimeException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.underflowexception.php )
 *
 * Exception thrown when you try to remove an element of an empty
 * container
 *
 */
  class UnderflowException       extends RuntimeException {}
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.unexpectedvalueexception.php )
 *
 * Exception thrown if a value does not match with a set of values
 *
 */
  class UnexpectedValueException extends RuntimeException {}

  class InvalidOperationException extends RuntimeException {}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.errorexception.php )
 *
 * An Error Exception.
 *
 */
class ErrorException extends Exception {
  protected $severity;
  public function __construct($message = "", $code = 0, $severity = 0,
                              $filename = null, $lineno = null) {
    parent::__construct($message, $code);
    $this->severity = $severity;
    if ($filename !== null) {
      $this->file = $filename;
    }
    if ($lineno !== null) {
      $this->line = $lineno;
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/errorexception.getseverity.php )
 *
 * Returns the severity of the exception.
 *
 * @return     mixed   Returns the severity level of the exception.
 */
  final public function getSeverity() { return $this->severity; }
}

class DOMException extends Exception {
  public function __construct($message, $code) {
    parent::__construct($message, $code);
  }
}

class PDOException extends Exception {
  public function __construct() {
  }
}


// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.arrayaccess.php )
 *
 * Interface to provide accessing objects as arrays.
 *
 */
interface ArrayAccess {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayaccess.offsetexists.php )
 *
 * Whether or not an offset exists.
 *
 * This method is executed when using isset() or empty() on objects
 * implementing ArrayAccess.
 *
 * When using empty() ArrayAccess::offsetGet() will be called and checked
 * if empty only if ArrayAccess::offsetExists() returns TRUE.
 *
 * @index      mixed   An offset to check for.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 *
 *                     The return value will be casted to boolean if
 *                     non-boolean was returned.
 */
  public function offsetExists($index);
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayaccess.offsetget.php )
 *
 * Returns the value at specified offset.
 *
 * This method is executed when checking if offset is empty().
 *
 * @index      mixed   The offset to retrieve.
 *
 * @return     mixed   Can return all value types.
 */
  public function offsetGet($index);
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayaccess.offsetset.php )
 *
 * Assigns a value to the specified offset.
 *
 * @index      mixed   The offset to assign the value to.
 * @newvalue   mixed   The value to set.
 *
 * @return     mixed   No value is returned.
 */
  public function offsetSet($index, $newvalue);
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayaccess.offsetunset.php )
 *
 * Unsets an offset.
 *
 * This method will not be called when type-casting to (unset)
 *
 * @index      mixed   The offset to unset.
 *
 * @return     mixed   No value is returned.
 */
  public function offsetUnset($index);
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.countable.php )
 *
 * Classes implementing Countable can be used with the count() function.
 *
 */
interface Countable {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/countable.count.php )
 *
 * This method is executed when using the count() function on an object
 * implementing Countable.
 *
 * @return     mixed   The custom count as an integer.
 *
 *                     The return value is cast to an integer.
 */
  public function count();
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.serializable.php )
 *
 * Interface for customized serializing.
 *
 * Classes that implement this interface no longer support __sleep() and
 * __wakeup(). The method serialize is called whenever an instance needs to
 * be serialized. This does not invoke __destruct() or has any other side
 * effect unless programmed inside the method. When the data is
 * unserialized the class is known and the appropriate unserialize() method
 * is called as a constructor instead of calling __construct(). If you need
 * to execute the standard constructor you may do so in the method.
 *
 */
interface Serializable {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/serializable.serialize.php )
 *
 * Should return the string representation of the object.
 *
 * This method acts as the destructor of the object. The __destruct()
 * method will not be called after this method.
 *
 * @return     mixed   Returns the string representation of the object or
 *                     NULL
 */
  public function serialize();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/serializable.unserialize.php )
 *
 * Called during unserialization of the object.
 *
 * This method acts as the constructor of the object. The __construct()
 * method will not be called after this method.
 *
 * @serialized mixed   The string representation of the object.
 *
 * @return     mixed   Returns the original value unserialized.
 */
  public function unserialize($serialized);
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.jsonserializable.php )
 *
 */
interface JsonSerializable {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/jsonserializable.jsonserialize.php )
 *
 * Specify data which should be serialized to JSON
 *
 */
  public function jsonSerialize();
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.traversable.php )
 *
 * Interface to detect if a class is traversable using foreach.
 *
 * Abstract base interface that cannot be implemented alone. Instead it
 * must be implemented by either IteratorAggregate or Iterator.
 *
 * Internal (built-in) classes that implement this interface can be used
 * in a foreach construct and do not need to implement IteratorAggregate or
 * Iterator.
 *
 * This is an internal engine interface which cannot be implemented in PHP
 * scripts. Either IteratorAggregate or Iterator must be used instead.
 *
 */
interface Traversable {
}

interface KeyedTraversable extends Traversable {
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.iterator.php )
 *
 * Interface for external iterators or objects that can be iterated
 * themselves internally.
 *
 */
interface Iterator extends Traversable {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/iterator.current.php )
 *
 * Returns the current element.
 *
 * @return     mixed   Can return any type.
 */
  public function current();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/iterator.key.php )
 *
 * Returns the key of the current element.
 *
 * @return     mixed   Returns scalar on success, or NULL on failure.
 */
  public function key();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/iterator.next.php )
 *
 * Moves the current position to the next element.
 *
 * This method is called after each foreach loop.
 *
 * @return     mixed   Any returned value is ignored.
 */
  public function next();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/iterator.rewind.php )
 *
 * Rewinds back to the first element of the Iterator.
 *
 * This is the first method called when starting a foreach loop. It will
 * not be executed after foreach loops.
 *
 * @return     mixed   Any returned value is ignored.
 */
  public function rewind();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/iterator.valid.php )
 *
 * This method is called after Iterator::rewind() and Iterator::next() to
 * check if the current position is valid.
 *
 * @return     mixed   The return value will be casted to boolean and then
 *                     evaluated. Returns TRUE on success or FALSE on
 *                     failure.
 */
  public function valid();
}

interface KeyedIterator extends Iterator, KeyedTraversable {
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.seekableiterator.php )
 *
 * The Seekable iterator.
 *
 */
interface SeekableIterator extends Iterator {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/seekableiterator.seek.php )
 *
 * Seeks to a given position in the iterator.
 *
 * @position   mixed   The position to seek to.
 *
 * @return     mixed   No value is returned.
 */
  public function seek($position);
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.outeriterator.php )
 *
 * Classes implementing OuterIterator can be used to iterate over
 * iterators.
 *
 */
interface OuterIterator extends Iterator {
  public function getInnerIterator();
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.recursiveiterator.php )
 *
 * Classes implementing RecursiveIterator can be used to iterate over
 * iterators recursively.
 *
 */
interface RecursiveIterator extends Iterator {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiterator.getchildren.php )
 *
 * Returns an iterator for the current iterator entry.
 *
 * @return     mixed   An iterator for the current entry.
 */
  public function getChildren();
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiterator.haschildren.php )
 *
 * Returns if an iterator can be created fot the current entry.
 * RecursiveIterator::getChildren().
 *
 * @return     mixed   Returns TRUE if the current entry can be iterated
 *                     over, otherwise returns FALSE.
 */
  public function hasChildren();
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.recursiveiteratoriterator.php )
 *
 * Can be used to iterate through recursive iterators.
 *
 */
class RecursiveIteratorIterator implements OuterIterator, Traversable {

  private $rsrc;

  const LEAVES_ONLY = 0;
  const SELF_FIRST = 1;
  const CHILD_FIRST = 2;
  const CATCH_GET_CHILD = 16;

  public function __construct($iterator,
                              $mode = RecursiveIteratorIterator::LEAVES_ONLY,
                              $flags = 0) {
    hphp_recursiveiteratoriterator___construct($this, $iterator, $mode, $flags);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.getinneriterator.php
 * )
 *
 * Gets the current active sub iterator. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   The current active sub iterator.
 */
  public function getInnerIterator() {
    return hphp_recursiveiteratoriterator_getinneriterator($this);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.current.php )
 *
 *
 * @return     mixed   The current elements value.
 */
  public function current() {
    return hphp_recursiveiteratoriterator_current($this);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.key.php )
 *
 *
 * @return     mixed   The current key.
 */
  public function key() {
    return hphp_recursiveiteratoriterator_key($this);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.next.php )
 *
 *
 * @return     mixed   No value is returned.
 */
  public function next() {
    hphp_recursiveiteratoriterator_next($this);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.rewind.php )
 *
 *
 * @return     mixed   No value is returned.
 */
  public function rewind() {
    hphp_recursiveiteratoriterator_rewind($this);
  }
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursiveiteratoriterator.valid.php )
 *
 *
 * @return     mixed   TRUE if the current position is valid, otherwise
 *                     FALSE
 */
  public function valid() {
    return hphp_recursiveiteratoriterator_valid($this);
  }
}

///////////////////////////////////////////////////////////////////////////////

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.arrayiterator.php )
 *
 * This iterator allows to unset and modify values and keys while
 * iterating over Arrays and Objects.
 *
 * When you want to iterate over the same array multiple times you need to
 * instantiate ArrayObject and let it create ArrayIterator instances that
 * refer to it either by using foreach or by calling its getIterator()
 * method manually.
 *
 */
class ArrayIterator implements ArrayAccess, SeekableIterator, Countable {
  protected $arr;
  protected $flags;

  const STD_PROP_LIST = 1;
  const ARRAY_AS_PROPS = 2;

  public function __construct($array, $flags = 0) {
    $this->arr = $array;
    $this->flags = $flags;
    reset($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.append.php )
 *
 * Appends value as the last element. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @value      mixed   The value to append.
 *
 * @return     mixed   No value is returned.
 */
  public function append($value) {
    $this->arr[] = $value;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.asort.php )
 *
 * Sorts an array by values. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   No value is returned.
 */
  public function asort() {
    return asort($this->arr, $this->flags);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.count.php )
 *
 * Gets the number of elements in the array, or the number of public
 * properties in the object. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The number.
 */
  public function count() {
    return count($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.current.php )
 *
 * Get the current array entry.
 *
 * @return     mixed   The current array entry.
 */
  public function current() {
    return current($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.getarraycopy.php )
 *
 * Get a copy of an array. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   A copy of the array, or array of public properties
 *                     if ArrayIterator refers to an object.
 */
  public function getArrayCopy() {
    return $this->arr;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.getflags.php )
 *
 * Get the current flags. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The current flags.
 */
  public function getFlags() {
    return $this->flags;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.key.php )
 *
 * This function returns the current array key
 *
 * @return     mixed   The current array key.
 */
  public function key() {
    return key($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.ksort.php )
 *
 * Sorts an array by the keys. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   No value is returned.
 */
  public function ksort() {
    return ksort($this->arr, $this->flags);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.natcasesort.php )
 *
 * Sort the entries by values using a case insensitive "natural order"
 * algorithm. WarningThis function is currently not documented; only its
 * argument list is available.
 *
 * @return     mixed   No value is returned.
 */
  public function natcasesort() {
    return natcasesort($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.natsort.php )
 *
 * Sort the entries by values using "natural order" algorithm. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @return     mixed   No value is returned.
 */
  public function natsort() {
    return natsort($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.next.php )
 *
 * The iterator to the next entry.
 *
 * @return     mixed   No value is returned.
 */
  public function next() {
    next($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.offsetexists.php )
 *
 * Checks if the offset exists. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @index      mixed   The offset being checked.
 *
 * @return     mixed   TRUE if the offset exists, otherwise FALSE
 */
  public function offsetExists($index) {
    return isset($this->arr[$index]);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.offsetget.php )
 *
 * Gets the value from the provided offset. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @index      mixed   The offset to get the value from.
 *
 * @return     mixed   The value at offset index.
 */
  public function offsetGet($index) {
    return $this->arr[$index];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.offsetset.php )
 *
 * Sets a value for a given offset. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @index      mixed   The index to set for.
 * @newval     mixed   The new value to store at the index.
 *
 * @return     mixed   No value is returned.
 */
  public function offsetSet($index, $newval) {
    $this->arr[$index] = $newval;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.offsetunset.php )
 *
 * Unsets a value for an offset. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @index      mixed   The offset to unset.
 *
 * @return     mixed   No value is returned.
 */
  public function offsetUnset($index) {
    unset($this->arr[$index]);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.rewind.php )
 *
 * This rewinds the iterator to the beginning.
 *
 * @return     mixed   No value is returned.
 */
  public function rewind() {
    reset($this->arr);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.seek.php )
 *
 *
 * @position   mixed   The position to seek to.
 *
 * @return     mixed   No value is returned.
 */
  public function seek($position) {
    reset($this->arr);
    for ($i = 0; $i < $position; $i++) {
      if (!next($this->arr)) {
        break;
      }
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.setflags.php )
 *
 * Sets behaviour flags. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @flags      mixed   A bitmask as follows: 0 = Properties of the object
 *                     have their normal functionality when accessed as
 *                     list (var_dump, foreach, etc.). 1 = Array indices
 *                     can be accessed as properties in read/write.
 *
 * @return     mixed   No value is returned.
 */
  public function setFlags($flags) {
    $this->flags = $flags;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.uasort.php )
 *
 * Sort the entries by values using user defined function. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @cmp_function
 *             mixed   The compare function used for the sort.
 *
 * @return     mixed   No value is returned.
 */
  public function uasort($cmp_function) {
    return uasort($this->arr, $cmp_function);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.uksort.php )
 *
 * Sort the entries by key using user defined function. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @cmp_function
 *             mixed   The compare function used for the sort.
 *
 * @return     mixed   No value is returned.
 */
  public function uksort($cmp_function) {
    return uksort($this->arr, $cmp_function);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/arrayiterator.valid.php )
 *
 * Checks if the array contains any more entries.
 *
 * @return     mixed   No value is returned.
 */
  public function valid() {
    return key($this->arr) !== null;
  }
}

// http://www.php.net/~helly/php/ext/spl/iteratoriterator_8inc-source.html
class IteratorIterator implements OuterIterator {
  private $iterator;

  public function __construct(Traversable $iterator) {
    if ($iterator instanceof IteratorAggregate) {
      $iterator = $iterator->getIterator();
    }
    if ($iterator instanceof Iterator) {
      $this->iterator = $iterator;
    } else {
      throw new Exception(
        "Need to pass a Traversable that is convertable to an iterator");
    }
  }

  public function getInnerIterator() {
    return $this->iterator;
  }

  public function valid() {
    return $this->iterator->valid();
  }

  public function key() {
    return $this->iterator->key();
  }

  public function current() {
    return $this->iterator->current();
  }

  public function next() {
    return $this->iterator->next();
  }

  public function rewind() {
    return $this->iterator->rewind();
  }

  public function __call($func, $params) {
    return call_user_func_array(array($this->iterator, $func), $params);
  }
}

// http://www.php.net/~helly/php/ext/spl/filteriterator_8inc-source.html
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.filteriterator.php )
 *
 * This abstract iterator filters out unwanted values. This class should
 * be extended to implement custom iterator filters. The
 * FilterIterator::accept() must be implemented in the subclass.
 *
 */
abstract class FilterIterator extends IteratorIterator {
  private $it;

  public function __construct(Iterator $it) {
    $this->it = $it;
  }

  public function rewind() {
    $this->it->rewind();
    $this->fetch();
  }

  abstract function accept();

  private function fetch() {
    while ($this->it->valid()) {
      if ($this->accept()) {
        return;
      }
      $this->it->next();
    }
  }

  public function next() {
    $this->it->next();
    $this->fetch();
  }

  public function valid() {
    return $this->it->valid();
  }

  public function key() {
    return $this->it->key();
  }

  public function current() {
    return $this->it->current();
  }

  protected function __clone() {
    // disallow clone
  }

  public function getInnerIterator() {
    return $this->it;
  }

  public function __call($func, $params) {
    return call_user_func_array(array($this->it, $func), $params);
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.iteratoraggregate.php )
 *
 * Interface to create an external Iterator.
 *
 */
interface IteratorAggregate extends Traversable {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/iteratoraggregate.getiterator.php )
 *
 * Returns an external iterator.
 *
 * @return     mixed   An instance of an object implementing Iterator or
 *                     Traversable
 */
  public function getIterator();
}

interface Iterable extends IteratorAggregate {
}

interface KeyedIterable extends Iterable, KeyedTraversable {
}

///////////////////////////////////////////////////////////////////////////////
// http://www.php.net/~helly/php/ext/spl/appenditerator_8inc-source.html

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.appenditerator.php )
 *
 * An Iterator that iterates over several iterators one after the other.
 *
 */
class AppendIterator implements OuterIterator {
  private $iterators;

  function __construct() {
    $this->iterators = new ArrayIterator(array());
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.append.php )
 *
 * Appends an iterator. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @it         mixed   The iterator to append.
 *
 * @return     mixed   No value is returned.
 */
  function append(Iterator $it) {
    $this->iterators->append($it);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/appenditerator.getinneriterator.php )
 *
 * Get an inner iterator WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The current inner Iterator.
 */
  function getInnerIterator() {
    return $this->iterators->current();
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.rewind.php )
 *
 * Rewind to the first element of the first inner Iterator. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @return     mixed   No value is returned.
 */
  function rewind() {
    $this->iterators->rewind();
    if ($this->iterators->valid()) {
      $this->getInnerIterator()->rewind();
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.valid.php )
 *
 * Checks validity of the current element. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  function valid() {
    return $this->iterators->valid() && $this->getInnerIterator()->valid();
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.current.php )
 *
 * Gets the current value. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The current value if it is valid or NULL otherwise.
 */
  function current() {
    /* Using $this->valid() would be exactly the same; it would omit
     * the access to a non valid element in the inner iterator. Since
     * the user didn't respect the valid() return value false this
     * must be intended hence we go on. */
    return $this->iterators->valid() ?
      $this->getInnerIterator()->current() : NULL;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.key.php )
 *
 * Get the current key WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The current key if it is valid or NULL otherwise.
 */
  function key() {
    return $this->iterators->valid() ? $this->getInnerIterator()->key() : NULL;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/appenditerator.next.php )
 *
 * Moves to the next element. If this means to another Iterator then it
 * rewinds that Iterator. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   No value is returned.
 */
  function next() {
    if (!$this->iterators->valid()){
      return; /* done all */
    }
    $this->getInnerIterator()->next();
    if ($this->getInnerIterator()->valid()) {
      return; /* found valid element in current inner iterator */
    }
    $this->iterators->next();
    while ($this->iterators->valid()) {
      $this->getInnerIterator()->rewind();
      if ($this->getInnerIterator()->valid()) {
        return; /* found element as first elemet in another iterator */
      }
      $this->iterators->next();
    }
  }

  function __call($func, $params) {
    return call_user_func_array(array($this->getInnerIterator(), $func),
                                $params);
  }
}


// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.splfileinfo.php )
 *
 * The SplFileInfo class offers a high-level object oriented interface to
 * information for an individual file.
 *
 */
class SplFileInfo {
  private $rsrc;

  public function __construct($file_name) {
    hphp_splfileinfo___construct($this, $file_name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getpath.php )
 *
 * Returns the path to the file, omitting the filename and any trailing
 * slash.
 *
 * @return     mixed   Returns the path to the file.
 */
  public function getPath() {
    return hphp_splfileinfo_getpath($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getfilename.php )
 *
 * Gets the filename without any path information.
 *
 * @return     mixed   The filename.
 */
  public function getFilename() {
    return hphp_splfileinfo_getfilename($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getfileinfo.php )
 *
 * This method gets an SplFileInfo object for the referenced file.
 *
 * @class_name mixed   Name of an SplFileInfo derived class to use.
 *
 * @return     mixed   An SplFileInfo object created for the file.
 */
  public function getFileInfo($class_name = "") {
    return hphp_splfileinfo_getfileinfo($this, $class_name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getbasename.php )
 *
 * This method returns the base name of the file, directory, or link
 * without path info.
 *
 * @suffix     mixed   Optional suffix to omit from the base name returned.
 *
 * @return     mixed   Returns the base name without path information.
 */
  public function getBasename($suffix = "") {
    return hphp_splfileinfo_getbasename($this, $suffix);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getpathname.php )
 *
 * Returns the path to the file.
 *
 * @return     mixed   The path to the file.
 */
  public function getPathname() {
    return hphp_splfileinfo_getpathname($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getpathinfo.php )
 *
 * Gets an SplFileInfo object for the parent of the current file.
 *
 * @class_name mixed   Name of an SplFileInfo derived class to use.
 *
 * @return     mixed   Returns an SplFileInfo object for the parent path of
 *                     the file.
 */
  public function getPathInfo($class_name = "") {
    return hphp_splfileinfo_getpathinfo($this, $class_name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getperms.php )
 *
 * Gets the file permissions for the file.
 *
 * @return     mixed   Returns the file permissions.
 */
  public function getPerms() {
    return hphp_splfileinfo_getperms($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getinode.php )
 *
 * Gets the inode number for the filesystem object.
 *
 * @return     mixed   Returns the inode number for the filesystem object.
 */
  public function getInode() {
    return hphp_splfileinfo_getinode($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getsize.php )
 *
 * Returns the filesize in bytes for the file referenced.
 *
 * @return     mixed   The filesize in bytes.
 */
  public function getSize() {
    return hphp_splfileinfo_getsize($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getowner.php )
 *
 * Gets the file owner. The owner ID is returned in numerical format.
 *
 * @return     mixed   The owner id in numerical format.
 */
  public function getOwner() {
    return hphp_splfileinfo_getowner($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getgroup.php )
 *
 * Gets the file group. The group ID is returned in numerical format.
 *
 * @return     mixed   The group id in numerical format.
 */
  public function getGroup() {
    return hphp_splfileinfo_getgroup($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getatime.php )
 *
 * Gets the last access time for the file.
 *
 * @return     mixed   Returns the time the file was last accessed.
 */
  public function getATime() {
    return hphp_splfileinfo_getatime($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getmtime.php )
 *
 * Returns the time when the contents of the file were changed. The time
 * returned is a Unix timestamp.
 *
 * @return     mixed   Returns the last modified time for the file, in a
 *                     Unix timestamp.
 */
  public function getMTime() {
    return hphp_splfileinfo_getmtime($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getctime.php )
 *
 * Returns the inode change time for the file. The time returned is a Unix
 * timestamp.
 *
 * @return     mixed   The last change time, in a Unix timestamp.
 */
  public function getCTime() {
    return hphp_splfileinfo_getctime($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.gettype.php )
 *
 * Returns the type of the file referenced.
 *
 * @return     mixed   A string representing the type of the entry. May be
 *                     one of file, link, or dir
 */
  public function getType() {
    return hphp_splfileinfo_gettype($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.iswritable.php )
 *
 * Checks if the current entry is writable.
 *
 * @return     mixed   Returns TRUE if writable, FALSE otherwise;
 */
  public function isWritable() {
    return hphp_splfileinfo_iswritable($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.isreadable.php )
 *
 * Check if the file is readable.
 *
 * @return     mixed   Returns TRUE if readable, FALSE otherwise.
 */
  public function isReadable() {
    return hphp_splfileinfo_isreadable($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.isexecutable.php )
 *
 * Checks if the file is executable.
 *
 * @return     mixed   Returns TRUE if executable, FALSE otherwise.
 */
  public function isExecutable() {
    return hphp_splfileinfo_isexecutable($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.isfile.php )
 *
 * Checks if the file referenced by this SplFileInfo object exists and is
 * a regular file.
 *
 * @return     mixed   Returns TRUE if the file exists and is a regular
 *                     file (not a link), FALSE otherwise.
 */
  public function isFile() {
    return hphp_splfileinfo_isfile($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.isdir.php )
 *
 * This method can be used to determine if the file is a directory.
 *
 * @return     mixed   Returns TRUE if a directory, FALSE otherwise.
 */
  public function isDir() {
    return hphp_splfileinfo_isdir($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.islink.php )
 *
 * Use this method to check if the file referenced by the SplFileInfo
 * object is a link.
 *
 * @return     mixed   Returns TRUE if the file is a link, FALSE otherwise.
 */
  public function isLink() {
    return hphp_splfileinfo_islink($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getlinktarget.php )
 *
 * Gets the target of a filesystem link.
 *
 * The target may not be the real path on the filesystem. Use
 * SplFileInfo::getRealPath() to determine the true path on the filesystem.
 *
 * @return     mixed   Returns the target of the filesystem link.
 */
  public function getLinkTarget() {
    return hphp_splfileinfo_getlinktarget($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.getrealpath.php )
 *
 * This method expands all symbolic links, resolves relative references
 * and returns the real path to the file.
 *
 * @return     mixed   Returns the path to the file.
 */
  public function getRealPath() {
    return hphp_splfileinfo_getrealpath($this);
  }

  public function __toString() {
    return hphp_splfileinfo___tostring($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.openfile.php )
 *
 * Creates an SplFileObject object of the file. This is useful because
 * SplFileObject contains additional methods for manipulating the file
 * whereas SplFileInfo is only useful for gaining information, like whether
 * the file is writable.
 *
 * @mode       mixed   The mode for opening the file. See the fopen()
 *                     documentation for descriptions of possible modes.
 *                     The default is read only.
 * @use_include_path
 *             mixed   When set to TRUE, the filename is also searched for
 *                     within the include_path
 * @context    mixed   Refer to the context section of the manual for a
 *                     description of contexts.
 *
 * @return     mixed   The opened file as an SplFileObject object.
 */
  public function openFile($mode = 'r', $use_include_path = false,
                           $context = null) {
    return hphp_splfileinfo_openfile($this, $mode,
                                     $use_include_path, $context);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.setfileclass.php )
 *
 * Set the class name which SplFileInfo will use to open files with when
 * openFile() is called. The class name passed to this method must be
 * derived from SplFileObject.
 *
 * @class_name mixed   The class name to use when openFile() is called.
 *
 * @return     mixed   No value is returned.
 */
  public function setFileClass($class_name = "SplFileObject") {
    hphp_splfileinfo_setfileclass($this, $class_name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileinfo.setinfoclass.php )
 *
 * Use this method to set a custom class which will be used when
 * getFileInfo and getPathInfo are called. The class name passed to this
 * method must be derived from SplFileInfo.
 *
 * @class_name mixed   The class name to use.
 *
 * @return     mixed   No value is returned.
 */
  public function setInfoClass($class_name = "SplFileInfo") {
    hphp_splfileinfo_setinfoclass($this, $class_name);
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.splfileobject.php )
 *
 * The SplFileObject class offers an object oriented interface for a file.
 *
 */
class SplFileObject extends SplFileInfo implements RecursiveIterator,
  Traversable, SeekableIterator {

  const DROP_NEW_LINE = 1;
  const READ_AHEAD = 2;
  const SKIP_EMPTY = 6;
  const READ_CSV = 8;

  public function __construct($filename, $open_mode = 'r',
                              $use_include_path = false,
                              $context = null) {
    hphp_splfileobject___construct($this, $filename, $open_mode,
                                   $use_include_path, $context);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.current.php )
 *
 * Retrieves the current line of the file.
 *
 * @return     mixed   Retrieves the current line of the file. If the
 *                     SplFileObject::READ_CSV flag is set, this method
 *                     returns an array containing the current line parsed
 *                     as CSV data.
 */
  public function current() {
    return hphp_splfileobject_current($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.eof.php )
 *
 * Determine whether the end of file has been reached
 *
 * @return     mixed   Returns TRUE if file is at EOF, FALSE otherwise.
 */
  public function eof() {
    return hphp_splfileobject_eof($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fflush.php )
 *
 * Forces a write of all buffered output to the file.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function fflush() {
    return hphp_splfileobject_fflush($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fgetc.php )
 *
 * Gets a character from the file.
 *
 * @return     mixed   Returns a string containing a single character read
 *                     from the file or FALSE on EOF. WarningThis function
 *                     may return Boolean FALSE, but may also return a
 *                     non-Boolean value which evaluates to FALSE, such as
 *                     0 or "". Please read the section on Booleans for
 *                     more information. Use the === operator for testing
 *                     the return value of this function.
 */
  public function fgetc() {
    return hphp_splfileobject_fgetc($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fgetcsv.php )
 *
 * Gets a line from the file which is in CSV format and returns an array
 * containing the fields read.
 *
 * @delimiter  mixed   The field delimiter (one character only). Defaults
 *                     as a comma or the value set using
 *                     SplFileObject::setCsvControl().
 * @enclosure  mixed   The field enclosure character (one character only).
 *                     Defaults as a double quotation mark or the value set
 *                     using SplFileObject::setCsvControl().
 * @escape     mixed   The escape character (one character only). Defaults
 *                     as a backslash (\) or the value set using
 *                     SplFileObject::setCsvControl().
 *
 * @return     mixed   Returns an indexed array containing the fields read,
 *                     or FALSE on error.
 *
 *                     A blank line in a CSV file will be returned as an
 *                     array comprising a single NULL field unless using
 *                     SplFileObject::SKIP_EMPTY |
 *                     SplFileObject::DROP_NEW_LINE, in which case empty
 *                     lines are skipped.
 */
  public function fgetcsv($delimiter = ",", $enclosure = "\"",
                           $escape = "\\") {
    return hphp_splfileobject_fgetcsv($this, $delimiter,
                                      $enclosure, $escape);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fgets.php )
 *
 * Gets a line from the file.
 *
 * @return     mixed   Returns a string containing the next line from the
 *                     file, or FALSE on error.
 */
  public function fgets() {
    return hphp_splfileobject_fgets($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fgetss.php )
 *
 * Identical to SplFileObject::fgets(), except that
 * SplFileObject::fgetss() attempts to strip any HTML and PHP tags from the
 * text it reads.
 *
 * @allowable_tags
 *             mixed   You can use the optional third parameter to specify
 *                     tags which should not be stripped.
 *
 * @return     mixed   Returns a string containing the next line of the
 *                     file with HTML and PHP code stripped, or FALSE on
 *                     error.
 */
  public function fgetss($allowable_tags) {
    return hphp_splfileobject_fgetss($this, $allowable_tags);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.flock.php )
 *
 * Locks or unlocks the file in the same portable way as flock().
 *
 * @operation  mixed   operation is one of the following: LOCK_SH to
 *                     acquire a shared lock (reader). LOCK_EX to acquire
 *                     an exclusive lock (writer). LOCK_UN to release a
 *                     lock (shared or exclusive). LOCK_NB to not block
 *                     while locking (not supported on Windows).
 * @wouldblock mixed   Set to TRUE if the lock would block (EWOULDBLOCK
 *                     errno condition).
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function flock($operation, &$wouldblock) {
    return hphp_splfileobject_flock($this, $wouldblock);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fpassthru.php )
 *
 * Reads to EOF on the given file pointer from the current position and
 * writes the results to the output buffer.
 *
 * You may need to call SplFileObject::rewind() to reset the file pointer
 * to the beginning of the file if you have already written data to the
 * file.
 *
 * @return     mixed   Returns the number of characters read from handle
 *                     and passed through to the output.
 */
  public function fpassthru() {
    return hphp_splfileobject_fpassthru($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fscanf.php )
 *
 * Reads a line from the file and interprets it according to the specified
 * format, which is described in the documentation for sprintf().
 *
 * Any whitespace in the format string matches any whitespace in the line
 * from the file. This means that even a tab \t in the format string can
 * match a single space character in the input stream.
 *
 * @format     mixed   The specified format as described in the sprintf()
 *                     documentation.
 *
 * @return     mixed   If only two parameters were passed to this method,
 *                     the values parsed will be returned as an array.
 *                     Otherwise, if optional parameters are passed, the
 *                     function will return the number of assigned values.
 *                     The optional parameters must be passed by reference.
 */
  public function fscanf($format) {
    $argc = func_num_args();
    $argv = func_get_args();
    return hphp_splfileobject_fscanf($argc, $this, $format, $argv);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fseek.php )
 *
 * Seek to a position in the file measured in bytes from the beginning of
 * the file, obtained by adding offset to the position specified by whence.
 *
 * @offset     mixed   The offset. A negative value can be used to move
 *                     backwards through the file which is useful when
 *                     SEEK_END is used as the whence value.
 * @whence     mixed   whence values are: SEEK_SET - Set position equal to
 *                     offset bytes. SEEK_CUR - Set position to current
 *                     location plus offset. SEEK_END - Set position to
 *                     end-of-file plus offset.
 *
 *                     If whence is not specified, it is assumed to be
 *                     SEEK_SET.
 *
 * @return     mixed   Returns 0 if the seek was successful, -1 otherwise.
 *                     Note that seeking past EOF is not considered an
 *                     error.
 */
  public function fseek($offset, $whence) {
    return hphp_splfileobject_fseek($this, $offset, $whence);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fstat.php )
 *
 * Gathers the statistics of the file. Behaves identically to fstat().
 *
 * @return     mixed   Returns an array with the statistics of the file;
 *                     the format of the array is described in detail on
 *                     the stat() manual page.
 */
  public function fstat() {
    return hphp_splfileobject_fstat($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.ftell.php )
 *
 * Returns the position of the file pointer which represents the current
 * offset in the file stream.
 *
 * @return     mixed   Returns the position of the file pointer as an
 *                     integer, or FALSE on error.
 */
  public function ftell() {
    return hphp_splfileobject_ftell($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.ftruncate.php )
 *
 * Truncates the file to size bytes.
 *
 * @size       mixed   The size to truncate to.
 *
 *                     If size is larger than the file it is extended with
 *                     null bytes.
 *
 *                     If size is smaller than the file, the extra data
 *                     will be lost.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function ftruncate($size) {
    return hphp_splfileobject_ftruncate($this, $size);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.fwrite.php )
 *
 * Writes the contents of string to the file
 *
 * @str        mixed   The string to be written to the file.
 * @length     mixed   If the length argument is given, writing will stop
 *                     after length bytes have been written or the end of
 *                     string is reached, whichever comes first.
 *
 * @return     mixed   Returns the number of bytes written, or NULL on
 *                     error.
 */
  public function fwrite($str, $length) {
    return hphp_splfileobject_fwrite($this, $str, $length);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.getchildren.php )
 *
 * An SplFileObject does not have children so this method returns NULL.
 *
 * @return     mixed   No value is returned.
 */
  public function getChildren() {
    return null; // An SplFileOjbect does not have children
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.getcsvcontrol.php
 * )
 *
 * Gets the delimiter and enclosure character used for parsing CSV fields.
 *
 * @return     mixed   Returns an indexed array containing the delimiter
 *                     and enclosure character.
 */
  public function getCsvControl() {
    return hphp_splfileobject_getcvscontrol($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.getflags.php )
 *
 * Gets the flags set for an instance of SplFileObject as an integer.
 *
 * @return     mixed   Returns an integer representing the flags.
 */
  public function getFlags() {
    return hphp_splfileobject_getflags($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.getmaxlinelen.php
 * )
 *
 * Gets the maximum line length as set by SplFileObject::setMaxLineLen().
 *
 * @return     mixed   Returns the maximum line length if one has been set
 *                     with SplFileObject::setMaxLineLen(), default is 0.
 */
  public function getMaxLineLen() {
    return hphp_splfileobject_getmaxlinelen($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.haschildren.php )
 *
 * An SplFileObject does not have children so this method always return
 * FALSE.
 *
 * @return     mixed   Returns FALSE
 */
  public function hasChildren() {
    return false; // An SplFileOjbect does not have children
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.key.php )
 *
 * Gets the current line number.
 *
 * This number may not reflect the actual line number in the file if
 * SplFileObject::setMaxLineLen() is used to read fixed lengths of the
 * file.
 *
 * @return     mixed   Returns the current line number.
 */
  public function key() {
    return hphp_splfileobject_key($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.next.php )
 *
 * Moves ahead to the next line in the file.
 *
 * @return     mixed   No value is returned.
 */
  public function next() {
    hphp_splfileobject_next($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.rewind.php )
 *
 * Rewinds the file back to the first line.
 *
 * @return     mixed   No value is returned.
 */
  public function rewind() {
    hphp_splfileobject_rewind($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.seek.php )
 *
 * Seek to specified line in the file.
 *
 * @line_pos   mixed   The zero-based line number to seek to.
 *
 * @return     mixed   No value is returned.
 */
  public function seek($line_pos) {
    hphp_splfileobject_seek($this, $line_pos);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.setcsvcontrol.php
 * )
 *
 * Sets the delimiter and enclosure character for parsing CSV fields.
 *
 * @delimiter  mixed   The field delimiter (one character only).
 * @enclosure  mixed   The field enclosure character (one character only).
 * @escape     mixed   The field escape character (one character only).
 *
 * @return     mixed   No value is returned.
 */
  public function setCsvControl($delimiter = ",", $enclosure = "\"",
                                $escape = "\\") {
    hphp_splfileobject_setcsvcontrol($this, $delimiter, $enclosure, $escape);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.setflags.php )
 *
 * Sets the flags to be used by the SplFileObject.
 *
 * @flags      mixed   Bit mask of the flags to set. See SplFileObject
 *                     constants for the available flags.
 *
 * @return     mixed   No value is returned.
 */
  public function setFlags($flags) {
    hphp_splfileobject_setflags($this, $flags);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.setmaxlinelen.php
 * )
 *
 * Sets the maximum length of a line to be read.
 *
 * @max_len    mixed   The maximum length of a line.
 *
 * @return     mixed   No value is returned.
 */
  public function setMaxLineLen($max_len) {
    hphp_splfileobject_setmaxlinelen($this, $max_len);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splfileobject.valid.php )
 *
 * Check whether EOF has been reached.
 *
 * @return     mixed   Returns TRUE if not reached EOF, FALSE otherwise.
 */
  public function valid() {
    return hphp_splfileobject_valid($this);
  }
}

interface Awaitable {
  public function getWaitHandle();
}

trait IterableTrait {
  public function view() {
    return $this;
  }
  public function map($callback) {
    return new MappedIterable($this, $callback);
  }
  public function filter($callback) {
    return new FilteredIterable($this, $callback);
  }
  public function zip($iterable) {
    return new ZippedIterable($this, $iterable);
  }
}

trait KeyedIterableTrait {
  public function view() {
    return $this;
  }
  public function map($callback) {
    return new MappedKeyedIterable($this, $callback);
  }
  public function filter($callback) {
    return new FilteredKeyedIterable($this, $callback);
  }
  public function zip($iterable) {
    return new ZippedKeyedIterable($this, $iterable);
  }
  public function keys() {
    return new KeysIterable($this);
  }
  public function kvzip() {
    return new KVZippedIterable($this);
  }
}

class MappedIterator implements Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return ($this->fn)($this->it->current());
  }
}

class MappedIterable implements Iterable {
  use IterableTrait;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new MappedIterator($this->iterable->getIterator(), $this->fn);
  }
}

class MappedKeyedIterator implements KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return ($this->fn)($this->it->current());
  }
}

class MappedKeyedIterable implements KeyedIterable {
  use KeyedIterableTrait;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new MappedKeyedIterator($this->iterable->getIterator(), $this->fn);
  }
}

class FilteredIterator implements Iterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $it = $this->it;
    $fn = $this->fn;
    $it->next();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function key() {
    return null;
  }
  public function current() {
    return $this->it->current();
  }
}

class FilteredIterable implements Iterable {
  use IterableTrait;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new FilteredIterator($this->iterable->getIterator(), $this->fn);
  }
}

class FilteredKeyedIterator implements KeyedIterator {
  private $it;
  private $fn;

  public function __construct($it, $fn) {
    $this->it = $it;
    $this->fn = $fn;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $it = $this->it;
    $fn = $this->fn;
    $it->rewind();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $it = $this->it;
    $fn = $this->fn;
    $it->next();
    while ($it->valid() && !$fn($it->current())) {
      $it->next();
    }
  }
  public function key() {
    return $this->it->key();
  }
  public function current() {
    return $this->it->current();
  }
}

class FilteredKeyedIterable implements KeyedIterable {
  use KeyedIterableTrait;

  private $iterable;
  private $fn;

  public function __construct($iterable, $fn) {
    $this->iterable = $iterable;
    $this->fn = $fn;
  }
  public function getIterator() {
    return new FilteredKeyedIterator($this->iterable->getIterator(), $this->fn);
  }
}

class ZippedIterator implements Iterator {
  private $it1;
  private $it2;

  public function __construct($it1, $it2) {
    $this->it1 = $it1;
    $this->it2 = $it2;
  }
  public function __clone() {
    $this->it1 = clone $this->it1;
    $this->it2 = clone $this->it2;
  }
  public function rewind() {
    $this->it1->rewind();
    $this->it2->rewind();
  }
  public function valid() {
    return ($this->it1->valid() && $this->it2->valid());
  }
  public function next() {
    $this->it1->next();
    $this->it2->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return Pair {$this->it1->current(), $this->it2->current()};
  }
}

class ZippedIterable implements Iterable {
  use IterableTrait;

  private $iterable1;
  private $iterable2;

  public function __construct($iterable1, $iterable2) {
    $this->iterable1 = $iterable1;
    $this->iterable2 = $iterable2;
  }
  public function getIterator() {
    return new ZippedIterator($this->iterable1->getIterator(),
                              $this->iterable2->getIterator());
  }
}

class ZippedKeyedIterator implements KeyedIterator {
  private $it1;
  private $it2;

  public function __construct($it1, $it2) {
    $this->it1 = $it1;
    $this->it2 = $it2;
  }
  public function __clone() {
    $this->it1 = clone $this->it1;
    $this->it2 = clone $this->it2;
  }
  public function rewind() {
    $this->it1->rewind();
    $this->it2->rewind();
  }
  public function valid() {
    return ($this->it1->valid() && $this->it2->valid());
  }
  public function next() {
    $this->it1->next();
    $this->it2->next();
  }
  public function key() {
    return $this->it1->key();
  }
  public function current() {
    return Pair {$this->it1->current(), $this->it2->current()};
  }
}

class ZippedKeyedIterable implements KeyedIterable {
  use KeyedIterableTrait;
  
  private $iterable1;
  private $iterable2;

  public function __construct($iterable1, $iterable2) {
    $this->iterable1 = $iterable1;
    $this->iterable2 = $iterable2;
  }
  public function getIterator() {
    return new ZippedKeyedIterator($this->iterable1->getIterator(),
                                   $this->iterable2->getIterator());
  }
}

class KeysIterator implements Iterator {
  private $it;

  public function __construct($it) {
    $this->it = $it;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return $this->it->key();
  }
}

class KeysIterable implements Iterable {
  use IterableTrait;

  private $iterable;

  public function __construct($iterable) {
    $this->iterable = $iterable;
  }
  public function getIterator() {
    return new KeysIterator($this->iterable->getIterator());
  }
}

class KVZippedIterator implements Iterator {
  private $it;

  public function __construct($it) {
    $this->it = $it;
  }
  public function __clone() {
    $this->it = clone $this->it;
  }
  public function rewind() {
    $this->it->rewind();
  }
  public function valid() {
    return $this->it->valid();
  }
  public function next() {
    $this->it->next();
  }
  public function key() {
    return null;
  }
  public function current() {
    return Pair {$this->it->key(), $this->it->current()};
  }
}

class KVZippedIterable implements Iterable {
  use IterableTrait;

  private $iterable;

  public function __construct($iterable) {
    $this->iterable = $iterable;
  }
  public function getIterator() {
    return new KVZippedIterator($this->iterable->getIterator());
  }
}

interface ConstCollection extends Countable {
  public function isEmpty();
  public function count();
  public function items();
}

interface OutputCollection {
  public function add($e);
  public function addAll($iterable);
}

interface Collection extends ConstCollection,
                             OutputCollection {
  public function clear();
}

interface ConstSetAccess {
  public function contains($m);
}

interface SetAccess extends ConstSetAccess {
  public function remove($m);
}

interface ConstIndexAccess {
  public function at($k);
  public function get($k);
  public function containsKey($k);
}

interface IndexAccess extends ConstIndexAccess {
  public function set($k,$v);
  public function setAll($iterable);
  public function removeKey($k);
}

interface ConstMapAccess extends ConstSetAccess,
                                 ConstIndexAccess {
}

interface MapAccess extends ConstMapAccess,
                            SetAccess,
                            IndexAccess {
}

interface ConstVector extends ConstCollection,
                              ConstIndexAccess,
                              KeyedIterable {
}

interface MutableVector extends ConstVector,
                                Collection,
                                IndexAccess {
}

interface ConstMap extends ConstCollection,
                           ConstMapAccess,
                           KeyedIterable {
}

interface MutableMap extends ConstMap,
                             Collection,
                             MapAccess {
}

interface ConstSet extends ConstCollection,
                           ConstSetAccess,
                           Iterable {
}

interface MutableSet extends ConstSet,
                             Collection,
                             SetAccess {
}

class IterableView implements Iterable {
  public $iterable;

  public function __construct($iterable) { $this->iterable = $iterable; }
  public function getIterator() { return $this->iterable->getIterator(); }
  public function view() {
    return $this;
  }
  public function map($callback) {
    return new MappedIterable($this->iterable, $callback);
  }
  public function filter($callback) {
    return new FilteredIterable($this->iterable, $callback);
  }
  public function zip($iterable) {
    return new ZippedIterable($this->iterable, $iterable);
  }
}

class KeyedIterableView implements KeyedIterable {
  public $iterable;

  public function __construct($iterable) { $this->iterable = $iterable; }
  public function getIterator() { return $this->iterable->getIterator(); }
  public function view() {
    return $this;
  }
  public function map($callback) {
    return new MappedKeyedIterable($this->iterable, $callback);
  }
  public function filter($callback) {
    return new FilteredKeyedIterable($this->iterable, $callback);
  }
  public function zip($iterable) {
    return new ZippedKeyedIterable($this->iterable, $iterable);
  }
  public function keys() {
    return new KeysIterable($this->iterable);
  }
  public function kvzip() {
    return new KVZippedIterable($this->iterable);
  }
}


interface DebuggerCommand {
  /**
   * Called when DebuggerClient needs to auto-complete. Inside this function,
   * one can call $client->addCompletion() with a list of strings or one of
   * those DebuggerClient::AUTO_COMPLETE_ constants.
   */
  public function onAutoComplete($client);

  /**
   * Called when DebuggerClient needs to displays help on the command. Inside
   * this function, one can call $client->help() and its different forms.
   *
   * @return  TRUE if helped, FALSE if any error
   */
  public function help($client);

  /**
   * How to process the command on client side.
   *
   * @return  TRUE for success, FALSE for failure
   */
  public function onClient($client);

  /**
   * How to process the command on server side.
   *
   * @return  TRUE for success, FALSE for failure
   */
  public function onServer($proxy);
}

class Directory {
  public $path;
  public $handle;

  public function __construct($path) {
    $this->path = $path;
    $this->handle = opendir($path);
  }

  public function read() {
    return readdir($this->handle);
  }

  public function rewind() {
    rewinddir($this->handle);
  }

  public function close() {
    closedir($this->handle);
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.directoryiterator.php )
 *
 * The DirectoryIterator class provides a simple interface for viewing the
 * contents of filesystem directories.
 *
 */
class DirectoryIterator extends SplFileInfo implements Traversable,
  SeekableIterator {

  public function __construct($path) {
    if (!hphp_directoryiterator___construct($this, $path)) {
      throw new UnexpectedValueException(
          "DirectoryIterator::__construct($path): failed to open dir");
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.current.php )
 *
 * Get the current DirectoryIterator item.
 *
 * @return     mixed   The current DirectoryIterator item.
 */
  public function current() {
    return hphp_directoryiterator_current($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.key.php )
 *
 * Get the key for the current DirectoryIterator item.
 *
 * @return     mixed   The key for the current DirectoryIterator item.
 */
  public function key() {
    return hphp_directoryiterator_key($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.next.php )
 *
 * Move forward to the next DirectoryIterator item.
 *
 * @return     mixed   No value is returned.
 */
  public function next() {
    hphp_directoryiterator_next($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.rewind.php )
 *
 * Rewind the DirectoryIterator back to the start.
 *
 * @return     mixed   No value is returned.
 */
  public function rewind() {
    hphp_directoryiterator_rewind($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.seek.php )
 *
 * Seek to a given position in the DirectoryIterator.
 *
 * @position   mixed   The zero-based numeric position to seek to.
 *
 * @return     mixed   No value is returned.
 */
  public function seek($position) {
    hphp_directoryiterator_seek($this, $position);
  }

  public function __toString() {
    return hphp_directoryiterator___tostring($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.valid.php )
 *
 * Check whether current DirectoryIterator position is a valid file.
 *
 * @return     mixed   Returns TRUE if the position is valid, otherwise
 *                     FALSE
 */
  public function valid() {
    return hphp_directoryiterator_valid($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/directoryiterator.isdot.php )
 *
 * Determines if the current DirectoryIterator item is a directory and
 * either . or ...
 *
 * @return     mixed   TRUE if the entry is . or .., otherwise FALSE
 */
  public function isDot() {
    return hphp_directoryiterator_isdot($this);
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.recursivedirectoryiterator.php )
 *
 * ...
 *
 */
class RecursiveDirectoryIterator extends DirectoryIterator
  implements RecursiveIterator {
  
  const CURRENT_AS_SELF     = 0x0;
  const CURRENT_AS_FILEINFO = 0x00000010;
  const CURRENT_AS_PATHNAME = 0x00000020;
  const KEY_AS_PATHNAME     = 0x0;
  const KEY_AS_FILENAME     = 0x00000100;
  const NEW_CURRENT_AND_KEY = 0x00000110;

  function __construct($path,
    $flags = RecursiveDirectoryIterator::CURRENT_AS_FILEINFO) {
    if (!hphp_recursivedirectoryiterator___construct($this, $path, $flags)) {
      throw new UnexpectedValueException(
          "RecursiveDirectoryIterator::__construct($path): failed to open dir");
    }
  }

  function current() {
    return hphp_recursivedirectoryiterator_current($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.key.php )
 *
 *
 * @return     mixed   The path and filename of the current dir entry.
 */
  function key() {
    return hphp_recursivedirectoryiterator_key($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.next.php )
 *
 *
 * @return     mixed   No value is returned.
 */
  public function next() {
    hphp_recursivedirectoryiterator_next($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.rewind.php )
 *
 *
 * @return     mixed   No value is returned.
 */
  public function rewind() {
    hphp_recursivedirectoryiterator_rewind($this);
  }

  public function seek($position) {
    hphp_recursivedirectoryiterator_seek($this, $position);
  }

  public function __toString() {
    return hphp_recursivedirectoryiterator___toString($this);
  }

  public function valid() {
    return hphp_recursivedirectoryiterator_valid($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.haschildren.php )
 *
 *
 * @return     mixed   Returns whether the current entry is a directory,
 *                     but not '.' or '..'
 */
  function hasChildren() {
    return hphp_recursivedirectoryiterator_haschildren($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.getchildren.php )
 *
 *
 * @return     mixed   An iterator for the current entry, if it is a
 *                     directory.
 */
  function getChildren() {
    return hphp_recursivedirectoryiterator_getchildren($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.getsubpath.php )
 *
 * Gets the sub path. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The sub path (sub directory).
 */
  function getSubPath() {
    return hphp_recursivedirectoryiterator_getsubpath($this);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/recursivedirectoryiterator.getsubpathname.php )
 *
 * Gets the sub path and filename. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The sub path (sub directory) and filename.
 */
  function getSubPathname() {
    return hphp_recursivedirectoryiterator_getsubpathname($this);
  }
}

/* vim: set expandtab tabstop=4 shiftwidth=4: */
// +----------------------------------------------------------------------+
// | Copyright (c) 2002-2004 Brent Cook                                        |
// +----------------------------------------------------------------------+
// | This library is free software; you can redistribute it and/or        |
// | modify it under the terms of the GNU Lesser General Public           |
// | License as published by the Free Software Foundation; either         |
// | version 2.1 of the License, or (at your option) any later version.   |
// |                                                                      |
// | This library is distributed in the hope that it will be useful,      |
// | but WITHOUT ANY WARRANTY; without even the implied warranty of       |
// | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    |
// | Lesser General Public License for more details.                      |
// |                                                                      |
// | You should have received a copy of the GNU Lesser General Public     |
// | License along with this library; if not, write to the Free Software  |
// | Foundation, Inc., 59 Temple Place, Suite 330,Boston,MA 02111-1307 USA|
// +----------------------------------------------------------------------+
// | Authors: Brent Cook <busterbcook@yahoo.com>                          |
// |          Jason Pell <jasonpell@hotmail.com>                          |
// +----------------------------------------------------------------------+
//
// $Id: Lexer.php,v 1.20 2004/05/07 12:33:35 busterb Exp $
//

// {{{ token definitions
// variables: 'ident', 'sys_var'
// values:    'real_val', 'text_val', 'int_val', null
// }}}

/**
 * A lexigraphical analyser inspired by the msql lexer
 *
 * @author  Brent Cook <busterbcook@yahoo.com>
 * @version 0.5
 * @access  public
 * @package SQL_Parser
 */
class FB_MySQLLexer
{
    // array of valid tokens for the lexer to recognize
    // format is 'token literal'=>TOKEN_VALUE
    var $symbols = array();

// {{{ instance variables
    var $tokPtr = 0;
    var $tokStart = 0;
    var $tokLen = 0;
    var $tokText = '';
    var $lineNo = 0;
    var $lineBegin = 0;
    var $string = '';
    var $stringLen = 0;

    // Will not be altered by skip()
    var $tokAbsStart = 0;
    var $skipText = '';

    // Provide lookahead capability.
    var $lookahead = 0;
    // Specify how many tokens to save in tokenStack, so the
    // token stream can be pushed back.
    var $tokenStack = array();
    var $stackPtr = 0;
// }}}

// {{{ incidental functions
    function __construct($string = '', $lookahead=0)
    {
        $this->string = $string;
        $this->stringLen = strlen($string);
        $this->lookahead = $lookahead;
    }

    function get() {
        ++$this->tokPtr;
        ++$this->tokLen;
        return ($this->tokPtr <= $this->stringLen) ? $this->string{$this->tokPtr - 1} : null;
    }

    function unget() {
        --$this->tokPtr;
        --$this->tokLen;
    }

    function skip() {
        ++$this->tokStart;
        return ($this->tokPtr != $this->stringLen) ? $this->string{$this->tokPtr++} : '';
    }

    function revert() {
        $this->tokPtr = $this->tokStart;
        $this->tokLen = 0;
    }

    function isCompop($c) {
        return (($c == '<') || ($c == '>') || ($c == '=') || ($c == '!'));
    }
// }}}

// {{{ pushBack()
/*
 * Push back a token, so the very next call to lex() will return that token.
 * Calls to this function will be ignored if there is no lookahead specified
 * to the constructor, or the pushBack() function has already been called the
 * maximum number of token's that can be looked ahead.
 */
function pushBack()
{
    if($this->lookahead>0 && count($this->tokenStack)>0 && $this->stackPtr>0) {
        $this->stackPtr--;
    }
}
// }}}

// {{{ lex()
function lex()
{
    if($this->lookahead>0) {
        // The stackPtr, should always be the same as the count of
        // elements in the tokenStack.  The stackPtr, can be thought
        // of as pointing to the next token to be added.  If however
        // a pushBack() call is made, the stackPtr, will be less than the
        // count, to indicate that we should take that token from the
        // stack, instead of calling nextToken for a new token.

        if ($this->stackPtr<count($this->tokenStack)) {

            $this->tokText = $this->tokenStack[$this->stackPtr]['tokText'];
            $this->skipText = $this->tokenStack[$this->stackPtr]['skipText'];
            $token = $this->tokenStack[$this->stackPtr]['token'];

            // We have read the token, so now iterate again.
            $this->stackPtr++;
            return $token;

        } else {

            // If $tokenStack is full (equal to lookahead), pop the oldest
            // element off, to make room for the new one.

            if ($this->stackPtr == $this->lookahead) {
                // For some reason array_shift and
                // array_pop screw up the indexing, so we do it manually.
                for($i=0; $i<(count($this->tokenStack)-1); $i++) {
                    $this->tokenStack[$i] = $this->tokenStack[$i+1];
                }

                // Indicate that we should put the element in
                // at the stackPtr position.
                $this->stackPtr--;
            }

            $token = $this->nextToken();
            $this->tokenStack[$this->stackPtr] =
                array('token'=>$token,
                      'tokText'=>$this->tokText,
                      'skipText'=>$this->skipText);
            $this->stackPtr++;
            return $token;
        }
    }
    else
    {
        return $this->nextToken();
    }
}
// }}}

// {{{ nextToken()
function nextToken()
{
    if ($this->string == '') return;
    $state = 0;
    $this->tokAbsStart = $this->tokStart;

    while (true){
        //echo "State: $state, Char: $c\n";
        switch($state) {
            // {{{ State 0 : Start of token
            case 0:
                $this->tokPtr = $this->tokStart;
                $this->tokText = '';
                $this->tokLen = 0;
                $c = $this->get();

                if (is_null($c)) { // End Of Input
                    $state = 1000;
                    break;
                }

                while (($c == ' ') || ($c == "\t")
                    || ($c == "\n") || ($c == "\r")) {
                    if ($c == "\n" || $c == "\r") {
                        // Handle MAC/Unix/Windows line endings.
                        if($c == "\r") {
                            $c = $this->skip();

                            // If not DOS newline
                            if($c != "\n")
                                $this->unget();
                        }
                        ++$this->lineNo;
                        $this->lineBegin = $this->tokPtr;
                    }

                       $c = $this->skip();
                    $this->tokLen = 1;
                }

                // Escape quotes and backslashes
                if ($c == '\\') {
                     $t = $this->get();
                    if ($t == '\'' || $t == '\\' || $t == '"') {
                        $this->tokText = $t;
                        $this->tokStart = $this->tokPtr;
                        return $this->tokText;
                    } else {
                      $this->unget();

                      // Unknown token.  Revert to single char
                      $state = 999;
                      break;
                    }
                }

                if (($c == '\'') || ($c == '"')) { // text string
                    $quote = $c;
                    $state = 12;
                    break;
                }

                if ($c == '_') { // system variable
                    $state = 18;
                    break;
                }

                if ($c == '`') { // escaped ident
                  $state = 20;
                  break;
                }

                if (ctype_alpha($c)) { // keyword or ident
                    $state = 1;
                    break;
                }

                if (ctype_digit($c)) { // real or int number
                    $state = 5;
                    break;
                }

                if ($c == '.') {
                    $t = $this->get();
                    if ($t == '.') { // ellipsis
                        if ($this->get() == '.') {
                            $this->tokText = '...';
                            $this->tokStart = $this->tokPtr;
                            return $this->tokText;
                        } else {
                            $state = 999;
                            break;
                        }
                    } else if (ctype_digit($t)) { // real number
                        $this->unget();
                        $state = 7;
                        break;
                    } else { // period
                        $this->unget();
                    }
                }

                if ($c == '#') { // Comments
                    $state = 14;
                    break;
                }
                if ($c == '-') {
                    $t = $this->get();
                    if ($t == '-') {
                      $state = 14;
                      break;
                    } else {
                      // negative number ... or - used as an operator
                      $state = 999;
                      break;
                    }
                }

                if ($this->isCompop($c)) { // comparison operator
                    $state = 10;
                    break;
                }
                // Unknown token.  Revert to single char
                $state = 999;
                break;
            // }}}

            // {{{ State 1 : Incomplete keyword or ident
            case 1:
                $c = $this->get();
                if (ctype_alnum($c) || ($c == '_')) {
                    $state = 1;
                    break;
                }
                $state = 2;
                break;
            // }}}

            // {{{ State 20 : Incomplete keyword or ident
          case 20:
            do {
              $c = $this->get();
            } while ('`' != $c);

            $c = $this->get();
            $state = 2;
            break;
            // }}}

            /* {{{ State 2 : Complete keyword or ident */
            case 2:
                $this->unget();
                $this->tokText = substr($this->string, $this->tokStart,
                                        $this->tokLen);

                $testToken = strtolower($this->tokText);
                if (isset($this->symbols[$testToken])) {

                    $this->skipText = substr($this->string, $this->tokAbsStart,
                                            $this->tokStart-$this->tokAbsStart);
                    $this->tokStart = $this->tokPtr;
                    return $testToken;
                } else {
                    $this->skipText = substr($this->string, $this->tokAbsStart,
                                            $this->tokStart-$this->tokAbsStart);
                    $this->tokStart = $this->tokPtr;
                    $this->tokText  = trim($this->tokText, '`');
                    return 'ident';
                }
                break;
            // }}}

            // {{{ State 5: Incomplete real or int number
            case 5:
                $c = $this->get();
                if (ctype_digit($c)) {
                    $state = 5;
                    break;
                } else if ($c == '.') {
                    $t = $this->get();
                    if ($t == '.') { // ellipsis
                        $this->unget();
                    } else { // real number
                        $state = 7;
                        break;
                    }
                } else if(ctype_alpha($c)) { // number must end with non-alpha character
                    $state = 999;
                    break;
                } else {
                  // complete number
                  $state = 6;
                  break;
                }
            // }}}

            // {{{ State 6: Complete integer number
            case 6:
                $this->unget();
                $this->tokText = intval(substr($this->string, $this->tokStart,
                                               $this->tokLen));
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return 'int_val';
                break;
            // }}}

            // {{{ State 7: Incomplete real number
            case 7:
                $c = $this->get();

                /* Analogy Start */
                if ($c == 'e' || $c == 'E') {
                        $state = 15;
                        break;
                }
                /* Analogy End   */

                if (ctype_digit($c)) {
                    $state = 7;
                    break;
                }
                $state = 8;
                break;
            // }}}

            // {{{ State 8: Complete real number */
            case 8:
                $this->unget();
                $this->tokText = floatval(substr($this->string, $this->tokStart,
                                        $this->tokLen));
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return 'real_val';
            // }}}

            // {{{ State 10: Incomplete comparison operator
            case 10:
                $c = $this->get();
                if ($this->isCompop($c))
                {
                    $state = 10;
                    break;
                }
                $state = 11;
                break;
            // }}}

            // {{{ State 11: Complete comparison operator
            case 11:
                $this->unget();
                $this->tokText = substr($this->string, $this->tokStart,
                                        $this->tokLen);
                if($this->tokText) {
                    $this->skipText = substr($this->string, $this->tokAbsStart,
                                            $this->tokStart-$this->tokAbsStart);
                    $this->tokStart = $this->tokPtr;
                    return $this->tokText;
                }
                $state = 999;
                break;
            // }}}

            // {{{ State 12: Incomplete text string
            case 12:
                $bail = false;
                $text = '';
                while (!$bail) {
                    $c = $this->get();
                    switch ($c) {
                        case '':
                            $this->tokText = null;
                            $bail = true;
                            break;
                        case "\\":
                            $c = $this->get();
                            switch ($c) {
                              // undo mysql_escape_string
                              case '0':
                                $text .= "\0";
                                break;
                              case 'r':
                                $text .= "\r";
                                break;
                              case 'n':
                                $text .= "\n";
                                break;
                              case 'Z':
                                $text .= "\x1a";
                                break;
                              default:
                                if (!$c) {
                                  $this->tokText = null;
                                  $bail = true;
                                } else {
                                  $text .= $c;
                                }
                            }
                            break;
                        case $quote:
                          $this->tokText = $text;
                          $bail = true;
                          break;
                        default:
                          $text .= $c;
                          break;
                    }
                }
                if (!is_null($this->tokText)) {
                    $state = 13;
                    break;
                }
                $state = 999;
                break;
            // }}}

            // {{{ State 13: Complete text string
            case 13:
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return 'text_val';
                break;
            // }}}

            // {{{ State 14: Comment
            case 14:
                $c = $this->skip();
                if ($c == "\n" || $c == "\r" || $c == "") {
                    // Handle MAC/Unix/Windows line endings.
                    if ($c == "\r") {
                        $c = $this->skip();
                        // If not DOS newline
                        if ($c != "\n") {
                            $this->unget();
                        }
                    }

                    if ($c != "") {
                        ++$this->lineNo;
                        $this->lineBegin = $this->tokPtr;
                    }

                    // We need to skip all the text.
                    $this->tokStart = $this->tokPtr;
                    $state = 0;
                } else {
                    $state = 14;
                }
                break;
            // }}}

            // {{{ State 15: Exponent Sign in Scientific Notation
            case 15:
                    $c = $this->get();
                    if($c == '-' || $c == '+') {
                            $state = 16;
                            break;
                    }
                    $state = 999;
                    break;
            // }}}

            // {{{ state 16: Exponent Value-first digit in Scientific Notation
            case 16:
                    $c = $this->get();
                    if (ctype_digit($c)) {
                            $state = 17;
                            break;
                    }
                    $state = 999;  // if no digit, then token is unknown
                    break;
            // }}}

            // {{{ State 17: Exponent Value in Scientific Notation
            case 17:
                    $c = $this->get();
                    if (ctype_digit($c)) {
                            $state = 17;
                            break;
                    }
                    $state = 8;  // At least 1 exponent digit was required
                    break;
            // }}}

            // {{{ State 18 : Incomplete System Variable
            case 18:
                $c = $this->get();
                if (ctype_alnum($c) || $c == '_') {
                    $state = 18;
                    break;
                }
                $state = 19;
                break;
            // }}}

            // {{{ State 19: Complete Sys Var
            case 19:
                $this->unget();
                $this->tokText = substr($this->string, $this->tokStart,
                                        $this->tokLen);
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return 'sys_var';
            // }}}

            // {{{ State 999 : Unknown token.  Revert to single char
            case 999:
                $this->revert();
                $this->tokText = $this->get();
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return $this->tokText;
            // }}}

            // {{{ State 1000 : End Of Input
            case 1000:
                $this->tokText = '*end of input*';
                $this->skipText = substr($this->string, $this->tokAbsStart,
                                         $this->tokStart-$this->tokAbsStart);
                $this->tokStart = $this->tokPtr;
                return null;
            // }}}
        }
    }
}
// }}}
}

///////////////////////////////////////////////////////////////////////////////
// helpers

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflector.php )
 *
 * Reflector is an interface implemented by all exportable Reflection
 * classes.
 *
 */
interface Reflector {
  public function __toString();
}

class ReflectionException extends Exception {
}

///////////////////////////////////////////////////////////////////////////////
// parameter

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionparameter.php )
 *
 * The ReflectionParameter class retrieves information about a function's
 * or method's parameters.
 *
 * To introspect function parameters, first create an instance of the
 * ReflectionFunction or ReflectionMethod classes and then use their
 * ReflectionFunctionAbstract::getParameters() method to retrieve an array
 * of parameters.
 *
 */
class ReflectionParameter implements Reflector {
  public $info;

  public function __construct($func, $param) {
    if ($func && $param) {
      $params = $func->getParameters();
      $this->info = $params[$param]->info;
    }
  }

  public function __toString() {
    // TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.export.php )
 *
 * Exports. WarningThis function is currently not documented; only its
 * argument list is available.
 *
 * @func       mixed   The function name.
 * @param      mixed   The parameter name.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   The exported reflection.
 */
  public static function export($func, $param, $ret=false) {
    $obj = new ReflectionParameter($func, $param);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.getname.php
 * )
 *
 * Gets the name of the parameter.
 *
 * @return     mixed   The name of the reflected parameter.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.ispassedbyreference.php )
 *
 * Checks if the parameter is passed in by reference. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if the parameter is passed in by reference,
 *                     otherwise FALSE
 */
  public function isPassedByReference() {
    return isset($this->info['ref']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getdeclaringclass.php )
 *
 * Gets the declaring class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

  public function getDeclaringFunction() {
    if (empty($this->info['class'])) {
      return new ReflectionFunction($this->info['function']);
    }
    return new ReflectionMethod($this->info['class'], $this->info['function']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.getclass.php
 * )
 *
 * Gets a class. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getClass() {
    if (empty($this->info['type'])) {
      return null;
    }
    $ltype = strtolower($this->info['type']);
    if (hphp_scalar_typehints_enabled()) {
      $nonClassTypehints = array(
        'bool' => 1,
        'boolean' => 1,
        'int' => 1,
        'integer' => 1,
        'real' => 1,
        'double' => 1,
        'float' => 1,
        'string' => 1,
        'array' => 1
      );
      if (isset($nonClassTypehints[$ltype])) {
        return null;
      }
    } else if ($ltype === 'array') {
      return null;
    }
    return new ReflectionClass($this->info['type']);
  }

  public function getTypehintText() {
    if (isset($this->info['type'])) {
      return $this->info['type'];
    }
    return '';
  }

  public function getTypeText() {
    if (isset($this->info['type_hint'])) {
      return $this->info['type_hint'];
    }
    return '';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionparameter.isarray.php
 * )
 *
 * Checks if the parameter expects an array.
 *
 * @return     mixed   TRUE if an array is expected, FALSE otherwise.
 */
  public function isArray() {
    return $this->info['type'] == 'array';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.allowsnull.php )
 *
 * Checks whether the parameter allows NULL. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if NULL is allowed, otherwise FALSE
 */
  public function allowsNull() {
    return isset($this->info['nullable']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.isoptional.php )
 *
 * Checks if the parameter is optional.
 *
 * @return     mixed   TRUE if the parameter is optional, otherwise FALSE
 */
  public function isOptional() {
    return array_key_exists('default', $this->info);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.isdefaultvalueavailable.php
 * )
 *
 * Checks if a default value for the parameter is available.
 *
 * @return     mixed   TRUE if a default value is available, otherwise
 *                     FALSE
 */
  public function isDefaultValueAvailable() {
    return array_key_exists('default', $this->info);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getdefaultvalue.php )
 *
 * Gets the default value of the parameter for a user-defined function or
 * method. If the parameter is not optional a ReflectionException will be
 * thrown.
 *
 * @return     mixed   The parameters default value.
 */
  public function getDefaultValue() {
    if (!$this->isOptional()) {
      throw new ReflectionException('Parameter is not optional');
    }
    $defaultValue = $this->info['default'];
    if ($defaultValue instanceof stdclass) {
      if (isset($defaultValue->class)) {
        return hphp_get_class_constant($defaultValue->class,
                                       $defaultValue->name);
      }
      hphp_throw_fatal_error($defaultValue->msg);
    }
    return $defaultValue;
  }

  public function getDefaultValueText() {
    if (isset($this->info['defaultText'])) {
      return $this->info['defaultText'];
    }
    return '';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionparameter.getposition.php )
 *
 * Gets the position of the parameter.
 *
 * @return     mixed   The position of the parameter, left to right,
 *                     starting at position #0.
 */
  public function getPosition() {
    return $this->info['index'];
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->getAttributesRecursive();
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    if (!isset($this->info['class'])) {
      return $this->getAttributes();
    }

    $attrs = array();
    $class = $this->getDeclaringClass();
    $function_name = $this->info['function'];
    $index = $this->info['index'];
    self::collectAttributes(&$attrs, $class, $function_name, $index);
    return $attrs;
  }

  private static function collectAttributes(&$attrs, $class, $function_name,
                                            $index) {
    if ($class->hasMethod($function_name)) {
      $method = $class->getMethod($function_name);
      $params = $method->getParameters();
      if (count($params) >= $index) {
        $attrs += $params[$index]->getAttributes();
      }
    }

    $parent = $class->getParentClass();
    if ($parent) {
      self::collectAttributes(
        &$attrs,
        $parent,
        $function_name,
        $index);
    }
  }
}

///////////////////////////////////////////////////////////////////////////////

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/class.reflectionfunctionabstract.php )
 *
 * A parent class to ReflectionFunction, read its description for details.
 *
 */
class ReflectionFunctionAbstract {
  public $info;

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getname.php )
 *
 * Get the name of the function. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The name of the function.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.isinternal.php )
 *
 * Checks whether the function is internal, as opposed to user-defined.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   TRUE if it's internal, otherwise FALSE
 */
  public function isInternal() {
    return isset($this->info['internal']);
  }

  public function getClosure() {
    return $this->info['closure'];
  }

  public function isClosure() {
    return !empty($this->info['is_closure']);
  }

  public function isGenerator() {
    return !empty($this->info['is_generator']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.isuserdefined.php )
 *
 * Checks whether the function is user-defined, as opposed to internal.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   TRUE if it's user-defined, otherwise false;
 */
  public function isUserDefined() {
    return !isset($this->info['internal']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getfilename.php )
 *
 * Gets the file name from a user-defined function. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   The file name.
 */
  public function getFileName() {
    return $this->info['file'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getstartline.php )
 *
 * Gets the starting line number of the function. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   The starting line number.
 */
  public function getStartLine() {
    return $this->info['line1'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getendline.php )
 *
 * Get the ending line number. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The ending line number of the user defined class, or
 *                     FALSE if unknown.
 */
  public function getEndLine() {
    return $this->info['line2'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getdoccomment.php )
 *
 * Get a Doc comment from a function. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   The doc comment if it exists, otherwise FALSE
 */
  public function getDocComment() {
    return $this->info['doc'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getstaticvariables.php
 * )
 *
 * Get the static variables. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   An array of static variables.
 */
  public function getStaticVariables() {
    return $this->info['static_variables'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.returnsreference.php
 * )
 *
 * Checks whether the function returns a reference. WarningThis function
 * is currently not documented; only its argument list is available.
 *
 * @return     mixed   TRUE if it returns a reference, otherwise FALSE
 */
  public function returnsReference() {
    return isset($this->info['ref']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getparameters.php )
 *
 * Get the parameters as an array of ReflectionParameter. WarningThis
 * function is currently not documented; only its argument list is
 * available.
 *
 * @return     mixed   The parameters, as a ReflectionParameter object.
 */
  public function getParameters() {
    $ret = array();
    foreach ($this->info['params'] as $name => $info) {
      $param = new ReflectionParameter(null, null);
      $param->info = $info;
      $ret[] = $param;
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getnumberofparameters.php
 * )
 *
 * Get the number of parameters that a function defines, both optional and
 * required. WarningThis function is currently not documented; only its
 * argument list is available.
 *
 * @return     mixed   The number of parameters.
 */
  public function getNumberOfParameters() {
    return count($this->info['params']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunctionabstract.getnumberofrequiredparameters.php
 * )
 *
 * Get the number of required parameters that a function defines.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   The number of required parameters.
 */
  public function getNumberOfRequiredParameters() {
    $count = 0;
    $params = $this->getParameters();
    foreach ($params as $name => $param) {
      if ($param->isOptional()) {
        break;
      }
      $count++;
    }
    return $count;
  }

  public function getReturnTypeText() {
    if (isset($this->info['return_type'])) {
      return $this->info['return_type'];
    }
    return '';
  }
}

///////////////////////////////////////////////////////////////////////////////
// function

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionfunction.php )
 *
 * The ReflectionFunction class reports information about a function.
 *
 * Parent class ReflectionFunctionAbstract has the same methods except
 * invoke(), invokeArgs(), export() and isDisabled().
 *
 */
class ReflectionFunction extends ReflectionFunctionAbstract
implements Reflector {
  const IS_DEPRECATED = 262144;

  public function __construct($name) {
    if ($name instanceof Closure) {
      $this->info = hphp_get_closure_info($name);
    } else {
      $this->info = hphp_get_function_info($name);
      if (empty($this->info)) {
        throw new ReflectionException("Function $name does not exist");
      }
    }
  }

  public function __toString() {
    //TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionfunction.export.php )
 *
 * Exports a Reflected function. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionFunction($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionfunction.invoke.php )
 *
 * Invokes a reflected function.
 *
 */
  public function invoke() {
    $args = func_get_args();
    if (isset($this->info['closureobj'])) {
      $closure = $this->info['closureobj'];
      return hphp_invoke_method($closure, get_class($closure),
                                '__invoke', $args);
    }
    return hphp_invoke($this->info['name'], $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionfunction.invokeargs.php )
 *
 * Invokes args. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @args       mixed   The args to invoke.
 */
  public function invokeArgs($args) {
    if (isset($this->info['closureobj'])) {
      $closure = $this->info['closureobj'];
      return hphp_invoke_method($closure, get_class($closure),
                                '__invoke', array_values($args));
    }
    return hphp_invoke($this->info['name'], array_values($args));
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    return $this->info['attributes'];
  }
}

///////////////////////////////////////////////////////////////////////////////
// class

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionclass.php )
 *
 * The ReflectionClass class reports information about a class.
 *
 */
class ReflectionClass implements Reflector {
  const IS_IMPLICIT_ABSTRACT = 16 ;
  const IS_EXPLICIT_ABSTRACT = 32 ;
  const IS_FINAL = 64 ;

  public $name;
  private $info = null;
  private static $fetched = array();

  public function __construct($name) {
    if (is_object($name)) {
      $name = get_class($name);
    }

    $this->name = hphp_get_original_class_name($name);
    if (empty($this->name)) {
      throw new ReflectionException("Class $name does not exist");
    }
  }

  private function fetch($what) {
    if (!$this->info) {
      $this->info = self::fetch_recur($this->name);
      $this->info['properties'] += $this->info['private_properties'];
    }
    return $this->info[$what];
  }

  private static function fetch_recur($name) {
    if (isset(self::$fetched[$name])) return self::$fetched[$name];
    $info = hphp_get_class_info($name);
    if (empty($info)) {
      throw new ReflectionException("Class $name does not exist");
    }

    $info['attributes_rec'] = $info['attributes'];

    $abstract = isset($info['abstract']) || isset($info['interface']);
    // flattening the trees, so it's easier for lookups
    foreach ($info['interfaces'] as $interface => $_) {
      $p = self::fetch_recur($interface);
      if ($abstract) $info['methods'] += $p['methods'];
      $info['constants'] += $p['constants'];
      $info['interfaces'] += $p['interfaces'];
    }

    $parent = $info['parent'];
    if (!empty($parent)) {
      $p = self::fetch_recur($parent);
      if (isset($p['interface'])) {
        $info['interfaces'][$parent] = 1;
      } else {
        $info['properties'] += $p['properties'];
      }
      $info['methods'] += $p['methods'];
      $info['constants']  += $p['constants'];
      $info['interfaces'] += $p['interfaces'];
      $info['attributes_rec'] += $p['attributes_rec'];
    }
    self::$fetched[$name] = $info;
    return $info;
  }

  private function check($what) {
    if (!$this->info) {
      $this->info = self::fetch_recur($this->name);
    }
    return isset($this->info[$what]);
  }

  private function test($what, $name) {
    $v = $this->fetch($what);
    return $v && isset($v[$name]);
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.export.php )
 *
 * Exports a reflected class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionClass($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getname.php )
 *
 * Gets the class name. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The class name.
 */
  public function getName() {
    return $this->name;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinternal.php )
 *
 * Checks whether the class is internal, as opposed to user-defined.
 * WarningThis function is currently not documented; only its argument list
 * is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInternal() {
    return $this->check('internal');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isuserdefined.php )
 *
 * Checks whether the class is user-defined, as opposed to internal.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isUserDefined() {
    return !$this->check('internal');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isinstantiable.php )
 *
 * Checks if the class is instanciable. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInstantiable() {
    return !$this->check('abstract');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasconstant.php
 * )
 *
 * Checks whether the class has a specific constant defined or not.
 *
 * @name       mixed   The name of the constant being checked for.
 *
 * @return     mixed   TRUE if the constant is defined, otherwise FALSE.
 */
  public function hasConstant($name) {
    return $this->test('constants', $name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasmethod.php )
 *
 * Checks whether a specific method is defined in a class.
 *
 * @name       mixed   Name of the method being checked for.
 *
 * @return     mixed   TRUE if it has the method, otherwise FALSE
 */
  public function hasMethod($name) {
    return $this->test('methods', strtolower($name));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.hasproperty.php
 * )
 *
 * Checks whether the specified property is defined.
 *
 * @name       mixed   Name of the property being checked for.
 *
 * @return     mixed   TRUE if it has the property, otherwise FALSE
 */
  public function hasProperty($name) {
    return $this->test('properties', $name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getfilename.php
 * )
 *
 * Gets the filename of the file in which the class has been defined.
 *
 * @return     mixed   Returns the filename of the file in which the class
 *                     has been defined. If the class is defined in the PHP
 *                     core or in a PHP extension, FALSE is returned.
 */
  public function getFileName() {
    return $this->fetch('file');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getstartline.php
 * )
 *
 * Get the starting line number. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The starting line number, as an integer.
 */
  public function getStartLine() {
    return $this->fetch('line1');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getendline.php )
 *
 * Gets end line number from a user-defined class definition.
 *
 * @return     mixed   The ending line number of the user defined class, or
 *                     FALSE if unknown.
 */
  public function getEndLine() {
    return $this->fetch('line2');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getdoccomment.php )
 *
 * Gets doc comments from a class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The doc comment if it exists, otherwise FALSE
 */
  public function getDocComment() {
    return $this->fetch('doc');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getconstructor.php )
 *
 * Gets the constructor from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionMethod object.
 */
  public function getConstructor() {
    if ($this->hasMethod('__construct')) {
      return $this->getMethod('__construct');
    }
    if (!$this->isTrait() && $this->hasMethod($name = $this->name)) {
      return $this->getMethod($name);
    }
    return null;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmethod.php )
 *
 * Gets a ReflectionMethod about a method. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @name       mixed   The method name to reflect.
 *
 * @return     mixed   A ReflectionMethod.
 */
  public function getMethod($name) {
    if (!$this->info) {
      $method = hphp_get_method_info($this->name, $name);
    } else {
      $lname = strtolower($name);
      $methods = $this->info['methods'];
      if (isset($methods[$lname])) $method = $methods[$lname];
    }
    if (empty($method)) {
      $class = $this->name;
      throw new ReflectionException("Method $class::$name does not exist");
    }

    $ret = new ReflectionMethod(null, null);
    $ret->info  = $method;
    $ret->name  = $method['name'];
    $ret->class = $method['class'];
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmethods.php )
 *
 * Gets a list of methods. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @filter     mixed   Any combination of ReflectionMethod::IS_STATIC,
 *                     ReflectionMethod::IS_PUBLIC,
 *                     ReflectionMethod::IS_PROTECTED,
 *                     ReflectionMethod::IS_PRIVATE,
 *                     ReflectionMethod::IS_ABSTRACT,
 *                     ReflectionMethod::IS_FINAL.
 *
 * @return     mixed   An array of methods.
 */
  public function getMethods($filter = 0xFFFF) {
    $ret = array();
    $methods = $this->fetch('methods');
    foreach ($methods as $name => $_) {
      $m = $this->getMethod($name);
      if ((($filter & ReflectionMethod::IS_PUBLIC))    && $m->isPublic()    ||
          (($filter & ReflectionMethod::IS_PROTECTED)) && $m->isProtected() ||
          (($filter & ReflectionMethod::IS_PRIVATE))   && $m->isPrivate()   ||
          (($filter & ReflectionMethod::IS_STATIC))    && $m->isStatic()    ||
          (($filter & ReflectionMethod::IS_FINAL))     && $m->isFinal()     ||
          (($filter & ReflectionMethod::IS_ABSTRACT    && $m->isAbstract()))) {
        $ret[] = $m;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getproperty.php
 * )
 *
 * Gets a property. WarningThis function is currently not documented; only
 * its argument list is available.
 *
 * @name       mixed   The property name.
 *
 * @return     mixed   A ReflectionProperty.
 */
  public function getProperty($name) {
    $properties = $this->fetch('properties');
    if (!isset($properties[$name])) {
      $class = $this->info['name'];
      throw new ReflectionException("Property $class::$name does not exist");
    }

    $ret = new ReflectionProperty(null, null);
    $ret->info  = $properties[$name];
    $ret->name  = $name;
    $ret->class = $this->info['name'];
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getproperties.php )
 *
 * Retrieves reflected properties.
 *
 * @return     mixed   An array of ReflectionProperty objects.
 */
  public function getProperties($filter = 0xFFFF) {
    $ret = array();
    foreach ($this->fetch('properties') as $name => $_) {
      $p = $this->getProperty($name);
      if (($filter & ReflectionProperty::IS_PUBLIC)    && $p->isPublic()    ||
          ($filter & ReflectionProperty::IS_PROTECTED) && $p->isProtected() ||
          ($filter & ReflectionProperty::IS_PRIVATE)   && $p->isPrivate()   ||
          ($filter & ReflectionProperty::IS_STATIC)    && $p->isStatic()) {
        $ret[] = $p;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getconstants.php
 * )
 *
 * Gets defined constants from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   An array of constants.
 */
  public function getConstants() {
    return $this->fetch('constants');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getconstant.php
 * )
 *
 * Gets the defined constants. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed
 */
  public function getConstant($name) {
    $constants = $this->fetch('constants');
    if (!isset($constants[$name])) {
      $class = $this->info['name'];
      throw new ReflectionException("Class constant $class::$name does not exist");
    }
    return $constants[$name];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getinterfaces.php )
 *
 * Gets the interfaces.
 *
 * @return     mixed   An associative array of interfaces, with keys as
 *                     interface names and the array values as
 *                     ReflectionClass objects.
 */
  public function getInterfaces() {
    $ret = array();
    foreach ($this->fetch('interfaces') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isInterface()) {
        $ret[$cls->getName()] = $cls;
      }
    }
    return $ret;
  }

  public function getTraits() {
    $ret = array();
    foreach ($this->fetch('traits') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isTrait()) {
        $ret[$cls->getName()] = $cls;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getinterfacenames.php )
 *
 * Get the interface names.
 *
 * @return     mixed   A numerical array with interface names as the
 *                     values.
 */
  public function getInterfaceNames() {
    $ret = array();
    foreach ($this->fetch('interfaces') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isInterface()) {
        $ret[] = $cls->getName();
      }
    }
    return $ret;
  }

  public function getTraitNames() {
    $ret = array();
    foreach ($this->fetch('traits') as $name => $_) {
      $cls = new ReflectionClass($name);
      if ($cls->isTrait()) {
        $ret[] = $cls->getName();
      }
    }
    return $ret;
  }

  public function getTraitAliases() {
    $ret = array();
    foreach ($this->fetch('trait_aliases') as $old_name => $new_name) {
      $ret[$old_name] = $new_name;
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinterface.php
 * )
 *
 * Checks whether the class is an interface. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInterface() {
    return $this->check('interface');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isabstract.php )
 *
 * Checks if the class is abstract.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isAbstract() {
    return $this->check('abstract');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isfinal.php )
 *
 * Checks if a class is final.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isFinal() {
    return $this->check('final');
  }

  public function isTrait() {
    return $this->check('trait');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getmodifiers.php
 * )
 *
 * WarningThis function is currently not documented; only its argument
 * list is available.
 *
 */
  public function getModifiers() {
    return $this->fetch('modifiers');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.isinstance.php )
 *
 * Checks if an object is an instance of a class.
 *
 * @obj        mixed   The object being compared to.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isInstance($obj) {
    return hphp_instanceof($obj, $this->name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.newinstance.php
 * )
 *
 * Creates a new cass instance of the class, the given arguments are
 * passed to the class constructor.
 *
 */
  public function newInstance() {
    $args = func_get_args();
    return hphp_create_object($this->name, $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.newinstanceargs.php )
 *
 * Creates a new cass instance of the class, the given arguments are
 * passed to the class constructor. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @args       mixed   The parameters to be passed to the class constructor
 *                     as an array.
 *
 * @return     mixed   Returns a new instance of the class.
 */
  public function newInstanceArgs($args) {
    return hphp_create_object($this->name, array_values($args));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.newinstancewithoutconstructor.php )
 *
 * Creates a new instance of the class without invoking the constructor.
 *
 * @return     mixed   Returns a new instance of the class.
 */
  public function newInstanceWithoutConstructor() {
    return hphp_create_object_without_constructor($this->name);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getparentclass.php )
 *
 * WarningThis function is currently not documented; only its argument
 * list is available.
 *
 * @return     mixed   A ReflectionClass.
 */
  public function getParentClass() {
    $parent = $this->fetch('parent');
    if (empty($parent)) {
      return false;
    }
    return new ReflectionClass($parent);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.issubclassof.php
 * )
 *
 * Checks if the class is a subclass of a specified class.
 *
 * @cls        mixed   The class name being checked against.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isSubclassOf($cls) {
    if ($cls instanceof ReflectionClass) {
      $cls = $cls->name;
    }
    foreach ($this->fetch('interfaces') as $name => $_) {
      if (strcasecmp($cls, $name) == 0) {
        return true;
      }
    }
    $parent = $this->fetch('parent');
    if (empty($parent)) {
      return false;
    }
    if (strcasecmp($cls, $parent) == 0) {
      return true;
    }
    return $this->getParentClass()->isSubclassOf($cls);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getstaticproperties.php )
 *
 * Get the static properties. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The static properties, as an array.
 */
  public function getStaticProperties() {
    $ret = array();
    foreach ($this->getProperties() as $prop) {
      if ($prop->isStatic()) {
        $ret[$prop->name] = $prop;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getstaticpropertyvalue.php )
 *
 * Gets the static property values. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed
 * @default    mixed
 */
  public function getStaticPropertyValue($name, $default = null) {
    if ($this->hasProperty($name) &&
        $this->getProperty($name)->isStatic()) {
      return hphp_get_static_property($this->name, $name);
    }
    return $default;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.setstaticpropertyvalue.php )
 *
 * Sets static property value. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @name       mixed   Property name.
 * @value      mixed   New property value.
 *
 * @return     mixed   No value is returned.
 */
  public function setStaticPropertyValue($name, $value) {
    hphp_set_static_property($this->name, $name, $value);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getdefaultproperties.php )
 *
 * Gets default properties from a class. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @return     mixed   An array of default properties.
 */
  public function getDefaultProperties() {
    $ret = array();
    foreach ($this->getProperties() as $prop) {
      if ($prop->isDefault()) {
        $ret[$prop->name] = $prop;
      }
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.isiterateable.php )
 *
 * Checks whether the class is iterateable.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function isIterateable() {
    return $this->isSubclassOf('ArrayAccess');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.implementsinterface.php )
 *
 * Checks whether it implements an interface.
 *
 * @cls        mixed   The interface name.
 *
 * @return     mixed   Returns TRUE on success or FALSE on failure.
 */
  public function implementsInterface($cls) {
    if ($cls instanceof ReflectionClass) {
      $cls = $cls->name;
    }
    if (!interface_exists($cls)) {
      throw new ReflectionException("$cls is not an Interface");
    }
    foreach ($this->fetch('interfaces') as $name => $_) {
      if (strcasecmp($cls, $name) == 0) {
        return true;
      }
    }
    return false;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionclass.getextension.php
 * )
 *
 * Gets an extensions ReflectionExtension object. WarningThis function is
 * currently not documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionExtension object.
 */
  public function getExtension() {
    return $this->fetch('extension');
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionclass.getextensionname.php )
 *
 * Gets an extensions name. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The extensions name.
 */
  public function getExtensionName() {
    return $this->fetch('extension')->getName();
  }

  public function getAttribute($name) {
    $attrs = $this->fetch('attributes');
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->fetch('attributes');
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->fetch('attributes_rec');
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributesRecursive() {
    return $this->fetch('attributes_rec');
  }
}

///////////////////////////////////////////////////////////////////////////////
// object

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionobject.php )
 *
 * The ReflectionObject class reports information about an object.
 *
 */
class ReflectionObject extends ReflectionClass {
// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionobject.export.php )
 *
 * Exports a reflection. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @obj        mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($obj, $ret=false) {
    $obj = new ReflectionObject($obj);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }
}

///////////////////////////////////////////////////////////////////////////////
// property

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionproperty.php )
 *
 * The ReflectionProperty class reports information about a classes
 * properties.
 *
 */
class ReflectionProperty implements Reflector {
  const IS_STATIC = 1;
  const IS_PUBLIC = 256;
  const IS_PROTECTED = 512;
  const IS_PRIVATE = 1024;

  public $info;
  public $name;
  public $class;

  public function __construct($cls, $name) {
    if ($cls && $name) {
      if (!is_object($cls)) {
        $cls = new ReflectionClass($cls);
      } else {
        $cls = new ReflectionClass(get_class($cls));
      }
      $prop = $cls->getProperty($name);
      if ($prop) {
        $this->info  = $prop->info;
        $this->name  = $prop->name;
        $this->class = $prop->class;
      }
    }
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.export.php )
 *
 * Exports a reflection. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @cls        mixed   The reflection to export.
 * @name       mixed   The property name.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 */
  public static function export($cls, $name, $ret=false) {
    if (!is_object($cls)) {
      $cls = new ReflectionClass($cls);
    } else {
      $cls = new ReflectionClass(get_class($cls));
    }
    $obj = $cls->getProperty($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.getname.php )
 *
 * Gets the properties name. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   The name of the reflected property.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.ispublic.php
 * )
 *
 * Checks whether the property is public.
 *
 * @return     mixed   TRUE if the property is public, FALSE otherwise.
 */
  public function isPublic() {
    return $this->info['access'] == 'public';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isprivate.php
 * )
 *
 * Checks whether the property is private.
 *
 * @return     mixed   TRUE if the property is private, FALSE otherwise.
 */
  public function isPrivate() {
    return $this->info['access'] == 'private';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.isprotected.php )
 *
 * Checks whether the property is protected.
 *
 * @return     mixed   TRUE if the property is protected, FALSE otherwise.
 */
  public function isProtected() {
    return $this->info['access'] == 'protected';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isstatic.php
 * )
 *
 * Checks whether the property is static.
 *
 * @return     mixed   TRUE if the property is static, FALSE otherwise.
 */
  public function isStatic() {
    return isset($this->info['static']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.isdefault.php
 * )
 *
 * Checks whether the property is the default.
 *
 * @return     mixed   TRUE if the property was declared at compile-time,
 *                     or FALSE if it was created at run-time.
 */
  public function isDefault() {
    return $this->info['default'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.setaccessible.php )
 *
 * Sets a property to be accessible. For example, it may allow protected
 * and private properties to be accessed.
 *
 * @return     mixed   No value is returned.
 */
  public function setAccessible($accessible) {
    throw new ReflectionException(__METHOD__." is not supported");
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getmodifiers.php )
 *
 * Gets the modifiers. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   A numeric representation of the modifiers.
 */
  public function getModifiers() {
    return $this->info['modifiers'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.getvalue.php
 * )
 *
 * Gets the properties value. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @obj        mixed   The object being reflected.
 *
 * @return     mixed   The current value of the property.
 */
  public function getValue($obj = null) {
    if ($this->isStatic()) {
      return hphp_get_static_property($this->info['class'],
                                      $this->info['name']);
    }
    if ($obj) {
      return hphp_get_property($obj, $this->info['class'],
                               $this->info['name']);
    }
    return null;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionproperty.setvalue.php
 * )
 *
 * Sets (changes) a properties value. WarningThis function is currently
 * not documented; only its argument list is available.
 *
 * @obj        mixed   The object name.
 * @value      mixed   The new value.
 *
 * @return     mixed   No value is returned.
 */
  public function setValue($obj, $value) {
    if ($this->isStatic()) {
      hphp_set_static_property($this->info['class'], $this->info['name'],
                               $value);
    } else {
      hphp_set_property($obj, $this->info['class'], $this->info['name'],
                        $value);
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getdeclaringclass.php )
 *
 * Gets the declaring class. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   A ReflectionClass object.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionproperty.getdoccomment.php )
 *
 * Gets the doc comment. WarningThis function is currently not documented;
 * only its argument list is available.
 *
 * @return     mixed   The doc comment.
 */
  public function getDocComment() {
    return $this->info['doc'];
  }

  public function getTypeText() {
    if (isset($this->info['type'])) {
      return $this->info['type'];
    }
    return '';
  }
}

///////////////////////////////////////////////////////////////////////////////
// method

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionmethod.php )
 *
 * The ReflectionMethod class reports information about a method.
 *
 */
class ReflectionMethod extends ReflectionFunctionAbstract
implements Reflector {
  const IS_STATIC = 1;
  const IS_PUBLIC = 256;
  const IS_PROTECTED = 512;
  const IS_PRIVATE = 1024;
  const IS_ABSTRACT = 2;
  const IS_FINAL = 4;

  public $name;
  public $class;

  public function __construct($cls, $name = '') {
    if (!$name && is_string($cls)) {
      $arr = explode('::', $cls);
      if (count($arr) == 2) {
        $cls = $arr[0];
        $name = $arr[1];
      }
    }
    if ($cls && $name) {
      $method = hphp_get_method_info($cls, $name);
      if (!$method) {
        throw new ReflectionException("Method $cls::$name does not exist");
      }

      $this->info  = $method;
      $this->name  = $method['name'];
      $this->class = $method['class'];
    }
  }

  public function __toString() {
    //TODO
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.export.php )
 *
 * Exports a ReflectionMethod. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @cls        mixed   The class name.
 * @name       mixed   The name of the method.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($cls, $name, $ret=false) {
    if (!is_object($cls)) {
      $cls = new ReflectionClass($cls);
    } else {
      $cls = new ReflectionClass(get_class($cls));
    }
    $obj = $cls->getMethod($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.invoke.php )
 *
 * Invokes a reflected method.
 *
 * @obj        mixed   The object to invoke the method on. In case of
 *                     static methods, you can pass null to this parameter.
 *
 * @return     mixed   Returns the method result.
 */
  public function invoke($obj) {
    $args = func_get_args();
    array_shift($args);
    return hphp_invoke_method($obj, $this->info['class'], $this->info['name'],
                              $args);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.invokeargs.php
 * )
 *
 * Invoke arguments.
 *
 * @obj        mixed   The object to invoke the method on. In case of
 *                     static methods, you can pass null to this parameter.
 * @args       mixed   The parameters to be passed to the function, as an
 *                     array.
 *
 * @return     mixed   Returns the method result.
 */
  public function invokeArgs($obj, $args) {
    return hphp_invoke_method($obj, $this->info['class'], $this->info['name'],
                              array_values($args));
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isfinal.php )
 *
 * Checks if the method is final.
 *
 * @return     mixed   TRUE if the method is final, otherwise FALSE
 */
  public function isFinal() {
    return isset($this->info['final']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isabstract.php
 * )
 *
 * Checks if the method is abstract.
 *
 * @return     mixed   TRUE if the method is abstract, otherwise FALSE
 */
  public function isAbstract() {
    return isset($this->info['abstract']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.ispublic.php )
 *
 * Checks if the method is public.
 *
 * @return     mixed   TRUE if the method is public, otherwise FALSE
 */
  public function isPublic() {
    return $this->info['access'] == "public";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isprivate.php )
 *
 * Checks if the method is private. WarningThis function is currently not
 * documented; only its argument list is available.
 *
 * @return     mixed   TRUE if the method is private, otherwise FALSE
 */
  public function isPrivate() {
    return $this->info['access'] == "private";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isprotected.php
 * )
 *
 * Checks if the method is protected.
 *
 * @return     mixed   TRUE if the method is protected, otherwise FALSE
 */
  public function isProtected() {
    return $this->info['access'] == "protected";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionmethod.isstatic.php )
 *
 * Checks if the method is static.
 *
 * @return     mixed   TRUE if the method is static, otherwise FALSE
 */
  public function isStatic() {
    return isset($this->info['static']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.isconstructor.php )
 *
 * Checks if the method is a constructor.
 *
 * @return     mixed   TRUE if the method is a constructor, otherwise FALSE
 */
  public function isConstructor() {
    return isset($this->info['constructor']);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.isdestructor.php )
 *
 * Checks if the method is a destructor.
 *
 * @return     mixed   TRUE if the method is a destructor, otherwise FALSE
 */
  public function isDestructor() {
    return $this->getName() == '__destruct';
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.getmodifiers.php )
 *
 * Gets the method modifiers.
 *
 * @return     mixed   A numeric representation of the modifiers. The
 *                     modifiers are listed below. The actual meanings of
 *                     these modifiers are described in the predefined
 *                     constants. ReflectionMethod modifiers value constant
 *                     1 ReflectionMethod::IS_STATIC 2
 *                     ReflectionMethod::IS_ABSTRACT 4
 *                     ReflectionMethod::IS_FINAL 256
 *                     ReflectionMethod::IS_PUBLIC 512
 *                     ReflectionMethod::IS_PROTECTED 1024
 *                     ReflectionMethod::IS_PRIVATE
 */
  public function getModifiers() {
    return $this->info['modifiers'];
  }

  public function getClosure() {
    return $this->info['closure'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionmethod.getdeclaringclass.php )
 *
 * Gets the declaring class for the reflected method.
 *
 * @return     mixed   A ReflectionClass object of the class that the
 *                     reflected method is part of.
 */
  public function getDeclaringClass() {
    if (empty($this->info['class'])) {
      return null;
    }
    return new ReflectionClass($this->info['class']);
  }

  public function getAttribute($name) {
    $attrs = $this->info['attributes'];
    return isset($attrs[$name]) ? $attrs[$name] : null;
  }

  public function getAttributes() {
    return $this->info['attributes'];
  }

  public function getAttributeRecursive($name) {
    $attrs = $this->info['attributes'];
    if (isset($attrs[$name])) {
      return $attrs[$name];
    }
    $p = get_parent_class($this->class);
    if ($p === false) {
      return null;
    }
    $rm = new ReflectionMethod($p, $this->name);
    if ($rm->isPrivate()) {
      return null;
    }
    return $rm->getAttributeRecursive($name);
  }

  public function getAttributesRecursive() {
    $attrs = $this->info['attributes'];
    $p = get_parent_class($this->class);
    if ($p !== false) {
      $rm = new ReflectionMethod($p, $this->name);
      if (!$rm->isPrivate()) {
        $attrs += $rm->getAttributesRecursive();
      }
    }
    return $attrs;
  }
}

///////////////////////////////////////////////////////////////////////////////
// extension

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.reflectionextension.php )
 *
 * The ReflectionExtension class reports information about an extension.
 *
 */
class ReflectionExtension implements Reflector {
  private $name;
  private $info;

  public function __construct($name) {
    $this->info = hphp_get_extension_info($name);
  }

  public function __toString() {
    return "";
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.export.php )
 *
 * Exports a reflected extension. The output format of this function is
 * the same as the CLI argument --re [extension].
 *
 * @name       mixed   The reflection to export.
 * @ret        mixed   Setting to TRUE will return the export, as opposed
 *                     to emitting it. Setting to FALSE (the default) will
 *                     do the opposite.
 *
 * @return     mixed   If the return parameter is set to TRUE, then the
 *                     export is returned as a string, otherwise NULL is
 *                     returned.
 */
  public static function export($name, $ret=false) {
    $obj = new ReflectionExtension($name);
    $str = (string)$obj;
    if ($ret) {
      return $str;
    }
    print $str;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.getname.php
 * )
 *
 * Gets the extensions name.
 *
 * @return     mixed   The extensions name.
 */
  public function getName() {
    return $this->info['name'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getversion.php )
 *
 * Gets the version of the extension.
 *
 * @return     mixed   The version of the extension.
 */
  public function getVersion() {
    return $this->info['version'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getfunctions.php )
 *
 * Get defined functions from an extension.
 *
 * @return     mixed   An associative array of ReflectionFunction objects,
 *                     for each function defined in the extension with the
 *                     keys being the function names. If no function are
 *                     defined, an empty array is returned.
 */
  public function getFunctions() {
    return $this->info['functions'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getconstants.php )
 *
 * Get defined constants from an extension.
 *
 * @return     mixed   An associative array with constant names as keys.
 */
  public function getConstants() {
    return $this->info['constants'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getinientries.php )
 *
 * Get the ini entries for an extension.
 *
 * @return     mixed   An associative array with the ini entries as keys,
 *                     with their defined values as values.
 */
  public function getINIEntries() {
    return $this->info['ini'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getclasses.php )
 *
 * Gets a list of classes from an extension.
 *
 * @return     mixed   An array of ReflectionClass objects, one for each
 *                     class within the extension. If no classes are
 *                     defined, an empty array is returned.
 */
  public function getClasses() {
    return $this->info['classes'];
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from
 * http://php.net/manual/en/reflectionextension.getclassnames.php )
 *
 * Gets a listing of class names as defined in the extension.
 *
 * @return     mixed   An array of class names, as defined in the
 *                     extension. If no classes are defined, an empty array
 *                     is returned.
 */
  public function getClassNames() {
    $ret = array();
    foreach ($this->info['classes'] as $cls) {
      $ret[] = $cls->getName();
    }
    return $ret;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/reflectionextension.info.php )
 *
 * Gets information about an extension.
 *
 * @return     mixed   Information about the extension.
 */
  public function info() {
    return $this->info['info'];
  }
}

class SoapFault extends Exception {
  public $faultcode;
  public $faultcodens;
  public $faultstring;
  public $faultactor;
  public $detail;
  public $_name;
  public $headerfault;

  public function __construct($code, $message, $actor = null, $detail = null,
                              $name = null, $header = null) {
    $fault_ns = null;
    $fault_code = null;
    if (is_string($code)) {
      $fault_code = $code;
    } else if (is_array($code) && count($code) == 2) {
      $code = array_values($code);
      $fault_ns = $code[0];
      $fault_code = $code[1];
      if (!is_string($fault_ns) || !is_string($fault_code)) {
        hphp_throw_fatal_error("Invalid fault code"); 
        return;
      }
    } else  {
      hphp_throw_fatal_error("Invalid fault code"); 
      return;
    }
    $this->faultcodens = $fault_ns;
    $this->faultcode = $fault_code;
    if (empty($this->faultcode)) {
      hphp_throw_fatal_error("Invalid fault code"); 
      return;
    }

    $this->faultstring = $this->message = $message;
    $this->faultactor = $actor;
    $this->detail = $detail;
    $this->_name = $name;
    $this->headerfault = $header;

    $SOAP_1_1 = 1;
    $SOAP_1_2 = 2;
    $SOAP_1_1_ENV_NAMESPACE = 'http://schemas.xmlsoap.org/soap/envelope/';
    $SOAP_1_2_ENV_NAMESPACE = 'http://www.w3.org/2003/05/soap-envelope';

    $soap_version = _soap_active_version();
    if (empty($this->faultcodens)) {
      if ($soap_version == $SOAP_1_1) {
        if ($this->faultcode == "Client" ||
            $this->faultcode == "Server" ||
            $this->faultcode == "VersionMismatch" ||
            $this->faultcode == "MustUnderstand") {
          $this->faultcodens = $SOAP_1_1_ENV_NAMESPACE;
        }
      } else if ($soap_version == $SOAP_1_2) {
        if ($this->faultcode == "Client") {
          $this->faultcode = "Sender";
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        } else if ($this->faultcode == "Server") {
          $this->faultcode = "Receiver";
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        } else if ($this->faultcode == "VersionMismatch" ||
                   $this->faultcode == "MustUnderstand" ||
                   $this->faultcode == "DataEncodingUnknown") {
          $this->faultcodens = $SOAP_1_2_ENV_NAMESPACE;
        }
      }
    }
  }

  public function __toString() {
    return "SoapFault exception: [" . $this->faultcode . "] " .
           $this->faultstring;
  }
}

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/class.splobjectstorage.php )
 *
 * The SplObjectStorage class provides a map from objects to data or, by
 * ignoring data, an object set. This dual purpose can be useful in many
 * cases involving the need to uniquely identify objects.
 *
 */
class SplObjectStorage implements Iterator, Countable {
  private $storage = array();
  private $index = 0;

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.rewind.php )
 *
 * Rewind the iterator to the first storage element.
 *
 * @return     mixed   No value is returned.
 */
  function rewind() {
    rewind($this->storage);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.valid.php )
 *
 * Returns if the current iterator entry is valid.
 *
 * @return     mixed   Returns TRUE if the iterator entry is valid, FALSE
 *                     otherwise.
 */
  function valid() {
    return key($this->storage) !== false;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.key.php )
 *
 * Returns the index at which the iterator currently is.
 *
 * @return     mixed   The index corresponding to the position of the
 *                     iterator.
 */
  function key() {
    return $this->index;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.current.php )
 *
 * Returns the current storage entry.
 *
 * @return     mixed   The object at the current iterator position.
 */
  function current() {
    return current($this->storage);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.next.php )
 *
 * Moves the iterator to the next object in the storage.
 *
 * @return     mixed   No value is returned.
 */
  function next() {
    next($this->storage);
    $this->index++;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.count.php )
 *
 * Counts the number of objects in the storage.
 *
 * @return     mixed   The number of objects in the storage.
 */
  function count() {
    return count($this->storage);
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.contains.php )
 *
 * Checks if the storage contains the object provided.
 *
 * @obj        mixed   The object to look for.
 *
 * @return     mixed   Returns TRUE if the object is in the storage, FALSE
 *                     otherwise.
 */
  function contains($obj) {
    if (is_object($obj)) {
      foreach($this->storage as $object) {
        if ($object === $obj) {
          return true;
        }
      }
    }
    return false;
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.attach.php )
 *
 * Adds an object inside the storage, and optionaly associate it to some
 * data.
 *
 * @obj        mixed   The object to add.
 *
 * @return     mixed   No value is returned.
 */
  function attach($obj) {
    if (is_object($obj) && !$this->contains($obj)) {
      $this->storage[] = $obj;
    }
  }

// Do NOT modifiy this doc comment block generated by idl/sysdoc.php
/**
 * ( excerpt from http://php.net/manual/en/splobjectstorage.detach.php )
 *
 * Removes the object from the storage.
 *
 * @obj        mixed   The object to remove.
 *
 * @return     mixed   No value is returned.
 */
  function detach($obj) {
    if (is_object($obj)) {
      foreach($this->storage as $idx => $object) {
        if ($object === $obj) {
          unset($this->storage[$idx]);
          $this->rewind();
          return;
        }
      }
    }
  }
}

/**
 * Helps application inserting an artificial frame in xhprof's reporting.
 */
class XhprofFrame {
  public function __construct($name) {
    xhprof_frame_begin($name);
  }
  public function __destruct() {
    xhprof_frame_end();
  }
}

// Used as a sentinel type in 86pinit().
class __pinitSentinel {
}

// Used to represent resources
class __resource {
  public function __toString() {
    return hphp_to_string($this);
  }
}

