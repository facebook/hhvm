/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/includes_types.h"
#include <folly/small_vector.h>

namespace apache {
namespace thrift {
namespace ident {
struct boolField;
struct boolField;
struct MyBoolField;
struct MyIntField;
struct MyStringField;
struct MyStringField2;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryField3;
struct MyBinaryListField4;
struct MyMapEnumAndInt;
struct MyCustomField;
struct MyOptCustomField;
struct intValue;
struct stringValue;
struct intValue;
struct opt_intValue;
struct stringValue;
struct opt_stringValue;
struct intValue2;
struct intValue3;
struct doubelValue;
struct boolValue;
struct union_list;
struct union_set;
struct union_map;
struct opt_union_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union;
struct opt_a_union;
struct a_union_list;
struct a_union_typedef;
struct a_union_typedef_list;
struct MyBinaryField;
struct MyBinaryField2;
struct MyBinaryListField4;
struct ref_field;
struct ref_field2;
struct excp_field;
struct MyCustomField;
struct code;
struct req_code;
struct message2;
struct req_message;
struct exception_list;
struct exception_set;
struct exception_map;
struct req_exception_map;
struct enum_field;
struct enum_container;
struct a_struct;
struct a_set_struct;
struct a_union_list;
struct union_typedef;
struct a_union_typedef_list;
struct MyCustomField;
struct MyOptCustomField;
struct code;
struct req_code;
struct message;
struct fieldA;
struct req_fieldA;
struct opt_fieldA;
struct fieldB;
struct req_fieldB;
struct opt_fieldB;
struct fieldC;
struct req_fieldC;
struct opt_fieldC;
struct fieldD;
struct fieldE;
struct req_fieldE;
struct opt_fieldE;
struct fieldF;
struct fieldG;
struct fieldH;
struct fieldI;
struct fieldJ;
struct fieldK;
struct fieldL;
struct fieldM;
struct fieldN;
struct fieldO;
struct fieldP;
struct fieldQ;
struct fieldR;
struct req_fieldR;
struct opt_fieldR;
struct fieldS;
struct fieldT;
struct fieldU;
struct fieldV;
struct req_fieldV;
struct opt_fieldV;
struct fieldW;
struct fieldX;
struct req_fieldX;
struct opt_fieldX;
struct fieldY;
struct fieldZ;
struct fieldAA;
struct fieldAB;
struct fieldAC;
struct fieldAD;
struct fieldAE;
struct fieldSD;
struct MyIncludedInt;
struct MyIncludedStruct;
struct ARefField;
struct ARequiredField;
struct no_annotation;
struct cpp_unique_ref;
struct cpp2_unique_ref;
struct container_with_ref;
struct req_cpp_unique_ref;
struct req_cpp2_unique_ref;
struct req_container_with_ref;
struct opt_cpp_unique_ref;
struct opt_cpp2_unique_ref;
struct opt_container_with_ref;
struct ref_type_unique;
struct ref_type_shared;
struct ref_type_const;
struct req_ref_type_shared;
struct req_ref_type_const;
struct req_ref_type_unique;
struct opt_ref_type_const;
struct opt_ref_type_unique;
struct opt_ref_type_shared;
struct base_type;
struct list_type;
struct set_type;
struct map_type;
struct map_struct_type;
struct iobuf_type;
struct iobuf_ptr;
struct list_i32_template;
struct list_string_template;
struct set_template;
struct map_template;
struct typedef_list_template;
struct typedef_deque_template;
struct typedef_set_template;
struct typedef_map_template;
struct indirection_a;
struct indirection_b;
struct indirection_c;
struct iobuf_type_val;
struct iobuf_ptr_val;
struct struct_struct;
struct map_of_iobufs;
struct map_of_iobuf_ptrs;
struct floatField;
struct doubleField;
struct floatSide;
struct doubleSide;
struct intField;
} // namespace ident
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolField
#define APACHE_THRIFT_ACCESSOR_boolField
APACHE_THRIFT_DEFINE_ACCESSOR(boolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBoolField
#define APACHE_THRIFT_ACCESSOR_MyBoolField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBoolField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIntField
#define APACHE_THRIFT_ACCESSOR_MyIntField
APACHE_THRIFT_DEFINE_ACCESSOR(MyIntField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField
#define APACHE_THRIFT_ACCESSOR_MyStringField
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyStringField2
#define APACHE_THRIFT_ACCESSOR_MyStringField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyStringField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField3
#define APACHE_THRIFT_ACCESSOR_MyBinaryField3
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
#define APACHE_THRIFT_ACCESSOR_MyMapEnumAndInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyMapEnumAndInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyCustomField
#define APACHE_THRIFT_ACCESSOR_MyCustomField
APACHE_THRIFT_DEFINE_ACCESSOR(MyCustomField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyOptCustomField
#define APACHE_THRIFT_ACCESSOR_MyOptCustomField
APACHE_THRIFT_DEFINE_ACCESSOR(MyOptCustomField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue
#define APACHE_THRIFT_ACCESSOR_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_intValue
#define APACHE_THRIFT_ACCESSOR_opt_intValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_intValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_stringValue
#define APACHE_THRIFT_ACCESSOR_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_stringValue
#define APACHE_THRIFT_ACCESSOR_opt_stringValue
APACHE_THRIFT_DEFINE_ACCESSOR(opt_stringValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue2
#define APACHE_THRIFT_ACCESSOR_intValue2
APACHE_THRIFT_DEFINE_ACCESSOR(intValue2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intValue3
#define APACHE_THRIFT_ACCESSOR_intValue3
APACHE_THRIFT_DEFINE_ACCESSOR(intValue3);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubelValue
#define APACHE_THRIFT_ACCESSOR_doubelValue
APACHE_THRIFT_DEFINE_ACCESSOR(doubelValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_boolValue
#define APACHE_THRIFT_ACCESSOR_boolValue
APACHE_THRIFT_DEFINE_ACCESSOR(boolValue);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_list
#define APACHE_THRIFT_ACCESSOR_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_set
#define APACHE_THRIFT_ACCESSOR_union_set
APACHE_THRIFT_DEFINE_ACCESSOR(union_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_map
#define APACHE_THRIFT_ACCESSOR_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_union_map
#define APACHE_THRIFT_ACCESSOR_opt_union_map
APACHE_THRIFT_DEFINE_ACCESSOR(opt_union_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union
#define APACHE_THRIFT_ACCESSOR_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_a_union
#define APACHE_THRIFT_ACCESSOR_opt_a_union
APACHE_THRIFT_DEFINE_ACCESSOR(opt_a_union);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef
#define APACHE_THRIFT_ACCESSOR_a_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField
#define APACHE_THRIFT_ACCESSOR_MyBinaryField
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryField2
#define APACHE_THRIFT_ACCESSOR_MyBinaryField2
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryField2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyBinaryListField4
#define APACHE_THRIFT_ACCESSOR_MyBinaryListField4
APACHE_THRIFT_DEFINE_ACCESSOR(MyBinaryListField4);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field
#define APACHE_THRIFT_ACCESSOR_ref_field
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_field2
#define APACHE_THRIFT_ACCESSOR_ref_field2
APACHE_THRIFT_DEFINE_ACCESSOR(ref_field2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_excp_field
#define APACHE_THRIFT_ACCESSOR_excp_field
APACHE_THRIFT_DEFINE_ACCESSOR(excp_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyCustomField
#define APACHE_THRIFT_ACCESSOR_MyCustomField
APACHE_THRIFT_DEFINE_ACCESSOR(MyCustomField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message2
#define APACHE_THRIFT_ACCESSOR_message2
APACHE_THRIFT_DEFINE_ACCESSOR(message2);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_message
#define APACHE_THRIFT_ACCESSOR_req_message
APACHE_THRIFT_DEFINE_ACCESSOR(req_message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_list
#define APACHE_THRIFT_ACCESSOR_exception_list
APACHE_THRIFT_DEFINE_ACCESSOR(exception_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_set
#define APACHE_THRIFT_ACCESSOR_exception_set
APACHE_THRIFT_DEFINE_ACCESSOR(exception_set);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exception_map
#define APACHE_THRIFT_ACCESSOR_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_exception_map
#define APACHE_THRIFT_ACCESSOR_req_exception_map
APACHE_THRIFT_DEFINE_ACCESSOR(req_exception_map);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_field
#define APACHE_THRIFT_ACCESSOR_enum_field
APACHE_THRIFT_DEFINE_ACCESSOR(enum_field);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_enum_container
#define APACHE_THRIFT_ACCESSOR_enum_container
APACHE_THRIFT_DEFINE_ACCESSOR(enum_container);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_struct
#define APACHE_THRIFT_ACCESSOR_a_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_set_struct
#define APACHE_THRIFT_ACCESSOR_a_set_struct
APACHE_THRIFT_DEFINE_ACCESSOR(a_set_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_list
#define APACHE_THRIFT_ACCESSOR_a_union_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_union_typedef
#define APACHE_THRIFT_ACCESSOR_union_typedef
APACHE_THRIFT_DEFINE_ACCESSOR(union_typedef);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_a_union_typedef_list
#define APACHE_THRIFT_ACCESSOR_a_union_typedef_list
APACHE_THRIFT_DEFINE_ACCESSOR(a_union_typedef_list);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyCustomField
#define APACHE_THRIFT_ACCESSOR_MyCustomField
APACHE_THRIFT_DEFINE_ACCESSOR(MyCustomField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyOptCustomField
#define APACHE_THRIFT_ACCESSOR_MyOptCustomField
APACHE_THRIFT_DEFINE_ACCESSOR(MyOptCustomField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_code
#define APACHE_THRIFT_ACCESSOR_req_code
APACHE_THRIFT_DEFINE_ACCESSOR(req_code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_message
#define APACHE_THRIFT_ACCESSOR_message
APACHE_THRIFT_DEFINE_ACCESSOR(message);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldA
#define APACHE_THRIFT_ACCESSOR_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldA
#define APACHE_THRIFT_ACCESSOR_req_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldA
#define APACHE_THRIFT_ACCESSOR_opt_fieldA
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldB
#define APACHE_THRIFT_ACCESSOR_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldB
#define APACHE_THRIFT_ACCESSOR_req_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldB
#define APACHE_THRIFT_ACCESSOR_opt_fieldB
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldC
#define APACHE_THRIFT_ACCESSOR_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldC
#define APACHE_THRIFT_ACCESSOR_req_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldC
#define APACHE_THRIFT_ACCESSOR_opt_fieldC
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldD
#define APACHE_THRIFT_ACCESSOR_fieldD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldE
#define APACHE_THRIFT_ACCESSOR_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldE
#define APACHE_THRIFT_ACCESSOR_req_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldE
#define APACHE_THRIFT_ACCESSOR_opt_fieldE
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldF
#define APACHE_THRIFT_ACCESSOR_fieldF
APACHE_THRIFT_DEFINE_ACCESSOR(fieldF);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldG
#define APACHE_THRIFT_ACCESSOR_fieldG
APACHE_THRIFT_DEFINE_ACCESSOR(fieldG);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldH
#define APACHE_THRIFT_ACCESSOR_fieldH
APACHE_THRIFT_DEFINE_ACCESSOR(fieldH);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldI
#define APACHE_THRIFT_ACCESSOR_fieldI
APACHE_THRIFT_DEFINE_ACCESSOR(fieldI);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldJ
#define APACHE_THRIFT_ACCESSOR_fieldJ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldJ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldK
#define APACHE_THRIFT_ACCESSOR_fieldK
APACHE_THRIFT_DEFINE_ACCESSOR(fieldK);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldL
#define APACHE_THRIFT_ACCESSOR_fieldL
APACHE_THRIFT_DEFINE_ACCESSOR(fieldL);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldM
#define APACHE_THRIFT_ACCESSOR_fieldM
APACHE_THRIFT_DEFINE_ACCESSOR(fieldM);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldN
#define APACHE_THRIFT_ACCESSOR_fieldN
APACHE_THRIFT_DEFINE_ACCESSOR(fieldN);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldO
#define APACHE_THRIFT_ACCESSOR_fieldO
APACHE_THRIFT_DEFINE_ACCESSOR(fieldO);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldP
#define APACHE_THRIFT_ACCESSOR_fieldP
APACHE_THRIFT_DEFINE_ACCESSOR(fieldP);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldQ
#define APACHE_THRIFT_ACCESSOR_fieldQ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldQ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldR
#define APACHE_THRIFT_ACCESSOR_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldR
#define APACHE_THRIFT_ACCESSOR_req_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldR
#define APACHE_THRIFT_ACCESSOR_opt_fieldR
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldR);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldS
#define APACHE_THRIFT_ACCESSOR_fieldS
APACHE_THRIFT_DEFINE_ACCESSOR(fieldS);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldT
#define APACHE_THRIFT_ACCESSOR_fieldT
APACHE_THRIFT_DEFINE_ACCESSOR(fieldT);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldU
#define APACHE_THRIFT_ACCESSOR_fieldU
APACHE_THRIFT_DEFINE_ACCESSOR(fieldU);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldV
#define APACHE_THRIFT_ACCESSOR_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldV
#define APACHE_THRIFT_ACCESSOR_req_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldV
#define APACHE_THRIFT_ACCESSOR_opt_fieldV
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldV);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldW
#define APACHE_THRIFT_ACCESSOR_fieldW
APACHE_THRIFT_DEFINE_ACCESSOR(fieldW);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldX
#define APACHE_THRIFT_ACCESSOR_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_fieldX
#define APACHE_THRIFT_ACCESSOR_req_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(req_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_fieldX
#define APACHE_THRIFT_ACCESSOR_opt_fieldX
APACHE_THRIFT_DEFINE_ACCESSOR(opt_fieldX);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldY
#define APACHE_THRIFT_ACCESSOR_fieldY
APACHE_THRIFT_DEFINE_ACCESSOR(fieldY);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldZ
#define APACHE_THRIFT_ACCESSOR_fieldZ
APACHE_THRIFT_DEFINE_ACCESSOR(fieldZ);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAA
#define APACHE_THRIFT_ACCESSOR_fieldAA
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAA);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAB
#define APACHE_THRIFT_ACCESSOR_fieldAB
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAB);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAC
#define APACHE_THRIFT_ACCESSOR_fieldAC
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAC);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAD
#define APACHE_THRIFT_ACCESSOR_fieldAD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldAE
#define APACHE_THRIFT_ACCESSOR_fieldAE
APACHE_THRIFT_DEFINE_ACCESSOR(fieldAE);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_fieldSD
#define APACHE_THRIFT_ACCESSOR_fieldSD
APACHE_THRIFT_DEFINE_ACCESSOR(fieldSD);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedInt
#define APACHE_THRIFT_ACCESSOR_MyIncludedInt
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedInt);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_MyIncludedStruct
#define APACHE_THRIFT_ACCESSOR_MyIncludedStruct
APACHE_THRIFT_DEFINE_ACCESSOR(MyIncludedStruct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARefField
#define APACHE_THRIFT_ACCESSOR_ARefField
APACHE_THRIFT_DEFINE_ACCESSOR(ARefField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ARequiredField
#define APACHE_THRIFT_ACCESSOR_ARequiredField
APACHE_THRIFT_DEFINE_ACCESSOR(ARequiredField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_no_annotation
#define APACHE_THRIFT_ACCESSOR_no_annotation
APACHE_THRIFT_DEFINE_ACCESSOR(no_annotation);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_container_with_ref
#define APACHE_THRIFT_ACCESSOR_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_req_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_container_with_ref
#define APACHE_THRIFT_ACCESSOR_req_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(req_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
#define APACHE_THRIFT_ACCESSOR_opt_cpp2_unique_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_cpp2_unique_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_container_with_ref
#define APACHE_THRIFT_ACCESSOR_opt_container_with_ref
APACHE_THRIFT_DEFINE_ACCESSOR(opt_container_with_ref);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_ref_type_const
#define APACHE_THRIFT_ACCESSOR_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_req_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_const
#define APACHE_THRIFT_ACCESSOR_req_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_req_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_req_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(req_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_const
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_const
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_const);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_unique
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_unique);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
#define APACHE_THRIFT_ACCESSOR_opt_ref_type_shared
APACHE_THRIFT_DEFINE_ACCESSOR(opt_ref_type_shared);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_base_type
#define APACHE_THRIFT_ACCESSOR_base_type
APACHE_THRIFT_DEFINE_ACCESSOR(base_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_type
#define APACHE_THRIFT_ACCESSOR_list_type
APACHE_THRIFT_DEFINE_ACCESSOR(list_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_type
#define APACHE_THRIFT_ACCESSOR_set_type
APACHE_THRIFT_DEFINE_ACCESSOR(set_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_type
#define APACHE_THRIFT_ACCESSOR_map_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_struct_type
#define APACHE_THRIFT_ACCESSOR_map_struct_type
APACHE_THRIFT_DEFINE_ACCESSOR(map_struct_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type
#define APACHE_THRIFT_ACCESSOR_iobuf_type
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_i32_template
#define APACHE_THRIFT_ACCESSOR_list_i32_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_i32_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_list_string_template
#define APACHE_THRIFT_ACCESSOR_list_string_template
APACHE_THRIFT_DEFINE_ACCESSOR(list_string_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_set_template
#define APACHE_THRIFT_ACCESSOR_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_template
#define APACHE_THRIFT_ACCESSOR_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_list_template
#define APACHE_THRIFT_ACCESSOR_typedef_list_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_list_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_deque_template
#define APACHE_THRIFT_ACCESSOR_typedef_deque_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_deque_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_set_template
#define APACHE_THRIFT_ACCESSOR_typedef_set_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_set_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_typedef_map_template
#define APACHE_THRIFT_ACCESSOR_typedef_map_template
APACHE_THRIFT_DEFINE_ACCESSOR(typedef_map_template);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_a
#define APACHE_THRIFT_ACCESSOR_indirection_a
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_a);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_b
#define APACHE_THRIFT_ACCESSOR_indirection_b
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_b);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_indirection_c
#define APACHE_THRIFT_ACCESSOR_indirection_c
APACHE_THRIFT_DEFINE_ACCESSOR(indirection_c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_type_val
#define APACHE_THRIFT_ACCESSOR_iobuf_type_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_type_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
#define APACHE_THRIFT_ACCESSOR_iobuf_ptr_val
APACHE_THRIFT_DEFINE_ACCESSOR(iobuf_ptr_val);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_struct_struct
#define APACHE_THRIFT_ACCESSOR_struct_struct
APACHE_THRIFT_DEFINE_ACCESSOR(struct_struct);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobufs
#define APACHE_THRIFT_ACCESSOR_map_of_iobufs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobufs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
#define APACHE_THRIFT_ACCESSOR_map_of_iobuf_ptrs
APACHE_THRIFT_DEFINE_ACCESSOR(map_of_iobuf_ptrs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatField
#define APACHE_THRIFT_ACCESSOR_floatField
APACHE_THRIFT_DEFINE_ACCESSOR(floatField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleField
#define APACHE_THRIFT_ACCESSOR_doubleField
APACHE_THRIFT_DEFINE_ACCESSOR(doubleField);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_floatSide
#define APACHE_THRIFT_ACCESSOR_floatSide
APACHE_THRIFT_DEFINE_ACCESSOR(floatSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_doubleSide
#define APACHE_THRIFT_ACCESSOR_doubleSide
APACHE_THRIFT_DEFINE_ACCESSOR(doubleSide);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_intField
#define APACHE_THRIFT_ACCESSOR_intField
APACHE_THRIFT_DEFINE_ACCESSOR(intField);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace some { namespace valid { namespace ns {

enum class MyEnumA {
  fieldA = 1,
  fieldB = 2,
  fieldC = 4,
};



enum class AnnotatedEnum : ::std::uint32_t {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};

inline constexpr AnnotatedEnum operator&(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator&=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum operator|(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator|=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum operator^(AnnotatedEnum a, AnnotatedEnum b) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum& operator^=(AnnotatedEnum& a, AnnotatedEnum b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum operator~(AnnotatedEnum a) {
  using E = AnnotatedEnum;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class AnnotatedEnum2 : ::std::int16_t {
  FIELDA = 2,
  FIELDB = 4,
  FIELDC = 9,
};

inline constexpr AnnotatedEnum2 operator&(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) & static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator&=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a & b;
}

inline constexpr AnnotatedEnum2 operator|(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) | static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator|=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a | b;
}

inline constexpr AnnotatedEnum2 operator^(AnnotatedEnum2 a, AnnotatedEnum2 b) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(static_cast<U>(a) ^ static_cast<U>(b));
}
inline constexpr AnnotatedEnum2& operator^=(AnnotatedEnum2& a, AnnotatedEnum2 b) {
  return a = a ^ b;
}

inline constexpr AnnotatedEnum2 operator~(AnnotatedEnum2 a) {
  using E = AnnotatedEnum2;
  using U = std::underlying_type_t<E>;
  return static_cast<E>(~static_cast<U>(a));
}

enum class MyEnumB {
  AField = 0,
};



}}} // some::valid::ns

namespace std {
template<> struct hash<::some::valid::ns::MyEnumA> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::MyEnumA> {};
template<> struct hash<::some::valid::ns::AnnotatedEnum> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::AnnotatedEnum> {};
template<> struct hash<::some::valid::ns::AnnotatedEnum2> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::AnnotatedEnum2> {};
template<> struct hash<::some::valid::ns::MyEnumB> :
  ::apache::thrift::detail::enum_hash<::some::valid::ns::MyEnumB> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumA>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumA> {
  using type = ::some::valid::ns::MyEnumA;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::fieldA; }
  static constexpr type max() { return type::fieldC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum> {
  using type = ::some::valid::ns::AnnotatedEnum;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::AnnotatedEnum2>;

template <> struct TEnumTraits<::some::valid::ns::AnnotatedEnum2> {
  using type = ::some::valid::ns::AnnotatedEnum2;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::FIELDA; }
  static constexpr type max() { return type::FIELDC; }
};


template <> struct TEnumDataStorage<::some::valid::ns::MyEnumB>;

template <> struct TEnumTraits<::some::valid::ns::MyEnumB> {
  using type = ::some::valid::ns::MyEnumB;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
  static constexpr type min() { return type::AField; }
  static constexpr type max() { return type::AField; }
};


}} // apache::thrift


// END declare_enums
// BEGIN forward_declare
namespace some { namespace valid { namespace ns {
class Empty;
class ASimpleStruct;
class ASimpleStructNoexcept;
class MyStruct;
class SimpleUnion;
class ComplexUnion;
class AnException;
class AnotherException;
class containerStruct;
class MyIncludedStruct;
class AnnotatedStruct;
class ComplexContainerStruct;
class FloatStruct;
class FloatUnion;
class AllRequiredNoExceptMoveCtrStruct;
}}} // some::valid::ns
// END forward_declare
namespace apache::thrift::detail::annotation {
} // namespace apache::thrift::detail::annotation

namespace apache::thrift::detail::qualifier {
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<8>> : std::true_type{};
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<9>> : std::true_type{};
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<10>> : std::true_type{};
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<17>> : std::true_type{};
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<18>> : std::true_type{};
template<>
struct is_cpp_ref_field_optional<::some::valid::ns::AnnotatedStruct,::apache::thrift::type::field_id<19>> : std::true_type{};
} // namespace apache::thrift::detail::qualifier

// BEGIN hash_and_equal_to
namespace std {

template<> struct hash<typename ::some::valid::ns::MyIncludedStruct> {
  size_t operator()(const ::some::valid::ns::MyIncludedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::MyIncludedStruct> {
  bool operator()(const ::some::valid::ns::MyIncludedStruct&,const ::some::valid::ns::MyIncludedStruct&) const;
};

template<> struct hash<typename ::some::valid::ns::AnnotatedStruct> {
  size_t operator()(const ::some::valid::ns::AnnotatedStruct&) const;
};
template<> struct equal_to<typename ::some::valid::ns::AnnotatedStruct> {
  bool operator()(const ::some::valid::ns::AnnotatedStruct&,const ::some::valid::ns::AnnotatedStruct&) const;
};
} // std
// END hash_and_equal_to
namespace some { namespace valid { namespace ns {
using ::apache::thrift::detail::operator!=;
using ::apache::thrift::detail::operator>;
using ::apache::thrift::detail::operator<=;
using ::apache::thrift::detail::operator>=;

typedef ::a::different::ns::AStruct AStruct;
typedef folly::IOBuf IOBuf;
typedef ::apache::thrift::adapt_detail::adapted_t<::CustomProtocolAdapter, ::some::valid::ns::IOBuf> CustomProtocolType;
typedef ::std::int32_t simpleTypeDef;
typedef ::std::map<::std::int16_t, ::std::string> containerTypeDef;
typedef ::std::vector<::std::map<::std::int16_t, ::std::string>> complexContainerTypeDef;
typedef ::std::set<::some::valid::ns::SimpleUnion> unionTypeDef;
typedef ::std::vector<::some::valid::ns::MyStruct> structTypeDef;
typedef ::std::vector<::std::map<::some::valid::ns::Empty, ::some::valid::ns::MyStruct>> complexStructTypeDef;
typedef ::std::vector<::some::valid::ns::complexStructTypeDef> mostComplexTypeDef;
typedef Foo IndirectionA;
typedef Baz IndirectionC;
typedef Bar IndirectionB;
typedef FooBar IndirectionD;
typedef ::std::map<::some::valid::ns::MyEnumA, ::std::string> HashedTypedef;
typedef CppFakeI32 CppFakeI32;
typedef folly::small_vector<int64_t, 8 /* maxInline */> FollySmallVectorI64;
typedef folly::sorted_vector_set<std::string> SortedVectorSetString;
typedef FakeMap FakeMap;
typedef std::unordered_map<std::string, containerStruct> UnorderedMapStruct;
typedef std::list<::std::int32_t> std_list;
typedef std::deque<::std::string> std_deque;
typedef folly::sorted_vector_set<::std::string> folly_set;
typedef folly::sorted_vector_map<::std::int64_t, ::std::string> folly_map;
typedef std::unique_ptr<folly::IOBuf> IOBufPtr;

class Empty final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0};
  using __fbthrift_reflection_type_tags = folly::tag_t<
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 0;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = Empty;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  Empty() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  Empty(apache::thrift::FragileConstructor);

  Empty(Empty&&) = default;

  Empty(const Empty&) = default;


  Empty& operator=(Empty&&) = default;

  Empty& operator=(const Empty&) = default;

 public:

  bool operator==(const Empty&) const;
  bool operator<(const Empty&) const;

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<Empty>;
  friend void swap(Empty& a, Empty& b);
};

template <class Protocol_>
unsigned long Empty::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class ASimpleStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::boolField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 1;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ASimpleStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ASimpleStruct() :
      __fbthrift_field_boolField() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStruct(apache::thrift::FragileConstructor, ::std::int64_t boolField__arg);

  ASimpleStruct(ASimpleStruct&&) = default;

  ASimpleStruct(const ASimpleStruct&) = default;


  ASimpleStruct& operator=(ASimpleStruct&&) = default;

  ASimpleStruct& operator=(const ASimpleStruct&) = default;
 private:
  ::std::int64_t __fbthrift_field_boolField;
 private:
  apache::thrift::detail::isset_bitset<1, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const ASimpleStruct&) const;
  bool operator<(const ASimpleStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField() const& {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField() & {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField() && {
    return {static_cast<T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  ::std::int64_t get_boolField() const {
    return __fbthrift_field_boolField;
  }

  [[deprecated("Use `FOO.boolField_ref() = BAR;` instead of `FOO.set_boolField(BAR);`")]]
  ::std::int64_t& set_boolField(::std::int64_t boolField_) {
    boolField_ref() = boolField_;
    return __fbthrift_field_boolField;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ASimpleStruct>;
  friend void swap(ASimpleStruct& a, ASimpleStruct& b);
};

template <class Protocol_>
unsigned long ASimpleStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class ASimpleStructNoexcept final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::boolField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 1;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ASimpleStructNoexcept;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ASimpleStructNoexcept() :
      __fbthrift_field_boolField() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ASimpleStructNoexcept(apache::thrift::FragileConstructor, ::std::int64_t boolField__arg);

  ASimpleStructNoexcept(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept(const ASimpleStructNoexcept&) = default;


  ASimpleStructNoexcept& operator=(ASimpleStructNoexcept&&) = default;

  ASimpleStructNoexcept& operator=(const ASimpleStructNoexcept&) = default;
 private:
  ::std::int64_t __fbthrift_field_boolField;
 private:
  apache::thrift::detail::isset_bitset<1, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const ASimpleStructNoexcept&) const;
  bool operator<(const ASimpleStructNoexcept&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField_ref() const& {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField_ref() & {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> boolField() const& {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> boolField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> boolField() & {
    return {this->__fbthrift_field_boolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> boolField() && {
    return {static_cast<T&&>(this->__fbthrift_field_boolField), __isset.at(0), __isset.bit(0)};
  }

  ::std::int64_t get_boolField() const {
    return __fbthrift_field_boolField;
  }

  [[deprecated("Use `FOO.boolField_ref() = BAR;` instead of `FOO.set_boolField(BAR);`")]]
  ::std::int64_t& set_boolField(::std::int64_t boolField_) {
    boolField_ref() = boolField_;
    return __fbthrift_field_boolField;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ASimpleStructNoexcept>;
  friend void swap(ASimpleStructNoexcept& a, ASimpleStructNoexcept& b);
};

template <class Protocol_>
unsigned long ASimpleStructNoexcept::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class MyStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::MyBoolField,
    ::apache::thrift::ident::MyIntField,
    ::apache::thrift::ident::MyStringField,
    ::apache::thrift::ident::MyStringField2,
    ::apache::thrift::ident::MyBinaryField,
    ::apache::thrift::ident::MyBinaryField2,
    ::apache::thrift::ident::MyBinaryField3,
    ::apache::thrift::ident::MyBinaryListField4,
    ::apache::thrift::ident::MyMapEnumAndInt,
    ::apache::thrift::ident::MyCustomField,
    ::apache::thrift::ident::MyOptCustomField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2,3,4,5,6,7,8,9,10,11};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::list<::apache::thrift::type::binary_t>,
    ::apache::thrift::type::map<::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>, ::apache::thrift::type::string_t>,
    ::apache::thrift::type::adapted<::CustomProtocolAdapter, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>,
    ::apache::thrift::type::adapted<::CustomProtocolAdapter, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 11;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = MyStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyStruct(apache::thrift::FragileConstructor, bool MyBoolField__arg, ::std::int64_t MyIntField__arg, ::std::string MyStringField__arg, ::std::string MyStringField2__arg, ::std::string MyBinaryField__arg, ::std::string MyBinaryField2__arg, ::std::string MyBinaryField3__arg, ::std::vector<::std::string> MyBinaryListField4__arg, ::std::map<::some::valid::ns::MyEnumA, ::std::string> MyMapEnumAndInt__arg, ::some::valid::ns::CustomProtocolType MyCustomField__arg, ::some::valid::ns::CustomProtocolType MyOptCustomField__arg);

  MyStruct(MyStruct&&) noexcept;
  MyStruct(const MyStruct& src);


  MyStruct& operator=(MyStruct&&) noexcept;
  MyStruct& operator=(const MyStruct& src);

  ~MyStruct();

 private:
  bool __fbthrift_field_MyBoolField;
 private:
  ::std::int64_t __fbthrift_field_MyIntField;
 private:
  ::std::string __fbthrift_field_MyStringField;
 private:
  ::std::string __fbthrift_field_MyStringField2;
 private:
  ::std::string __fbthrift_field_MyBinaryField;
 private:
  ::std::string __fbthrift_field_MyBinaryField2;
 private:
  ::std::string __fbthrift_field_MyBinaryField3;
 private:
  ::std::vector<::std::string> __fbthrift_field_MyBinaryListField4;
 private:
  ::std::map<::some::valid::ns::MyEnumA, ::std::string> __fbthrift_field_MyMapEnumAndInt;
 private:
  ::some::valid::ns::CustomProtocolType __fbthrift_field_MyCustomField;
 private:
  ::some::valid::ns::CustomProtocolType __fbthrift_field_MyOptCustomField;
 private:
  apache::thrift::detail::isset_bitset<10, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const MyStruct&) const;
  bool operator<(const MyStruct&) const;

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBoolField_ref() const& {
    return {this->__fbthrift_field_MyBoolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBoolField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBoolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBoolField_ref() & {
    return {this->__fbthrift_field_MyBoolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBoolField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBoolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBoolField() const& {
    return {this->__fbthrift_field_MyBoolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBoolField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBoolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBoolField() & {
    return {this->__fbthrift_field_MyBoolField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBoolField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBoolField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIntField_ref() const& {
    return {this->__fbthrift_field_MyIntField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIntField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIntField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIntField_ref() & {
    return {this->__fbthrift_field_MyIntField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIntField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIntField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIntField() const& {
    return {this->__fbthrift_field_MyIntField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIntField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIntField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIntField() & {
    return {this->__fbthrift_field_MyIntField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIntField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIntField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField_ref() const& {
    return {this->__fbthrift_field_MyStringField, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyStringField), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField_ref() & {
    return {this->__fbthrift_field_MyStringField, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyStringField), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField() const& {
    return {this->__fbthrift_field_MyStringField, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyStringField), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField() & {
    return {this->__fbthrift_field_MyStringField, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyStringField), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField2_ref() const& {
    return {this->__fbthrift_field_MyStringField2, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField2_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyStringField2), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField2_ref() & {
    return {this->__fbthrift_field_MyStringField2, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField2_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyStringField2), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyStringField2() const& {
    return {this->__fbthrift_field_MyStringField2, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyStringField2() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyStringField2), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyStringField2() & {
    return {this->__fbthrift_field_MyStringField2, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyStringField2() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyStringField2), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryField_ref() const& {
    return {this->__fbthrift_field_MyBinaryField, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryField), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryField_ref() & {
    return {this->__fbthrift_field_MyBinaryField, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryField), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryField() const& {
    return {this->__fbthrift_field_MyBinaryField, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryField), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryField() & {
    return {this->__fbthrift_field_MyBinaryField, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryField), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyBinaryField2_ref() const& {
    return {this->__fbthrift_field_MyBinaryField2, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryField2), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyBinaryField2_ref() & {
    return {this->__fbthrift_field_MyBinaryField2, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyBinaryField2_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryField2), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyBinaryField2() const& {
    return {this->__fbthrift_field_MyBinaryField2, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyBinaryField2() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryField2), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyBinaryField2() & {
    return {this->__fbthrift_field_MyBinaryField2, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyBinaryField2() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryField2), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> MyBinaryField3_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> MyBinaryField3_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_MyBinaryField3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> MyBinaryField3_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> MyBinaryField3_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_MyBinaryField3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> MyBinaryField3() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> MyBinaryField3() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_MyBinaryField3)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> MyBinaryField3() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_MyBinaryField3};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> MyBinaryField3() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_MyBinaryField3)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryListField4_ref() const& {
    return {this->__fbthrift_field_MyBinaryListField4, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryListField4), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryListField4_ref() & {
    return {this->__fbthrift_field_MyBinaryListField4, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryListField4_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryListField4), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyBinaryListField4() const& {
    return {this->__fbthrift_field_MyBinaryListField4, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyBinaryListField4() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyBinaryListField4), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyBinaryListField4() & {
    return {this->__fbthrift_field_MyBinaryListField4, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyBinaryListField4() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyBinaryListField4), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyMapEnumAndInt_ref() const& {
    return {this->__fbthrift_field_MyMapEnumAndInt, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyMapEnumAndInt_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyMapEnumAndInt), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyMapEnumAndInt_ref() & {
    return {this->__fbthrift_field_MyMapEnumAndInt, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyMapEnumAndInt_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyMapEnumAndInt), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyMapEnumAndInt() const& {
    return {this->__fbthrift_field_MyMapEnumAndInt, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyMapEnumAndInt() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyMapEnumAndInt), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyMapEnumAndInt() & {
    return {this->__fbthrift_field_MyMapEnumAndInt, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyMapEnumAndInt() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyMapEnumAndInt), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyCustomField_ref() const& {
    return {this->__fbthrift_field_MyCustomField, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyCustomField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyCustomField), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyCustomField_ref() & {
    return {this->__fbthrift_field_MyCustomField, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyCustomField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyCustomField), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyCustomField() const& {
    return {this->__fbthrift_field_MyCustomField, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyCustomField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyCustomField), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyCustomField() & {
    return {this->__fbthrift_field_MyCustomField, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyCustomField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyCustomField), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyOptCustomField_ref() const& {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyOptCustomField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyOptCustomField_ref() & {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyOptCustomField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyOptCustomField() const& {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyOptCustomField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyOptCustomField() & {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyOptCustomField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(9), __isset.bit(9)};
  }

  bool get_MyBoolField() const {
    return __fbthrift_field_MyBoolField;
  }

  [[deprecated("Use `FOO.MyBoolField_ref() = BAR;` instead of `FOO.set_MyBoolField(BAR);`")]]
  bool& set_MyBoolField(bool MyBoolField_) {
    MyBoolField_ref() = MyBoolField_;
    return __fbthrift_field_MyBoolField;
  }

  ::std::int64_t get_MyIntField() const {
    return __fbthrift_field_MyIntField;
  }

  [[deprecated("Use `FOO.MyIntField_ref() = BAR;` instead of `FOO.set_MyIntField(BAR);`")]]
  ::std::int64_t& set_MyIntField(::std::int64_t MyIntField_) {
    MyIntField_ref() = MyIntField_;
    return __fbthrift_field_MyIntField;
  }

  const ::std::string& get_MyStringField() const& {
    return __fbthrift_field_MyStringField;
  }

  ::std::string get_MyStringField() && {
    return std::move(__fbthrift_field_MyStringField);
  }

  template <typename T_MyStruct_MyStringField_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyStringField_ref() = BAR;` instead of `FOO.set_MyStringField(BAR);`")]]
  ::std::string& set_MyStringField(T_MyStruct_MyStringField_struct_setter&& MyStringField_) {
    MyStringField_ref() = std::forward<T_MyStruct_MyStringField_struct_setter>(MyStringField_);
    return __fbthrift_field_MyStringField;
  }

  const ::std::string& get_MyStringField2() const& {
    return __fbthrift_field_MyStringField2;
  }

  ::std::string get_MyStringField2() && {
    return std::move(__fbthrift_field_MyStringField2);
  }

  template <typename T_MyStruct_MyStringField2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyStringField2_ref() = BAR;` instead of `FOO.set_MyStringField2(BAR);`")]]
  ::std::string& set_MyStringField2(T_MyStruct_MyStringField2_struct_setter&& MyStringField2_) {
    MyStringField2_ref() = std::forward<T_MyStruct_MyStringField2_struct_setter>(MyStringField2_);
    return __fbthrift_field_MyStringField2;
  }

  const ::std::string& get_MyBinaryField() const& {
    return __fbthrift_field_MyBinaryField;
  }

  ::std::string get_MyBinaryField() && {
    return std::move(__fbthrift_field_MyBinaryField);
  }

  template <typename T_MyStruct_MyBinaryField_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField_ref() = BAR;` instead of `FOO.set_MyBinaryField(BAR);`")]]
  ::std::string& set_MyBinaryField(T_MyStruct_MyBinaryField_struct_setter&& MyBinaryField_) {
    MyBinaryField_ref() = std::forward<T_MyStruct_MyBinaryField_struct_setter>(MyBinaryField_);
    return __fbthrift_field_MyBinaryField;
  }

  const ::std::string* get_MyBinaryField2() const& {
    return MyBinaryField2_ref() ? std::addressof(__fbthrift_field_MyBinaryField2) : nullptr;
  }

  ::std::string* get_MyBinaryField2() & {
    return MyBinaryField2_ref() ? std::addressof(__fbthrift_field_MyBinaryField2) : nullptr;
  }
  ::std::string* get_MyBinaryField2() && = delete;

  template <typename T_MyStruct_MyBinaryField2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField2_ref() = BAR;` instead of `FOO.set_MyBinaryField2(BAR);`")]]
  ::std::string& set_MyBinaryField2(T_MyStruct_MyBinaryField2_struct_setter&& MyBinaryField2_) {
    MyBinaryField2_ref() = std::forward<T_MyStruct_MyBinaryField2_struct_setter>(MyBinaryField2_);
    return __fbthrift_field_MyBinaryField2;
  }

  const ::std::string& get_MyBinaryField3() const& {
    return __fbthrift_field_MyBinaryField3;
  }

  ::std::string get_MyBinaryField3() && {
    return std::move(__fbthrift_field_MyBinaryField3);
  }

  template <typename T_MyStruct_MyBinaryField3_struct_setter = ::std::string>
  [[deprecated("Use `FOO.MyBinaryField3_ref() = BAR;` instead of `FOO.set_MyBinaryField3(BAR);`")]]
  ::std::string& set_MyBinaryField3(T_MyStruct_MyBinaryField3_struct_setter&& MyBinaryField3_) {
    MyBinaryField3_ref() = std::forward<T_MyStruct_MyBinaryField3_struct_setter>(MyBinaryField3_);
    return __fbthrift_field_MyBinaryField3;
  }
  const ::std::vector<::std::string>& get_MyBinaryListField4() const&;
  ::std::vector<::std::string> get_MyBinaryListField4() &&;

  template <typename T_MyStruct_MyBinaryListField4_struct_setter = ::std::vector<::std::string>>
  [[deprecated("Use `FOO.MyBinaryListField4_ref() = BAR;` instead of `FOO.set_MyBinaryListField4(BAR);`")]]
  ::std::vector<::std::string>& set_MyBinaryListField4(T_MyStruct_MyBinaryListField4_struct_setter&& MyBinaryListField4_) {
    MyBinaryListField4_ref() = std::forward<T_MyStruct_MyBinaryListField4_struct_setter>(MyBinaryListField4_);
    return __fbthrift_field_MyBinaryListField4;
  }
  const ::std::map<::some::valid::ns::MyEnumA, ::std::string>& get_MyMapEnumAndInt() const&;
  ::std::map<::some::valid::ns::MyEnumA, ::std::string> get_MyMapEnumAndInt() &&;

  template <typename T_MyStruct_MyMapEnumAndInt_struct_setter = ::std::map<::some::valid::ns::MyEnumA, ::std::string>>
  [[deprecated("Use `FOO.MyMapEnumAndInt_ref() = BAR;` instead of `FOO.set_MyMapEnumAndInt(BAR);`")]]
  ::std::map<::some::valid::ns::MyEnumA, ::std::string>& set_MyMapEnumAndInt(T_MyStruct_MyMapEnumAndInt_struct_setter&& MyMapEnumAndInt_) {
    MyMapEnumAndInt_ref() = std::forward<T_MyStruct_MyMapEnumAndInt_struct_setter>(MyMapEnumAndInt_);
    return __fbthrift_field_MyMapEnumAndInt;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyStruct>;
  friend void swap(MyStruct& a, MyStruct& b);
};

template <class Protocol_>
unsigned long MyStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class SimpleUnion  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::intValue,
    ::apache::thrift::ident::stringValue
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,7,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 2;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = SimpleUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 7,
    stringValue = 2,
  } ;

  SimpleUnion()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  SimpleUnion(SimpleUnion&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  SimpleUnion(const SimpleUnion& rhs);

  SimpleUnion& operator=(SimpleUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  SimpleUnion& operator=(const SimpleUnion& rhs);

  virtual ~SimpleUnion();

  union storage_type {
    ::std::int64_t intValue;
    ::std::string stringValue;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const SimpleUnion&) const;
  bool operator<(const SimpleUnion&) const;

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int64_t& set_intValue(::std::int64_t t = ::std::int64_t()) {
    using T0 = ::std::int64_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::intValue);
    ::new (std::addressof(value_.intValue)) T(t);
    return value_.intValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(t);
    return value_.stringValue;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }


  ::std::int64_t const& get_intValue() const {
    if (getType() != Type::intValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intValue;
  }

  ::std::string const& get_stringValue() const {
    if (getType() != Type::stringValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringValue;
  }

  ::std::int64_t& mutable_intValue() {
    assert(getType() == Type::intValue);
    return value_.intValue;
  }

  ::std::string& mutable_stringValue() {
    assert(getType() == Type::stringValue);
    return value_.stringValue;
  }

  ::std::int64_t move_intValue() {
    assert(getType() == Type::intValue);
    return std::move(value_.intValue);
  }

  ::std::string move_stringValue() {
    assert(getType() == Type::stringValue);
    return std::move(value_.stringValue);
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {std::move(value_.intValue), type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {std::move(value_.intValue), type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {std::move(value_.stringValue), type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {std::move(value_.stringValue), type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<SimpleUnion>;
  friend void swap(SimpleUnion& a, SimpleUnion& b);
};

template <class Protocol_>
unsigned long SimpleUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class FOLLY_EXPORT AnException : public virtual apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::code,
    ::apache::thrift::ident::req_code,
    ::apache::thrift::ident::message2,
    ::apache::thrift::ident::req_message,
    ::apache::thrift::ident::exception_list,
    ::apache::thrift::ident::exception_set,
    ::apache::thrift::ident::exception_map,
    ::apache::thrift::ident::req_exception_map,
    ::apache::thrift::ident::enum_field,
    ::apache::thrift::ident::enum_container,
    ::apache::thrift::ident::a_struct,
    ::apache::thrift::ident::a_set_struct,
    ::apache::thrift::ident::a_union_list,
    ::apache::thrift::ident::union_typedef,
    ::apache::thrift::ident::a_union_typedef_list,
    ::apache::thrift::ident::MyCustomField,
    ::apache::thrift::ident::MyOptCustomField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,101,2,102,3,4,5,105,6,7,8,9,10,11,19,20,21};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::list<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::set<::apache::thrift::type::i64_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::list<::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::set<::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>>,
    ::apache::thrift::type::list<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>,
    ::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>,
    ::apache::thrift::type::list<::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>>,
    ::apache::thrift::type::adapted<::CustomProtocolAdapter, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>,
    ::apache::thrift::type::adapted<::CustomProtocolAdapter, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 17;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = AnException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnException();
  explicit AnException(std::string __message);

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnException(apache::thrift::FragileConstructor, ::std::int32_t code__arg, ::std::int32_t req_code__arg, ::std::string message2__arg, ::std::string req_message__arg, ::std::vector<::std::int32_t> exception_list__arg, ::std::set<::std::int64_t> exception_set__arg, ::std::map<::std::string, ::std::int32_t> exception_map__arg, ::std::map<::std::string, ::std::int32_t> req_exception_map__arg, ::some::valid::ns::MyEnumA enum_field__arg, ::std::vector<::some::valid::ns::MyEnumA> enum_container__arg, ::some::valid::ns::MyStruct a_struct__arg, ::std::set<::some::valid::ns::MyStruct> a_set_struct__arg, ::std::vector<::some::valid::ns::SimpleUnion> a_union_list__arg, ::some::valid::ns::unionTypeDef union_typedef__arg, ::std::vector<::some::valid::ns::unionTypeDef> a_union_typedef_list__arg, ::some::valid::ns::CustomProtocolType MyCustomField__arg, ::some::valid::ns::CustomProtocolType MyOptCustomField__arg);

  AnException(AnException&&) noexcept;
  AnException(const AnException& src);


  AnException& operator=(AnException&&) noexcept;
  AnException& operator=(const AnException& src);

  ~AnException() override;

 private:
  ::std::int32_t __fbthrift_field_code;
 private:
  ::std::int32_t __fbthrift_field_req_code;
 private:
  ::std::string __fbthrift_field_message2;
 private:
  ::std::string __fbthrift_field_req_message;
 private:
  ::std::vector<::std::int32_t> __fbthrift_field_exception_list;
 private:
  ::std::set<::std::int64_t> __fbthrift_field_exception_set;
 private:
  ::std::map<::std::string, ::std::int32_t> __fbthrift_field_exception_map;
 private:
  ::std::map<::std::string, ::std::int32_t> __fbthrift_field_req_exception_map;
 private:
  ::some::valid::ns::MyEnumA __fbthrift_field_enum_field;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> __fbthrift_field_enum_container;
 private:
  ::some::valid::ns::MyStruct __fbthrift_field_a_struct;
 private:
  ::std::set<::some::valid::ns::MyStruct> __fbthrift_field_a_set_struct;
 private:
  ::std::vector<::some::valid::ns::SimpleUnion> __fbthrift_field_a_union_list;
 private:
  ::some::valid::ns::unionTypeDef __fbthrift_field_union_typedef;
 private:
  ::std::vector<::some::valid::ns::unionTypeDef> __fbthrift_field_a_union_typedef_list;
 private:
  ::some::valid::ns::CustomProtocolType __fbthrift_field_MyCustomField;
 private:
  ::some::valid::ns::CustomProtocolType __fbthrift_field_MyOptCustomField;
 private:
  apache::thrift::detail::isset_bitset<14, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const AnException&) const;
  bool operator<(const AnException&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code() const& {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code() & {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code() && {
    return {static_cast<T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message2_ref() const& {
    return {this->__fbthrift_field_message2, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message2_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_message2), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message2_ref() & {
    return {this->__fbthrift_field_message2, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message2_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_message2), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message2() const& {
    return {this->__fbthrift_field_message2, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message2() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_message2), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message2() & {
    return {this->__fbthrift_field_message2, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message2() && {
    return {static_cast<T&&>(this->__fbthrift_field_message2), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_message_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_message_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_message)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_message_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_message_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_message)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_message() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_message() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_message)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_message() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_message};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_message() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_message)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_list_ref() const& {
    return {this->__fbthrift_field_exception_list, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_list_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_list), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_list_ref() & {
    return {this->__fbthrift_field_exception_list, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_list_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_list), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_list() const& {
    return {this->__fbthrift_field_exception_list, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_list() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_list), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_list() & {
    return {this->__fbthrift_field_exception_list, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_list() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_list), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_set_ref() const& {
    return {this->__fbthrift_field_exception_set, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_set_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_set), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_set_ref() & {
    return {this->__fbthrift_field_exception_set, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_set_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_set), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_set() const& {
    return {this->__fbthrift_field_exception_set, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_set() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_set), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_set() & {
    return {this->__fbthrift_field_exception_set, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_set() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_set), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_map_ref() const& {
    return {this->__fbthrift_field_exception_map, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_map_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_map), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_map_ref() & {
    return {this->__fbthrift_field_exception_map, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_map_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_map), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> exception_map() const& {
    return {this->__fbthrift_field_exception_map, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> exception_map() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_exception_map), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> exception_map() & {
    return {this->__fbthrift_field_exception_map, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> exception_map() && {
    return {static_cast<T&&>(this->__fbthrift_field_exception_map), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_exception_map_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_exception_map_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_exception_map)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_exception_map_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_exception_map_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_exception_map)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_exception_map() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_exception_map() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_exception_map)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_exception_map() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_exception_map};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_exception_map() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_exception_map)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_field_ref() const& {
    return {this->__fbthrift_field_enum_field, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_field_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_enum_field), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_field_ref() & {
    return {this->__fbthrift_field_enum_field, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_field_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_enum_field), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_field() const& {
    return {this->__fbthrift_field_enum_field, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_field() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_enum_field), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_field() & {
    return {this->__fbthrift_field_enum_field, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_field() && {
    return {static_cast<T&&>(this->__fbthrift_field_enum_field), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_container_ref() const& {
    return {this->__fbthrift_field_enum_container, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_container_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_enum_container), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_container_ref() & {
    return {this->__fbthrift_field_enum_container, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_container_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_enum_container), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> enum_container() const& {
    return {this->__fbthrift_field_enum_container, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> enum_container() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_enum_container), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> enum_container() & {
    return {this->__fbthrift_field_enum_container, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> enum_container() && {
    return {static_cast<T&&>(this->__fbthrift_field_enum_container), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_struct_ref() const& {
    return {this->__fbthrift_field_a_struct, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_struct_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_struct), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_struct_ref() & {
    return {this->__fbthrift_field_a_struct, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_struct_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_struct), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_struct() const& {
    return {this->__fbthrift_field_a_struct, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_struct() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_struct), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_struct() & {
    return {this->__fbthrift_field_a_struct, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_struct() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_struct), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_set_struct_ref() const& {
    return {this->__fbthrift_field_a_set_struct, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_set_struct_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_set_struct), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_set_struct_ref() & {
    return {this->__fbthrift_field_a_set_struct, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_set_struct_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_set_struct), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_set_struct() const& {
    return {this->__fbthrift_field_a_set_struct, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_set_struct() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_set_struct), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_set_struct() & {
    return {this->__fbthrift_field_a_set_struct, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_set_struct() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_set_struct), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_list_ref() const& {
    return {this->__fbthrift_field_a_union_list, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_list_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_union_list), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_list_ref() & {
    return {this->__fbthrift_field_a_union_list, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_list_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_union_list), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_list() const& {
    return {this->__fbthrift_field_a_union_list, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_list() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_union_list), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_list() & {
    return {this->__fbthrift_field_a_union_list, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_list() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_union_list), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> union_typedef_ref() const& {
    return {this->__fbthrift_field_union_typedef, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> union_typedef_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_union_typedef), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> union_typedef_ref() & {
    return {this->__fbthrift_field_union_typedef, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> union_typedef_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_union_typedef), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> union_typedef() const& {
    return {this->__fbthrift_field_union_typedef, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> union_typedef() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_union_typedef), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> union_typedef() & {
    return {this->__fbthrift_field_union_typedef, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> union_typedef() && {
    return {static_cast<T&&>(this->__fbthrift_field_union_typedef), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_typedef_list_ref() const& {
    return {this->__fbthrift_field_a_union_typedef_list, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_union_typedef_list), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_typedef_list_ref() & {
    return {this->__fbthrift_field_a_union_typedef_list, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_typedef_list_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_union_typedef_list), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> a_union_typedef_list() const& {
    return {this->__fbthrift_field_a_union_typedef_list, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> a_union_typedef_list() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_a_union_typedef_list), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> a_union_typedef_list() & {
    return {this->__fbthrift_field_a_union_typedef_list, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> a_union_typedef_list() && {
    return {static_cast<T&&>(this->__fbthrift_field_a_union_typedef_list), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyCustomField_ref() const& {
    return {this->__fbthrift_field_MyCustomField, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyCustomField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyCustomField), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyCustomField_ref() & {
    return {this->__fbthrift_field_MyCustomField, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyCustomField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyCustomField), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyCustomField() const& {
    return {this->__fbthrift_field_MyCustomField, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyCustomField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyCustomField), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyCustomField() & {
    return {this->__fbthrift_field_MyCustomField, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyCustomField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyCustomField), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyOptCustomField_ref() const& {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyOptCustomField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyOptCustomField_ref() & {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyOptCustomField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> MyOptCustomField() const& {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> MyOptCustomField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> MyOptCustomField() & {
    return {this->__fbthrift_field_MyOptCustomField, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> MyOptCustomField() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyOptCustomField), __isset.at(13), __isset.bit(13)};
  }

  ::std::int32_t get_code() const {
    return __fbthrift_field_code;
  }

  [[deprecated("Use `FOO.code_ref() = BAR;` instead of `FOO.set_code(BAR);`")]]
  ::std::int32_t& set_code(::std::int32_t code_) {
    code_ref() = code_;
    return __fbthrift_field_code;
  }

  ::std::int32_t get_req_code() const {
    return __fbthrift_field_req_code;
  }

  [[deprecated("Use `FOO.req_code_ref() = BAR;` instead of `FOO.set_req_code(BAR);`")]]
  ::std::int32_t& set_req_code(::std::int32_t req_code_) {
    req_code_ref() = req_code_;
    return __fbthrift_field_req_code;
  }

  const ::std::string& get_message2() const& {
    return __fbthrift_field_message2;
  }

  ::std::string get_message2() && {
    return std::move(__fbthrift_field_message2);
  }

  template <typename T_AnException_message2_struct_setter = ::std::string>
  [[deprecated("Use `FOO.message2_ref() = BAR;` instead of `FOO.set_message2(BAR);`")]]
  ::std::string& set_message2(T_AnException_message2_struct_setter&& message2_) {
    message2_ref() = std::forward<T_AnException_message2_struct_setter>(message2_);
    return __fbthrift_field_message2;
  }

  const ::std::string& get_req_message() const& {
    return __fbthrift_field_req_message;
  }

  ::std::string get_req_message() && {
    return std::move(__fbthrift_field_req_message);
  }

  template <typename T_AnException_req_message_struct_setter = ::std::string>
  [[deprecated("Use `FOO.req_message_ref() = BAR;` instead of `FOO.set_req_message(BAR);`")]]
  ::std::string& set_req_message(T_AnException_req_message_struct_setter&& req_message_) {
    req_message_ref() = std::forward<T_AnException_req_message_struct_setter>(req_message_);
    return __fbthrift_field_req_message;
  }
  const ::std::vector<::std::int32_t>& get_exception_list() const&;
  ::std::vector<::std::int32_t> get_exception_list() &&;

  template <typename T_AnException_exception_list_struct_setter = ::std::vector<::std::int32_t>>
  [[deprecated("Use `FOO.exception_list_ref() = BAR;` instead of `FOO.set_exception_list(BAR);`")]]
  ::std::vector<::std::int32_t>& set_exception_list(T_AnException_exception_list_struct_setter&& exception_list_) {
    exception_list_ref() = std::forward<T_AnException_exception_list_struct_setter>(exception_list_);
    return __fbthrift_field_exception_list;
  }
  const ::std::set<::std::int64_t>& get_exception_set() const&;
  ::std::set<::std::int64_t> get_exception_set() &&;

  template <typename T_AnException_exception_set_struct_setter = ::std::set<::std::int64_t>>
  [[deprecated("Use `FOO.exception_set_ref() = BAR;` instead of `FOO.set_exception_set(BAR);`")]]
  ::std::set<::std::int64_t>& set_exception_set(T_AnException_exception_set_struct_setter&& exception_set_) {
    exception_set_ref() = std::forward<T_AnException_exception_set_struct_setter>(exception_set_);
    return __fbthrift_field_exception_set;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_exception_map() const&;
  ::std::map<::std::string, ::std::int32_t> get_exception_map() &&;

  template <typename T_AnException_exception_map_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.exception_map_ref() = BAR;` instead of `FOO.set_exception_map(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_exception_map(T_AnException_exception_map_struct_setter&& exception_map_) {
    exception_map_ref() = std::forward<T_AnException_exception_map_struct_setter>(exception_map_);
    return __fbthrift_field_exception_map;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_req_exception_map() const&;
  ::std::map<::std::string, ::std::int32_t> get_req_exception_map() &&;

  template <typename T_AnException_req_exception_map_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.req_exception_map_ref() = BAR;` instead of `FOO.set_req_exception_map(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_req_exception_map(T_AnException_req_exception_map_struct_setter&& req_exception_map_) {
    req_exception_map_ref() = std::forward<T_AnException_req_exception_map_struct_setter>(req_exception_map_);
    return __fbthrift_field_req_exception_map;
  }

  ::some::valid::ns::MyEnumA get_enum_field() const {
    return __fbthrift_field_enum_field;
  }

  [[deprecated("Use `FOO.enum_field_ref() = BAR;` instead of `FOO.set_enum_field(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_enum_field(::some::valid::ns::MyEnumA enum_field_) {
    enum_field_ref() = enum_field_;
    return __fbthrift_field_enum_field;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_enum_container() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_enum_container() &&;

  template <typename T_AnException_enum_container_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.enum_container_ref() = BAR;` instead of `FOO.set_enum_container(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(T_AnException_enum_container_struct_setter&& enum_container_) {
    enum_container_ref() = std::forward<T_AnException_enum_container_struct_setter>(enum_container_);
    return __fbthrift_field_enum_container;
  }
  const ::some::valid::ns::MyStruct& get_a_struct() const&;
  ::some::valid::ns::MyStruct get_a_struct() &&;

  template <typename T_AnException_a_struct_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.a_struct_ref() = BAR;` instead of `FOO.set_a_struct(BAR);`")]]
  ::some::valid::ns::MyStruct& set_a_struct(T_AnException_a_struct_struct_setter&& a_struct_) {
    a_struct_ref() = std::forward<T_AnException_a_struct_struct_setter>(a_struct_);
    return __fbthrift_field_a_struct;
  }
  const ::std::set<::some::valid::ns::MyStruct>& get_a_set_struct() const&;
  ::std::set<::some::valid::ns::MyStruct> get_a_set_struct() &&;

  template <typename T_AnException_a_set_struct_struct_setter = ::std::set<::some::valid::ns::MyStruct>>
  [[deprecated("Use `FOO.a_set_struct_ref() = BAR;` instead of `FOO.set_a_set_struct(BAR);`")]]
  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(T_AnException_a_set_struct_struct_setter&& a_set_struct_) {
    a_set_struct_ref() = std::forward<T_AnException_a_set_struct_struct_setter>(a_set_struct_);
    return __fbthrift_field_a_set_struct;
  }
  const ::std::vector<::some::valid::ns::SimpleUnion>& get_a_union_list() const&;
  ::std::vector<::some::valid::ns::SimpleUnion> get_a_union_list() &&;

  template <typename T_AnException_a_union_list_struct_setter = ::std::vector<::some::valid::ns::SimpleUnion>>
  [[deprecated("Use `FOO.a_union_list_ref() = BAR;` instead of `FOO.set_a_union_list(BAR);`")]]
  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(T_AnException_a_union_list_struct_setter&& a_union_list_) {
    a_union_list_ref() = std::forward<T_AnException_a_union_list_struct_setter>(a_union_list_);
    return __fbthrift_field_a_union_list;
  }
  const ::some::valid::ns::unionTypeDef& get_union_typedef() const&;
  ::some::valid::ns::unionTypeDef get_union_typedef() &&;

  template <typename T_AnException_union_typedef_struct_setter = ::some::valid::ns::unionTypeDef>
  [[deprecated("Use `FOO.union_typedef_ref() = BAR;` instead of `FOO.set_union_typedef(BAR);`")]]
  ::some::valid::ns::unionTypeDef& set_union_typedef(T_AnException_union_typedef_struct_setter&& union_typedef_) {
    union_typedef_ref() = std::forward<T_AnException_union_typedef_struct_setter>(union_typedef_);
    return __fbthrift_field_union_typedef;
  }
  const ::std::vector<::some::valid::ns::unionTypeDef>& get_a_union_typedef_list() const&;
  ::std::vector<::some::valid::ns::unionTypeDef> get_a_union_typedef_list() &&;

  template <typename T_AnException_a_union_typedef_list_struct_setter = ::std::vector<::some::valid::ns::unionTypeDef>>
  [[deprecated("Use `FOO.a_union_typedef_list_ref() = BAR;` instead of `FOO.set_a_union_typedef_list(BAR);`")]]
  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T_AnException_a_union_typedef_list_struct_setter&& a_union_typedef_list_) {
    a_union_typedef_list_ref() = std::forward<T_AnException_a_union_typedef_list_struct_setter>(a_union_typedef_list_);
    return __fbthrift_field_a_union_typedef_list;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return __fbthrift_field_message2.c_str();
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnException>;
  friend void swap(AnException& a, AnException& b);
};

template <class Protocol_>
unsigned long AnException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class ComplexUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::intValue,
    ::apache::thrift::ident::opt_intValue,
    ::apache::thrift::ident::stringValue,
    ::apache::thrift::ident::opt_stringValue,
    ::apache::thrift::ident::intValue2,
    ::apache::thrift::ident::intValue3,
    ::apache::thrift::ident::doubelValue,
    ::apache::thrift::ident::boolValue,
    ::apache::thrift::ident::union_list,
    ::apache::thrift::ident::union_set,
    ::apache::thrift::ident::union_map,
    ::apache::thrift::ident::opt_union_map,
    ::apache::thrift::ident::enum_field,
    ::apache::thrift::ident::enum_container,
    ::apache::thrift::ident::a_struct,
    ::apache::thrift::ident::a_set_struct,
    ::apache::thrift::ident::a_union,
    ::apache::thrift::ident::opt_a_union,
    ::apache::thrift::ident::a_union_list,
    ::apache::thrift::ident::a_union_typedef,
    ::apache::thrift::ident::a_union_typedef_list,
    ::apache::thrift::ident::MyBinaryField,
    ::apache::thrift::ident::MyBinaryField2,
    ::apache::thrift::ident::MyBinaryListField4,
    ::apache::thrift::ident::ref_field,
    ::apache::thrift::ident::ref_field2,
    ::apache::thrift::ident::excp_field,
    ::apache::thrift::ident::MyCustomField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,201,3,203,4,6,7,8,9,10,11,211,12,13,14,15,16,216,17,18,19,20,21,23,24,25,26,27};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::i16_t,
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::double_t,
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::list<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::set<::apache::thrift::type::i64_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::list<::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::set<::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>>,
    ::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>,
    ::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>,
    ::apache::thrift::type::list<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>,
    ::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>,
    ::apache::thrift::type::list<::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>>,
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::binary_t,
    ::apache::thrift::type::list<::apache::thrift::type::binary_t>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::exception_t<::some::valid::ns::AnException>,
    ::apache::thrift::type::adapted<::CustomProtocolAdapter, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 28;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ComplexUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    intValue = 1,
    opt_intValue = 201,
    stringValue = 3,
    opt_stringValue = 203,
    intValue2 = 4,
    intValue3 = 6,
    doubelValue = 7,
    boolValue = 8,
    union_list = 9,
    union_set = 10,
    union_map = 11,
    opt_union_map = 211,
    enum_field = 12,
    enum_container = 13,
    a_struct = 14,
    a_set_struct = 15,
    a_union = 16,
    opt_a_union = 216,
    a_union_list = 17,
    a_union_typedef = 18,
    a_union_typedef_list = 19,
    MyBinaryField = 20,
    MyBinaryField2 = 21,
    MyBinaryListField4 = 23,
    ref_field = 24,
    ref_field2 = 25,
    excp_field = 26,
    MyCustomField = 27,
  } ;

  ComplexUnion()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  ComplexUnion(ComplexUnion&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      case Type::MyCustomField:
      {
        set_MyCustomField(std::move(rhs.value_.MyCustomField));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  ComplexUnion(const ComplexUnion& rhs);

  ComplexUnion& operator=(ComplexUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::intValue:
      {
        set_intValue(std::move(rhs.value_.intValue));
        break;
      }
      case Type::opt_intValue:
      {
        set_opt_intValue(std::move(rhs.value_.opt_intValue));
        break;
      }
      case Type::stringValue:
      {
        set_stringValue(std::move(rhs.value_.stringValue));
        break;
      }
      case Type::opt_stringValue:
      {
        set_opt_stringValue(std::move(rhs.value_.opt_stringValue));
        break;
      }
      case Type::intValue2:
      {
        set_intValue2(std::move(rhs.value_.intValue2));
        break;
      }
      case Type::intValue3:
      {
        set_intValue3(std::move(rhs.value_.intValue3));
        break;
      }
      case Type::doubelValue:
      {
        set_doubelValue(std::move(rhs.value_.doubelValue));
        break;
      }
      case Type::boolValue:
      {
        set_boolValue(std::move(rhs.value_.boolValue));
        break;
      }
      case Type::union_list:
      {
        set_union_list(std::move(rhs.value_.union_list));
        break;
      }
      case Type::union_set:
      {
        set_union_set(std::move(rhs.value_.union_set));
        break;
      }
      case Type::union_map:
      {
        set_union_map(std::move(rhs.value_.union_map));
        break;
      }
      case Type::opt_union_map:
      {
        set_opt_union_map(std::move(rhs.value_.opt_union_map));
        break;
      }
      case Type::enum_field:
      {
        set_enum_field(std::move(rhs.value_.enum_field));
        break;
      }
      case Type::enum_container:
      {
        set_enum_container(std::move(rhs.value_.enum_container));
        break;
      }
      case Type::a_struct:
      {
        set_a_struct(std::move(rhs.value_.a_struct));
        break;
      }
      case Type::a_set_struct:
      {
        set_a_set_struct(std::move(rhs.value_.a_set_struct));
        break;
      }
      case Type::a_union:
      {
        set_a_union(std::move(rhs.value_.a_union));
        break;
      }
      case Type::opt_a_union:
      {
        set_opt_a_union(std::move(rhs.value_.opt_a_union));
        break;
      }
      case Type::a_union_list:
      {
        set_a_union_list(std::move(rhs.value_.a_union_list));
        break;
      }
      case Type::a_union_typedef:
      {
        set_a_union_typedef(std::move(rhs.value_.a_union_typedef));
        break;
      }
      case Type::a_union_typedef_list:
      {
        set_a_union_typedef_list(std::move(rhs.value_.a_union_typedef_list));
        break;
      }
      case Type::MyBinaryField:
      {
        set_MyBinaryField(std::move(rhs.value_.MyBinaryField));
        break;
      }
      case Type::MyBinaryField2:
      {
        set_MyBinaryField2(std::move(rhs.value_.MyBinaryField2));
        break;
      }
      case Type::MyBinaryListField4:
      {
        set_MyBinaryListField4(std::move(rhs.value_.MyBinaryListField4));
        break;
      }
      case Type::ref_field:
      {
        set_ref_field(std::move(*rhs.value_.ref_field));
        break;
      }
      case Type::ref_field2:
      {
        set_ref_field2(std::move(*rhs.value_.ref_field2));
        break;
      }
      case Type::excp_field:
      {
        set_excp_field(std::move(rhs.value_.excp_field));
        break;
      }
      case Type::MyCustomField:
      {
        set_MyCustomField(std::move(rhs.value_.MyCustomField));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  ComplexUnion& operator=(const ComplexUnion& rhs);

  ~ComplexUnion();

  union storage_type {
    ::std::int64_t intValue;
    ::std::int64_t opt_intValue;
    ::std::string stringValue;
    ::std::string opt_stringValue;
    ::std::int16_t intValue2;
    ::std::int32_t intValue3;
    double doubelValue;
    bool boolValue;
    ::std::vector<::std::int32_t> union_list;
    ::std::set<::std::int64_t> union_set;
    ::std::map<::std::string, ::std::int32_t> union_map;
    ::std::map<::std::string, ::std::int32_t> opt_union_map;
    ::some::valid::ns::MyEnumA enum_field;
    ::std::vector<::some::valid::ns::MyEnumA> enum_container;
    ::some::valid::ns::MyStruct a_struct;
    ::std::set<::some::valid::ns::MyStruct> a_set_struct;
    ::some::valid::ns::SimpleUnion a_union;
    ::some::valid::ns::SimpleUnion opt_a_union;
    ::std::vector<::some::valid::ns::SimpleUnion> a_union_list;
    ::some::valid::ns::unionTypeDef a_union_typedef;
    ::std::vector<::some::valid::ns::unionTypeDef> a_union_typedef_list;
    ::std::string MyBinaryField;
    ::std::string MyBinaryField2;
    ::std::vector<::std::string> MyBinaryListField4;
    ::std::unique_ptr<::some::valid::ns::MyStruct> ref_field;
    ::std::shared_ptr<const ::some::valid::ns::MyStruct> ref_field2;
    ::some::valid::ns::AnException excp_field;
    ::some::valid::ns::CustomProtocolType MyCustomField;

    storage_type() {}
    ~storage_type() {}
  } ;

  bool operator==(const ComplexUnion&) const;
  bool operator<(const ComplexUnion&) const;

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int64_t& set_intValue(::std::int64_t t = ::std::int64_t()) {
    using T0 = ::std::int64_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::intValue);
    ::new (std::addressof(value_.intValue)) T(t);
    return value_.intValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int64_t& set_opt_intValue(::std::int64_t t = ::std::int64_t()) {
    using T0 = ::std::int64_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_intValue);
    ::new (std::addressof(value_.opt_intValue)) T(t);
    return value_.opt_intValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(t);
    return value_.stringValue;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_stringValue(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) T(std::move(t));
    return value_.stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_stringValue(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::stringValue);
    ::new (std::addressof(value_.stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.stringValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_opt_stringValue(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_stringValue);
    ::new (std::addressof(value_.opt_stringValue)) T(t);
    return value_.opt_stringValue;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_opt_stringValue(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_stringValue);
    ::new (std::addressof(value_.opt_stringValue)) T(std::move(t));
    return value_.opt_stringValue;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_opt_stringValue(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_stringValue);
    ::new (std::addressof(value_.opt_stringValue)) ::std::string(std::forward<T>(t)...);
    return value_.opt_stringValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int16_t& set_intValue2(::std::int16_t t = ::std::int16_t()) {
    using T0 = ::std::int16_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::intValue2);
    ::new (std::addressof(value_.intValue2)) T(t);
    return value_.intValue2;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::int32_t& set_intValue3(::std::int32_t t = ::std::int32_t()) {
    using T0 = ::std::int32_t;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::intValue3);
    ::new (std::addressof(value_.intValue3)) T(t);
    return value_.intValue3;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  double& set_doubelValue(double t = double()) {
    using T0 = double;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::doubelValue);
    ::new (std::addressof(value_.doubelValue)) T(t);
    return value_.doubelValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  bool& set_boolValue(bool t = bool()) {
    using T0 = bool;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::boolValue);
    ::new (std::addressof(value_.boolValue)) T(t);
    return value_.boolValue;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int32_t>& set_union_list(::std::vector<::std::int32_t> const &t) {
    using T0 = ::std::vector<::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_list);
    ::new (std::addressof(value_.union_list)) T(t);
    return value_.union_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::int32_t>& set_union_list(::std::vector<::std::int32_t>&& t) {
    using T0 = ::std::vector<::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_list);
    ::new (std::addressof(value_.union_list)) T(std::move(t));
    return value_.union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::int32_t>, T...>> ::std::vector<::std::int32_t>& set_union_list(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_list);
    ::new (std::addressof(value_.union_list)) ::std::vector<::std::int32_t>(std::forward<T>(t)...);
    return value_.union_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::set<::std::int64_t>& set_union_set(::std::set<::std::int64_t> const &t) {
    using T0 = ::std::set<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_set);
    ::new (std::addressof(value_.union_set)) T(t);
    return value_.union_set;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::set<::std::int64_t>& set_union_set(::std::set<::std::int64_t>&& t) {
    using T0 = ::std::set<::std::int64_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_set);
    ::new (std::addressof(value_.union_set)) T(std::move(t));
    return value_.union_set;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set<::std::int64_t>, T...>> ::std::set<::std::int64_t>& set_union_set(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_set);
    ::new (std::addressof(value_.union_set)) ::std::set<::std::int64_t>(std::forward<T>(t)...);
    return value_.union_set;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::map<::std::string, ::std::int32_t>& set_union_map(::std::map<::std::string, ::std::int32_t> const &t) {
    using T0 = ::std::map<::std::string, ::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_map);
    ::new (std::addressof(value_.union_map)) T(t);
    return value_.union_map;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::map<::std::string, ::std::int32_t>& set_union_map(::std::map<::std::string, ::std::int32_t>&& t) {
    using T0 = ::std::map<::std::string, ::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_map);
    ::new (std::addressof(value_.union_map)) T(std::move(t));
    return value_.union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, ::std::int32_t>, T...>> ::std::map<::std::string, ::std::int32_t>& set_union_map(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::union_map);
    ::new (std::addressof(value_.union_map)) ::std::map<::std::string, ::std::int32_t>(std::forward<T>(t)...);
    return value_.union_map;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(::std::map<::std::string, ::std::int32_t> const &t) {
    using T0 = ::std::map<::std::string, ::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_union_map);
    ::new (std::addressof(value_.opt_union_map)) T(t);
    return value_.opt_union_map;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(::std::map<::std::string, ::std::int32_t>&& t) {
    using T0 = ::std::map<::std::string, ::std::int32_t>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_union_map);
    ::new (std::addressof(value_.opt_union_map)) T(std::move(t));
    return value_.opt_union_map;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::map<::std::string, ::std::int32_t>, T...>> ::std::map<::std::string, ::std::int32_t>& set_opt_union_map(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_union_map);
    ::new (std::addressof(value_.opt_union_map)) ::std::map<::std::string, ::std::int32_t>(std::forward<T>(t)...);
    return value_.opt_union_map;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::MyEnumA& set_enum_field(::some::valid::ns::MyEnumA t = ::some::valid::ns::MyEnumA()) {
    using T0 = ::some::valid::ns::MyEnumA;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enum_field);
    ::new (std::addressof(value_.enum_field)) T(t);
    return value_.enum_field;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(::std::vector<::some::valid::ns::MyEnumA> const &t) {
    using T0 = ::std::vector<::some::valid::ns::MyEnumA>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enum_container);
    ::new (std::addressof(value_.enum_container)) T(t);
    return value_.enum_container;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(::std::vector<::some::valid::ns::MyEnumA>&& t) {
    using T0 = ::std::vector<::some::valid::ns::MyEnumA>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enum_container);
    ::new (std::addressof(value_.enum_container)) T(std::move(t));
    return value_.enum_container;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::MyEnumA>, T...>> ::std::vector<::some::valid::ns::MyEnumA>& set_enum_container(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::enum_container);
    ::new (std::addressof(value_.enum_container)) ::std::vector<::some::valid::ns::MyEnumA>(std::forward<T>(t)...);
    return value_.enum_container;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::MyStruct& set_a_struct(::some::valid::ns::MyStruct const &t) {
    using T0 = ::some::valid::ns::MyStruct;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_struct);
    ::new (std::addressof(value_.a_struct)) T(t);
    return value_.a_struct;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::MyStruct& set_a_struct(::some::valid::ns::MyStruct&& t) {
    using T0 = ::some::valid::ns::MyStruct;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_struct);
    ::new (std::addressof(value_.a_struct)) T(std::move(t));
    return value_.a_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::some::valid::ns::MyStruct& set_a_struct(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_struct);
    ::new (std::addressof(value_.a_struct)) ::some::valid::ns::MyStruct(std::forward<T>(t)...);
    return value_.a_struct;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(::std::set<::some::valid::ns::MyStruct> const &t) {
    using T0 = ::std::set<::some::valid::ns::MyStruct>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_set_struct);
    ::new (std::addressof(value_.a_set_struct)) T(t);
    return value_.a_set_struct;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(::std::set<::some::valid::ns::MyStruct>&& t) {
    using T0 = ::std::set<::some::valid::ns::MyStruct>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_set_struct);
    ::new (std::addressof(value_.a_set_struct)) T(std::move(t));
    return value_.a_set_struct;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::set<::some::valid::ns::MyStruct>, T...>> ::std::set<::some::valid::ns::MyStruct>& set_a_set_struct(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_set_struct);
    ::new (std::addressof(value_.a_set_struct)) ::std::set<::some::valid::ns::MyStruct>(std::forward<T>(t)...);
    return value_.a_set_struct;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::SimpleUnion& set_a_union(::some::valid::ns::SimpleUnion const &t) {
    using T0 = ::some::valid::ns::SimpleUnion;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union);
    ::new (std::addressof(value_.a_union)) T(t);
    return value_.a_union;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::SimpleUnion& set_a_union(::some::valid::ns::SimpleUnion&& t) {
    using T0 = ::some::valid::ns::SimpleUnion;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union);
    ::new (std::addressof(value_.a_union)) T(std::move(t));
    return value_.a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::SimpleUnion, T...>> ::some::valid::ns::SimpleUnion& set_a_union(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union);
    ::new (std::addressof(value_.a_union)) ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.a_union;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::SimpleUnion& set_opt_a_union(::some::valid::ns::SimpleUnion const &t) {
    using T0 = ::some::valid::ns::SimpleUnion;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_a_union);
    ::new (std::addressof(value_.opt_a_union)) T(t);
    return value_.opt_a_union;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::SimpleUnion& set_opt_a_union(::some::valid::ns::SimpleUnion&& t) {
    using T0 = ::some::valid::ns::SimpleUnion;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_a_union);
    ::new (std::addressof(value_.opt_a_union)) T(std::move(t));
    return value_.opt_a_union;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::SimpleUnion, T...>> ::some::valid::ns::SimpleUnion& set_opt_a_union(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::opt_a_union);
    ::new (std::addressof(value_.opt_a_union)) ::some::valid::ns::SimpleUnion(std::forward<T>(t)...);
    return value_.opt_a_union;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector<::some::valid::ns::SimpleUnion> const &t) {
    using T0 = ::std::vector<::some::valid::ns::SimpleUnion>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_list);
    ::new (std::addressof(value_.a_union_list)) T(t);
    return value_.a_union_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(::std::vector<::some::valid::ns::SimpleUnion>&& t) {
    using T0 = ::std::vector<::some::valid::ns::SimpleUnion>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_list);
    ::new (std::addressof(value_.a_union_list)) T(std::move(t));
    return value_.a_union_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::SimpleUnion>, T...>> ::std::vector<::some::valid::ns::SimpleUnion>& set_a_union_list(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_list);
    ::new (std::addressof(value_.a_union_list)) ::std::vector<::some::valid::ns::SimpleUnion>(std::forward<T>(t)...);
    return value_.a_union_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::unionTypeDef& set_a_union_typedef(::some::valid::ns::unionTypeDef const &t) {
    using T0 = ::some::valid::ns::unionTypeDef;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef);
    ::new (std::addressof(value_.a_union_typedef)) T(t);
    return value_.a_union_typedef;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::unionTypeDef& set_a_union_typedef(::some::valid::ns::unionTypeDef&& t) {
    using T0 = ::some::valid::ns::unionTypeDef;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef);
    ::new (std::addressof(value_.a_union_typedef)) T(std::move(t));
    return value_.a_union_typedef;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::unionTypeDef, T...>> ::some::valid::ns::unionTypeDef& set_a_union_typedef(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef);
    ::new (std::addressof(value_.a_union_typedef)) ::some::valid::ns::unionTypeDef(std::forward<T>(t)...);
    return value_.a_union_typedef;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector<::some::valid::ns::unionTypeDef> const &t) {
    using T0 = ::std::vector<::some::valid::ns::unionTypeDef>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef_list);
    ::new (std::addressof(value_.a_union_typedef_list)) T(t);
    return value_.a_union_typedef_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(::std::vector<::some::valid::ns::unionTypeDef>&& t) {
    using T0 = ::std::vector<::some::valid::ns::unionTypeDef>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef_list);
    ::new (std::addressof(value_.a_union_typedef_list)) T(std::move(t));
    return value_.a_union_typedef_list;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::some::valid::ns::unionTypeDef>, T...>> ::std::vector<::some::valid::ns::unionTypeDef>& set_a_union_typedef_list(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::a_union_typedef_list);
    ::new (std::addressof(value_.a_union_typedef_list)) ::std::vector<::some::valid::ns::unionTypeDef>(std::forward<T>(t)...);
    return value_.a_union_typedef_list;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_MyBinaryField(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField);
    ::new (std::addressof(value_.MyBinaryField)) T(t);
    return value_.MyBinaryField;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_MyBinaryField(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField);
    ::new (std::addressof(value_.MyBinaryField)) T(std::move(t));
    return value_.MyBinaryField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField);
    ::new (std::addressof(value_.MyBinaryField)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_MyBinaryField2(::std::string const &t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField2);
    ::new (std::addressof(value_.MyBinaryField2)) T(t);
    return value_.MyBinaryField2;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::string& set_MyBinaryField2(::std::string&& t) {
    using T0 = ::std::string;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField2);
    ::new (std::addressof(value_.MyBinaryField2)) T(std::move(t));
    return value_.MyBinaryField2;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::string, T...>> ::std::string& set_MyBinaryField2(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryField2);
    ::new (std::addressof(value_.MyBinaryField2)) ::std::string(std::forward<T>(t)...);
    return value_.MyBinaryField2;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string> const &t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryListField4);
    ::new (std::addressof(value_.MyBinaryListField4)) T(t);
    return value_.MyBinaryListField4;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::std::vector<::std::string>& set_MyBinaryListField4(::std::vector<::std::string>&& t) {
    using T0 = ::std::vector<::std::string>;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryListField4);
    ::new (std::addressof(value_.MyBinaryListField4)) T(std::move(t));
    return value_.MyBinaryListField4;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::std::vector<::std::string>, T...>> ::std::vector<::std::string>& set_MyBinaryListField4(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyBinaryListField4);
    ::new (std::addressof(value_.MyBinaryListField4)) ::std::vector<::std::string>(std::forward<T>(t)...);
    return value_.MyBinaryListField4;
  }
  ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(::std::unique_ptr<::some::valid::ns::MyStruct> t);
  ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(::some::valid::ns::MyStruct const &t);
  ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::std::unique_ptr<::some::valid::ns::MyStruct>& set_ref_field(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), ::std::unique_ptr<::some::valid::ns::MyStruct>, void>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::ref_field);
    ::new (std::addressof(value_.ref_field)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field;
  }
  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(::std::shared_ptr<const ::some::valid::ns::MyStruct> t);
  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(::some::valid::ns::MyStruct const &t);
  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(::some::valid::ns::MyStruct&& t);
  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::MyStruct, T...>> ::std::shared_ptr<const ::some::valid::ns::MyStruct>& set_ref_field2(T&&... t) {
    // defer resolution of ref_ in case ref_::element_type would here be incomplete
    using ref_ = folly::conditional_t<(sizeof...(T) < size_t(-1)), ::std::shared_ptr<const ::some::valid::ns::MyStruct>, void>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::ref_field2);
    ::new (std::addressof(value_.ref_field2)) ref_(new typename ref_::element_type(std::forward<T>(t)...));
    return value_.ref_field2;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::AnException& set_excp_field(::some::valid::ns::AnException const &t) {
    using T0 = ::some::valid::ns::AnException;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::excp_field);
    ::new (std::addressof(value_.excp_field)) T(t);
    return value_.excp_field;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::AnException& set_excp_field(::some::valid::ns::AnException&& t) {
    using T0 = ::some::valid::ns::AnException;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::excp_field);
    ::new (std::addressof(value_.excp_field)) T(std::move(t));
    return value_.excp_field;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::AnException, T...>> ::some::valid::ns::AnException& set_excp_field(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::excp_field);
    ::new (std::addressof(value_.excp_field)) ::some::valid::ns::AnException(std::forward<T>(t)...);
    return value_.excp_field;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::CustomProtocolType& set_MyCustomField(::some::valid::ns::CustomProtocolType const &t) {
    using T0 = ::some::valid::ns::CustomProtocolType;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyCustomField);
    ::new (std::addressof(value_.MyCustomField)) T(t);
    return value_.MyCustomField;
  }

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  ::some::valid::ns::CustomProtocolType& set_MyCustomField(::some::valid::ns::CustomProtocolType&& t) {
    using T0 = ::some::valid::ns::CustomProtocolType;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyCustomField);
    ::new (std::addressof(value_.MyCustomField)) T(std::move(t));
    return value_.MyCustomField;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::some::valid::ns::CustomProtocolType, T...>> ::some::valid::ns::CustomProtocolType& set_MyCustomField(T&&... t) {
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::MyCustomField);
    ::new (std::addressof(value_.MyCustomField)) ::some::valid::ns::CustomProtocolType(std::forward<T>(t)...);
    return value_.MyCustomField;
  }


  ::std::int64_t const& get_intValue() const {
    if (getType() != Type::intValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intValue;
  }

  ::std::int64_t const& get_opt_intValue() const {
    if (getType() != Type::opt_intValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.opt_intValue;
  }

  ::std::string const& get_stringValue() const {
    if (getType() != Type::stringValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.stringValue;
  }

  ::std::string const& get_opt_stringValue() const {
    if (getType() != Type::opt_stringValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.opt_stringValue;
  }

  ::std::int16_t const& get_intValue2() const {
    if (getType() != Type::intValue2) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intValue2;
  }

  ::std::int32_t const& get_intValue3() const {
    if (getType() != Type::intValue3) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.intValue3;
  }

  double const& get_doubelValue() const {
    if (getType() != Type::doubelValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.doubelValue;
  }

  bool const& get_boolValue() const {
    if (getType() != Type::boolValue) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.boolValue;
  }

  ::std::vector<::std::int32_t> const& get_union_list() const {
    if (getType() != Type::union_list) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.union_list;
  }

  ::std::set<::std::int64_t> const& get_union_set() const {
    if (getType() != Type::union_set) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.union_set;
  }

  ::std::map<::std::string, ::std::int32_t> const& get_union_map() const {
    if (getType() != Type::union_map) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t> const& get_opt_union_map() const {
    if (getType() != Type::opt_union_map) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.opt_union_map;
  }

  ::some::valid::ns::MyEnumA const& get_enum_field() const {
    if (getType() != Type::enum_field) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.enum_field;
  }

  ::std::vector<::some::valid::ns::MyEnumA> const& get_enum_container() const {
    if (getType() != Type::enum_container) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.enum_container;
  }

  ::some::valid::ns::MyStruct const& get_a_struct() const {
    if (getType() != Type::a_struct) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_struct;
  }

  ::std::set<::some::valid::ns::MyStruct> const& get_a_set_struct() const {
    if (getType() != Type::a_set_struct) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_set_struct;
  }

  ::some::valid::ns::SimpleUnion const& get_a_union() const {
    if (getType() != Type::a_union) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion const& get_opt_a_union() const {
    if (getType() != Type::opt_a_union) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.opt_a_union;
  }

  ::std::vector<::some::valid::ns::SimpleUnion> const& get_a_union_list() const {
    if (getType() != Type::a_union_list) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_union_list;
  }

  ::some::valid::ns::unionTypeDef const& get_a_union_typedef() const {
    if (getType() != Type::a_union_typedef) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_union_typedef;
  }

  ::std::vector<::some::valid::ns::unionTypeDef> const& get_a_union_typedef_list() const {
    if (getType() != Type::a_union_typedef_list) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.a_union_typedef_list;
  }

  ::std::string const& get_MyBinaryField() const {
    if (getType() != Type::MyBinaryField) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.MyBinaryField;
  }

  ::std::string const& get_MyBinaryField2() const {
    if (getType() != Type::MyBinaryField2) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string> const& get_MyBinaryListField4() const {
    if (getType() != Type::MyBinaryListField4) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.MyBinaryListField4;
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct> const& get_ref_field() const {
    if (getType() != Type::ref_field) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.ref_field;
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct> const& get_ref_field2() const {
    if (getType() != Type::ref_field2) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.ref_field2;
  }

  ::some::valid::ns::AnException const& get_excp_field() const {
    if (getType() != Type::excp_field) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.excp_field;
  }

  ::some::valid::ns::CustomProtocolType const& get_MyCustomField() const {
    if (getType() != Type::MyCustomField) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.MyCustomField;
  }

  ::std::int64_t& mutable_intValue() {
    assert(getType() == Type::intValue);
    return value_.intValue;
  }

  ::std::int64_t& mutable_opt_intValue() {
    assert(getType() == Type::opt_intValue);
    return value_.opt_intValue;
  }

  ::std::string& mutable_stringValue() {
    assert(getType() == Type::stringValue);
    return value_.stringValue;
  }

  ::std::string& mutable_opt_stringValue() {
    assert(getType() == Type::opt_stringValue);
    return value_.opt_stringValue;
  }

  ::std::int16_t& mutable_intValue2() {
    assert(getType() == Type::intValue2);
    return value_.intValue2;
  }

  ::std::int32_t& mutable_intValue3() {
    assert(getType() == Type::intValue3);
    return value_.intValue3;
  }

  double& mutable_doubelValue() {
    assert(getType() == Type::doubelValue);
    return value_.doubelValue;
  }

  bool& mutable_boolValue() {
    assert(getType() == Type::boolValue);
    return value_.boolValue;
  }

  ::std::vector<::std::int32_t>& mutable_union_list() {
    assert(getType() == Type::union_list);
    return value_.union_list;
  }

  ::std::set<::std::int64_t>& mutable_union_set() {
    assert(getType() == Type::union_set);
    return value_.union_set;
  }

  ::std::map<::std::string, ::std::int32_t>& mutable_union_map() {
    assert(getType() == Type::union_map);
    return value_.union_map;
  }

  ::std::map<::std::string, ::std::int32_t>& mutable_opt_union_map() {
    assert(getType() == Type::opt_union_map);
    return value_.opt_union_map;
  }

  ::some::valid::ns::MyEnumA& mutable_enum_field() {
    assert(getType() == Type::enum_field);
    return value_.enum_field;
  }

  ::std::vector<::some::valid::ns::MyEnumA>& mutable_enum_container() {
    assert(getType() == Type::enum_container);
    return value_.enum_container;
  }

  ::some::valid::ns::MyStruct& mutable_a_struct() {
    assert(getType() == Type::a_struct);
    return value_.a_struct;
  }

  ::std::set<::some::valid::ns::MyStruct>& mutable_a_set_struct() {
    assert(getType() == Type::a_set_struct);
    return value_.a_set_struct;
  }

  ::some::valid::ns::SimpleUnion& mutable_a_union() {
    assert(getType() == Type::a_union);
    return value_.a_union;
  }

  ::some::valid::ns::SimpleUnion& mutable_opt_a_union() {
    assert(getType() == Type::opt_a_union);
    return value_.opt_a_union;
  }

  ::std::vector<::some::valid::ns::SimpleUnion>& mutable_a_union_list() {
    assert(getType() == Type::a_union_list);
    return value_.a_union_list;
  }

  ::some::valid::ns::unionTypeDef& mutable_a_union_typedef() {
    assert(getType() == Type::a_union_typedef);
    return value_.a_union_typedef;
  }

  ::std::vector<::some::valid::ns::unionTypeDef>& mutable_a_union_typedef_list() {
    assert(getType() == Type::a_union_typedef_list);
    return value_.a_union_typedef_list;
  }

  ::std::string& mutable_MyBinaryField() {
    assert(getType() == Type::MyBinaryField);
    return value_.MyBinaryField;
  }

  ::std::string& mutable_MyBinaryField2() {
    assert(getType() == Type::MyBinaryField2);
    return value_.MyBinaryField2;
  }

  ::std::vector<::std::string>& mutable_MyBinaryListField4() {
    assert(getType() == Type::MyBinaryListField4);
    return value_.MyBinaryListField4;
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct>& mutable_ref_field() {
    assert(getType() == Type::ref_field);
    return value_.ref_field;
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct>& mutable_ref_field2() {
    assert(getType() == Type::ref_field2);
    return value_.ref_field2;
  }

  ::some::valid::ns::AnException& mutable_excp_field() {
    assert(getType() == Type::excp_field);
    return value_.excp_field;
  }

  ::some::valid::ns::CustomProtocolType& mutable_MyCustomField() {
    assert(getType() == Type::MyCustomField);
    return value_.MyCustomField;
  }

  ::std::int64_t move_intValue() {
    assert(getType() == Type::intValue);
    return std::move(value_.intValue);
  }

  ::std::int64_t move_opt_intValue() {
    assert(getType() == Type::opt_intValue);
    return std::move(value_.opt_intValue);
  }

  ::std::string move_stringValue() {
    assert(getType() == Type::stringValue);
    return std::move(value_.stringValue);
  }

  ::std::string move_opt_stringValue() {
    assert(getType() == Type::opt_stringValue);
    return std::move(value_.opt_stringValue);
  }

  ::std::int16_t move_intValue2() {
    assert(getType() == Type::intValue2);
    return std::move(value_.intValue2);
  }

  ::std::int32_t move_intValue3() {
    assert(getType() == Type::intValue3);
    return std::move(value_.intValue3);
  }

  double move_doubelValue() {
    assert(getType() == Type::doubelValue);
    return std::move(value_.doubelValue);
  }

  bool move_boolValue() {
    assert(getType() == Type::boolValue);
    return std::move(value_.boolValue);
  }

  ::std::vector<::std::int32_t> move_union_list() {
    assert(getType() == Type::union_list);
    return std::move(value_.union_list);
  }

  ::std::set<::std::int64_t> move_union_set() {
    assert(getType() == Type::union_set);
    return std::move(value_.union_set);
  }

  ::std::map<::std::string, ::std::int32_t> move_union_map() {
    assert(getType() == Type::union_map);
    return std::move(value_.union_map);
  }

  ::std::map<::std::string, ::std::int32_t> move_opt_union_map() {
    assert(getType() == Type::opt_union_map);
    return std::move(value_.opt_union_map);
  }

  ::some::valid::ns::MyEnumA move_enum_field() {
    assert(getType() == Type::enum_field);
    return std::move(value_.enum_field);
  }

  ::std::vector<::some::valid::ns::MyEnumA> move_enum_container() {
    assert(getType() == Type::enum_container);
    return std::move(value_.enum_container);
  }

  ::some::valid::ns::MyStruct move_a_struct() {
    assert(getType() == Type::a_struct);
    return std::move(value_.a_struct);
  }

  ::std::set<::some::valid::ns::MyStruct> move_a_set_struct() {
    assert(getType() == Type::a_set_struct);
    return std::move(value_.a_set_struct);
  }

  ::some::valid::ns::SimpleUnion move_a_union() {
    assert(getType() == Type::a_union);
    return std::move(value_.a_union);
  }

  ::some::valid::ns::SimpleUnion move_opt_a_union() {
    assert(getType() == Type::opt_a_union);
    return std::move(value_.opt_a_union);
  }

  ::std::vector<::some::valid::ns::SimpleUnion> move_a_union_list() {
    assert(getType() == Type::a_union_list);
    return std::move(value_.a_union_list);
  }

  ::some::valid::ns::unionTypeDef move_a_union_typedef() {
    assert(getType() == Type::a_union_typedef);
    return std::move(value_.a_union_typedef);
  }

  ::std::vector<::some::valid::ns::unionTypeDef> move_a_union_typedef_list() {
    assert(getType() == Type::a_union_typedef_list);
    return std::move(value_.a_union_typedef_list);
  }

  ::std::string move_MyBinaryField() {
    assert(getType() == Type::MyBinaryField);
    return std::move(value_.MyBinaryField);
  }

  ::std::string move_MyBinaryField2() {
    assert(getType() == Type::MyBinaryField2);
    return std::move(value_.MyBinaryField2);
  }

  ::std::vector<::std::string> move_MyBinaryListField4() {
    assert(getType() == Type::MyBinaryListField4);
    return std::move(value_.MyBinaryListField4);
  }

  ::std::unique_ptr<::some::valid::ns::MyStruct> move_ref_field() {
    assert(getType() == Type::ref_field);
    return std::move(value_.ref_field);
  }

  ::std::shared_ptr<const ::some::valid::ns::MyStruct> move_ref_field2() {
    assert(getType() == Type::ref_field2);
    return std::move(value_.ref_field2);
  }

  ::some::valid::ns::AnException move_excp_field() {
    assert(getType() == Type::excp_field);
    return std::move(value_.excp_field);
  }

  ::some::valid::ns::CustomProtocolType move_MyCustomField() {
    assert(getType() == Type::MyCustomField);
    return std::move(value_.MyCustomField);
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue_ref() const& {
    return {value_.intValue, type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue_ref() const&& {
    return {std::move(value_.intValue), type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue_ref() & {
    return {value_.intValue, type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue_ref() && {
    return {std::move(value_.intValue), type_, folly::to_underlying(Type::intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_intValue_ref() const& {
    return {value_.opt_intValue, type_, folly::to_underlying(Type::opt_intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_intValue_ref() const&& {
    return {std::move(value_.opt_intValue), type_, folly::to_underlying(Type::opt_intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_intValue_ref() & {
    return {value_.opt_intValue, type_, folly::to_underlying(Type::opt_intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_intValue_ref() && {
    return {std::move(value_.opt_intValue), type_, folly::to_underlying(Type::opt_intValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> stringValue_ref() const& {
    return {value_.stringValue, type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> stringValue_ref() const&& {
    return {std::move(value_.stringValue), type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> stringValue_ref() & {
    return {value_.stringValue, type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> stringValue_ref() && {
    return {std::move(value_.stringValue), type_, folly::to_underlying(Type::stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_stringValue_ref() const& {
    return {value_.opt_stringValue, type_, folly::to_underlying(Type::opt_stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_stringValue_ref() const&& {
    return {std::move(value_.opt_stringValue), type_, folly::to_underlying(Type::opt_stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_stringValue_ref() & {
    return {value_.opt_stringValue, type_, folly::to_underlying(Type::opt_stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_stringValue_ref() && {
    return {std::move(value_.opt_stringValue), type_, folly::to_underlying(Type::opt_stringValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue2_ref() const& {
    return {value_.intValue2, type_, folly::to_underlying(Type::intValue2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue2_ref() const&& {
    return {std::move(value_.intValue2), type_, folly::to_underlying(Type::intValue2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue2_ref() & {
    return {value_.intValue2, type_, folly::to_underlying(Type::intValue2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int16_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue2_ref() && {
    return {std::move(value_.intValue2), type_, folly::to_underlying(Type::intValue2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> intValue3_ref() const& {
    return {value_.intValue3, type_, folly::to_underlying(Type::intValue3), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> intValue3_ref() const&& {
    return {std::move(value_.intValue3), type_, folly::to_underlying(Type::intValue3), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> intValue3_ref() & {
    return {value_.intValue3, type_, folly::to_underlying(Type::intValue3), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> intValue3_ref() && {
    return {std::move(value_.intValue3), type_, folly::to_underlying(Type::intValue3), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubelValue_ref() const& {
    return {value_.doubelValue, type_, folly::to_underlying(Type::doubelValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubelValue_ref() const&& {
    return {std::move(value_.doubelValue), type_, folly::to_underlying(Type::doubelValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubelValue_ref() & {
    return {value_.doubelValue, type_, folly::to_underlying(Type::doubelValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubelValue_ref() && {
    return {std::move(value_.doubelValue), type_, folly::to_underlying(Type::doubelValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> boolValue_ref() const& {
    return {value_.boolValue, type_, folly::to_underlying(Type::boolValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> boolValue_ref() const&& {
    return {std::move(value_.boolValue), type_, folly::to_underlying(Type::boolValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> boolValue_ref() & {
    return {value_.boolValue, type_, folly::to_underlying(Type::boolValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> boolValue_ref() && {
    return {std::move(value_.boolValue), type_, folly::to_underlying(Type::boolValue), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_list_ref() const& {
    return {value_.union_list, type_, folly::to_underlying(Type::union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_list_ref() const&& {
    return {std::move(value_.union_list), type_, folly::to_underlying(Type::union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_list_ref() & {
    return {value_.union_list, type_, folly::to_underlying(Type::union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_list_ref() && {
    return {std::move(value_.union_list), type_, folly::to_underlying(Type::union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_set_ref() const& {
    return {value_.union_set, type_, folly::to_underlying(Type::union_set), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_set_ref() const&& {
    return {std::move(value_.union_set), type_, folly::to_underlying(Type::union_set), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_set_ref() & {
    return {value_.union_set, type_, folly::to_underlying(Type::union_set), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::std::int64_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_set_ref() && {
    return {std::move(value_.union_set), type_, folly::to_underlying(Type::union_set), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> union_map_ref() const& {
    return {value_.union_map, type_, folly::to_underlying(Type::union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> union_map_ref() const&& {
    return {std::move(value_.union_map), type_, folly::to_underlying(Type::union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> union_map_ref() & {
    return {value_.union_map, type_, folly::to_underlying(Type::union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> union_map_ref() && {
    return {std::move(value_.union_map), type_, folly::to_underlying(Type::union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_union_map_ref() const& {
    return {value_.opt_union_map, type_, folly::to_underlying(Type::opt_union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_union_map_ref() const&& {
    return {std::move(value_.opt_union_map), type_, folly::to_underlying(Type::opt_union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_union_map_ref() & {
    return {value_.opt_union_map, type_, folly::to_underlying(Type::opt_union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_union_map_ref() && {
    return {std::move(value_.opt_union_map), type_, folly::to_underlying(Type::opt_union_map), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_field_ref() const& {
    return {value_.enum_field, type_, folly::to_underlying(Type::enum_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_field_ref() const&& {
    return {std::move(value_.enum_field), type_, folly::to_underlying(Type::enum_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_field_ref() & {
    return {value_.enum_field, type_, folly::to_underlying(Type::enum_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_field_ref() && {
    return {std::move(value_.enum_field), type_, folly::to_underlying(Type::enum_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> enum_container_ref() const& {
    return {value_.enum_container, type_, folly::to_underlying(Type::enum_container), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> enum_container_ref() const&& {
    return {std::move(value_.enum_container), type_, folly::to_underlying(Type::enum_container), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> enum_container_ref() & {
    return {value_.enum_container, type_, folly::to_underlying(Type::enum_container), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> enum_container_ref() && {
    return {std::move(value_.enum_container), type_, folly::to_underlying(Type::enum_container), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_struct_ref() const& {
    return {value_.a_struct, type_, folly::to_underlying(Type::a_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_struct_ref() const&& {
    return {std::move(value_.a_struct), type_, folly::to_underlying(Type::a_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_struct_ref() & {
    return {value_.a_struct, type_, folly::to_underlying(Type::a_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_struct_ref() && {
    return {std::move(value_.a_struct), type_, folly::to_underlying(Type::a_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_set_struct_ref() const& {
    return {value_.a_set_struct, type_, folly::to_underlying(Type::a_set_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_set_struct_ref() const&& {
    return {std::move(value_.a_set_struct), type_, folly::to_underlying(Type::a_set_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_set_struct_ref() & {
    return {value_.a_set_struct, type_, folly::to_underlying(Type::a_set_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_set_struct_ref() && {
    return {std::move(value_.a_set_struct), type_, folly::to_underlying(Type::a_set_struct), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_ref() const& {
    return {value_.a_union, type_, folly::to_underlying(Type::a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_ref() const&& {
    return {std::move(value_.a_union), type_, folly::to_underlying(Type::a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_ref() & {
    return {value_.a_union, type_, folly::to_underlying(Type::a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_ref() && {
    return {std::move(value_.a_union), type_, folly::to_underlying(Type::a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> opt_a_union_ref() const& {
    return {value_.opt_a_union, type_, folly::to_underlying(Type::opt_a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> opt_a_union_ref() const&& {
    return {std::move(value_.opt_a_union), type_, folly::to_underlying(Type::opt_a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> opt_a_union_ref() & {
    return {value_.opt_a_union, type_, folly::to_underlying(Type::opt_a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::SimpleUnion>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> opt_a_union_ref() && {
    return {std::move(value_.opt_a_union), type_, folly::to_underlying(Type::opt_a_union), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_list_ref() const& {
    return {value_.a_union_list, type_, folly::to_underlying(Type::a_union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_list_ref() const&& {
    return {std::move(value_.a_union_list), type_, folly::to_underlying(Type::a_union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_list_ref() & {
    return {value_.a_union_list, type_, folly::to_underlying(Type::a_union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::SimpleUnion>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_list_ref() && {
    return {std::move(value_.a_union_list), type_, folly::to_underlying(Type::a_union_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_ref() const& {
    return {value_.a_union_typedef, type_, folly::to_underlying(Type::a_union_typedef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_ref() const&& {
    return {std::move(value_.a_union_typedef), type_, folly::to_underlying(Type::a_union_typedef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_ref() & {
    return {value_.a_union_typedef, type_, folly::to_underlying(Type::a_union_typedef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_ref() && {
    return {std::move(value_.a_union_typedef), type_, folly::to_underlying(Type::a_union_typedef), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> a_union_typedef_list_ref() const& {
    return {value_.a_union_typedef_list, type_, folly::to_underlying(Type::a_union_typedef_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> a_union_typedef_list_ref() const&& {
    return {std::move(value_.a_union_typedef_list), type_, folly::to_underlying(Type::a_union_typedef_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> a_union_typedef_list_ref() & {
    return {value_.a_union_typedef_list, type_, folly::to_underlying(Type::a_union_typedef_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> a_union_typedef_list_ref() && {
    return {std::move(value_.a_union_typedef_list), type_, folly::to_underlying(Type::a_union_typedef_list), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField_ref() const& {
    return {value_.MyBinaryField, type_, folly::to_underlying(Type::MyBinaryField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField_ref() const&& {
    return {std::move(value_.MyBinaryField), type_, folly::to_underlying(Type::MyBinaryField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField_ref() & {
    return {value_.MyBinaryField, type_, folly::to_underlying(Type::MyBinaryField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField_ref() && {
    return {std::move(value_.MyBinaryField), type_, folly::to_underlying(Type::MyBinaryField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryField2_ref() const& {
    return {value_.MyBinaryField2, type_, folly::to_underlying(Type::MyBinaryField2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryField2_ref() const&& {
    return {std::move(value_.MyBinaryField2), type_, folly::to_underlying(Type::MyBinaryField2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryField2_ref() & {
    return {value_.MyBinaryField2, type_, folly::to_underlying(Type::MyBinaryField2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryField2_ref() && {
    return {std::move(value_.MyBinaryField2), type_, folly::to_underlying(Type::MyBinaryField2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyBinaryListField4_ref() const& {
    return {value_.MyBinaryListField4, type_, folly::to_underlying(Type::MyBinaryListField4), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyBinaryListField4_ref() const&& {
    return {std::move(value_.MyBinaryListField4), type_, folly::to_underlying(Type::MyBinaryListField4), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyBinaryListField4_ref() & {
    return {value_.MyBinaryListField4, type_, folly::to_underlying(Type::MyBinaryListField4), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::vector<::std::string>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyBinaryListField4_ref() && {
    return {std::move(value_.MyBinaryListField4), type_, folly::to_underlying(Type::MyBinaryListField4), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::unique_ptr<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field_ref() const& {
    return {value_.ref_field, type_, folly::to_underlying(Type::ref_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::unique_ptr<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field_ref() const&& {
    return {std::move(value_.ref_field), type_, folly::to_underlying(Type::ref_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::unique_ptr<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field_ref() & {
    return {value_.ref_field, type_, folly::to_underlying(Type::ref_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::unique_ptr<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field_ref() && {
    return {std::move(value_.ref_field), type_, folly::to_underlying(Type::ref_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::std::shared_ptr<const ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> ref_field2_ref() const& {
    return {value_.ref_field2, type_, folly::to_underlying(Type::ref_field2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::shared_ptr<const ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> ref_field2_ref() const&& {
    return {std::move(value_.ref_field2), type_, folly::to_underlying(Type::ref_field2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::shared_ptr<const ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> ref_field2_ref() & {
    return {value_.ref_field2, type_, folly::to_underlying(Type::ref_field2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::std::shared_ptr<const ::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> ref_field2_ref() && {
    return {std::move(value_.ref_field2), type_, folly::to_underlying(Type::ref_field2), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> excp_field_ref() const& {
    return {value_.excp_field, type_, folly::to_underlying(Type::excp_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> excp_field_ref() const&& {
    return {std::move(value_.excp_field), type_, folly::to_underlying(Type::excp_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> excp_field_ref() & {
    return {value_.excp_field, type_, folly::to_underlying(Type::excp_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::AnException>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> excp_field_ref() && {
    return {std::move(value_.excp_field), type_, folly::to_underlying(Type::excp_field), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> MyCustomField_ref() const& {
    return {value_.MyCustomField, type_, folly::to_underlying(Type::MyCustomField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> MyCustomField_ref() const&& {
    return {std::move(value_.MyCustomField), type_, folly::to_underlying(Type::MyCustomField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> MyCustomField_ref() & {
    return {value_.MyCustomField, type_, folly::to_underlying(Type::MyCustomField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::some::valid::ns::CustomProtocolType>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> MyCustomField_ref() && {
    return {std::move(value_.MyCustomField), type_, folly::to_underlying(Type::MyCustomField), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexUnion>;
  friend void swap(ComplexUnion& a, ComplexUnion& b);
};

template <class Protocol_>
unsigned long ComplexUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class FOLLY_EXPORT AnotherException : public virtual apache::thrift::TException {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::code,
    ::apache::thrift::ident::req_code,
    ::apache::thrift::ident::message
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,101,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::string_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 3;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;
  static constexpr ::apache::thrift::ExceptionKind __fbthrift_cpp2_gen_exception_kind =
         ::apache::thrift::ExceptionKind::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionSafety __fbthrift_cpp2_gen_exception_safety =
         ::apache::thrift::ExceptionSafety::UNSPECIFIED;
  static constexpr ::apache::thrift::ExceptionBlame __fbthrift_cpp2_gen_exception_blame =
         ::apache::thrift::ExceptionBlame::UNSPECIFIED;

 public:
  using __fbthrift_cpp2_type = AnotherException;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnotherException();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnotherException(apache::thrift::FragileConstructor, ::std::int32_t code__arg, ::std::int32_t req_code__arg, ::std::string message__arg);

  AnotherException(AnotherException&&) noexcept;

  AnotherException(const AnotherException& src);


  AnotherException& operator=(AnotherException&&) noexcept;
  AnotherException& operator=(const AnotherException& src);

   ~AnotherException()  override;

 private:
  ::std::int32_t __fbthrift_field_code;
 private:
  ::std::int32_t __fbthrift_field_req_code;
 private:
  ::std::string __fbthrift_field_message;
 private:
  apache::thrift::detail::isset_bitset<2, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const AnotherException&) const;
  bool operator<(const AnotherException&) const;

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code_ref() const& {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code_ref() & {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> code() const& {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> code() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> code() & {
    return {this->__fbthrift_field_code, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> code() && {
    return {static_cast<T&&>(this->__fbthrift_field_code), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_code() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_code() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_code() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_req_code};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_code() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_req_code)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message_ref() const& {
    return {this->__fbthrift_field_message, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_message), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message_ref() & {
    return {this->__fbthrift_field_message, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_message), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> message() const& {
    return {this->__fbthrift_field_message, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> message() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_message), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> message() & {
    return {this->__fbthrift_field_message, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> message() && {
    return {static_cast<T&&>(this->__fbthrift_field_message), __isset.at(1), __isset.bit(1)};
  }

  ::std::int32_t get_code() const {
    return __fbthrift_field_code;
  }

  [[deprecated("Use `FOO.code_ref() = BAR;` instead of `FOO.set_code(BAR);`")]]
  ::std::int32_t& set_code(::std::int32_t code_) {
    code_ref() = code_;
    return __fbthrift_field_code;
  }

  ::std::int32_t get_req_code() const {
    return __fbthrift_field_req_code;
  }

  [[deprecated("Use `FOO.req_code_ref() = BAR;` instead of `FOO.set_req_code(BAR);`")]]
  ::std::int32_t& set_req_code(::std::int32_t req_code_) {
    req_code_ref() = req_code_;
    return __fbthrift_field_req_code;
  }

  const ::std::string& get_message() const& {
    return __fbthrift_field_message;
  }

  ::std::string get_message() && {
    return std::move(__fbthrift_field_message);
  }

  template <typename T_AnotherException_message_struct_setter = ::std::string>
  [[deprecated("Use `FOO.message_ref() = BAR;` instead of `FOO.set_message(BAR);`")]]
  ::std::string& set_message(T_AnotherException_message_struct_setter&& message_) {
    message_ref() = std::forward<T_AnotherException_message_struct_setter>(message_);
    return __fbthrift_field_message;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

  const char* what() const noexcept override {
    return "::some::valid::ns::AnotherException";
  }

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnotherException>;
  friend void swap(AnotherException& a, AnotherException& b);
};

template <class Protocol_>
unsigned long AnotherException::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class containerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::fieldA,
    ::apache::thrift::ident::req_fieldA,
    ::apache::thrift::ident::opt_fieldA,
    ::apache::thrift::ident::fieldB,
    ::apache::thrift::ident::req_fieldB,
    ::apache::thrift::ident::opt_fieldB,
    ::apache::thrift::ident::fieldC,
    ::apache::thrift::ident::req_fieldC,
    ::apache::thrift::ident::opt_fieldC,
    ::apache::thrift::ident::fieldD,
    ::apache::thrift::ident::fieldE,
    ::apache::thrift::ident::req_fieldE,
    ::apache::thrift::ident::opt_fieldE,
    ::apache::thrift::ident::fieldF,
    ::apache::thrift::ident::fieldG,
    ::apache::thrift::ident::fieldH,
    ::apache::thrift::ident::fieldI,
    ::apache::thrift::ident::fieldJ,
    ::apache::thrift::ident::fieldK,
    ::apache::thrift::ident::fieldL,
    ::apache::thrift::ident::fieldM,
    ::apache::thrift::ident::fieldN,
    ::apache::thrift::ident::fieldO,
    ::apache::thrift::ident::fieldP,
    ::apache::thrift::ident::fieldQ,
    ::apache::thrift::ident::fieldR,
    ::apache::thrift::ident::req_fieldR,
    ::apache::thrift::ident::opt_fieldR,
    ::apache::thrift::ident::fieldS,
    ::apache::thrift::ident::fieldT,
    ::apache::thrift::ident::fieldU,
    ::apache::thrift::ident::fieldV,
    ::apache::thrift::ident::req_fieldV,
    ::apache::thrift::ident::opt_fieldV,
    ::apache::thrift::ident::fieldW,
    ::apache::thrift::ident::fieldX,
    ::apache::thrift::ident::req_fieldX,
    ::apache::thrift::ident::opt_fieldX,
    ::apache::thrift::ident::fieldY,
    ::apache::thrift::ident::fieldZ,
    ::apache::thrift::ident::fieldAA,
    ::apache::thrift::ident::fieldAB,
    ::apache::thrift::ident::fieldAC,
    ::apache::thrift::ident::fieldAD,
    ::apache::thrift::ident::fieldAE,
    ::apache::thrift::ident::fieldSD
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,101,201,2,102,202,3,103,203,4,5,105,205,6,7,8,9,10,11,12,13,14,15,16,17,18,118,218,19,21,22,23,123,223,24,25,125,225,26,27,28,29,30,31,32,33};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::bool_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::bool_t>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::bool_t>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::string_t,
    ::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>>>,
    ::apache::thrift::type::list<::apache::thrift::type::set<::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::bool_t,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::list<::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::i32_t>>>>,
    ::apache::thrift::type::set<::apache::thrift::type::set<::apache::thrift::type::set<::apache::thrift::type::bool_t>>>,
    ::apache::thrift::type::map<::apache::thrift::type::set<::apache::thrift::type::list<::apache::thrift::type::i32_t>>, ::apache::thrift::type::map<::apache::thrift::type::list<::apache::thrift::type::set<::apache::thrift::type::string_t>>, ::apache::thrift::type::string_t>>,
    ::apache::thrift::type::i32_t,
    ::apache::thrift::type::list<::apache::thrift::type::map<::apache::thrift::type::struct_t<::some::valid::ns::Empty>, ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>>>,
    ::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::list<::apache::thrift::type::map<::apache::thrift::type::struct_t<::some::valid::ns::Empty>, ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>>>>>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>,
    ::apache::thrift::type::list<::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>>,
    ::apache::thrift::type::list<::apache::thrift::type::enum_t<::some::valid::ns::MyEnumA>>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>,
    ::apache::thrift::type::set<::apache::thrift::type::struct_t<::some::valid::ns::MyStruct>>,
    ::apache::thrift::type::union_t<::some::valid::ns::ComplexUnion>,
    ::apache::thrift::type::union_t<::some::valid::ns::ComplexUnion>,
    ::apache::thrift::type::union_t<::some::valid::ns::ComplexUnion>,
    ::apache::thrift::type::list<::apache::thrift::type::union_t<::some::valid::ns::ComplexUnion>>,
    ::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>,
    ::apache::thrift::type::list<::apache::thrift::type::set<::apache::thrift::type::union_t<::some::valid::ns::SimpleUnion>>>,
    ::apache::thrift::type::map<::apache::thrift::type::indirected<Bar, ::apache::thrift::type::double_t>, ::apache::thrift::type::indirected<Baz, ::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::enum_t<::some::valid::ns::MyEnumB>,
    ::apache::thrift::type::enum_t<::a::different::ns::AnEnum>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::indirected<FooBar, ::apache::thrift::type::string_t>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 46;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = containerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  containerStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  containerStruct(apache::thrift::FragileConstructor, bool fieldA__arg, bool req_fieldA__arg, bool opt_fieldA__arg, ::std::map<::std::string, bool> fieldB__arg, ::std::map<::std::string, bool> req_fieldB__arg, ::std::map<::std::string, bool> opt_fieldB__arg, ::std::set<::std::int32_t> fieldC__arg, ::std::set<::std::int32_t> req_fieldC__arg, ::std::set<::std::int32_t> opt_fieldC__arg, ::std::string fieldD__arg, ::std::string fieldE__arg, ::std::string req_fieldE__arg, ::std::string opt_fieldE__arg, ::std::vector<::std::vector<::std::int32_t>> fieldF__arg, ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> fieldG__arg, ::std::vector<::std::set<::std::int32_t>> fieldH__arg, bool fieldI__arg, ::std::map<::std::string, ::std::vector<::std::int32_t>> fieldJ__arg, ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> fieldK__arg, ::std::set<::std::set<::std::set<bool>>> fieldL__arg, ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM__arg, ::some::valid::ns::simpleTypeDef fieldN__arg, ::some::valid::ns::complexStructTypeDef fieldO__arg, ::std::vector<::some::valid::ns::mostComplexTypeDef> fieldP__arg, ::some::valid::ns::MyEnumA fieldQ__arg, ::some::valid::ns::MyEnumA fieldR__arg, ::some::valid::ns::MyEnumA req_fieldR__arg, ::some::valid::ns::MyEnumA opt_fieldR__arg, ::some::valid::ns::MyEnumA fieldS__arg, ::std::vector<::some::valid::ns::MyEnumA> fieldT__arg, ::std::vector<::some::valid::ns::MyEnumA> fieldU__arg, ::some::valid::ns::MyStruct fieldV__arg, ::some::valid::ns::MyStruct req_fieldV__arg, ::some::valid::ns::MyStruct opt_fieldV__arg, ::std::set<::some::valid::ns::MyStruct> fieldW__arg, ::some::valid::ns::ComplexUnion fieldX__arg, ::some::valid::ns::ComplexUnion req_fieldX__arg, ::some::valid::ns::ComplexUnion opt_fieldX__arg, ::std::vector<::some::valid::ns::ComplexUnion> fieldY__arg, ::some::valid::ns::unionTypeDef fieldZ__arg, ::std::vector<::some::valid::ns::unionTypeDef> fieldAA__arg, ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> fieldAB__arg, ::some::valid::ns::MyEnumB fieldAC__arg, ::a::different::ns::AnEnum fieldAD__arg, ::std::map<::std::string, ::std::int32_t> fieldAE__arg, ::some::valid::ns::IndirectionD fieldSD__arg);

  containerStruct(containerStruct&&) = default;


  containerStruct& operator=(containerStruct&&) = default;

  ~containerStruct();

 private:
  bool fieldA;
 private:
  bool req_fieldA;
 private:
  bool opt_fieldA;
 private:
  ::std::map<::std::string, bool> fieldB;
 private:
  ::std::map<::std::string, bool> req_fieldB;
 private:
  ::std::map<::std::string, bool> opt_fieldB;
 private:
  ::std::set<::std::int32_t> fieldC;
 private:
  ::std::set<::std::int32_t> req_fieldC;
 private:
  ::std::set<::std::int32_t> opt_fieldC;
 private:
  ::std::string fieldD;
 private:
  ::std::string fieldE;
 private:
  ::std::string req_fieldE;
 private:
  ::std::string opt_fieldE;
 private:
  ::std::vector<::std::vector<::std::int32_t>> fieldF;
 private:
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> fieldG;
 private:
  ::std::vector<::std::set<::std::int32_t>> fieldH;
 private:
  bool fieldI;
 private:
  ::std::map<::std::string, ::std::vector<::std::int32_t>> fieldJ;
 private:
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> fieldK;
 private:
  ::std::set<::std::set<::std::set<bool>>> fieldL;
 private:
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> fieldM;
 private:
  ::some::valid::ns::simpleTypeDef fieldN;
 private:
  ::some::valid::ns::complexStructTypeDef fieldO;
 private:
  ::std::vector<::some::valid::ns::mostComplexTypeDef> fieldP;
 private:
  ::some::valid::ns::MyEnumA fieldQ;
 private:
  ::some::valid::ns::MyEnumA fieldR;
 private:
  ::some::valid::ns::MyEnumA req_fieldR;
 private:
  ::some::valid::ns::MyEnumA opt_fieldR;
 private:
  ::some::valid::ns::MyEnumA fieldS;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> fieldT;
 private:
  ::std::vector<::some::valid::ns::MyEnumA> fieldU;
 private:
  ::some::valid::ns::MyStruct fieldV;
 private:
  ::some::valid::ns::MyStruct req_fieldV;
 private:
  ::some::valid::ns::MyStruct opt_fieldV;
 private:
  ::std::set<::some::valid::ns::MyStruct> fieldW;
 private:
  ::some::valid::ns::ComplexUnion fieldX;
 private:
  ::some::valid::ns::ComplexUnion req_fieldX;
 private:
  ::some::valid::ns::ComplexUnion opt_fieldX;
 private:
  ::std::vector<::some::valid::ns::ComplexUnion> fieldY;
 private:
  ::some::valid::ns::unionTypeDef fieldZ;
 private:
  ::std::vector<::some::valid::ns::unionTypeDef> fieldAA;
 private:
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> fieldAB;
 private:
  ::some::valid::ns::MyEnumB fieldAC;
 private:
  ::a::different::ns::AnEnum fieldAD;
 private:
  ::std::map<::std::string, ::std::int32_t> fieldAE;
 private:
  ::some::valid::ns::IndirectionD fieldSD;
 private:
  apache::thrift::detail::isset_bitset<39, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const containerStruct&) const;
  bool operator<(const containerStruct&) const;

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldA_ref() const& {
    return {this->fieldA, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldA_ref() const&& {
    return {static_cast<const T&&>(this->fieldA), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldA_ref() & {
    return {this->fieldA, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldA_ref() && {
    return {static_cast<T&&>(this->fieldA), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldA_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldA_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldA)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldA_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldA};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldA_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldA)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldA_ref() const& {
    return {this->opt_fieldA, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldA_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldA), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldA_ref() & {
    return {this->opt_fieldA, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldA_ref() && {
    return {static_cast<T&&>(this->opt_fieldA), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldB_ref() const& {
    return {this->fieldB, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldB_ref() const&& {
    return {static_cast<const T&&>(this->fieldB), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldB_ref() & {
    return {this->fieldB, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldB_ref() && {
    return {static_cast<T&&>(this->fieldB), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldB_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldB_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldB)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldB_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldB};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldB_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldB)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldB_ref() const& {
    return {this->opt_fieldB, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldB_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldB), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldB_ref() & {
    return {this->opt_fieldB, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::map<::std::string, bool>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldB_ref() && {
    return {static_cast<T&&>(this->opt_fieldB), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldC_ref() const& {
    return {this->fieldC, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldC_ref() const&& {
    return {static_cast<const T&&>(this->fieldC), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldC_ref() & {
    return {this->fieldC, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldC_ref() && {
    return {static_cast<T&&>(this->fieldC), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldC_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldC_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldC)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldC_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldC};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldC_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldC)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldC_ref() const& {
    return {this->opt_fieldC, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldC_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldC), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldC_ref() & {
    return {this->opt_fieldC, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::set<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldC_ref() && {
    return {static_cast<T&&>(this->opt_fieldC), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldD_ref() const& {
    return {this->fieldD, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldD_ref() const&& {
    return {static_cast<const T&&>(this->fieldD), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldD_ref() & {
    return {this->fieldD, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldD_ref() && {
    return {static_cast<T&&>(this->fieldD), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldE_ref() const& {
    return {this->fieldE, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldE_ref() const&& {
    return {static_cast<const T&&>(this->fieldE), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldE_ref() & {
    return {this->fieldE, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldE_ref() && {
    return {static_cast<T&&>(this->fieldE), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldE_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldE_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldE)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldE_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldE};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldE_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldE)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldE_ref() const& {
    return {this->opt_fieldE, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldE_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldE), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldE_ref() & {
    return {this->opt_fieldE, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldE_ref() && {
    return {static_cast<T&&>(this->opt_fieldE), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldF_ref() const& {
    return {this->fieldF, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldF_ref() const&& {
    return {static_cast<const T&&>(this->fieldF), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldF_ref() & {
    return {this->fieldF, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldF_ref() && {
    return {static_cast<T&&>(this->fieldF), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldG_ref() const& {
    return {this->fieldG, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldG_ref() const&& {
    return {static_cast<const T&&>(this->fieldG), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldG_ref() & {
    return {this->fieldG, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldG_ref() && {
    return {static_cast<T&&>(this->fieldG), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldH_ref() const& {
    return {this->fieldH, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldH_ref() const&& {
    return {static_cast<const T&&>(this->fieldH), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldH_ref() & {
    return {this->fieldH, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::std::vector<::std::set<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldH_ref() && {
    return {static_cast<T&&>(this->fieldH), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldI_ref() const& {
    return {this->fieldI, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldI_ref() const&& {
    return {static_cast<const T&&>(this->fieldI), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldI_ref() & {
    return {this->fieldI, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldI_ref() && {
    return {static_cast<T&&>(this->fieldI), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldJ_ref() const& {
    return {this->fieldJ, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldJ_ref() const&& {
    return {static_cast<const T&&>(this->fieldJ), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldJ_ref() & {
    return {this->fieldJ, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldJ_ref() && {
    return {static_cast<T&&>(this->fieldJ), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldK_ref() const& {
    return {this->fieldK, __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldK_ref() const&& {
    return {static_cast<const T&&>(this->fieldK), __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldK_ref() & {
    return {this->fieldK, __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldK_ref() && {
    return {static_cast<T&&>(this->fieldK), __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldL_ref() const& {
    return {this->fieldL, __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldL_ref() const&& {
    return {static_cast<const T&&>(this->fieldL), __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldL_ref() & {
    return {this->fieldL, __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::std::set<::std::set<::std::set<bool>>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldL_ref() && {
    return {static_cast<T&&>(this->fieldL), __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldM_ref() const& {
    return {this->fieldM, __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldM_ref() const&& {
    return {static_cast<const T&&>(this->fieldM), __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldM_ref() & {
    return {this->fieldM, __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldM_ref() && {
    return {static_cast<T&&>(this->fieldM), __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldN_ref() const& {
    return {this->fieldN, __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldN_ref() const&& {
    return {static_cast<const T&&>(this->fieldN), __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldN_ref() & {
    return {this->fieldN, __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::some::valid::ns::simpleTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldN_ref() && {
    return {static_cast<T&&>(this->fieldN), __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldO_ref() const& {
    return {this->fieldO, __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldO_ref() const&& {
    return {static_cast<const T&&>(this->fieldO), __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldO_ref() & {
    return {this->fieldO, __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::some::valid::ns::complexStructTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldO_ref() && {
    return {static_cast<T&&>(this->fieldO), __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldP_ref() const& {
    return {this->fieldP, __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldP_ref() const&& {
    return {static_cast<const T&&>(this->fieldP), __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldP_ref() & {
    return {this->fieldP, __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldP_ref() && {
    return {static_cast<T&&>(this->fieldP), __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldQ_ref() const& {
    return {this->fieldQ, __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldQ_ref() const&& {
    return {static_cast<const T&&>(this->fieldQ), __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldQ_ref() & {
    return {this->fieldQ, __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldQ_ref() && {
    return {static_cast<T&&>(this->fieldQ), __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldR_ref() const& {
    return {this->fieldR, __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldR_ref() const&& {
    return {static_cast<const T&&>(this->fieldR), __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldR_ref() & {
    return {this->fieldR, __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldR_ref() && {
    return {static_cast<T&&>(this->fieldR), __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldR_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldR_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldR)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldR_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldR};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldR_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldR)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldR_ref() const& {
    return {this->opt_fieldR, __isset.at(22), __isset.bit(22)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldR_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldR), __isset.at(22), __isset.bit(22)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldR_ref() & {
    return {this->opt_fieldR, __isset.at(22), __isset.bit(22)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldR_ref() && {
    return {static_cast<T&&>(this->opt_fieldR), __isset.at(22), __isset.bit(22)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldS_ref() const& {
    return {this->fieldS, __isset.at(23), __isset.bit(23)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldS_ref() const&& {
    return {static_cast<const T&&>(this->fieldS), __isset.at(23), __isset.bit(23)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldS_ref() & {
    return {this->fieldS, __isset.at(23), __isset.bit(23)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldS_ref() && {
    return {static_cast<T&&>(this->fieldS), __isset.at(23), __isset.bit(23)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldT_ref() const& {
    return {this->fieldT, __isset.at(24), __isset.bit(24)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldT_ref() const&& {
    return {static_cast<const T&&>(this->fieldT), __isset.at(24), __isset.bit(24)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldT_ref() & {
    return {this->fieldT, __isset.at(24), __isset.bit(24)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldT_ref() && {
    return {static_cast<T&&>(this->fieldT), __isset.at(24), __isset.bit(24)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldU_ref() const& {
    return {this->fieldU, __isset.at(25), __isset.bit(25)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldU_ref() const&& {
    return {static_cast<const T&&>(this->fieldU), __isset.at(25), __isset.bit(25)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldU_ref() & {
    return {this->fieldU, __isset.at(25), __isset.bit(25)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::MyEnumA>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldU_ref() && {
    return {static_cast<T&&>(this->fieldU), __isset.at(25), __isset.bit(25)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldV_ref() const& {
    return {this->fieldV, __isset.at(26), __isset.bit(26)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldV_ref() const&& {
    return {static_cast<const T&&>(this->fieldV), __isset.at(26), __isset.bit(26)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldV_ref() & {
    return {this->fieldV, __isset.at(26), __isset.bit(26)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldV_ref() && {
    return {static_cast<T&&>(this->fieldV), __isset.at(26), __isset.bit(26)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldV_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldV_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldV)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldV_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldV};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldV_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldV)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldV_ref() const& {
    return {this->opt_fieldV, __isset.at(27), __isset.bit(27)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldV_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldV), __isset.at(27), __isset.bit(27)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldV_ref() & {
    return {this->opt_fieldV, __isset.at(27), __isset.bit(27)};
  }

  template <typename..., typename T = ::some::valid::ns::MyStruct>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldV_ref() && {
    return {static_cast<T&&>(this->opt_fieldV), __isset.at(27), __isset.bit(27)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldW_ref() const& {
    return {this->fieldW, __isset.at(28), __isset.bit(28)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldW_ref() const&& {
    return {static_cast<const T&&>(this->fieldW), __isset.at(28), __isset.bit(28)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldW_ref() & {
    return {this->fieldW, __isset.at(28), __isset.bit(28)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::MyStruct>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldW_ref() && {
    return {static_cast<T&&>(this->fieldW), __isset.at(28), __isset.bit(28)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldX_ref() const& {
    return {this->fieldX, __isset.at(29), __isset.bit(29)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldX_ref() const&& {
    return {static_cast<const T&&>(this->fieldX), __isset.at(29), __isset.bit(29)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldX_ref() & {
    return {this->fieldX, __isset.at(29), __isset.bit(29)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldX_ref() && {
    return {static_cast<T&&>(this->fieldX), __isset.at(29), __isset.bit(29)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> req_fieldX_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->req_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> req_fieldX_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->req_fieldX)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> req_fieldX_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->req_fieldX};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> req_fieldX_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->req_fieldX)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opt_fieldX_ref() const& {
    return {this->opt_fieldX, __isset.at(30), __isset.bit(30)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opt_fieldX_ref() const&& {
    return {static_cast<const T&&>(this->opt_fieldX), __isset.at(30), __isset.bit(30)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opt_fieldX_ref() & {
    return {this->opt_fieldX, __isset.at(30), __isset.bit(30)};
  }

  template <typename..., typename T = ::some::valid::ns::ComplexUnion>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opt_fieldX_ref() && {
    return {static_cast<T&&>(this->opt_fieldX), __isset.at(30), __isset.bit(30)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldY_ref() const& {
    return {this->fieldY, __isset.at(31), __isset.bit(31)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldY_ref() const&& {
    return {static_cast<const T&&>(this->fieldY), __isset.at(31), __isset.bit(31)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldY_ref() & {
    return {this->fieldY, __isset.at(31), __isset.bit(31)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::ComplexUnion>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldY_ref() && {
    return {static_cast<T&&>(this->fieldY), __isset.at(31), __isset.bit(31)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldZ_ref() const& {
    return {this->fieldZ, __isset.at(32), __isset.bit(32)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldZ_ref() const&& {
    return {static_cast<const T&&>(this->fieldZ), __isset.at(32), __isset.bit(32)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldZ_ref() & {
    return {this->fieldZ, __isset.at(32), __isset.bit(32)};
  }

  template <typename..., typename T = ::some::valid::ns::unionTypeDef>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldZ_ref() && {
    return {static_cast<T&&>(this->fieldZ), __isset.at(32), __isset.bit(32)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAA_ref() const& {
    return {this->fieldAA, __isset.at(33), __isset.bit(33)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAA_ref() const&& {
    return {static_cast<const T&&>(this->fieldAA), __isset.at(33), __isset.bit(33)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAA_ref() & {
    return {this->fieldAA, __isset.at(33), __isset.bit(33)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::unionTypeDef>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAA_ref() && {
    return {static_cast<T&&>(this->fieldAA), __isset.at(33), __isset.bit(33)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAB_ref() const& {
    return {this->fieldAB, __isset.at(34), __isset.bit(34)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAB_ref() const&& {
    return {static_cast<const T&&>(this->fieldAB), __isset.at(34), __isset.bit(34)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAB_ref() & {
    return {this->fieldAB, __isset.at(34), __isset.bit(34)};
  }

  template <typename..., typename T = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAB_ref() && {
    return {static_cast<T&&>(this->fieldAB), __isset.at(34), __isset.bit(34)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAC_ref() const& {
    return {this->fieldAC, __isset.at(35), __isset.bit(35)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAC_ref() const&& {
    return {static_cast<const T&&>(this->fieldAC), __isset.at(35), __isset.bit(35)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAC_ref() & {
    return {this->fieldAC, __isset.at(35), __isset.bit(35)};
  }

  template <typename..., typename T = ::some::valid::ns::MyEnumB>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAC_ref() && {
    return {static_cast<T&&>(this->fieldAC), __isset.at(35), __isset.bit(35)};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAD_ref() const& {
    return {this->fieldAD, __isset.at(36), __isset.bit(36)};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAD_ref() const&& {
    return {static_cast<const T&&>(this->fieldAD), __isset.at(36), __isset.bit(36)};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAD_ref() & {
    return {this->fieldAD, __isset.at(36), __isset.bit(36)};
  }

  template <typename..., typename T = ::a::different::ns::AnEnum>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAD_ref() && {
    return {static_cast<T&&>(this->fieldAD), __isset.at(36), __isset.bit(36)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldAE_ref() const& {
    return {this->fieldAE, __isset.at(37), __isset.bit(37)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldAE_ref() const&& {
    return {static_cast<const T&&>(this->fieldAE), __isset.at(37), __isset.bit(37)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldAE_ref() & {
    return {this->fieldAE, __isset.at(37), __isset.bit(37)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldAE_ref() && {
    return {static_cast<T&&>(this->fieldAE), __isset.at(37), __isset.bit(37)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> fieldSD_ref() const& {
    return {this->fieldSD, __isset.at(38), __isset.bit(38)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> fieldSD_ref() const&& {
    return {static_cast<const T&&>(this->fieldSD), __isset.at(38), __isset.bit(38)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> fieldSD_ref() & {
    return {this->fieldSD, __isset.at(38), __isset.bit(38)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionD>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> fieldSD_ref() && {
    return {static_cast<T&&>(this->fieldSD), __isset.at(38), __isset.bit(38)};
  }

  bool get_fieldA() const {
    return fieldA;
  }

  [[deprecated("Use `FOO.fieldA_ref() = BAR;` instead of `FOO.set_fieldA(BAR);`")]]
  bool& set_fieldA(bool fieldA_) {
    fieldA_ref() = fieldA_;
    return fieldA;
  }

  bool get_req_fieldA() const {
    return req_fieldA;
  }

  [[deprecated("Use `FOO.req_fieldA_ref() = BAR;` instead of `FOO.set_req_fieldA(BAR);`")]]
  bool& set_req_fieldA(bool req_fieldA_) {
    req_fieldA_ref() = req_fieldA_;
    return req_fieldA;
  }

  const bool* get_opt_fieldA() const& {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }

  bool* get_opt_fieldA() & {
    return opt_fieldA_ref() ? std::addressof(opt_fieldA) : nullptr;
  }
  bool* get_opt_fieldA() && = delete;

  [[deprecated("Use `FOO.opt_fieldA_ref() = BAR;` instead of `FOO.set_opt_fieldA(BAR);`")]]
  bool& set_opt_fieldA(bool opt_fieldA_) {
    opt_fieldA_ref() = opt_fieldA_;
    return opt_fieldA;
  }
  const ::std::map<::std::string, bool>& get_fieldB() const&;
  ::std::map<::std::string, bool> get_fieldB() &&;

  template <typename T_containerStruct_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.fieldB_ref() = BAR;` instead of `FOO.set_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_fieldB(T_containerStruct_fieldB_struct_setter&& fieldB_) {
    fieldB_ref() = std::forward<T_containerStruct_fieldB_struct_setter>(fieldB_);
    return fieldB;
  }
  const ::std::map<::std::string, bool>& get_req_fieldB() const&;
  ::std::map<::std::string, bool> get_req_fieldB() &&;

  template <typename T_containerStruct_req_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.req_fieldB_ref() = BAR;` instead of `FOO.set_req_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_req_fieldB(T_containerStruct_req_fieldB_struct_setter&& req_fieldB_) {
    req_fieldB_ref() = std::forward<T_containerStruct_req_fieldB_struct_setter>(req_fieldB_);
    return req_fieldB;
  }
  const ::std::map<::std::string, bool>* get_opt_fieldB() const&;
  ::std::map<::std::string, bool>* get_opt_fieldB() &;
  ::std::map<::std::string, bool>* get_opt_fieldB() && = delete;

  template <typename T_containerStruct_opt_fieldB_struct_setter = ::std::map<::std::string, bool>>
  [[deprecated("Use `FOO.opt_fieldB_ref() = BAR;` instead of `FOO.set_opt_fieldB(BAR);`")]]
  ::std::map<::std::string, bool>& set_opt_fieldB(T_containerStruct_opt_fieldB_struct_setter&& opt_fieldB_) {
    opt_fieldB_ref() = std::forward<T_containerStruct_opt_fieldB_struct_setter>(opt_fieldB_);
    return opt_fieldB;
  }
  const ::std::set<::std::int32_t>& get_fieldC() const&;
  ::std::set<::std::int32_t> get_fieldC() &&;

  template <typename T_containerStruct_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.fieldC_ref() = BAR;` instead of `FOO.set_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_fieldC(T_containerStruct_fieldC_struct_setter&& fieldC_) {
    fieldC_ref() = std::forward<T_containerStruct_fieldC_struct_setter>(fieldC_);
    return fieldC;
  }
  const ::std::set<::std::int32_t>& get_req_fieldC() const&;
  ::std::set<::std::int32_t> get_req_fieldC() &&;

  template <typename T_containerStruct_req_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.req_fieldC_ref() = BAR;` instead of `FOO.set_req_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_req_fieldC(T_containerStruct_req_fieldC_struct_setter&& req_fieldC_) {
    req_fieldC_ref() = std::forward<T_containerStruct_req_fieldC_struct_setter>(req_fieldC_);
    return req_fieldC;
  }
  const ::std::set<::std::int32_t>* get_opt_fieldC() const&;
  ::std::set<::std::int32_t>* get_opt_fieldC() &;
  ::std::set<::std::int32_t>* get_opt_fieldC() && = delete;

  template <typename T_containerStruct_opt_fieldC_struct_setter = ::std::set<::std::int32_t>>
  [[deprecated("Use `FOO.opt_fieldC_ref() = BAR;` instead of `FOO.set_opt_fieldC(BAR);`")]]
  ::std::set<::std::int32_t>& set_opt_fieldC(T_containerStruct_opt_fieldC_struct_setter&& opt_fieldC_) {
    opt_fieldC_ref() = std::forward<T_containerStruct_opt_fieldC_struct_setter>(opt_fieldC_);
    return opt_fieldC;
  }

  const ::std::string& get_fieldD() const& {
    return fieldD;
  }

  ::std::string get_fieldD() && {
    return std::move(fieldD);
  }

  template <typename T_containerStruct_fieldD_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldD_ref() = BAR;` instead of `FOO.set_fieldD(BAR);`")]]
  ::std::string& set_fieldD(T_containerStruct_fieldD_struct_setter&& fieldD_) {
    fieldD_ref() = std::forward<T_containerStruct_fieldD_struct_setter>(fieldD_);
    return fieldD;
  }

  const ::std::string& get_fieldE() const& {
    return fieldE;
  }

  ::std::string get_fieldE() && {
    return std::move(fieldE);
  }

  template <typename T_containerStruct_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.fieldE_ref() = BAR;` instead of `FOO.set_fieldE(BAR);`")]]
  ::std::string& set_fieldE(T_containerStruct_fieldE_struct_setter&& fieldE_) {
    fieldE_ref() = std::forward<T_containerStruct_fieldE_struct_setter>(fieldE_);
    return fieldE;
  }

  const ::std::string& get_req_fieldE() const& {
    return req_fieldE;
  }

  ::std::string get_req_fieldE() && {
    return std::move(req_fieldE);
  }

  template <typename T_containerStruct_req_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.req_fieldE_ref() = BAR;` instead of `FOO.set_req_fieldE(BAR);`")]]
  ::std::string& set_req_fieldE(T_containerStruct_req_fieldE_struct_setter&& req_fieldE_) {
    req_fieldE_ref() = std::forward<T_containerStruct_req_fieldE_struct_setter>(req_fieldE_);
    return req_fieldE;
  }

  const ::std::string* get_opt_fieldE() const& {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }

  ::std::string* get_opt_fieldE() & {
    return opt_fieldE_ref() ? std::addressof(opt_fieldE) : nullptr;
  }
  ::std::string* get_opt_fieldE() && = delete;

  template <typename T_containerStruct_opt_fieldE_struct_setter = ::std::string>
  [[deprecated("Use `FOO.opt_fieldE_ref() = BAR;` instead of `FOO.set_opt_fieldE(BAR);`")]]
  ::std::string& set_opt_fieldE(T_containerStruct_opt_fieldE_struct_setter&& opt_fieldE_) {
    opt_fieldE_ref() = std::forward<T_containerStruct_opt_fieldE_struct_setter>(opt_fieldE_);
    return opt_fieldE;
  }
  const ::std::vector<::std::vector<::std::int32_t>>& get_fieldF() const&;
  ::std::vector<::std::vector<::std::int32_t>> get_fieldF() &&;

  template <typename T_containerStruct_fieldF_struct_setter = ::std::vector<::std::vector<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldF_ref() = BAR;` instead of `FOO.set_fieldF(BAR);`")]]
  ::std::vector<::std::vector<::std::int32_t>>& set_fieldF(T_containerStruct_fieldF_struct_setter&& fieldF_) {
    fieldF_ref() = std::forward<T_containerStruct_fieldF_struct_setter>(fieldF_);
    return fieldF;
  }
  const ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>& get_fieldG() const&;
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>> get_fieldG() &&;

  template <typename T_containerStruct_fieldG_struct_setter = ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>
  [[deprecated("Use `FOO.fieldG_ref() = BAR;` instead of `FOO.set_fieldG(BAR);`")]]
  ::std::map<::std::string, ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>& set_fieldG(T_containerStruct_fieldG_struct_setter&& fieldG_) {
    fieldG_ref() = std::forward<T_containerStruct_fieldG_struct_setter>(fieldG_);
    return fieldG;
  }
  const ::std::vector<::std::set<::std::int32_t>>& get_fieldH() const&;
  ::std::vector<::std::set<::std::int32_t>> get_fieldH() &&;

  template <typename T_containerStruct_fieldH_struct_setter = ::std::vector<::std::set<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldH_ref() = BAR;` instead of `FOO.set_fieldH(BAR);`")]]
  ::std::vector<::std::set<::std::int32_t>>& set_fieldH(T_containerStruct_fieldH_struct_setter&& fieldH_) {
    fieldH_ref() = std::forward<T_containerStruct_fieldH_struct_setter>(fieldH_);
    return fieldH;
  }

  bool get_fieldI() const {
    return fieldI;
  }

  [[deprecated("Use `FOO.fieldI_ref() = BAR;` instead of `FOO.set_fieldI(BAR);`")]]
  bool& set_fieldI(bool fieldI_) {
    fieldI_ref() = fieldI_;
    return fieldI;
  }
  const ::std::map<::std::string, ::std::vector<::std::int32_t>>& get_fieldJ() const&;
  ::std::map<::std::string, ::std::vector<::std::int32_t>> get_fieldJ() &&;

  template <typename T_containerStruct_fieldJ_struct_setter = ::std::map<::std::string, ::std::vector<::std::int32_t>>>
  [[deprecated("Use `FOO.fieldJ_ref() = BAR;` instead of `FOO.set_fieldJ(BAR);`")]]
  ::std::map<::std::string, ::std::vector<::std::int32_t>>& set_fieldJ(T_containerStruct_fieldJ_struct_setter&& fieldJ_) {
    fieldJ_ref() = std::forward<T_containerStruct_fieldJ_struct_setter>(fieldJ_);
    return fieldJ;
  }
  const ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>& get_fieldK() const&;
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>> get_fieldK() &&;

  template <typename T_containerStruct_fieldK_struct_setter = ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>>
  [[deprecated("Use `FOO.fieldK_ref() = BAR;` instead of `FOO.set_fieldK(BAR);`")]]
  ::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>& set_fieldK(T_containerStruct_fieldK_struct_setter&& fieldK_) {
    fieldK_ref() = std::forward<T_containerStruct_fieldK_struct_setter>(fieldK_);
    return fieldK;
  }
  const ::std::set<::std::set<::std::set<bool>>>& get_fieldL() const&;
  ::std::set<::std::set<::std::set<bool>>> get_fieldL() &&;

  template <typename T_containerStruct_fieldL_struct_setter = ::std::set<::std::set<::std::set<bool>>>>
  [[deprecated("Use `FOO.fieldL_ref() = BAR;` instead of `FOO.set_fieldL(BAR);`")]]
  ::std::set<::std::set<::std::set<bool>>>& set_fieldL(T_containerStruct_fieldL_struct_setter&& fieldL_) {
    fieldL_ref() = std::forward<T_containerStruct_fieldL_struct_setter>(fieldL_);
    return fieldL;
  }
  const ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& get_fieldM() const&;
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> get_fieldM() &&;

  template <typename T_containerStruct_fieldM_struct_setter = ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>
  [[deprecated("Use `FOO.fieldM_ref() = BAR;` instead of `FOO.set_fieldM(BAR);`")]]
  ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& set_fieldM(T_containerStruct_fieldM_struct_setter&& fieldM_) {
    fieldM_ref() = std::forward<T_containerStruct_fieldM_struct_setter>(fieldM_);
    return fieldM;
  }

  ::some::valid::ns::simpleTypeDef get_fieldN() const {
    return fieldN;
  }

  [[deprecated("Use `FOO.fieldN_ref() = BAR;` instead of `FOO.set_fieldN(BAR);`")]]
  ::some::valid::ns::simpleTypeDef& set_fieldN(::some::valid::ns::simpleTypeDef fieldN_) {
    fieldN_ref() = fieldN_;
    return fieldN;
  }
  const ::some::valid::ns::complexStructTypeDef& get_fieldO() const&;
  ::some::valid::ns::complexStructTypeDef get_fieldO() &&;

  template <typename T_containerStruct_fieldO_struct_setter = ::some::valid::ns::complexStructTypeDef>
  [[deprecated("Use `FOO.fieldO_ref() = BAR;` instead of `FOO.set_fieldO(BAR);`")]]
  ::some::valid::ns::complexStructTypeDef& set_fieldO(T_containerStruct_fieldO_struct_setter&& fieldO_) {
    fieldO_ref() = std::forward<T_containerStruct_fieldO_struct_setter>(fieldO_);
    return fieldO;
  }
  const ::std::vector<::some::valid::ns::mostComplexTypeDef>& get_fieldP() const&;
  ::std::vector<::some::valid::ns::mostComplexTypeDef> get_fieldP() &&;

  template <typename T_containerStruct_fieldP_struct_setter = ::std::vector<::some::valid::ns::mostComplexTypeDef>>
  [[deprecated("Use `FOO.fieldP_ref() = BAR;` instead of `FOO.set_fieldP(BAR);`")]]
  ::std::vector<::some::valid::ns::mostComplexTypeDef>& set_fieldP(T_containerStruct_fieldP_struct_setter&& fieldP_) {
    fieldP_ref() = std::forward<T_containerStruct_fieldP_struct_setter>(fieldP_);
    return fieldP;
  }

  ::some::valid::ns::MyEnumA get_fieldQ() const {
    return fieldQ;
  }

  [[deprecated("Use `FOO.fieldQ_ref() = BAR;` instead of `FOO.set_fieldQ(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldQ(::some::valid::ns::MyEnumA fieldQ_) {
    fieldQ_ref() = fieldQ_;
    return fieldQ;
  }

  ::some::valid::ns::MyEnumA get_fieldR() const {
    return fieldR;
  }

  [[deprecated("Use `FOO.fieldR_ref() = BAR;` instead of `FOO.set_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldR(::some::valid::ns::MyEnumA fieldR_) {
    fieldR_ref() = fieldR_;
    return fieldR;
  }

  ::some::valid::ns::MyEnumA get_req_fieldR() const {
    return req_fieldR;
  }

  [[deprecated("Use `FOO.req_fieldR_ref() = BAR;` instead of `FOO.set_req_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_req_fieldR(::some::valid::ns::MyEnumA req_fieldR_) {
    req_fieldR_ref() = req_fieldR_;
    return req_fieldR;
  }

  const ::some::valid::ns::MyEnumA* get_opt_fieldR() const& {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }

  ::some::valid::ns::MyEnumA* get_opt_fieldR() & {
    return opt_fieldR_ref() ? std::addressof(opt_fieldR) : nullptr;
  }
  ::some::valid::ns::MyEnumA* get_opt_fieldR() && = delete;

  [[deprecated("Use `FOO.opt_fieldR_ref() = BAR;` instead of `FOO.set_opt_fieldR(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_opt_fieldR(::some::valid::ns::MyEnumA opt_fieldR_) {
    opt_fieldR_ref() = opt_fieldR_;
    return opt_fieldR;
  }

  ::some::valid::ns::MyEnumA get_fieldS() const {
    return fieldS;
  }

  [[deprecated("Use `FOO.fieldS_ref() = BAR;` instead of `FOO.set_fieldS(BAR);`")]]
  ::some::valid::ns::MyEnumA& set_fieldS(::some::valid::ns::MyEnumA fieldS_) {
    fieldS_ref() = fieldS_;
    return fieldS;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_fieldT() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_fieldT() &&;

  template <typename T_containerStruct_fieldT_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.fieldT_ref() = BAR;` instead of `FOO.set_fieldT(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_fieldT(T_containerStruct_fieldT_struct_setter&& fieldT_) {
    fieldT_ref() = std::forward<T_containerStruct_fieldT_struct_setter>(fieldT_);
    return fieldT;
  }
  const ::std::vector<::some::valid::ns::MyEnumA>& get_fieldU() const&;
  ::std::vector<::some::valid::ns::MyEnumA> get_fieldU() &&;

  template <typename T_containerStruct_fieldU_struct_setter = ::std::vector<::some::valid::ns::MyEnumA>>
  [[deprecated("Use `FOO.fieldU_ref() = BAR;` instead of `FOO.set_fieldU(BAR);`")]]
  ::std::vector<::some::valid::ns::MyEnumA>& set_fieldU(T_containerStruct_fieldU_struct_setter&& fieldU_) {
    fieldU_ref() = std::forward<T_containerStruct_fieldU_struct_setter>(fieldU_);
    return fieldU;
  }
  const ::some::valid::ns::MyStruct& get_fieldV() const&;
  ::some::valid::ns::MyStruct get_fieldV() &&;

  template <typename T_containerStruct_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.fieldV_ref() = BAR;` instead of `FOO.set_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_fieldV(T_containerStruct_fieldV_struct_setter&& fieldV_) {
    fieldV_ref() = std::forward<T_containerStruct_fieldV_struct_setter>(fieldV_);
    return fieldV;
  }
  const ::some::valid::ns::MyStruct& get_req_fieldV() const&;
  ::some::valid::ns::MyStruct get_req_fieldV() &&;

  template <typename T_containerStruct_req_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.req_fieldV_ref() = BAR;` instead of `FOO.set_req_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_req_fieldV(T_containerStruct_req_fieldV_struct_setter&& req_fieldV_) {
    req_fieldV_ref() = std::forward<T_containerStruct_req_fieldV_struct_setter>(req_fieldV_);
    return req_fieldV;
  }
  const ::some::valid::ns::MyStruct* get_opt_fieldV() const&;
  ::some::valid::ns::MyStruct* get_opt_fieldV() &;
  ::some::valid::ns::MyStruct* get_opt_fieldV() && = delete;

  template <typename T_containerStruct_opt_fieldV_struct_setter = ::some::valid::ns::MyStruct>
  [[deprecated("Use `FOO.opt_fieldV_ref() = BAR;` instead of `FOO.set_opt_fieldV(BAR);`")]]
  ::some::valid::ns::MyStruct& set_opt_fieldV(T_containerStruct_opt_fieldV_struct_setter&& opt_fieldV_) {
    opt_fieldV_ref() = std::forward<T_containerStruct_opt_fieldV_struct_setter>(opt_fieldV_);
    return opt_fieldV;
  }
  const ::std::set<::some::valid::ns::MyStruct>& get_fieldW() const&;
  ::std::set<::some::valid::ns::MyStruct> get_fieldW() &&;

  template <typename T_containerStruct_fieldW_struct_setter = ::std::set<::some::valid::ns::MyStruct>>
  [[deprecated("Use `FOO.fieldW_ref() = BAR;` instead of `FOO.set_fieldW(BAR);`")]]
  ::std::set<::some::valid::ns::MyStruct>& set_fieldW(T_containerStruct_fieldW_struct_setter&& fieldW_) {
    fieldW_ref() = std::forward<T_containerStruct_fieldW_struct_setter>(fieldW_);
    return fieldW;
  }
  const ::some::valid::ns::ComplexUnion& get_fieldX() const&;
  ::some::valid::ns::ComplexUnion get_fieldX() &&;

  template <typename T_containerStruct_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.fieldX_ref() = BAR;` instead of `FOO.set_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_fieldX(T_containerStruct_fieldX_struct_setter&& fieldX_) {
    fieldX_ref() = std::forward<T_containerStruct_fieldX_struct_setter>(fieldX_);
    return fieldX;
  }
  const ::some::valid::ns::ComplexUnion& get_req_fieldX() const&;
  ::some::valid::ns::ComplexUnion get_req_fieldX() &&;

  template <typename T_containerStruct_req_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.req_fieldX_ref() = BAR;` instead of `FOO.set_req_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_req_fieldX(T_containerStruct_req_fieldX_struct_setter&& req_fieldX_) {
    req_fieldX_ref() = std::forward<T_containerStruct_req_fieldX_struct_setter>(req_fieldX_);
    return req_fieldX;
  }
  const ::some::valid::ns::ComplexUnion* get_opt_fieldX() const&;
  ::some::valid::ns::ComplexUnion* get_opt_fieldX() &;
  ::some::valid::ns::ComplexUnion* get_opt_fieldX() && = delete;

  template <typename T_containerStruct_opt_fieldX_struct_setter = ::some::valid::ns::ComplexUnion>
  [[deprecated("Use `FOO.opt_fieldX_ref() = BAR;` instead of `FOO.set_opt_fieldX(BAR);`")]]
  ::some::valid::ns::ComplexUnion& set_opt_fieldX(T_containerStruct_opt_fieldX_struct_setter&& opt_fieldX_) {
    opt_fieldX_ref() = std::forward<T_containerStruct_opt_fieldX_struct_setter>(opt_fieldX_);
    return opt_fieldX;
  }
  const ::std::vector<::some::valid::ns::ComplexUnion>& get_fieldY() const&;
  ::std::vector<::some::valid::ns::ComplexUnion> get_fieldY() &&;

  template <typename T_containerStruct_fieldY_struct_setter = ::std::vector<::some::valid::ns::ComplexUnion>>
  [[deprecated("Use `FOO.fieldY_ref() = BAR;` instead of `FOO.set_fieldY(BAR);`")]]
  ::std::vector<::some::valid::ns::ComplexUnion>& set_fieldY(T_containerStruct_fieldY_struct_setter&& fieldY_) {
    fieldY_ref() = std::forward<T_containerStruct_fieldY_struct_setter>(fieldY_);
    return fieldY;
  }
  const ::some::valid::ns::unionTypeDef& get_fieldZ() const&;
  ::some::valid::ns::unionTypeDef get_fieldZ() &&;

  template <typename T_containerStruct_fieldZ_struct_setter = ::some::valid::ns::unionTypeDef>
  [[deprecated("Use `FOO.fieldZ_ref() = BAR;` instead of `FOO.set_fieldZ(BAR);`")]]
  ::some::valid::ns::unionTypeDef& set_fieldZ(T_containerStruct_fieldZ_struct_setter&& fieldZ_) {
    fieldZ_ref() = std::forward<T_containerStruct_fieldZ_struct_setter>(fieldZ_);
    return fieldZ;
  }
  const ::std::vector<::some::valid::ns::unionTypeDef>& get_fieldAA() const&;
  ::std::vector<::some::valid::ns::unionTypeDef> get_fieldAA() &&;

  template <typename T_containerStruct_fieldAA_struct_setter = ::std::vector<::some::valid::ns::unionTypeDef>>
  [[deprecated("Use `FOO.fieldAA_ref() = BAR;` instead of `FOO.set_fieldAA(BAR);`")]]
  ::std::vector<::some::valid::ns::unionTypeDef>& set_fieldAA(T_containerStruct_fieldAA_struct_setter&& fieldAA_) {
    fieldAA_ref() = std::forward<T_containerStruct_fieldAA_struct_setter>(fieldAA_);
    return fieldAA;
  }
  const ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>& get_fieldAB() const&;
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC> get_fieldAB() &&;

  template <typename T_containerStruct_fieldAB_struct_setter = ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>>
  [[deprecated("Use `FOO.fieldAB_ref() = BAR;` instead of `FOO.set_fieldAB(BAR);`")]]
  ::std::map<::some::valid::ns::IndirectionB, ::some::valid::ns::IndirectionC>& set_fieldAB(T_containerStruct_fieldAB_struct_setter&& fieldAB_) {
    fieldAB_ref() = std::forward<T_containerStruct_fieldAB_struct_setter>(fieldAB_);
    return fieldAB;
  }

  ::some::valid::ns::MyEnumB get_fieldAC() const {
    return fieldAC;
  }

  [[deprecated("Use `FOO.fieldAC_ref() = BAR;` instead of `FOO.set_fieldAC(BAR);`")]]
  ::some::valid::ns::MyEnumB& set_fieldAC(::some::valid::ns::MyEnumB fieldAC_) {
    fieldAC_ref() = fieldAC_;
    return fieldAC;
  }

  ::a::different::ns::AnEnum get_fieldAD() const {
    return fieldAD;
  }

  [[deprecated("Use `FOO.fieldAD_ref() = BAR;` instead of `FOO.set_fieldAD(BAR);`")]]
  ::a::different::ns::AnEnum& set_fieldAD(::a::different::ns::AnEnum fieldAD_) {
    fieldAD_ref() = fieldAD_;
    return fieldAD;
  }
  const ::std::map<::std::string, ::std::int32_t>& get_fieldAE() const&;
  ::std::map<::std::string, ::std::int32_t> get_fieldAE() &&;

  template <typename T_containerStruct_fieldAE_struct_setter = ::std::map<::std::string, ::std::int32_t>>
  [[deprecated("Use `FOO.fieldAE_ref() = BAR;` instead of `FOO.set_fieldAE(BAR);`")]]
  ::std::map<::std::string, ::std::int32_t>& set_fieldAE(T_containerStruct_fieldAE_struct_setter&& fieldAE_) {
    fieldAE_ref() = std::forward<T_containerStruct_fieldAE_struct_setter>(fieldAE_);
    return fieldAE;
  }

  const ::some::valid::ns::IndirectionD& get_fieldSD() const& {
    return fieldSD;
  }

  ::some::valid::ns::IndirectionD get_fieldSD() && {
    return std::move(fieldSD);
  }

  template <typename T_containerStruct_fieldSD_struct_setter = ::some::valid::ns::IndirectionD>
  [[deprecated("Use `FOO.fieldSD_ref() = BAR;` instead of `FOO.set_fieldSD(BAR);`")]]
  ::some::valid::ns::IndirectionD& set_fieldSD(T_containerStruct_fieldSD_struct_setter&& fieldSD_) {
    fieldSD_ref() = std::forward<T_containerStruct_fieldSD_struct_setter>(fieldSD_);
    return fieldSD;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<containerStruct>;
  friend void swap(containerStruct& a, containerStruct& b);
};

template <class Protocol_>
unsigned long containerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class MyIncludedStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::MyIncludedInt,
    ::apache::thrift::ident::MyIncludedStruct,
    ::apache::thrift::ident::ARefField,
    ::apache::thrift::ident::ARequiredField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2,3,4};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t,
    ::apache::thrift::type::struct_t<::a::different::ns::AStruct>,
    ::apache::thrift::type::struct_t<::a::different::ns::AStruct>,
    ::apache::thrift::type::struct_t<::a::different::ns::AStruct>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 4;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = MyIncludedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  MyIncludedStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  MyIncludedStruct(apache::thrift::FragileConstructor, ::a::different::ns::IncludedInt64 MyIncludedInt__arg, ::some::valid::ns::AStruct MyIncludedStruct__arg, ::std::unique_ptr<::some::valid::ns::AStruct> ARefField__arg, ::some::valid::ns::AStruct ARequiredField__arg);

  MyIncludedStruct(MyIncludedStruct&&) noexcept;
  MyIncludedStruct(const MyIncludedStruct& src);


  MyIncludedStruct& operator=(MyIncludedStruct&&) noexcept;
  MyIncludedStruct& operator=(const MyIncludedStruct& src);

  ~MyIncludedStruct();

 private:
  ::a::different::ns::IncludedInt64 __fbthrift_field_MyIncludedInt;
 private:
  ::some::valid::ns::AStruct __fbthrift_field_MyIncludedStruct;
 private:
  ::std::unique_ptr<::some::valid::ns::AStruct> __fbthrift_field_ARefField;
 private:
  ::some::valid::ns::AStruct __fbthrift_field_ARequiredField;
 private:
  apache::thrift::detail::isset_bitset<2, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const MyIncludedStruct&) const;
  bool operator<(const MyIncludedStruct&) const;

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedInt_ref() const& {
    return {this->__fbthrift_field_MyIncludedInt, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedInt_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIncludedInt), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedInt_ref() & {
    return {this->__fbthrift_field_MyIncludedInt, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedInt_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIncludedInt), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedInt() const& {
    return {this->__fbthrift_field_MyIncludedInt, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedInt() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIncludedInt), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedInt() & {
    return {this->__fbthrift_field_MyIncludedInt, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::a::different::ns::IncludedInt64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedInt() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIncludedInt), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedStruct_ref() const& {
    return {this->__fbthrift_field_MyIncludedStruct, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedStruct_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIncludedStruct), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedStruct_ref() & {
    return {this->__fbthrift_field_MyIncludedStruct, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedStruct_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIncludedStruct), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> MyIncludedStruct() const& {
    return {this->__fbthrift_field_MyIncludedStruct, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> MyIncludedStruct() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_MyIncludedStruct), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> MyIncludedStruct() & {
    return {this->__fbthrift_field_MyIncludedStruct, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> MyIncludedStruct() && {
    return {static_cast<T&&>(this->__fbthrift_field_MyIncludedStruct), __isset.at(1), __isset.bit(1)};
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T& ARefField_ref() & {
    return __fbthrift_field_ARefField;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T& ARefField_ref() const& {
    return __fbthrift_field_ARefField;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T&& ARefField_ref() && {
    return static_cast<T&&>(__fbthrift_field_ARefField);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T&& ARefField_ref() const&& {
    return static_cast<const T&&>(__fbthrift_field_ARefField);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T& ARefField() & {
    return __fbthrift_field_ARefField;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T& ARefField() const& {
    return __fbthrift_field_ARefField;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE T&& ARefField() && {
    return static_cast<T&&>(__fbthrift_field_ARefField);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::AStruct>>
  FOLLY_ERASE const T&& ARefField() const&& {
    return static_cast<const T&&>(__fbthrift_field_ARefField);
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> ARequiredField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> ARequiredField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_ARequiredField)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> ARequiredField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> ARequiredField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_ARequiredField)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> ARequiredField() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> ARequiredField() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_ARequiredField)};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> ARequiredField() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_ARequiredField};
  }

  template <typename..., typename T = ::some::valid::ns::AStruct>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> ARequiredField() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_ARequiredField)};
  }

  ::a::different::ns::IncludedInt64 get_MyIncludedInt() const {
    return __fbthrift_field_MyIncludedInt;
  }

  [[deprecated("Use `FOO.MyIncludedInt_ref() = BAR;` instead of `FOO.set_MyIncludedInt(BAR);`")]]
  ::a::different::ns::IncludedInt64& set_MyIncludedInt(::a::different::ns::IncludedInt64 MyIncludedInt_) {
    MyIncludedInt_ref() = MyIncludedInt_;
    return __fbthrift_field_MyIncludedInt;
  }
  const ::some::valid::ns::AStruct& get_MyIncludedStruct() const&;
  ::some::valid::ns::AStruct get_MyIncludedStruct() &&;

  template <typename T_MyIncludedStruct_MyIncludedStruct_struct_setter = ::some::valid::ns::AStruct>
  [[deprecated("Use `FOO.MyIncludedStruct_ref() = BAR;` instead of `FOO.set_MyIncludedStruct(BAR);`")]]
  ::some::valid::ns::AStruct& set_MyIncludedStruct(T_MyIncludedStruct_MyIncludedStruct_struct_setter&& MyIncludedStruct_) {
    MyIncludedStruct_ref() = std::forward<T_MyIncludedStruct_MyIncludedStruct_struct_setter>(MyIncludedStruct_);
    return __fbthrift_field_MyIncludedStruct;
  }
  const ::some::valid::ns::AStruct& get_ARequiredField() const&;
  ::some::valid::ns::AStruct get_ARequiredField() &&;

  template <typename T_MyIncludedStruct_ARequiredField_struct_setter = ::some::valid::ns::AStruct>
  [[deprecated("Use `FOO.ARequiredField_ref() = BAR;` instead of `FOO.set_ARequiredField(BAR);`")]]
  ::some::valid::ns::AStruct& set_ARequiredField(T_MyIncludedStruct_ARequiredField_struct_setter&& ARequiredField_) {
    ARequiredField_ref() = std::forward<T_MyIncludedStruct_ARequiredField_struct_setter>(ARequiredField_);
    return __fbthrift_field_ARequiredField;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<MyIncludedStruct>;
  friend void swap(MyIncludedStruct& a, MyIncludedStruct& b);
};

template <class Protocol_>
unsigned long MyIncludedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class AnnotatedStruct  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::no_annotation,
    ::apache::thrift::ident::cpp_unique_ref,
    ::apache::thrift::ident::cpp2_unique_ref,
    ::apache::thrift::ident::container_with_ref,
    ::apache::thrift::ident::req_cpp_unique_ref,
    ::apache::thrift::ident::req_cpp2_unique_ref,
    ::apache::thrift::ident::req_container_with_ref,
    ::apache::thrift::ident::opt_cpp_unique_ref,
    ::apache::thrift::ident::opt_cpp2_unique_ref,
    ::apache::thrift::ident::opt_container_with_ref,
    ::apache::thrift::ident::ref_type_unique,
    ::apache::thrift::ident::ref_type_shared,
    ::apache::thrift::ident::ref_type_const,
    ::apache::thrift::ident::req_ref_type_shared,
    ::apache::thrift::ident::req_ref_type_const,
    ::apache::thrift::ident::req_ref_type_unique,
    ::apache::thrift::ident::opt_ref_type_const,
    ::apache::thrift::ident::opt_ref_type_unique,
    ::apache::thrift::ident::opt_ref_type_shared,
    ::apache::thrift::ident::base_type,
    ::apache::thrift::ident::list_type,
    ::apache::thrift::ident::set_type,
    ::apache::thrift::ident::map_type,
    ::apache::thrift::ident::map_struct_type,
    ::apache::thrift::ident::iobuf_type,
    ::apache::thrift::ident::iobuf_ptr,
    ::apache::thrift::ident::list_i32_template,
    ::apache::thrift::ident::list_string_template,
    ::apache::thrift::ident::set_template,
    ::apache::thrift::ident::map_template,
    ::apache::thrift::ident::typedef_list_template,
    ::apache::thrift::ident::typedef_deque_template,
    ::apache::thrift::ident::typedef_set_template,
    ::apache::thrift::ident::typedef_map_template,
    ::apache::thrift::ident::indirection_a,
    ::apache::thrift::ident::indirection_b,
    ::apache::thrift::ident::indirection_c,
    ::apache::thrift::ident::iobuf_type_val,
    ::apache::thrift::ident::iobuf_ptr_val,
    ::apache::thrift::ident::struct_struct
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::map<::apache::thrift::type::i32_t, ::apache::thrift::type::list<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::list<::apache::thrift::type::string_t>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::map<::apache::thrift::type::i32_t, ::apache::thrift::type::list<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::list<::apache::thrift::type::string_t>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>,
    ::apache::thrift::type::set<::apache::thrift::type::i32_t>,
    ::apache::thrift::type::cpp_type<CppFakeI32, ::apache::thrift::type::i32_t>,
    ::apache::thrift::type::cpp_type<folly::small_vector<int64_t, 8 /* maxInline */>, ::apache::thrift::type::list<::apache::thrift::type::i64_t>>,
    ::apache::thrift::type::cpp_type<folly::sorted_vector_set<std::string>, ::apache::thrift::type::set<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<FakeMap, ::apache::thrift::type::map<::apache::thrift::type::i64_t, ::apache::thrift::type::double_t>>,
    ::apache::thrift::type::cpp_type<std::unordered_map<std::string, containerStruct>, ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>>>,
    ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>,
    ::apache::thrift::type::cpp_type<std::unique_ptr<folly::IOBuf>, ::apache::thrift::type::binary_t>,
    ::apache::thrift::type::cpp_type<std::list<::std::int32_t>, ::apache::thrift::type::list<::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::cpp_type<std::deque<::std::string>, ::apache::thrift::type::list<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<folly::sorted_vector_set<::std::string>, ::apache::thrift::type::set<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<folly::sorted_vector_map<::std::int64_t, ::std::string>, ::apache::thrift::type::map<::apache::thrift::type::i64_t, ::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<std::list<::std::int32_t>, ::apache::thrift::type::list<::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::cpp_type<std::deque<::std::string>, ::apache::thrift::type::list<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<folly::sorted_vector_set<::std::string>, ::apache::thrift::type::set<::apache::thrift::type::string_t>>,
    ::apache::thrift::type::cpp_type<folly::sorted_vector_map<::std::int64_t, ::std::string>, ::apache::thrift::type::map<::apache::thrift::type::i64_t, ::apache::thrift::type::string_t>>,
    ::apache::thrift::type::indirected<Foo, ::apache::thrift::type::i64_t>,
    ::apache::thrift::type::list<::apache::thrift::type::indirected<Bar, ::apache::thrift::type::double_t>>,
    ::apache::thrift::type::set<::apache::thrift::type::indirected<Baz, ::apache::thrift::type::i32_t>>,
    ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>,
    ::apache::thrift::type::cpp_type<std::unique_ptr<folly::IOBuf>, ::apache::thrift::type::binary_t>,
    ::apache::thrift::type::struct_t<::some::valid::ns::containerStruct>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 40;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = AnnotatedStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AnnotatedStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AnnotatedStruct(apache::thrift::FragileConstructor, ::some::valid::ns::containerStruct no_annotation__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> cpp2_unique_ref__arg, ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp2_unique_ref__arg, ::std::unique_ptr<::std::vector<::std::string>> req_container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp_unique_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp2_unique_ref__arg, ::std::unique_ptr<::std::set<::std::int32_t>> opt_container_with_ref__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> ref_type_unique__arg, ::std::shared_ptr<::some::valid::ns::containerStruct> ref_type_shared__arg, ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>> ref_type_const__arg, ::std::shared_ptr<::some::valid::ns::containerStruct> req_ref_type_shared__arg, ::std::shared_ptr<const ::some::valid::ns::containerStruct> req_ref_type_const__arg, ::std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique__arg, ::std::shared_ptr<const ::some::valid::ns::containerStruct> opt_ref_type_const__arg, ::std::unique_ptr<::some::valid::ns::containerStruct> opt_ref_type_unique__arg, ::std::shared_ptr<::std::set<::std::int32_t>> opt_ref_type_shared__arg, ::some::valid::ns::CppFakeI32 base_type__arg, ::some::valid::ns::FollySmallVectorI64 list_type__arg, ::some::valid::ns::SortedVectorSetString set_type__arg, ::some::valid::ns::FakeMap map_type__arg, ::some::valid::ns::UnorderedMapStruct map_struct_type__arg, ::some::valid::ns::IOBuf iobuf_type__arg, ::some::valid::ns::IOBufPtr iobuf_ptr__arg, std::list<::std::int32_t> list_i32_template__arg, std::deque<::std::string> list_string_template__arg, folly::sorted_vector_set<::std::string> set_template__arg, folly::sorted_vector_map<::std::int64_t, ::std::string> map_template__arg, ::some::valid::ns::std_list typedef_list_template__arg, ::some::valid::ns::std_deque typedef_deque_template__arg, ::some::valid::ns::folly_set typedef_set_template__arg, ::some::valid::ns::folly_map typedef_map_template__arg, ::some::valid::ns::IndirectionA indirection_a__arg, ::std::vector<::some::valid::ns::IndirectionB> indirection_b__arg, ::std::set<::some::valid::ns::IndirectionC> indirection_c__arg, ::some::valid::ns::IOBuf iobuf_type_val__arg, ::some::valid::ns::IOBufPtr iobuf_ptr_val__arg, ::some::valid::ns::containerStruct struct_struct__arg);

  AnnotatedStruct(AnnotatedStruct&&) = default;


  AnnotatedStruct& operator=(AnnotatedStruct&&) = default;

  virtual ~AnnotatedStruct() ;

 private:
  ::some::valid::ns::containerStruct no_annotation;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> cpp_unique_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> cpp2_unique_ref;
 private:
  ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> container_with_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp_unique_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> req_cpp2_unique_ref;
 private:
  ::std::unique_ptr<::std::vector<::std::string>> req_container_with_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp_unique_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_cpp2_unique_ref;
 private:
  ::std::unique_ptr<::std::set<::std::int32_t>> opt_container_with_ref;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> ref_type_unique;
 private:
  ::std::shared_ptr<::some::valid::ns::containerStruct> ref_type_shared;
 private:
  ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>> ref_type_const;
 private:
  ::std::shared_ptr<::some::valid::ns::containerStruct> req_ref_type_shared;
 private:
  ::std::shared_ptr<const ::some::valid::ns::containerStruct> req_ref_type_const;
 private:
  ::std::unique_ptr<::std::vector<::std::string>> req_ref_type_unique;
 private:
  ::std::shared_ptr<const ::some::valid::ns::containerStruct> opt_ref_type_const;
 private:
  ::std::unique_ptr<::some::valid::ns::containerStruct> opt_ref_type_unique;
 private:
  ::std::shared_ptr<::std::set<::std::int32_t>> opt_ref_type_shared;
 private:
  ::some::valid::ns::CppFakeI32 base_type;
 private:
  ::some::valid::ns::FollySmallVectorI64 list_type;
 private:
  ::some::valid::ns::SortedVectorSetString set_type;
 private:
  ::some::valid::ns::FakeMap map_type;
 private:
  ::some::valid::ns::UnorderedMapStruct map_struct_type;
 private:
  ::some::valid::ns::IOBuf iobuf_type;
 private:
  ::some::valid::ns::IOBufPtr iobuf_ptr;
 private:
  std::list<::std::int32_t> list_i32_template;
 private:
  std::deque<::std::string> list_string_template;
 private:
  folly::sorted_vector_set<::std::string> set_template;
 private:
  folly::sorted_vector_map<::std::int64_t, ::std::string> map_template;
 private:
  ::some::valid::ns::std_list typedef_list_template;
 private:
  ::some::valid::ns::std_deque typedef_deque_template;
 private:
  ::some::valid::ns::folly_set typedef_set_template;
 private:
  ::some::valid::ns::folly_map typedef_map_template;
 private:
  ::some::valid::ns::IndirectionA indirection_a;
 private:
  ::std::vector<::some::valid::ns::IndirectionB> indirection_b;
 private:
  ::std::set<::some::valid::ns::IndirectionC> indirection_c;
 private:
  ::some::valid::ns::IOBuf iobuf_type_val;
 private:
  ::some::valid::ns::IOBufPtr iobuf_ptr_val;
 private:
  ::some::valid::ns::containerStruct struct_struct;
 private:
  apache::thrift::detail::isset_bitset<22, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const AnnotatedStruct&) const;
  bool operator<(const AnnotatedStruct&) const;

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> no_annotation_ref() const& {
    return {this->no_annotation, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> no_annotation_ref() const&& {
    return {static_cast<const T&&>(this->no_annotation), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> no_annotation_ref() & {
    return {this->no_annotation, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> no_annotation_ref() && {
    return {static_cast<T&&>(this->no_annotation), __isset.at(0), __isset.bit(0)};
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp_unique_ref_ref() & {
    return cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp_unique_ref_ref() const& {
    return cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp_unique_ref_ref() && {
    return static_cast<T&&>(cpp_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp_unique_ref_ref() const&& {
    return static_cast<const T&&>(cpp_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& cpp2_unique_ref_ref() & {
    return cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& cpp2_unique_ref_ref() const& {
    return cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& cpp2_unique_ref_ref() && {
    return static_cast<T&&>(cpp2_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& cpp2_unique_ref_ref() const&& {
    return static_cast<const T&&>(cpp2_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& container_with_ref_ref() & {
    return container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& container_with_ref_ref() const& {
    return container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& container_with_ref_ref() && {
    return static_cast<T&&>(container_with_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& container_with_ref_ref() const&& {
    return static_cast<const T&&>(container_with_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp_unique_ref_ref() & {
    return req_cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp_unique_ref_ref() const& {
    return req_cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp_unique_ref_ref() && {
    return static_cast<T&&>(req_cpp_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp_unique_ref_ref() const&& {
    return static_cast<const T&&>(req_cpp_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_cpp2_unique_ref_ref() & {
    return req_cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_cpp2_unique_ref_ref() const& {
    return req_cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_cpp2_unique_ref_ref() && {
    return static_cast<T&&>(req_cpp2_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_cpp2_unique_ref_ref() const&& {
    return static_cast<const T&&>(req_cpp2_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_container_with_ref_ref() & {
    return req_container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_container_with_ref_ref() const& {
    return req_container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_container_with_ref_ref() && {
    return static_cast<T&&>(req_container_with_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_container_with_ref_ref() const&& {
    return static_cast<const T&&>(req_container_with_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp_unique_ref_ref() & {
    return opt_cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp_unique_ref_ref() const& {
    return opt_cpp_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp_unique_ref_ref() && {
    return static_cast<T&&>(opt_cpp_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp_unique_ref_ref() const&& {
    return static_cast<const T&&>(opt_cpp_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_cpp2_unique_ref_ref() & {
    return opt_cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_cpp2_unique_ref_ref() const& {
    return opt_cpp2_unique_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_cpp2_unique_ref_ref() && {
    return static_cast<T&&>(opt_cpp2_unique_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_cpp2_unique_ref_ref() const&& {
    return static_cast<const T&&>(opt_cpp2_unique_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T& opt_container_with_ref_ref() & {
    return opt_container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T& opt_container_with_ref_ref() const& {
    return opt_container_with_ref;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T&& opt_container_with_ref_ref() && {
    return static_cast<T&&>(opt_container_with_ref);
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T&& opt_container_with_ref_ref() const&& {
    return static_cast<const T&&>(opt_container_with_ref);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_unique_ref() & {
    return ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_unique_ref() const& {
    return ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_unique_ref() && {
    return static_cast<T&&>(ref_type_unique);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_unique_ref() const&& {
    return static_cast<const T&&>(ref_type_unique);
  }
  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& ref_type_shared_ref() & {
    return ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& ref_type_shared_ref() const& {
    return ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& ref_type_shared_ref() && {
    return static_cast<T&&>(ref_type_shared);
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& ref_type_shared_ref() const&& {
    return static_cast<const T&&>(ref_type_shared);
  }
  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T& ref_type_const_ref() & {
    return ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T& ref_type_const_ref() const& {
    return ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE T&& ref_type_const_ref() && {
    return static_cast<T&&>(ref_type_const);
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::std::map<::std::int32_t, ::std::vector<::std::string>>>>
  FOLLY_ERASE const T&& ref_type_const_ref() const&& {
    return static_cast<const T&&>(ref_type_const);
  }
  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_shared_ref() & {
    return req_ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_shared_ref() const& {
    return req_ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_shared_ref() && {
    return static_cast<T&&>(req_ref_type_shared);
  }

  template <typename ..., typename T = ::std::shared_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_shared_ref() const&& {
    return static_cast<const T&&>(req_ref_type_shared);
  }
  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& req_ref_type_const_ref() & {
    return req_ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& req_ref_type_const_ref() const& {
    return req_ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& req_ref_type_const_ref() && {
    return static_cast<T&&>(req_ref_type_const);
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& req_ref_type_const_ref() const&& {
    return static_cast<const T&&>(req_ref_type_const);
  }
  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T& req_ref_type_unique_ref() & {
    return req_ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T& req_ref_type_unique_ref() const& {
    return req_ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE T&& req_ref_type_unique_ref() && {
    return static_cast<T&&>(req_ref_type_unique);
  }

  template <typename ..., typename T = ::std::unique_ptr<::std::vector<::std::string>>>
  FOLLY_ERASE const T&& req_ref_type_unique_ref() const&& {
    return static_cast<const T&&>(req_ref_type_unique);
  }
  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_const_ref() & {
    return opt_ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_const_ref() const& {
    return opt_ref_type_const;
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_const_ref() && {
    return static_cast<T&&>(opt_ref_type_const);
  }

  template <typename ..., typename T = ::std::shared_ptr<const ::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_const_ref() const&& {
    return static_cast<const T&&>(opt_ref_type_const);
  }
  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T& opt_ref_type_unique_ref() & {
    return opt_ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T& opt_ref_type_unique_ref() const& {
    return opt_ref_type_unique;
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE T&& opt_ref_type_unique_ref() && {
    return static_cast<T&&>(opt_ref_type_unique);
  }

  template <typename ..., typename T = ::std::unique_ptr<::some::valid::ns::containerStruct>>
  FOLLY_ERASE const T&& opt_ref_type_unique_ref() const&& {
    return static_cast<const T&&>(opt_ref_type_unique);
  }
  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T& opt_ref_type_shared_ref() & {
    return opt_ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T& opt_ref_type_shared_ref() const& {
    return opt_ref_type_shared;
  }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE T&& opt_ref_type_shared_ref() && {
    return static_cast<T&&>(opt_ref_type_shared);
  }

  template <typename ..., typename T = ::std::shared_ptr<::std::set<::std::int32_t>>>
  FOLLY_ERASE const T&& opt_ref_type_shared_ref() const&& {
    return static_cast<const T&&>(opt_ref_type_shared);
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> base_type_ref() const& {
    return {this->base_type, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> base_type_ref() const&& {
    return {static_cast<const T&&>(this->base_type), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> base_type_ref() & {
    return {this->base_type, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::CppFakeI32>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> base_type_ref() && {
    return {static_cast<T&&>(this->base_type), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_type_ref() const& {
    return {this->list_type, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_type_ref() const&& {
    return {static_cast<const T&&>(this->list_type), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_type_ref() & {
    return {this->list_type, __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::some::valid::ns::FollySmallVectorI64>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_type_ref() && {
    return {static_cast<T&&>(this->list_type), __isset.at(2), __isset.bit(2)};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_type_ref() const& {
    return {this->set_type, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_type_ref() const&& {
    return {static_cast<const T&&>(this->set_type), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_type_ref() & {
    return {this->set_type, __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::some::valid::ns::SortedVectorSetString>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_type_ref() && {
    return {static_cast<T&&>(this->set_type), __isset.at(3), __isset.bit(3)};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_type_ref() const& {
    return {this->map_type, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_type_ref() const&& {
    return {static_cast<const T&&>(this->map_type), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_type_ref() & {
    return {this->map_type, __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::some::valid::ns::FakeMap>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_type_ref() && {
    return {static_cast<T&&>(this->map_type), __isset.at(4), __isset.bit(4)};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_struct_type_ref() const& {
    return {this->map_struct_type, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_struct_type_ref() const&& {
    return {static_cast<const T&&>(this->map_struct_type), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_struct_type_ref() & {
    return {this->map_struct_type, __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::UnorderedMapStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_struct_type_ref() && {
    return {static_cast<T&&>(this->map_struct_type), __isset.at(5), __isset.bit(5)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_ref() const& {
    return {this->iobuf_type, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_ref() const&& {
    return {static_cast<const T&&>(this->iobuf_type), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_ref() & {
    return {this->iobuf_type, __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_ref() && {
    return {static_cast<T&&>(this->iobuf_type), __isset.at(6), __isset.bit(6)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_ref() const& {
    return {this->iobuf_ptr, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_ref() const&& {
    return {static_cast<const T&&>(this->iobuf_ptr), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_ref() & {
    return {this->iobuf_ptr, __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_ref() && {
    return {static_cast<T&&>(this->iobuf_ptr), __isset.at(7), __isset.bit(7)};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_i32_template_ref() const& {
    return {this->list_i32_template, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_i32_template_ref() const&& {
    return {static_cast<const T&&>(this->list_i32_template), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_i32_template_ref() & {
    return {this->list_i32_template, __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = std::list<::std::int32_t>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_i32_template_ref() && {
    return {static_cast<T&&>(this->list_i32_template), __isset.at(8), __isset.bit(8)};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> list_string_template_ref() const& {
    return {this->list_string_template, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> list_string_template_ref() const&& {
    return {static_cast<const T&&>(this->list_string_template), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> list_string_template_ref() & {
    return {this->list_string_template, __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = std::deque<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> list_string_template_ref() && {
    return {static_cast<T&&>(this->list_string_template), __isset.at(9), __isset.bit(9)};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> set_template_ref() const& {
    return {this->set_template, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> set_template_ref() const&& {
    return {static_cast<const T&&>(this->set_template), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> set_template_ref() & {
    return {this->set_template, __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = folly::sorted_vector_set<::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> set_template_ref() && {
    return {static_cast<T&&>(this->set_template), __isset.at(10), __isset.bit(10)};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_template_ref() const& {
    return {this->map_template, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_template_ref() const&& {
    return {static_cast<const T&&>(this->map_template), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_template_ref() & {
    return {this->map_template, __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_template_ref() && {
    return {static_cast<T&&>(this->map_template), __isset.at(11), __isset.bit(11)};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_list_template_ref() const& {
    return {this->typedef_list_template, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_list_template_ref() const&& {
    return {static_cast<const T&&>(this->typedef_list_template), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_list_template_ref() & {
    return {this->typedef_list_template, __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::std_list>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_list_template_ref() && {
    return {static_cast<T&&>(this->typedef_list_template), __isset.at(12), __isset.bit(12)};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_deque_template_ref() const& {
    return {this->typedef_deque_template, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_deque_template_ref() const&& {
    return {static_cast<const T&&>(this->typedef_deque_template), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_deque_template_ref() & {
    return {this->typedef_deque_template, __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::std_deque>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_deque_template_ref() && {
    return {static_cast<T&&>(this->typedef_deque_template), __isset.at(13), __isset.bit(13)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_set_template_ref() const& {
    return {this->typedef_set_template, __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_set_template_ref() const&& {
    return {static_cast<const T&&>(this->typedef_set_template), __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_set_template_ref() & {
    return {this->typedef_set_template, __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_set>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_set_template_ref() && {
    return {static_cast<T&&>(this->typedef_set_template), __isset.at(14), __isset.bit(14)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> typedef_map_template_ref() const& {
    return {this->typedef_map_template, __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> typedef_map_template_ref() const&& {
    return {static_cast<const T&&>(this->typedef_map_template), __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> typedef_map_template_ref() & {
    return {this->typedef_map_template, __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::some::valid::ns::folly_map>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> typedef_map_template_ref() && {
    return {static_cast<T&&>(this->typedef_map_template), __isset.at(15), __isset.bit(15)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_a_ref() const& {
    return {this->indirection_a, __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_a_ref() const&& {
    return {static_cast<const T&&>(this->indirection_a), __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_a_ref() & {
    return {this->indirection_a, __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::some::valid::ns::IndirectionA>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_a_ref() && {
    return {static_cast<T&&>(this->indirection_a), __isset.at(16), __isset.bit(16)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_b_ref() const& {
    return {this->indirection_b, __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_b_ref() const&& {
    return {static_cast<const T&&>(this->indirection_b), __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_b_ref() & {
    return {this->indirection_b, __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::std::vector<::some::valid::ns::IndirectionB>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_b_ref() && {
    return {static_cast<T&&>(this->indirection_b), __isset.at(17), __isset.bit(17)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> indirection_c_ref() const& {
    return {this->indirection_c, __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> indirection_c_ref() const&& {
    return {static_cast<const T&&>(this->indirection_c), __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> indirection_c_ref() & {
    return {this->indirection_c, __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::std::set<::some::valid::ns::IndirectionC>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> indirection_c_ref() && {
    return {static_cast<T&&>(this->indirection_c), __isset.at(18), __isset.bit(18)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_type_val_ref() const& {
    return {this->iobuf_type_val, __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_type_val_ref() const&& {
    return {static_cast<const T&&>(this->iobuf_type_val), __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_type_val_ref() & {
    return {this->iobuf_type_val, __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBuf>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_type_val_ref() && {
    return {static_cast<T&&>(this->iobuf_type_val), __isset.at(19), __isset.bit(19)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> iobuf_ptr_val_ref() const& {
    return {this->iobuf_ptr_val, __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> iobuf_ptr_val_ref() const&& {
    return {static_cast<const T&&>(this->iobuf_ptr_val), __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> iobuf_ptr_val_ref() & {
    return {this->iobuf_ptr_val, __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::IOBufPtr>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> iobuf_ptr_val_ref() && {
    return {static_cast<T&&>(this->iobuf_ptr_val), __isset.at(20), __isset.bit(20)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> struct_struct_ref() const& {
    return {this->struct_struct, __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> struct_struct_ref() const&& {
    return {static_cast<const T&&>(this->struct_struct), __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> struct_struct_ref() & {
    return {this->struct_struct, __isset.at(21), __isset.bit(21)};
  }

  template <typename..., typename T = ::some::valid::ns::containerStruct>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> struct_struct_ref() && {
    return {static_cast<T&&>(this->struct_struct), __isset.at(21), __isset.bit(21)};
  }
  const ::some::valid::ns::containerStruct& get_no_annotation() const&;
  ::some::valid::ns::containerStruct get_no_annotation() &&;

  template <typename T_AnnotatedStruct_no_annotation_struct_setter = ::some::valid::ns::containerStruct>
  [[deprecated("Use `FOO.no_annotation_ref() = BAR;` instead of `FOO.set_no_annotation(BAR);`")]]
  ::some::valid::ns::containerStruct& set_no_annotation(T_AnnotatedStruct_no_annotation_struct_setter&& no_annotation_) {
    no_annotation_ref() = std::forward<T_AnnotatedStruct_no_annotation_struct_setter>(no_annotation_);
    return no_annotation;
  }

  ::some::valid::ns::CppFakeI32 get_base_type() const {
    return base_type;
  }

  [[deprecated("Use `FOO.base_type_ref() = BAR;` instead of `FOO.set_base_type(BAR);`")]]
  ::some::valid::ns::CppFakeI32& set_base_type(::some::valid::ns::CppFakeI32 base_type_) {
    base_type_ref() = base_type_;
    return base_type;
  }
  const ::some::valid::ns::FollySmallVectorI64& get_list_type() const&;
  ::some::valid::ns::FollySmallVectorI64 get_list_type() &&;

  template <typename T_AnnotatedStruct_list_type_struct_setter = ::some::valid::ns::FollySmallVectorI64>
  [[deprecated("Use `FOO.list_type_ref() = BAR;` instead of `FOO.set_list_type(BAR);`")]]
  ::some::valid::ns::FollySmallVectorI64& set_list_type(T_AnnotatedStruct_list_type_struct_setter&& list_type_) {
    list_type_ref() = std::forward<T_AnnotatedStruct_list_type_struct_setter>(list_type_);
    return list_type;
  }
  const ::some::valid::ns::SortedVectorSetString& get_set_type() const&;
  ::some::valid::ns::SortedVectorSetString get_set_type() &&;

  template <typename T_AnnotatedStruct_set_type_struct_setter = ::some::valid::ns::SortedVectorSetString>
  [[deprecated("Use `FOO.set_type_ref() = BAR;` instead of `FOO.set_set_type(BAR);`")]]
  ::some::valid::ns::SortedVectorSetString& set_set_type(T_AnnotatedStruct_set_type_struct_setter&& set_type_) {
    set_type_ref() = std::forward<T_AnnotatedStruct_set_type_struct_setter>(set_type_);
    return set_type;
  }
  const ::some::valid::ns::FakeMap& get_map_type() const&;
  ::some::valid::ns::FakeMap get_map_type() &&;

  template <typename T_AnnotatedStruct_map_type_struct_setter = ::some::valid::ns::FakeMap>
  [[deprecated("Use `FOO.map_type_ref() = BAR;` instead of `FOO.set_map_type(BAR);`")]]
  ::some::valid::ns::FakeMap& set_map_type(T_AnnotatedStruct_map_type_struct_setter&& map_type_) {
    map_type_ref() = std::forward<T_AnnotatedStruct_map_type_struct_setter>(map_type_);
    return map_type;
  }
  const ::some::valid::ns::UnorderedMapStruct& get_map_struct_type() const&;
  ::some::valid::ns::UnorderedMapStruct get_map_struct_type() &&;

  template <typename T_AnnotatedStruct_map_struct_type_struct_setter = ::some::valid::ns::UnorderedMapStruct>
  [[deprecated("Use `FOO.map_struct_type_ref() = BAR;` instead of `FOO.set_map_struct_type(BAR);`")]]
  ::some::valid::ns::UnorderedMapStruct& set_map_struct_type(T_AnnotatedStruct_map_struct_type_struct_setter&& map_struct_type_) {
    map_struct_type_ref() = std::forward<T_AnnotatedStruct_map_struct_type_struct_setter>(map_struct_type_);
    return map_struct_type;
  }

  const ::some::valid::ns::IOBuf& get_iobuf_type() const& {
    return iobuf_type;
  }

  ::some::valid::ns::IOBuf get_iobuf_type() && {
    return std::move(iobuf_type);
  }

  template <typename T_AnnotatedStruct_iobuf_type_struct_setter = ::some::valid::ns::IOBuf>
  [[deprecated("Use `FOO.iobuf_type_ref() = BAR;` instead of `FOO.set_iobuf_type(BAR);`")]]
  ::some::valid::ns::IOBuf& set_iobuf_type(T_AnnotatedStruct_iobuf_type_struct_setter&& iobuf_type_) {
    iobuf_type_ref() = std::forward<T_AnnotatedStruct_iobuf_type_struct_setter>(iobuf_type_);
    return iobuf_type;
  }

  const ::some::valid::ns::IOBufPtr& get_iobuf_ptr() const& {
    return iobuf_ptr;
  }

  ::some::valid::ns::IOBufPtr get_iobuf_ptr() && {
    return std::move(iobuf_ptr);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_struct_setter = ::some::valid::ns::IOBufPtr>
  [[deprecated("Use `FOO.iobuf_ptr_ref() = BAR;` instead of `FOO.set_iobuf_ptr(BAR);`")]]
  ::some::valid::ns::IOBufPtr& set_iobuf_ptr(T_AnnotatedStruct_iobuf_ptr_struct_setter&& iobuf_ptr_) {
    iobuf_ptr_ref() = std::forward<T_AnnotatedStruct_iobuf_ptr_struct_setter>(iobuf_ptr_);
    return iobuf_ptr;
  }
  const std::list<::std::int32_t>& get_list_i32_template() const&;
  std::list<::std::int32_t> get_list_i32_template() &&;

  template <typename T_AnnotatedStruct_list_i32_template_struct_setter = std::list<::std::int32_t>>
  [[deprecated("Use `FOO.list_i32_template_ref() = BAR;` instead of `FOO.set_list_i32_template(BAR);`")]]
  std::list<::std::int32_t>& set_list_i32_template(T_AnnotatedStruct_list_i32_template_struct_setter&& list_i32_template_) {
    list_i32_template_ref() = std::forward<T_AnnotatedStruct_list_i32_template_struct_setter>(list_i32_template_);
    return list_i32_template;
  }
  const std::deque<::std::string>& get_list_string_template() const&;
  std::deque<::std::string> get_list_string_template() &&;

  template <typename T_AnnotatedStruct_list_string_template_struct_setter = std::deque<::std::string>>
  [[deprecated("Use `FOO.list_string_template_ref() = BAR;` instead of `FOO.set_list_string_template(BAR);`")]]
  std::deque<::std::string>& set_list_string_template(T_AnnotatedStruct_list_string_template_struct_setter&& list_string_template_) {
    list_string_template_ref() = std::forward<T_AnnotatedStruct_list_string_template_struct_setter>(list_string_template_);
    return list_string_template;
  }
  const folly::sorted_vector_set<::std::string>& get_set_template() const&;
  folly::sorted_vector_set<::std::string> get_set_template() &&;

  template <typename T_AnnotatedStruct_set_template_struct_setter = folly::sorted_vector_set<::std::string>>
  [[deprecated("Use `FOO.set_template_ref() = BAR;` instead of `FOO.set_set_template(BAR);`")]]
  folly::sorted_vector_set<::std::string>& set_set_template(T_AnnotatedStruct_set_template_struct_setter&& set_template_) {
    set_template_ref() = std::forward<T_AnnotatedStruct_set_template_struct_setter>(set_template_);
    return set_template;
  }
  const folly::sorted_vector_map<::std::int64_t, ::std::string>& get_map_template() const&;
  folly::sorted_vector_map<::std::int64_t, ::std::string> get_map_template() &&;

  template <typename T_AnnotatedStruct_map_template_struct_setter = folly::sorted_vector_map<::std::int64_t, ::std::string>>
  [[deprecated("Use `FOO.map_template_ref() = BAR;` instead of `FOO.set_map_template(BAR);`")]]
  folly::sorted_vector_map<::std::int64_t, ::std::string>& set_map_template(T_AnnotatedStruct_map_template_struct_setter&& map_template_) {
    map_template_ref() = std::forward<T_AnnotatedStruct_map_template_struct_setter>(map_template_);
    return map_template;
  }
  const ::some::valid::ns::std_list& get_typedef_list_template() const&;
  ::some::valid::ns::std_list get_typedef_list_template() &&;

  template <typename T_AnnotatedStruct_typedef_list_template_struct_setter = ::some::valid::ns::std_list>
  [[deprecated("Use `FOO.typedef_list_template_ref() = BAR;` instead of `FOO.set_typedef_list_template(BAR);`")]]
  ::some::valid::ns::std_list& set_typedef_list_template(T_AnnotatedStruct_typedef_list_template_struct_setter&& typedef_list_template_) {
    typedef_list_template_ref() = std::forward<T_AnnotatedStruct_typedef_list_template_struct_setter>(typedef_list_template_);
    return typedef_list_template;
  }
  const ::some::valid::ns::std_deque& get_typedef_deque_template() const&;
  ::some::valid::ns::std_deque get_typedef_deque_template() &&;

  template <typename T_AnnotatedStruct_typedef_deque_template_struct_setter = ::some::valid::ns::std_deque>
  [[deprecated("Use `FOO.typedef_deque_template_ref() = BAR;` instead of `FOO.set_typedef_deque_template(BAR);`")]]
  ::some::valid::ns::std_deque& set_typedef_deque_template(T_AnnotatedStruct_typedef_deque_template_struct_setter&& typedef_deque_template_) {
    typedef_deque_template_ref() = std::forward<T_AnnotatedStruct_typedef_deque_template_struct_setter>(typedef_deque_template_);
    return typedef_deque_template;
  }
  const ::some::valid::ns::folly_set& get_typedef_set_template() const&;
  ::some::valid::ns::folly_set get_typedef_set_template() &&;

  template <typename T_AnnotatedStruct_typedef_set_template_struct_setter = ::some::valid::ns::folly_set>
  [[deprecated("Use `FOO.typedef_set_template_ref() = BAR;` instead of `FOO.set_typedef_set_template(BAR);`")]]
  ::some::valid::ns::folly_set& set_typedef_set_template(T_AnnotatedStruct_typedef_set_template_struct_setter&& typedef_set_template_) {
    typedef_set_template_ref() = std::forward<T_AnnotatedStruct_typedef_set_template_struct_setter>(typedef_set_template_);
    return typedef_set_template;
  }
  const ::some::valid::ns::folly_map& get_typedef_map_template() const&;
  ::some::valid::ns::folly_map get_typedef_map_template() &&;

  template <typename T_AnnotatedStruct_typedef_map_template_struct_setter = ::some::valid::ns::folly_map>
  [[deprecated("Use `FOO.typedef_map_template_ref() = BAR;` instead of `FOO.set_typedef_map_template(BAR);`")]]
  ::some::valid::ns::folly_map& set_typedef_map_template(T_AnnotatedStruct_typedef_map_template_struct_setter&& typedef_map_template_) {
    typedef_map_template_ref() = std::forward<T_AnnotatedStruct_typedef_map_template_struct_setter>(typedef_map_template_);
    return typedef_map_template;
  }

  ::some::valid::ns::IndirectionA get_indirection_a() const {
    return indirection_a;
  }

  [[deprecated("Use `FOO.indirection_a_ref() = BAR;` instead of `FOO.set_indirection_a(BAR);`")]]
  ::some::valid::ns::IndirectionA& set_indirection_a(::some::valid::ns::IndirectionA indirection_a_) {
    indirection_a_ref() = indirection_a_;
    return indirection_a;
  }
  const ::std::vector<::some::valid::ns::IndirectionB>& get_indirection_b() const&;
  ::std::vector<::some::valid::ns::IndirectionB> get_indirection_b() &&;

  template <typename T_AnnotatedStruct_indirection_b_struct_setter = ::std::vector<::some::valid::ns::IndirectionB>>
  [[deprecated("Use `FOO.indirection_b_ref() = BAR;` instead of `FOO.set_indirection_b(BAR);`")]]
  ::std::vector<::some::valid::ns::IndirectionB>& set_indirection_b(T_AnnotatedStruct_indirection_b_struct_setter&& indirection_b_) {
    indirection_b_ref() = std::forward<T_AnnotatedStruct_indirection_b_struct_setter>(indirection_b_);
    return indirection_b;
  }
  const ::std::set<::some::valid::ns::IndirectionC>& get_indirection_c() const&;
  ::std::set<::some::valid::ns::IndirectionC> get_indirection_c() &&;

  template <typename T_AnnotatedStruct_indirection_c_struct_setter = ::std::set<::some::valid::ns::IndirectionC>>
  [[deprecated("Use `FOO.indirection_c_ref() = BAR;` instead of `FOO.set_indirection_c(BAR);`")]]
  ::std::set<::some::valid::ns::IndirectionC>& set_indirection_c(T_AnnotatedStruct_indirection_c_struct_setter&& indirection_c_) {
    indirection_c_ref() = std::forward<T_AnnotatedStruct_indirection_c_struct_setter>(indirection_c_);
    return indirection_c;
  }

  const ::some::valid::ns::IOBuf& get_iobuf_type_val() const& {
    return iobuf_type_val;
  }

  ::some::valid::ns::IOBuf get_iobuf_type_val() && {
    return std::move(iobuf_type_val);
  }

  template <typename T_AnnotatedStruct_iobuf_type_val_struct_setter = ::some::valid::ns::IOBuf>
  [[deprecated("Use `FOO.iobuf_type_val_ref() = BAR;` instead of `FOO.set_iobuf_type_val(BAR);`")]]
  ::some::valid::ns::IOBuf& set_iobuf_type_val(T_AnnotatedStruct_iobuf_type_val_struct_setter&& iobuf_type_val_) {
    iobuf_type_val_ref() = std::forward<T_AnnotatedStruct_iobuf_type_val_struct_setter>(iobuf_type_val_);
    return iobuf_type_val;
  }

  const ::some::valid::ns::IOBufPtr& get_iobuf_ptr_val() const& {
    return iobuf_ptr_val;
  }

  ::some::valid::ns::IOBufPtr get_iobuf_ptr_val() && {
    return std::move(iobuf_ptr_val);
  }

  template <typename T_AnnotatedStruct_iobuf_ptr_val_struct_setter = ::some::valid::ns::IOBufPtr>
  [[deprecated("Use `FOO.iobuf_ptr_val_ref() = BAR;` instead of `FOO.set_iobuf_ptr_val(BAR);`")]]
  ::some::valid::ns::IOBufPtr& set_iobuf_ptr_val(T_AnnotatedStruct_iobuf_ptr_val_struct_setter&& iobuf_ptr_val_) {
    iobuf_ptr_val_ref() = std::forward<T_AnnotatedStruct_iobuf_ptr_val_struct_setter>(iobuf_ptr_val_);
    return iobuf_ptr_val;
  }
  const ::some::valid::ns::containerStruct& get_struct_struct() const&;
  ::some::valid::ns::containerStruct get_struct_struct() &&;

  template <typename T_AnnotatedStruct_struct_struct_struct_setter = ::some::valid::ns::containerStruct>
  [[deprecated("Use `FOO.struct_struct_ref() = BAR;` instead of `FOO.set_struct_struct(BAR);`")]]
  ::some::valid::ns::containerStruct& set_struct_struct(T_AnnotatedStruct_struct_struct_struct_setter&& struct_struct_) {
    struct_struct_ref() = std::forward<T_AnnotatedStruct_struct_struct_struct_setter>(struct_struct_);
    return struct_struct;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
  // user defined code (cpp2.methods = ...)
  void foo(const std::string& bar) {}

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AnnotatedStruct>;
  friend void swap(AnnotatedStruct& a, AnnotatedStruct& b);
};

template <class Protocol_>
unsigned long AnnotatedStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class ComplexContainerStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::map_of_iobufs,
    ::apache::thrift::ident::map_of_iobuf_ptrs
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::cpp_type<folly::IOBuf, ::apache::thrift::type::binary_t>>,
    ::apache::thrift::type::map<::apache::thrift::type::string_t, ::apache::thrift::type::cpp_type<std::unique_ptr<folly::IOBuf>, ::apache::thrift::type::binary_t>>
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 2;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = ComplexContainerStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ComplexContainerStruct();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ComplexContainerStruct(apache::thrift::FragileConstructor, ::std::map<::std::string, ::some::valid::ns::IOBuf> map_of_iobufs__arg, ::std::map<::std::string, ::some::valid::ns::IOBufPtr> map_of_iobuf_ptrs__arg);

  ComplexContainerStruct(ComplexContainerStruct&&) noexcept;
  ComplexContainerStruct(const ComplexContainerStruct& src);


  ComplexContainerStruct& operator=(ComplexContainerStruct&&) noexcept;
  ComplexContainerStruct& operator=(const ComplexContainerStruct& src);

  ~ComplexContainerStruct();

 private:
  ::std::map<::std::string, ::some::valid::ns::IOBuf> __fbthrift_field_map_of_iobufs;
 private:
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr> __fbthrift_field_map_of_iobuf_ptrs;
 private:
  apache::thrift::detail::isset_bitset<2, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const ComplexContainerStruct&) const;
  bool operator<(const ComplexContainerStruct&) const;

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobufs_ref() const& {
    return {this->__fbthrift_field_map_of_iobufs, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobufs_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_map_of_iobufs), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobufs_ref() & {
    return {this->__fbthrift_field_map_of_iobufs, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobufs_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_map_of_iobufs), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobufs() const& {
    return {this->__fbthrift_field_map_of_iobufs, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobufs() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_map_of_iobufs), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobufs() & {
    return {this->__fbthrift_field_map_of_iobufs, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobufs() && {
    return {static_cast<T&&>(this->__fbthrift_field_map_of_iobufs), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobuf_ptrs_ref() const& {
    return {this->__fbthrift_field_map_of_iobuf_ptrs, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobuf_ptrs_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_map_of_iobuf_ptrs), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobuf_ptrs_ref() & {
    return {this->__fbthrift_field_map_of_iobuf_ptrs, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobuf_ptrs_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_map_of_iobuf_ptrs), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> map_of_iobuf_ptrs() const& {
    return {this->__fbthrift_field_map_of_iobuf_ptrs, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> map_of_iobuf_ptrs() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_map_of_iobuf_ptrs), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> map_of_iobuf_ptrs() & {
    return {this->__fbthrift_field_map_of_iobuf_ptrs, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> map_of_iobuf_ptrs() && {
    return {static_cast<T&&>(this->__fbthrift_field_map_of_iobuf_ptrs), __isset.at(1), __isset.bit(1)};
  }
  const ::std::map<::std::string, ::some::valid::ns::IOBuf>& get_map_of_iobufs() const&;
  ::std::map<::std::string, ::some::valid::ns::IOBuf> get_map_of_iobufs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobufs_struct_setter = ::std::map<::std::string, ::some::valid::ns::IOBuf>>
  [[deprecated("Use `FOO.map_of_iobufs_ref() = BAR;` instead of `FOO.set_map_of_iobufs(BAR);`")]]
  ::std::map<::std::string, ::some::valid::ns::IOBuf>& set_map_of_iobufs(T_ComplexContainerStruct_map_of_iobufs_struct_setter&& map_of_iobufs_) {
    map_of_iobufs_ref() = std::forward<T_ComplexContainerStruct_map_of_iobufs_struct_setter>(map_of_iobufs_);
    return __fbthrift_field_map_of_iobufs;
  }
  const ::std::map<::std::string, ::some::valid::ns::IOBufPtr>& get_map_of_iobuf_ptrs() const&;
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr> get_map_of_iobuf_ptrs() &&;

  template <typename T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter = ::std::map<::std::string, ::some::valid::ns::IOBufPtr>>
  [[deprecated("Use `FOO.map_of_iobuf_ptrs_ref() = BAR;` instead of `FOO.set_map_of_iobuf_ptrs(BAR);`")]]
  ::std::map<::std::string, ::some::valid::ns::IOBufPtr>& set_map_of_iobuf_ptrs(T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter&& map_of_iobuf_ptrs_) {
    map_of_iobuf_ptrs_ref() = std::forward<T_ComplexContainerStruct_map_of_iobuf_ptrs_struct_setter>(map_of_iobuf_ptrs_);
    return __fbthrift_field_map_of_iobuf_ptrs;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<ComplexContainerStruct>;
  friend void swap(ComplexContainerStruct& a, ComplexContainerStruct& b);
};

template <class Protocol_>
unsigned long ComplexContainerStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class FloatStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::floatField,
    ::apache::thrift::ident::doubleField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::float_t,
    ::apache::thrift::type::double_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 2;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = FloatStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  FloatStruct() :
      __fbthrift_field_floatField(),
      __fbthrift_field_doubleField() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  FloatStruct(apache::thrift::FragileConstructor, float floatField__arg, double doubleField__arg);

  FloatStruct(FloatStruct&&) = default;

  FloatStruct(const FloatStruct&) = default;


  FloatStruct& operator=(FloatStruct&&) = default;

  FloatStruct& operator=(const FloatStruct&) = default;
 private:
  float __fbthrift_field_floatField;
 private:
  double __fbthrift_field_doubleField;
 private:
  apache::thrift::detail::isset_bitset<2, apache::thrift::detail::IssetBitsetOption::Unpacked> __isset;

 public:

  bool operator==(const FloatStruct&) const;
  bool operator<(const FloatStruct&) const;

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> floatField_ref() const& {
    return {this->__fbthrift_field_floatField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> floatField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_floatField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> floatField_ref() & {
    return {this->__fbthrift_field_floatField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> floatField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_floatField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> floatField() const& {
    return {this->__fbthrift_field_floatField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> floatField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_floatField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> floatField() & {
    return {this->__fbthrift_field_floatField, __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> floatField() && {
    return {static_cast<T&&>(this->__fbthrift_field_floatField), __isset.at(0), __isset.bit(0)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> doubleField_ref() const& {
    return {this->__fbthrift_field_doubleField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> doubleField_ref() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_doubleField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> doubleField_ref() & {
    return {this->__fbthrift_field_doubleField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> doubleField_ref() && {
    return {static_cast<T&&>(this->__fbthrift_field_doubleField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> doubleField() const& {
    return {this->__fbthrift_field_doubleField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> doubleField() const&& {
    return {static_cast<const T&&>(this->__fbthrift_field_doubleField), __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> doubleField() & {
    return {this->__fbthrift_field_doubleField, __isset.at(1), __isset.bit(1)};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> doubleField() && {
    return {static_cast<T&&>(this->__fbthrift_field_doubleField), __isset.at(1), __isset.bit(1)};
  }

  float get_floatField() const {
    return __fbthrift_field_floatField;
  }

  [[deprecated("Use `FOO.floatField_ref() = BAR;` instead of `FOO.set_floatField(BAR);`")]]
  float& set_floatField(float floatField_) {
    floatField_ref() = floatField_;
    return __fbthrift_field_floatField;
  }

  double get_doubleField() const {
    return __fbthrift_field_doubleField;
  }

  [[deprecated("Use `FOO.doubleField_ref() = BAR;` instead of `FOO.set_doubleField(BAR);`")]]
  double& set_doubleField(double doubleField_) {
    doubleField_ref() = doubleField_;
    return __fbthrift_field_doubleField;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FloatStruct>;
  friend void swap(FloatStruct& a, FloatStruct& b);
};

template <class Protocol_>
unsigned long FloatStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class FloatUnion final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::floatSide,
    ::apache::thrift::ident::doubleSide
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1,2};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::float_t,
    ::apache::thrift::type::double_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 2;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_destruct();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = FloatUnion;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    floatSide = 1,
    doubleSide = 2,
  } ;

  FloatUnion()
      : type_(folly::to_underlying(Type::__EMPTY__)) {}

  FloatUnion(FloatUnion&& rhs) noexcept
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    if (this == &rhs) { return; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        return;
      }
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    apache::thrift::clear(rhs);
  }

  FloatUnion(const FloatUnion& rhs);

  FloatUnion& operator=(FloatUnion&& rhs) noexcept {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
      {
        __fbthrift_clear();
        return *this;
      }
      case Type::floatSide:
      {
        set_floatSide(std::move(rhs.value_.floatSide));
        break;
      }
      case Type::doubleSide:
      {
        set_doubleSide(std::move(rhs.value_.doubleSide));
        break;
      }
      default:
      {
        assert(false);
        __fbthrift_clear();
      }
    }
    apache::thrift::clear(rhs);
    return *this;
  }

  FloatUnion& operator=(const FloatUnion& rhs);


  union storage_type {
    float floatSide;
    double doubleSide;

  } ;

  bool operator==(const FloatUnion&) const;
  bool operator<(const FloatUnion&) const;

  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  float& set_floatSide(float t = float()) {
    using T0 = float;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::floatSide);
    ::new (std::addressof(value_.floatSide)) T(t);
    return value_.floatSide;
  }


  template <typename... A, std::enable_if_t<!sizeof...(A), int> = 0>
  double& set_doubleSide(double t = double()) {
    using T0 = double;
    using T = folly::type_t<T0, A...>;
    __fbthrift_clear();
    type_ = folly::to_underlying(Type::doubleSide);
    ::new (std::addressof(value_.doubleSide)) T(t);
    return value_.doubleSide;
  }


  float const& get_floatSide() const {
    if (getType() != Type::floatSide) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.floatSide;
  }

  double const& get_doubleSide() const {
    if (getType() != Type::doubleSide) {
      ::apache::thrift::detail::throw_on_bad_union_field_access();
    }
    return value_.doubleSide;
  }

  float& mutable_floatSide() {
    assert(getType() == Type::floatSide);
    return value_.floatSide;
  }

  double& mutable_doubleSide() {
    assert(getType() == Type::doubleSide);
    return value_.doubleSide;
  }

  float move_floatSide() {
    assert(getType() == Type::floatSide);
    return std::move(value_.floatSide);
  }

  double move_doubleSide() {
    assert(getType() == Type::doubleSide);
    return std::move(value_.doubleSide);
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> floatSide_ref() const& {
    return {value_.floatSide, type_, folly::to_underlying(Type::floatSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> floatSide_ref() const&& {
    return {std::move(value_.floatSide), type_, folly::to_underlying(Type::floatSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> floatSide_ref() & {
    return {value_.floatSide, type_, folly::to_underlying(Type::floatSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = float>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> floatSide_ref() && {
    return {std::move(value_.floatSide), type_, folly::to_underlying(Type::floatSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> doubleSide_ref() const& {
    return {value_.doubleSide, type_, folly::to_underlying(Type::doubleSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> doubleSide_ref() const&& {
    return {std::move(value_.doubleSide), type_, folly::to_underlying(Type::doubleSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> doubleSide_ref() & {
    return {value_.doubleSide, type_, folly::to_underlying(Type::doubleSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = double>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> doubleSide_ref() && {
    return {std::move(value_.doubleSide), type_, folly::to_underlying(Type::doubleSide), this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<FloatUnion>;
  friend void swap(FloatUnion& a, FloatUnion& b);
};

template <class Protocol_>
unsigned long FloatUnion::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


class AllRequiredNoExceptMoveCtrStruct final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;
  template<class> friend struct ::apache::thrift::detail::invoke_reffer;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_is_runtime_annotation = false;
  static const folly::StringPiece __fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord);
  static const folly::StringPiece __fbthrift_get_class_name();
  using __fbthrift_reflection_ident_list = folly::tag_t<
    ::apache::thrift::ident::intField
  >;

  static constexpr std::int16_t __fbthrift_reflection_field_id_list[] = {0,1};
  using __fbthrift_reflection_type_tags = folly::tag_t<
    ::apache::thrift::type::i64_t
  >;

  static constexpr std::size_t __fbthrift_field_size_v = 1;

  template<class T>
  using __fbthrift_id = ::apache::thrift::type::field_id<__fbthrift_reflection_field_id_list[folly::to_underlying(T::value)]>;

  template<class T>
  using __fbthrift_type_tag = ::apache::thrift::detail::at<__fbthrift_reflection_type_tags, T::value>;

  template<class T>
  using __fbthrift_ident = ::apache::thrift::detail::at<__fbthrift_reflection_ident_list, T::value>;

  template<class T> using __fbthrift_ordinal = ::apache::thrift::type::ordinal_tag<
    ::apache::thrift::detail::getFieldOrdinal<T,
                                              __fbthrift_reflection_ident_list,
                                              __fbthrift_reflection_type_tags>(
      __fbthrift_reflection_field_id_list
    )
  >;
  void __fbthrift_clear();
  void __fbthrift_clear_terse_fields();
  bool __fbthrift_is_empty() const;

 public:
  using __fbthrift_cpp2_type = AllRequiredNoExceptMoveCtrStruct;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  AllRequiredNoExceptMoveCtrStruct() :
      __fbthrift_field_intField() {
  }
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  AllRequiredNoExceptMoveCtrStruct(apache::thrift::FragileConstructor, ::std::int64_t intField__arg);

  AllRequiredNoExceptMoveCtrStruct(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct(const AllRequiredNoExceptMoveCtrStruct&) = default;


  AllRequiredNoExceptMoveCtrStruct& operator=(AllRequiredNoExceptMoveCtrStruct&&) = default;

  AllRequiredNoExceptMoveCtrStruct& operator=(const AllRequiredNoExceptMoveCtrStruct&) = default;
 private:
  ::std::int64_t __fbthrift_field_intField;

 public:

  bool operator==(const AllRequiredNoExceptMoveCtrStruct&) const;
  bool operator<(const AllRequiredNoExceptMoveCtrStruct&) const;

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> intField_ref() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> intField_ref() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_intField)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> intField_ref() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> intField_ref() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_intField)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&> intField() const& {
    return ::apache::thrift::required_field_ref<const T&>{this->__fbthrift_field_intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<const T&&> intField() const&& {
    return ::apache::thrift::required_field_ref<const T&&>{static_cast<const T&&>(this->__fbthrift_field_intField)};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&> intField() & {
    return ::apache::thrift::required_field_ref<T&>{this->__fbthrift_field_intField};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::required_field_ref<T&&> intField() && {
    return ::apache::thrift::required_field_ref<T&&>{static_cast<T&&>(this->__fbthrift_field_intField)};
  }

  ::std::int64_t get_intField() const {
    return __fbthrift_field_intField;
  }

  [[deprecated("Use `FOO.intField_ref() = BAR;` instead of `FOO.set_intField(BAR);`")]]
  ::std::int64_t& set_intField(::std::int64_t intField_) {
    intField_ref() = intField_;
    return __fbthrift_field_intField;
  }

  template <class Protocol_>
  unsigned long read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops<AllRequiredNoExceptMoveCtrStruct>;
  friend void swap(AllRequiredNoExceptMoveCtrStruct& a, AllRequiredNoExceptMoveCtrStruct& b);
};

template <class Protocol_>
unsigned long AllRequiredNoExceptMoveCtrStruct::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}


}}} // some::valid::ns

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::some::valid::ns::SimpleUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::SimpleUnion::Type> {
  using type = ::some::valid::ns::SimpleUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};

template <> struct TEnumDataStorage<::some::valid::ns::ComplexUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::ComplexUnion::Type> {
  using type = ::some::valid::ns::ComplexUnion::Type;

  static constexpr std::size_t const size = 28;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};

template <> struct TEnumDataStorage<::some::valid::ns::FloatUnion::Type>;

template <> struct TEnumTraits<::some::valid::ns::FloatUnion::Type> {
  using type = ::some::valid::ns::FloatUnion::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<std::string_view const*> const names;

  static bool findName(type value, std::string_view* out) noexcept;
  static bool findValue(std::string_view name, type* out) noexcept;

  static bool findName(type value, folly::StringPiece* out) noexcept {
    std::string_view outp;
    return findName(value, &outp) && ((*out = outp), true);
  }
  static char const* findName(type value) noexcept {
    std::string_view ret;
    (void)findName(value, &ret);
    return ret.data();
  }
};
}} // apache::thrift
