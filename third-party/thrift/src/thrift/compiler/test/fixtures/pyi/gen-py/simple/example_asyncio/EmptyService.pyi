#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
import typing as __T
import asyncio

from thrift import Thrift
from thrift.protocol.TProtocol import TProtocolBase

import simple.dependent_asyncio.ttypes
from simple.example_asyncio.ttypes import *


class Iface: ...  # EmptyService
    # These have to be Awaitable because handler methods don't return Futures
    # Clients do return Futures but lsp requires us to say they are both Awaitable
    # You can cast the result of a Client if you need Future

class Client(Iface, __T.ContextManager[Client]):  # EmptyService
    def __init__(self, oprot: __T.Optional[TProtocolBase], loop: __T.Optional[asyncio.AbstractEventLoop] = None, cpp_transport: __T.Optional[__T.TypeVar("SyncClient")] = None) -> None: ...
    def set_persistent_header(self, key: str, value: str) -> None: ...
    def get_persistent_headers(self) -> __T.Mapping[str, str]: ...
    def clear_persistent_headers(self) -> None: ...
    def set_onetime_header(self, key: str, value: str) -> None: ...
    def get_last_response_headers(self) -> __T.Mapping[str, str]: ...
    def set_max_frame_size(self, size: int) -> None: ...

class Processor(Iface, Thrift.TProcessor):  # EmptyService
    def __init__(self, handler: Iface) -> None:
        self._handler: Iface
        self._onewayMethods: __T.Sequence[__T.Callable]
        self._processMap: __T.Dict[str, __T.Callable]

    def process_main(self, iprot: TProtocolBase, oprot: TProtocolBase, server_ctx: __T.Any = ...) -> asyncio.Future: ...
    def onewayMethods(self) -> __T.Tuple[__T.Callable]: ...
