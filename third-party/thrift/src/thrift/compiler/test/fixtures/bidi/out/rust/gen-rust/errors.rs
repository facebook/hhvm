// @generated by Thrift for thrift/compiler/test/fixtures/bidi/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `BiDiService`.
pub mod bi_di_service {

    pub trait AsBiDiMethodException {
        fn as_bi_di_method_exception(&self) -> ::std::option::Option<&crate::types::BiDiMethodException>;
    }

    impl AsBiDiMethodException for ::anyhow::Error {
        fn as_bi_di_method_exception(&self) -> ::std::option::Option<&crate::types::BiDiMethodException> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(CanThrowError::ex(e)) = cause.downcast_ref::<CanThrowError>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub trait AsBiDiSinkException {
        fn as_bi_di_sink_exception(&self) -> ::std::option::Option<&crate::types::BiDiSinkException>;
    }

    impl AsBiDiSinkException for ::anyhow::Error {
        fn as_bi_di_sink_exception(&self) -> ::std::option::Option<&crate::types::BiDiSinkException> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(CanThrowSinkError::ex(e)) = cause.downcast_ref::<CanThrowSinkError>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub trait AsBiDiStreamException {
        fn as_bi_di_stream_exception(&self) -> ::std::option::Option<&crate::types::BiDiStreamException>;
    }

    impl AsBiDiStreamException for ::anyhow::Error {
        fn as_bi_di_stream_exception(&self) -> ::std::option::Option<&crate::types::BiDiStreamException> {
            for cause in self.chain() {
                if let ::std::option::Option::Some(CanThrowStreamError::ex(e)) = cause.downcast_ref::<CanThrowStreamError>() {
                    return ::std::option::Option::Some(e);
                }
            }
            ::std::option::Option::None
        }
    }

    pub type SimpleError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum SimpleReader {}

    impl ::fbthrift::help::DeserializeExn for SimpleReader {
        type Success = ();
        type Error = SimpleError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(());
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "SimpleError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    #[derive(Debug)]
    pub enum SimpleSinkError {

        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for SimpleSinkError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::ApplicationException(inner) => {
                    write!(f, "BiDiService::simple failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "BiDiService::simple failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for SimpleSinkError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::fbthrift::ExceptionInfo for SimpleSinkError {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ThriftError(_) => "ThriftError",
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ThriftError(err) => err.to_string(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ThriftError(_) => false,
            }
        }
    }

    impl ::fbthrift::ResultInfo for SimpleSinkError {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ThriftError(_err) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for SimpleSinkError {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for SimpleSinkError {
        fn from(exn: ::fbthrift::NonthrowingFunctionError) -> Self {
            match exn {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => Self::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => Self::ThriftError(err),
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for SimpleSinkError {
        type Success = ::std::primitive::i32;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            if let ::std::result::Result::Err(Self::ThriftError(err)) = res {
                let aexn = ::fbthrift::ApplicationException::new(::fbthrift::ApplicationExceptionErrorCode::InternalError, format!("ThriftError: {err:?}"));
                ::fbthrift::Serialize::rs_thrift_write(&aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::I32,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
                ::std::result::Result::Err(Self::ThriftError(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    pub type SimpleStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum SimpleStreamReader {}

    impl ::fbthrift::help::DeserializeExn for SimpleStreamReader {
        type Success = ::std::primitive::i16;
        type Error = SimpleStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I16, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "SimpleStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "SimpleStreamError"),
                )
                .into(),
            )
        }
    }

    pub type ResponseError = ::fbthrift::NonthrowingFunctionError;


    pub(crate) enum ResponseReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseReader {
        type Success = ();
        type Error = ResponseError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(()));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseError"),
                )
                .into(),
            )
        }
    }

    #[derive(Debug)]
    pub enum ResponseSinkError {

        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseSinkError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::ApplicationException(inner) => {
                    write!(f, "BiDiService::response failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "BiDiService::response failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for ResponseSinkError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::fbthrift::ExceptionInfo for ResponseSinkError {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ThriftError(_) => "ThriftError",
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ThriftError(err) => err.to_string(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ThriftError(_) => false,
            }
        }
    }

    impl ::fbthrift::ResultInfo for ResponseSinkError {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ThriftError(_err) => ::fbthrift::ResultType::Exception,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseSinkError {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for ResponseSinkError {
        fn from(exn: ::fbthrift::NonthrowingFunctionError) -> Self {
            match exn {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => Self::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => Self::ThriftError(err),
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for ResponseSinkError {
        type Success = ::std::primitive::i32;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            if let ::std::result::Result::Err(Self::ThriftError(err)) = res {
                let aexn = ::fbthrift::ApplicationException::new(::fbthrift::ApplicationExceptionErrorCode::InternalError, format!("ThriftError: {err:?}"));
                ::fbthrift::Serialize::rs_thrift_write(&aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::I32,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }

                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
                ::std::result::Result::Err(Self::ThriftError(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    pub type ResponseStreamError = ::fbthrift::NonthrowingFunctionError;

    pub(crate) enum ResponseStreamReader {}

    impl ::fbthrift::help::DeserializeExn for ResponseStreamReader {
        type Success = ::std::primitive::i16;
        type Error = ResponseStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I16, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "ResponseStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "ResponseStreamError"),
                )
                .into(),
            )
        }
    }

    /// Errors for canThrow (client side).
    #[derive(Debug)]
    pub enum CanThrowError {
        ex(crate::types::BiDiMethodException),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for CanThrowError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::ex(inner) => {
                    if f.alternate() {
                        write!(f, "BiDiService::canThrow failed with variant `ex`: {:#}", inner)?;
                    } else {
                        write!(f, "BiDiService::canThrow failed with ex(BiDiMethodException)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "BiDiService::canThrow failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "BiDiService::canThrow failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for CanThrowError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::ex(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::BiDiMethodException> for CanThrowError {
        fn from(e: crate::types::BiDiMethodException) -> Self {
            Self::ex(e)
        }
    }

    impl AsBiDiMethodException for CanThrowError {
        fn as_bi_di_method_exception(&self) -> ::std::option::Option<&crate::types::BiDiMethodException> {
            match self {
                Self::ex(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for CanThrowError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for CanThrowError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::bi_di_service::CanThrowExn> for CanThrowError {
        fn from(e: crate::services::bi_di_service::CanThrowExn) -> Self {
            match e {
                crate::services::bi_di_service::CanThrowExn::ApplicationException(aexn) =>
                    CanThrowError::ApplicationException(aexn),
                crate::services::bi_di_service::CanThrowExn::ex(exn) =>
                    CanThrowError::ex(exn),
            }
        }
    }

    impl ::std::convert::From<CanThrowError> for crate::services::bi_di_service::CanThrowExn {
        fn from(err: CanThrowError) -> Self {
            match err {
                CanThrowError::ex(err) => crate::services::bi_di_service::CanThrowExn::ex(err),
                CanThrowError::ApplicationException(aexn) => crate::services::bi_di_service::CanThrowExn::ApplicationException(aexn),
                CanThrowError::ThriftError(err) => crate::services::bi_di_service::CanThrowExn::ApplicationException(::fbthrift::ApplicationException {
                    message: err.to_string(),
                    type_: ::fbthrift::ApplicationExceptionErrorCode::InternalError,
                }),
            }
        }
    }

    pub(crate) enum CanThrowReader {}

    impl ::fbthrift::help::DeserializeExn for CanThrowReader {
        type Success = ();
        type Error = CanThrowError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::result::Result::Ok(());
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::Void, 0i32), false) => {
                        once = true;
                        alt = ::std::result::Result::Ok(());
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::result::Result::Err(Self::Error::ex(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "CanThrowError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt)
        }
    }

    #[derive(Debug)]
    pub enum CanThrowSinkError {
        ex(crate::types::BiDiSinkException),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for CanThrowSinkError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::ex(inner) => {
                    if f.alternate() {
                        write!(f, "BiDiService::canThrow failed with variant `ex`: {:#}", inner)?;
                    } else {
                        write!(f, "BiDiService::canThrow failed with ex(BiDiSinkException)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "BiDiService::canThrow failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "BiDiService::canThrow failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for CanThrowSinkError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::ex(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::fbthrift::ExceptionInfo for CanThrowSinkError {
        fn exn_name(&self) -> &'static ::std::primitive::str {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_name(),
                Self::ThriftError(_) => "ThriftError",
                Self::ex(exn) => exn.exn_name(),
            }
        }

        fn exn_value(&self) -> String {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_value(),
                Self::ThriftError(err) => err.to_string(),
                Self::ex(exn) => exn.exn_value(),
            }
        }

        fn exn_is_declared(&self) -> bool {
            match self {
                Self::ApplicationException(aexn) => aexn.exn_is_declared(),
                Self::ThriftError(_) => false,
                Self::ex(exn) => exn.exn_is_declared(),
            }
        }
    }

    impl ::fbthrift::ResultInfo for CanThrowSinkError {
        fn result_type(&self) -> ::fbthrift::ResultType {
            match self {
                Self::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                Self::ThriftError(_err) => ::fbthrift::ResultType::Exception,
                Self::ex(_exn) => fbthrift::ResultType::Error,
            }
        }
    }

    impl ::std::convert::From<crate::types::BiDiSinkException> for CanThrowSinkError {
        fn from(exn: crate::types::BiDiSinkException) -> Self {
            Self::ex(exn)
        }
    }

    impl AsBiDiSinkException for CanThrowSinkError {
        fn as_bi_di_sink_exception(&self) -> ::std::option::Option<&crate::types::BiDiSinkException> {
            match self {
                Self::ex(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for CanThrowSinkError {
        fn from(exn: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(exn)
        }
    }

    impl ::std::convert::From<::fbthrift::NonthrowingFunctionError> for CanThrowSinkError {
        fn from(exn: ::fbthrift::NonthrowingFunctionError) -> Self {
            match exn {
                ::fbthrift::NonthrowingFunctionError::ApplicationException(aexn) => Self::ApplicationException(aexn),
                ::fbthrift::NonthrowingFunctionError::ThriftError(err) => Self::ThriftError(err),
            }
        }
    }

    impl ::fbthrift::help::SerializeExn for CanThrowSinkError {
        type Success = ::std::primitive::i64;

        fn write_result<P>(
            res: ::std::result::Result<&Self::Success, &Self>,
            p: &mut P,
            function_name: &'static ::std::primitive::str,
        )
        where
            P: ::fbthrift::ProtocolWriter,
        {
            if let ::std::result::Result::Err(Self::ApplicationException(aexn)) = res {
                ::fbthrift::Serialize::rs_thrift_write(aexn, p);
                return;
            }
            if let ::std::result::Result::Err(Self::ThriftError(err)) = res {
                let aexn = ::fbthrift::ApplicationException::new(::fbthrift::ApplicationExceptionErrorCode::InternalError, format!("ThriftError: {err:?}"));
                ::fbthrift::Serialize::rs_thrift_write(&aexn, p);
                return;
            }
            p.write_struct_begin(function_name);
            match res {
                ::std::result::Result::Ok(success) => {
                    p.write_field_begin(
                        "Success",
                        ::fbthrift::TType::I64,
                        0i16,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(success, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ex(inner)) => {
                    p.write_field_begin(
                        "ex",
                        ::fbthrift::TType::Struct,
                        1,
                    );
                    ::fbthrift::Serialize::rs_thrift_write(inner, p);
                    p.write_field_end();
                }
                ::std::result::Result::Err(Self::ApplicationException(_)) => unreachable!(),
                ::std::result::Result::Err(Self::ThriftError(_)) => unreachable!(),
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }
    #[derive(Debug)]
    pub enum CanThrowStreamError {
        ex(crate::types::BiDiStreamException),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for CanThrowStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::ex(inner) => {
                    if f.alternate() {
                        write!(f, "BiDiService::canThrow failed with variant `ex`: {:#}", inner)?;
                    } else {
                        write!(f, "BiDiService::canThrow failed with ex(BiDiStreamException)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "BiDiService::canThrow failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "BiDiService::canThrow failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            ::std::result::Result::Ok(())
        }
    }

    impl ::std::error::Error for CanThrowStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::ex(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ApplicationException(inner) => {
                    ::std::option::Option::Some(inner)
                }
                Self::ThriftError(inner) => {
                    ::std::option::Option::Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::BiDiStreamException> for CanThrowStreamError {
        fn from(e: crate::types::BiDiStreamException) -> Self {
            Self::ex(e)
        }
    }

    impl AsBiDiStreamException for CanThrowStreamError {
        fn as_bi_di_stream_exception(&self) -> ::std::option::Option<&crate::types::BiDiStreamException> {
            match self {
                Self::ex(inner) => ::std::option::Option::Some(inner),
                _ => ::std::option::Option::None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for CanThrowStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for CanThrowStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::bi_di_service::CanThrowStreamExn> for CanThrowStreamError {
        fn from(e: crate::services::bi_di_service::CanThrowStreamExn) -> Self {
            match e {
                crate::services::bi_di_service::CanThrowStreamExn::ApplicationException(aexn) =>
                    CanThrowStreamError::ApplicationException(aexn),
                crate::services::bi_di_service::CanThrowStreamExn::ex(exn) =>
                    CanThrowStreamError::ex(exn),
            }
        }
    }

    pub(crate) enum CanThrowStreamReader {}

    impl ::fbthrift::help::DeserializeExn for CanThrowStreamReader {
        type Success = ::std::primitive::i64;
        type Error = CanThrowStreamError;

        fn read_result<P>(p: &mut P) -> ::anyhow::Result<::std::result::Result<Self::Success, Self::Error>>
        where
            P: ::fbthrift::ProtocolReader,
        {
            static RETURNS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("Success", ::fbthrift::TType::Stream, 0),
                ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                match ((fty, fid as ::std::primitive::i32), once) {
                    ((::fbthrift::TType::Stop, _), _) => {
                        p.read_field_end()?;
                        break;
                    }
                    ((::fbthrift::TType::I64, 0i32), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Ok(::fbthrift::Deserialize::rs_thrift_read(p)?));
                    }
                    ((::fbthrift::TType::Struct, 1), false) => {
                        once = true;
                        alt = ::std::option::Option::Some(::std::result::Result::Err(Self::Error::ex(::fbthrift::Deserialize::rs_thrift_read(p)?)));
                    }
                    ((ty, _id), false) => p.skip(ty)?,
                    ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                        ::fbthrift::ApplicationException::new(
                            ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                            format!(
                                "unwanted extra union {} field ty {:?} id {}",
                                "CanThrowStreamError",
                                badty,
                                badid,
                            ),
                        )
                    )),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            alt.ok_or_else(||
                ::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                    format!("Empty union {}", "CanThrowStreamError"),
                )
                .into(),
            )
        }
    }

}

#[doc(inline)]
#[allow(ambiguous_glob_reexports)]
pub use self::bi_di_service::*;

