/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/ParamService.h"
#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/ParamService.tcc"
#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::getProcessor() {
  return std::make_unique<::some::valid::ns::ParamServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::some::valid::ns::ParamServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::some::valid::ns::ParamServiceServiceInfoHolder apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::__fbthrift_serviceInfoHolder;


void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_eb_void_ret_i16_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, ::std::int16_t /*param1*/) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("void_ret_i16_param"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_byte_i16_param(::std::int8_t /*param1*/, ::std::int16_t /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_byte_i16_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_byte_i16_param(::std::int8_t p_param1, ::std::int16_t p_param2) {
  return void_ret_byte_i16_param(p_param1, p_param2);
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_byte_i16_param(::std::int8_t p_param1, ::std::int16_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_byte_i16_param(p_param1, p_param2);
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_byte_i16_param(::std::int8_t p_param1, ::std::int16_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_byte_i16_param(p_param1, p_param2), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_byte_i16_param(::std::int8_t p_param1, ::std::int16_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int8_t /*param1*/, ::std::int16_t /*param2*/>(p_param1, p_param2));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_byte_i16_param(apache::thrift::RequestParams /* params */, ::std::int8_t p_param1, ::std::int16_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_byte_i16_param(p_param1, p_param2);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_byte_i16_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, ::std::int8_t p_param1, ::std::int16_t p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_byte_i16_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_byte_i16_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_byte_i16_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_byte_i16_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_byte_i16_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_byte_i16_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_byte_i16_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_byte_i16_param(p_param1, p_param2);
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<::std::int8_t /*param1*/, ::std::int16_t /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_map_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  return void_ret_map_param(std::move(p_param1));
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_map_param(std::move(p_param1));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_map_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_map_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_map_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_map_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_map_param(std::move(p_param1));
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/, std::unique_ptr<::std::set<::std::vector<::std::string>>> /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_map_setlist_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  return void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/, std::unique_ptr<::std::set<::std::vector<::std::string>>> /*param2*/>(std::move(p_param1), std::move(p_param2)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_setlist_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_map_setlist_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1, std::unique_ptr<::std::set<::std::vector<::std::string>>> p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_map_setlist_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_setlist_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_setlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_setlist_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/, std::unique_ptr<::std::set<::std::vector<::std::string>>> /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_map_typedef_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef p_param1) {
  return void_ret_map_typedef_param(p_param1);
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_map_typedef_param(p_param1);
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_map_typedef_param(p_param1), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::some::valid::ns::simpleTypeDef /*param1*/>(p_param1));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_map_typedef_param(apache::thrift::RequestParams /* params */, ::some::valid::ns::simpleTypeDef p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_map_typedef_param(p_param1);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_map_typedef_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, ::some::valid::ns::simpleTypeDef p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_map_typedef_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_typedef_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_map_typedef_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_map_typedef_param(p_param1);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_map_typedef_param(p_param1);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_map_typedef_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_map_typedef_param(p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_map_typedef_param(p_param1);
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<::some::valid::ns::simpleTypeDef /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_enum_param(::some::valid::ns::MyEnumA /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_enum_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_enum_param(::some::valid::ns::MyEnumA p_param1) {
  return void_ret_enum_param(p_param1);
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_enum_param(::some::valid::ns::MyEnumA p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_enum_param(p_param1);
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_enum_param(::some::valid::ns::MyEnumA p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_enum_param(p_param1), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_enum_param(::some::valid::ns::MyEnumA p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::some::valid::ns::MyEnumA /*param1*/>(p_param1));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_enum_param(apache::thrift::RequestParams /* params */, ::some::valid::ns::MyEnumA p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_enum_param(p_param1);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_enum_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, ::some::valid::ns::MyEnumA p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_enum_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_enum_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_enum_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_enum_param(p_param1);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_enum_param(p_param1);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_enum_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_enum_param(p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_enum_param(p_param1);
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<::some::valid::ns::MyEnumA /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_struct_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  return void_ret_struct_param(std::move(p_param1));
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_struct_param(std::move(p_param1));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_struct_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::some::valid::ns::MyStruct> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_struct_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_struct_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_struct_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::some::valid::ns::MyStruct> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_struct_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_struct_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_struct_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_struct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_struct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_struct_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_struct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_struct_param(std::move(p_param1));
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::some::valid::ns::MyStruct> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("void_ret_listunion_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  return void_ret_listunion_param(std::move(p_param1));
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_void_ret_listunion_param(std::move(p_param1));
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_void_ret_listunion_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_void_ret_listunion_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_void_ret_listunion_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_void_ret_listunion_param(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback, std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_void_ret_listunion_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_listunion_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_void_ret_listunion_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_void_ret_listunion_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_void_ret_listunion_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_void_ret_listunion_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_void_ret_listunion_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_void_ret_listunion_param(std::move(p_param1));
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::bool_ret_i32_i64_param(::std::int32_t /*param1*/, ::std::int64_t /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("bool_ret_i32_i64_param");
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_bool_ret_i32_i64_param(::std::int32_t p_param1, ::std::int64_t p_param2) {
  return bool_ret_i32_i64_param(p_param1, p_param2);
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_bool_ret_i32_i64_param(::std::int32_t p_param1, ::std::int64_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_bool_ret_i32_i64_param(p_param1, p_param2);
}

folly::Future<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_bool_ret_i32_i64_param(::std::int32_t p_param1, ::std::int64_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_bool_ret_i32_i64_param(p_param1, p_param2), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_i32_i64_param(::std::int32_t p_param1, ::std::int64_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int32_t /*param1*/, ::std::int64_t /*param2*/>(p_param1, p_param2));
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_i32_i64_param(apache::thrift::RequestParams /* params */, ::std::int32_t p_param1, ::std::int64_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_bool_ret_i32_i64_param(p_param1, p_param2);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_bool_ret_i32_i64_param(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, ::std::int32_t p_param1, ::std::int64_t p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_bool_ret_i32_i64_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_i32_i64_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_i32_i64_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_bool_ret_i32_i64_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_bool_ret_i32_i64_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_i32_i64_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_bool_ret_i32_i64_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_bool_ret_i32_i64_param(p_param1, p_param2));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<::std::int32_t /*param1*/, ::std::int64_t /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("bool_ret_map_param");
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  return bool_ret_map_param(std::move(p_param1));
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_bool_ret_map_param(std::move(p_param1));
}

folly::Future<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_bool_ret_map_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_map_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_bool_ret_map_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_bool_ret_map_param(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_bool_ret_map_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_bool_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_bool_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_bool_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_bool_ret_map_param(std::move(p_param1)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("bool_ret_union_param");
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  return bool_ret_union_param(std::move(p_param1));
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_bool_ret_union_param(std::move(p_param1));
}

folly::Future<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_bool_ret_union_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::some::valid::ns::ComplexUnion> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_bool_ret_union_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_bool_ret_union_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_bool_ret_union_param(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, std::unique_ptr<::some::valid::ns::ComplexUnion> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_bool_ret_union_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_union_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_bool_ret_union_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_bool_ret_union_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_bool_ret_union_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_bool_ret_union_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_bool_ret_union_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_bool_ret_union_param(std::move(p_param1)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::some::valid::ns::ComplexUnion> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::i64_ret_float_double_param(float /*param1*/, double /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("i64_ret_float_double_param");
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_i64_ret_float_double_param(float p_param1, double p_param2) {
  return i64_ret_float_double_param(p_param1, p_param2);
}

folly::SemiFuture<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_i64_ret_float_double_param(float p_param1, double p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_i64_ret_float_double_param(p_param1, p_param2);
}

folly::Future<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_i64_ret_float_double_param(float p_param1, double p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_i64_ret_float_double_param(p_param1, p_param2), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_i64_ret_float_double_param(float p_param1, double p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<float /*param1*/, double /*param2*/>(p_param1, p_param2));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_i64_ret_float_double_param(apache::thrift::RequestParams /* params */, float p_param1, double p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_i64_ret_float_double_param(p_param1, p_param2);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_i64_ret_float_double_param(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback, float p_param1, double p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_i64_ret_float_double_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64_ret_float_double_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64_ret_float_double_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_i64_ret_float_double_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_i64_ret_float_double_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64_ret_float_double_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_i64_ret_float_double_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_i64_ret_float_double_param(p_param1, p_param2));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<float /*param1*/, double /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::i64_ret_string_typedef_param(std::unique_ptr<::std::string> /*param1*/, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("i64_ret_string_typedef_param");
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_i64_ret_string_typedef_param(std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  return i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
}

folly::SemiFuture<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_i64_ret_string_typedef_param(std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
}

folly::Future<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_i64_ret_string_typedef_param(std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_i64_ret_string_typedef_param(std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*param1*/, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> /*param2*/>(std::move(p_param1), std::move(p_param2)));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_i64_ret_string_typedef_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_i64_ret_string_typedef_param(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback, std::unique_ptr<::std::string> p_param1, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_i64_ret_string_typedef_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64_ret_string_typedef_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64_ret_string_typedef_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64_ret_string_typedef_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_i64_ret_string_typedef_param(std::move(p_param1), std::move(p_param2)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*param1*/, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_eb_i64_ret_i32_i32_i32_i32_i32_param(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback, ::std::int32_t /*param1*/, ::std::int32_t /*param2*/, ::std::int32_t /*param3*/, ::std::int32_t /*param4*/, ::std::int32_t /*param5*/) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("i64_ret_i32_i32_i32_i32_i32_param"));
}

double apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("double_ret_setstruct_param");
}

double apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  return double_ret_setstruct_param(std::move(p_param1));
}

folly::SemiFuture<double> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_double_ret_setstruct_param(std::move(p_param1));
}

folly::Future<double> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_double_ret_setstruct_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<double> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<double> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_double_ret_setstruct_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_double_ret_setstruct_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_double_ret_setstruct_param(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback, std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_double_ret_setstruct_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_double_ret_setstruct_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_double_ret_setstruct_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_double_ret_setstruct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_double_ret_setstruct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_double_ret_setstruct_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_double_ret_setstruct_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_double_ret_setstruct_param(std::move(p_param1)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::string_ret_string_param(::std::string& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("string_ret_string_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_string_ret_string_param(::std::string& _return, std::unique_ptr<::std::string> p_param1) {
  return string_ret_string_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_string_ret_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_string_ret_string_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_string_ret_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_string_ret_string_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_string_ret_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_string_ret_string_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_string_ret_string_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_string_ret_string_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_string_ret_string_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_string_ret_string_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_string_ret_string_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_string_ret_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_string_ret_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_string_ret_string_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_string_ret_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_string_ret_string_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::binary_ret_binary_param(::std::string& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("binary_ret_binary_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_binary_ret_binary_param(::std::string& _return, std::unique_ptr<::std::string> p_param1) {
  return binary_ret_binary_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_binary_ret_binary_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_binary_ret_binary_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_binary_ret_binary_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_binary_ret_binary_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_binary_ret_binary_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_binary_ret_binary_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_binary_ret_binary_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_binary_ret_binary_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_binary_ret_binary_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_binary_ret_binary_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_binary_ret_binary_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_binary_ret_binary_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_binary_ret_binary_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_binary_ret_binary_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_binary_ret_binary_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_binary_ret_binary_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::map_ret_bool_param(::std::map<::std::string, ::std::int64_t>& /*_return*/, bool /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("map_ret_bool_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_map_ret_bool_param(::std::map<::std::string, ::std::int64_t>& _return, bool p_param1) {
  return map_ret_bool_param(_return, p_param1);
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_map_ret_bool_param(bool p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::int64_t>>();
  sync_map_ret_bool_param(*ret, p_param1);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_map_ret_bool_param(bool p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_map_ret_bool_param(p_param1), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_map_ret_bool_param(bool p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<bool /*param1*/>(p_param1));
}

folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_map_ret_bool_param(apache::thrift::RequestParams /* params */, bool p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_map_ret_bool_param(p_param1);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_map_ret_bool_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>>> callback, bool p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_map_ret_bool_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_map_ret_bool_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_map_ret_bool_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_map_ret_bool_param(p_param1);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_map_ret_bool_param(p_param1);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_map_ret_bool_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_map_ret_bool_param(p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::int64_t> _return;
        sync_map_ret_bool_param(_return, p_param1);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<bool /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::list_ret_map_setlist_param(::std::vector<bool>& /*_return*/, std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> /*param1*/, std::unique_ptr<::std::vector<::std::string>> /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_ret_map_setlist_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_list_ret_map_setlist_param(::std::vector<bool>& _return, std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  return list_ret_map_setlist_param(_return, std::move(p_param1), std::move(p_param2));
}

folly::SemiFuture<std::unique_ptr<::std::vector<bool>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_list_ret_map_setlist_param(std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<bool>>();
  sync_list_ret_map_setlist_param(*ret, std::move(p_param1), std::move(p_param2));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<bool>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_list_ret_map_setlist_param(std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_ret_map_setlist_param(std::move(p_param1), std::move(p_param2)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<bool>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_list_ret_map_setlist_param(std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> /*param1*/, std::unique_ptr<::std::vector<::std::string>> /*param2*/>(std::move(p_param1), std::move(p_param2)));
}

folly::coro::Task<std::unique_ptr<::std::vector<bool>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_list_ret_map_setlist_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_list_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_list_ret_map_setlist_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<bool>>>> callback, std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> p_param1, std::unique_ptr<::std::vector<::std::string>> p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_list_ret_map_setlist_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_ret_map_setlist_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_ret_map_setlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_ret_map_setlist_param(params, std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_list_ret_map_setlist_param(std::move(p_param1), std::move(p_param2));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<bool> _return;
        sync_list_ret_map_setlist_param(_return, std::move(p_param1), std::move(p_param2));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> /*param1*/, std::unique_ptr<::std::vector<::std::string>> /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::mapsetlistmapliststring_ret_listlistlist_param(::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("mapsetlistmapliststring_ret_listlistlist_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_mapsetlistmapliststring_ret_listlistlist_param(::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& _return, std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  return mapsetlistmapliststring_ret_listlistlist_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_mapsetlistmapliststring_ret_listlistlist_param(std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>();
  sync_mapsetlistmapliststring_ret_listlistlist_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_mapsetlistmapliststring_ret_listlistlist_param(std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_mapsetlistmapliststring_ret_listlistlist_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_mapsetlistmapliststring_ret_listlistlist_param(std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_mapsetlistmapliststring_ret_listlistlist_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_mapsetlistmapliststring_ret_listlistlist_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_mapsetlistmapliststring_ret_listlistlist_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>>>> callback, std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_mapsetlistmapliststring_ret_listlistlist_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_mapsetlistmapliststring_ret_listlistlist_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_mapsetlistmapliststring_ret_listlistlist_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_mapsetlistmapliststring_ret_listlistlist_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_mapsetlistmapliststring_ret_listlistlist_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_mapsetlistmapliststring_ret_listlistlist_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>> _return;
        sync_mapsetlistmapliststring_ret_listlistlist_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::some::valid::ns::simpleTypeDef apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::typedef_ret_i32_param(::std::int32_t /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("typedef_ret_i32_param");
}

::some::valid::ns::simpleTypeDef apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_typedef_ret_i32_param(::std::int32_t p_param1) {
  return typedef_ret_i32_param(p_param1);
}

folly::SemiFuture<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_typedef_ret_i32_param(::std::int32_t p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_typedef_ret_i32_param(p_param1);
}

folly::Future<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_typedef_ret_i32_param(::std::int32_t p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_typedef_ret_i32_param(p_param1), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_typedef_ret_i32_param(::std::int32_t p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int32_t /*param1*/>(p_param1));
}

folly::coro::Task<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_typedef_ret_i32_param(apache::thrift::RequestParams /* params */, ::std::int32_t p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_typedef_ret_i32_param(p_param1);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_typedef_ret_i32_param(std::unique_ptr<apache::thrift::HandlerCallback<::some::valid::ns::simpleTypeDef>> callback, ::std::int32_t p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_typedef_ret_i32_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_typedef_ret_i32_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_typedef_ret_i32_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_typedef_ret_i32_param(p_param1);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_typedef_ret_i32_param(p_param1);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_typedef_ret_i32_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_typedef_ret_i32_param(p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_typedef_ret_i32_param(p_param1));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<::std::int32_t /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_eb_listtypedef_ret_typedef_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::simpleTypeDef>>>> callback, std::unique_ptr<::some::valid::ns::complexStructTypeDef> /*param1*/) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("listtypedef_ret_typedef_param"));
}

::some::valid::ns::MyEnumA apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::enum_ret_double_param(double /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("enum_ret_double_param");
}

::some::valid::ns::MyEnumA apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_enum_ret_double_param(double p_param1) {
  return enum_ret_double_param(p_param1);
}

folly::SemiFuture<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_enum_ret_double_param(double p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_enum_ret_double_param(p_param1);
}

folly::Future<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_enum_ret_double_param(double p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_enum_ret_double_param(p_param1), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_enum_ret_double_param(double p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<double /*param1*/>(p_param1));
}

folly::coro::Task<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_enum_ret_double_param(apache::thrift::RequestParams /* params */, double p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_enum_ret_double_param(p_param1);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_enum_ret_double_param(std::unique_ptr<apache::thrift::HandlerCallback<::some::valid::ns::MyEnumA>> callback, double p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_enum_ret_double_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_enum_ret_double_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_enum_ret_double_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_enum_ret_double_param(p_param1);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_enum_ret_double_param(p_param1);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_enum_ret_double_param(params, p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_enum_ret_double_param(p_param1);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_enum_ret_double_param(p_param1));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<double /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::some::valid::ns::MyEnumA apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::enum_ret_double_enum_param(double /*param1*/, ::some::valid::ns::MyEnumA /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("enum_ret_double_enum_param");
}

::some::valid::ns::MyEnumA apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_enum_ret_double_enum_param(double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  return enum_ret_double_enum_param(p_param1, p_param2);
}

folly::SemiFuture<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_enum_ret_double_enum_param(double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_enum_ret_double_enum_param(p_param1, p_param2);
}

folly::Future<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_enum_ret_double_enum_param(double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_enum_ret_double_enum_param(p_param1, p_param2), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_enum_ret_double_enum_param(double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<double /*param1*/, ::some::valid::ns::MyEnumA /*param2*/>(p_param1, p_param2));
}

folly::coro::Task<::some::valid::ns::MyEnumA> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_enum_ret_double_enum_param(apache::thrift::RequestParams /* params */, double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_enum_ret_double_enum_param(p_param1, p_param2);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_enum_ret_double_enum_param(std::unique_ptr<apache::thrift::HandlerCallback<::some::valid::ns::MyEnumA>> callback, double p_param1, ::some::valid::ns::MyEnumA p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_enum_ret_double_enum_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_enum_ret_double_enum_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_enum_ret_double_enum_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_enum_ret_double_enum_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_enum_ret_double_enum_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_enum_ret_double_enum_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_enum_ret_double_enum_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_enum_ret_double_enum_param(p_param1, p_param2));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<double /*param1*/, ::some::valid::ns::MyEnumA /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::listenum_ret_map_param(::std::vector<::some::valid::ns::MyEnumA>& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("listenum_ret_map_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_listenum_ret_map_param(::std::vector<::some::valid::ns::MyEnumA>& _return, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  return listenum_ret_map_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_listenum_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::some::valid::ns::MyEnumA>>();
  sync_listenum_ret_map_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_listenum_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_listenum_ret_map_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_listenum_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_listenum_ret_map_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_listenum_ret_map_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_listenum_ret_map_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>>> callback, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_listenum_ret_map_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_listenum_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_listenum_ret_map_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_listenum_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_listenum_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_listenum_ret_map_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_listenum_ret_map_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::some::valid::ns::MyEnumA> _return;
        sync_listenum_ret_map_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_eb_struct_ret_i16_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::MyStruct>>> callback, ::std::int16_t /*param1*/) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("struct_ret_i16_param"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::setstruct_ret_set_param(::std::set<::some::valid::ns::MyStruct>& /*_return*/, std::unique_ptr<::std::set<::std::string>> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("setstruct_ret_set_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_setstruct_ret_set_param(::std::set<::some::valid::ns::MyStruct>& _return, std::unique_ptr<::std::set<::std::string>> p_param1) {
  return setstruct_ret_set_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_setstruct_ret_set_param(std::unique_ptr<::std::set<::std::string>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::some::valid::ns::MyStruct>>();
  sync_setstruct_ret_set_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_setstruct_ret_set_param(std::unique_ptr<::std::set<::std::string>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_setstruct_ret_set_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_setstruct_ret_set_param(std::unique_ptr<::std::set<::std::string>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::set<::std::string>> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_setstruct_ret_set_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::set<::std::string>> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_setstruct_ret_set_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_setstruct_ret_set_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>>> callback, std::unique_ptr<::std::set<::std::string>> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_setstruct_ret_set_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_setstruct_ret_set_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_setstruct_ret_set_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_setstruct_ret_set_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_setstruct_ret_set_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_setstruct_ret_set_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_setstruct_ret_set_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::some::valid::ns::MyStruct> _return;
        sync_setstruct_ret_set_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::set<::std::string>> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::union_ret_i32_i32_param(::some::valid::ns::ComplexUnion& /*_return*/, ::std::int32_t /*param1*/, ::std::int32_t /*param2*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("union_ret_i32_i32_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_union_ret_i32_i32_param(::some::valid::ns::ComplexUnion& _return, ::std::int32_t p_param1, ::std::int32_t p_param2) {
  return union_ret_i32_i32_param(_return, p_param1, p_param2);
}

folly::SemiFuture<std::unique_ptr<::some::valid::ns::ComplexUnion>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_union_ret_i32_i32_param(::std::int32_t p_param1, ::std::int32_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::some::valid::ns::ComplexUnion>();
  sync_union_ret_i32_i32_param(*ret, p_param1, p_param2);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::some::valid::ns::ComplexUnion>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_union_ret_i32_i32_param(::std::int32_t p_param1, ::std::int32_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_union_ret_i32_i32_param(p_param1, p_param2), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::some::valid::ns::ComplexUnion>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_union_ret_i32_i32_param(::std::int32_t p_param1, ::std::int32_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int32_t /*param1*/, ::std::int32_t /*param2*/>(p_param1, p_param2));
}

folly::coro::Task<std::unique_ptr<::some::valid::ns::ComplexUnion>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_union_ret_i32_i32_param(apache::thrift::RequestParams /* params */, ::std::int32_t p_param1, ::std::int32_t p_param2) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_union_ret_i32_i32_param(p_param1, p_param2);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_union_ret_i32_i32_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::ComplexUnion>>> callback, ::std::int32_t p_param1, ::std::int32_t p_param2) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_union_ret_i32_i32_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_union_ret_i32_i32_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_union_ret_i32_i32_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_union_ret_i32_i32_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_union_ret_i32_i32_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_union_ret_i32_i32_param(params, p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_union_ret_i32_i32_param(p_param1, p_param2);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::some::valid::ns::ComplexUnion _return;
        sync_union_ret_i32_i32_param(_return, p_param1, p_param2);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1, p_param2) = std::move(ex).restoreArgs<::std::int32_t /*param1*/, ::std::int32_t /*param2*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::listunion_string_param(::std::vector<::some::valid::ns::ComplexUnion>& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("listunion_string_param");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::sync_listunion_string_param(::std::vector<::some::valid::ns::ComplexUnion>& _return, std::unique_ptr<::std::string> p_param1) {
  return listunion_string_param(_return, std::move(p_param1));
}

folly::SemiFuture<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::semifuture_listunion_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_listunion_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::some::valid::ns::ComplexUnion>>();
  sync_listunion_string_param(*ret, std::move(p_param1));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::future_listunion_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_listunion_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_listunion_string_param(std::move(p_param1)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_listunion_string_param(std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_listunion_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*param1*/>(std::move(p_param1)));
}

folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::co_listunion_string_param(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_param1) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_listunion_string_param.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_listunion_string_param(std::move(p_param1));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ParamService>::async_tm_listunion_string_param(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>>> callback, std::unique_ptr<::std::string> p_param1) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_listunion_string_param.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_listunion_string_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_listunion_string_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_listunion_string_param.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        [[fallthrough]];
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_listunion_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_listunion_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_listunion_string_param(params, std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_listunion_string_param(std::move(p_param1));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::some::valid::ns::ComplexUnion> _return;
        sync_listunion_string_param(_return, std::move(p_param1));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_param1) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*param1*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}


namespace some { namespace valid { namespace ns {

void ParamServiceSvNull::void_ret_byte_i16_param(::std::int8_t /*param1*/, ::std::int16_t /*param2*/) {
  return;
}

void ParamServiceSvNull::void_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {
  return;
}

void ParamServiceSvNull::void_ret_map_setlist_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/, std::unique_ptr<::std::set<::std::vector<::std::string>>> /*param2*/) {
  return;
}

void ParamServiceSvNull::void_ret_map_typedef_param(::some::valid::ns::simpleTypeDef /*param1*/) {
  return;
}

void ParamServiceSvNull::void_ret_enum_param(::some::valid::ns::MyEnumA /*param1*/) {
  return;
}

void ParamServiceSvNull::void_ret_struct_param(std::unique_ptr<::some::valid::ns::MyStruct> /*param1*/) {
  return;
}

void ParamServiceSvNull::void_ret_listunion_param(std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>> /*param1*/) {
  return;
}

bool ParamServiceSvNull::bool_ret_i32_i64_param(::std::int32_t /*param1*/, ::std::int64_t /*param2*/) {
  return 0;
}

bool ParamServiceSvNull::bool_ret_map_param(std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {
  return 0;
}

bool ParamServiceSvNull::bool_ret_union_param(std::unique_ptr<::some::valid::ns::ComplexUnion> /*param1*/) {
  return 0;
}

::std::int64_t ParamServiceSvNull::i64_ret_float_double_param(float /*param1*/, double /*param2*/) {
  return 0;
}

::std::int64_t ParamServiceSvNull::i64_ret_string_typedef_param(std::unique_ptr<::std::string> /*param1*/, std::unique_ptr<::std::set<::some::valid::ns::mostComplexTypeDef>> /*param2*/) {
  return 0;
}

double ParamServiceSvNull::double_ret_setstruct_param(std::unique_ptr<::std::set<::some::valid::ns::MyStruct>> /*param1*/) {
  return 0;
}

void ParamServiceSvNull::string_ret_string_param(::std::string& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {}

void ParamServiceSvNull::binary_ret_binary_param(::std::string& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {}

void ParamServiceSvNull::map_ret_bool_param(::std::map<::std::string, ::std::int64_t>& /*_return*/, bool /*param1*/) {}

void ParamServiceSvNull::list_ret_map_setlist_param(::std::vector<bool>& /*_return*/, std::unique_ptr<::std::map<::std::int32_t, ::std::vector<::std::string>>> /*param1*/, std::unique_ptr<::std::vector<::std::string>> /*param2*/) {}

void ParamServiceSvNull::mapsetlistmapliststring_ret_listlistlist_param(::std::map<::std::set<::std::vector<::std::int32_t>>, ::std::map<::std::vector<::std::set<::std::string>>, ::std::string>>& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::vector<::std::vector<::std::int32_t>>>>> /*param1*/) {}

::some::valid::ns::simpleTypeDef ParamServiceSvNull::typedef_ret_i32_param(::std::int32_t /*param1*/) {
  return 0;
}

::some::valid::ns::MyEnumA ParamServiceSvNull::enum_ret_double_param(double /*param1*/) {
  return (::some::valid::ns::MyEnumA)0;
}

::some::valid::ns::MyEnumA ParamServiceSvNull::enum_ret_double_enum_param(double /*param1*/, ::some::valid::ns::MyEnumA /*param2*/) {
  return (::some::valid::ns::MyEnumA)0;
}

void ParamServiceSvNull::listenum_ret_map_param(::std::vector<::some::valid::ns::MyEnumA>& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::int64_t>> /*param1*/) {}

void ParamServiceSvNull::setstruct_ret_set_param(::std::set<::some::valid::ns::MyStruct>& /*_return*/, std::unique_ptr<::std::set<::std::string>> /*param1*/) {}

void ParamServiceSvNull::union_ret_i32_i32_param(::some::valid::ns::ComplexUnion& /*_return*/, ::std::int32_t /*param1*/, ::std::int32_t /*param2*/) {}

void ParamServiceSvNull::listunion_string_param(::std::vector<::some::valid::ns::ComplexUnion>& /*_return*/, std::unique_ptr<::std::string> /*param1*/) {}


const char* ParamServiceAsyncProcessor::getServiceName() {
  return "ParamService";
}

void ParamServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::some::valid::ns::ParamService>>::gen(response);
}

void ParamServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void ParamServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const ParamServiceAsyncProcessor::ProcessMap& ParamServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const ParamServiceAsyncProcessor::ProcessMap ParamServiceAsyncProcessor::kOwnProcessMap_ {
  {"void_ret_i16_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_byte_i16_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_byte_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_byte_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_byte_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_byte_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_map_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_map_setlist_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_setlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_setlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_setlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_setlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_map_typedef_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_map_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_map_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_enum_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_enum_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_enum_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_enum_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_enum_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_struct_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_struct_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_struct_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_struct_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_struct_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"void_ret_listunion_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_void_ret_listunion_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_void_ret_listunion_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_listunion_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_void_ret_listunion_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"bool_ret_i32_i64_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_i32_i64_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_i32_i64_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_i32_i64_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_i32_i64_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"bool_ret_map_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"bool_ret_union_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_union_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_bool_ret_union_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_union_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_bool_ret_union_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i64_ret_float_double_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_float_double_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_float_double_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_float_double_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_float_double_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i64_ret_string_typedef_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_string_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_string_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_string_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_string_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i64_ret_i32_i32_i32_i32_i32_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_i32_i32_i32_i32_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_i64_ret_i32_i32_i32_i32_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_i32_i32_i32_i32_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_i64_ret_i32_i32_i32_i32_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"double_ret_setstruct_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_double_ret_setstruct_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_double_ret_setstruct_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_double_ret_setstruct_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_double_ret_setstruct_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"string_ret_string_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_string_ret_string_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_string_ret_string_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_string_ret_string_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_string_ret_string_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"binary_ret_binary_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_binary_ret_binary_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_binary_ret_binary_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_binary_ret_binary_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_binary_ret_binary_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"map_ret_bool_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_map_ret_bool_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_map_ret_bool_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_map_ret_bool_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_map_ret_bool_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_ret_map_setlist_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_list_ret_map_setlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_list_ret_map_setlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_list_ret_map_setlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_list_ret_map_setlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"mapsetlistmapliststring_ret_listlistlist_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_mapsetlistmapliststring_ret_listlistlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_mapsetlistmapliststring_ret_listlistlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_mapsetlistmapliststring_ret_listlistlist_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_mapsetlistmapliststring_ret_listlistlist_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"typedef_ret_i32_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_typedef_ret_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_typedef_ret_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_typedef_ret_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_typedef_ret_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"listtypedef_ret_typedef_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_listtypedef_ret_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_listtypedef_ret_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listtypedef_ret_typedef_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listtypedef_ret_typedef_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"enum_ret_double_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_enum_ret_double_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_enum_ret_double_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_enum_ret_double_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_enum_ret_double_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"enum_ret_double_enum_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_enum_ret_double_enum_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_enum_ret_double_enum_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_enum_ret_double_enum_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_enum_ret_double_enum_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"listenum_ret_map_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_listenum_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_listenum_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listenum_ret_map_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listenum_ret_map_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"struct_ret_i16_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_struct_ret_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_struct_ret_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_struct_ret_i16_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_struct_ret_i16_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"setstruct_ret_set_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_setstruct_ret_set_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_setstruct_ret_set_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_setstruct_ret_set_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_setstruct_ret_set_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"union_ret_i32_i32_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_union_ret_i32_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_union_ret_i32_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_union_ret_i32_i32_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_union_ret_i32_i32_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"listunion_string_param",
    {&ParamServiceAsyncProcessor::setUpAndProcess_listunion_string_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::setUpAndProcess_listunion_string_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listunion_string_param<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ParamServiceAsyncProcessor::executeRequest_listunion_string_param<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& ParamServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap ParamServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"void_ret_i16_param",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_i16_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_byte_i16_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_byte_i16_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_map_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_map_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_map_setlist_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_map_setlist_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_map_typedef_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_map_typedef_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_enum_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_enum_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_struct_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_struct_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"void_ret_listunion_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.void_ret_listunion_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"bool_ret_i32_i64_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.bool_ret_i32_i64_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"bool_ret_map_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.bool_ret_map_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"bool_ret_union_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.bool_ret_union_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"i64_ret_float_double_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.i64_ret_float_double_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"i64_ret_string_typedef_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.i64_ret_string_typedef_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"i64_ret_i32_i32_i32_i32_i32_param",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.i64_ret_i32_i32_i32_i32_i32_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"double_ret_setstruct_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.double_ret_setstruct_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"string_ret_string_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.string_ret_string_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"binary_ret_binary_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.binary_ret_binary_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"map_ret_bool_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.map_ret_bool_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"list_ret_map_setlist_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.list_ret_map_setlist_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"mapsetlistmapliststring_ret_listlistlist_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.mapsetlistmapliststring_ret_listlistlist_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"typedef_ret_i32_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.typedef_ret_i32_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"listtypedef_ret_typedef_param",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.listtypedef_ret_typedef_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"enum_ret_double_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.enum_ret_double_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"enum_ret_double_enum_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.enum_ret_double_enum_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"listenum_ret_map_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.listenum_ret_map_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"struct_ret_i16_param",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.struct_ret_i16_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"setstruct_ret_set_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.setstruct_ret_set_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"union_ret_i32_i32_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.union_ret_i32_i32_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  {"listunion_string_param",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ParamService.listunion_string_param",
     std::nullopt,
     apache::thrift::concurrency::NORMAL,
     std::nullopt}},
  };

  return requestInfoMap;
}
}}} // some::valid::ns
