// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the "hack" directory of this source tree.

use cbindgen::*;
use std::path;
use structopt::StructOpt;

#[derive(Debug, structopt::StructOpt)]
#[structopt(
    name = "ffi_cbindgen",
    about = "
Generate a cbindgen style C++ header for a list of .rs sources.

Example invocation:

  ffi_cbindgen \
  --header foo-bar.h \
  --srcs \
hphp/hack/src/foo/foo.rs,\
hphp/hack/src/bar/bar.rs \
  --namespaces HPHP,hackc
  --includes hphp/hack/src/baz/baz.h
"
)]
struct Opt {
    // Input files
    #[structopt(long = "srcs", parse(from_os_str), use_delimiter = true)]
    srcs: Vec<path::PathBuf>,

    // The header file to write
    #[structopt(long = "header", parse(from_os_str))]
    header: path::PathBuf,

    // Any namespaces to wrap the generated code in
    #[structopt(long = "namespaces", use_delimiter = true)]
    namespaces: Vec<String>,

    // Any headers to add to the top of the header
    #[structopt(long = "includes", use_delimiter = true)]
    includes: Vec<String>,
}

fn mk_builder(opts: &Opt) -> Builder {
    let config: Config = Config {
        language: Language::Cxx,
        macro_expansion: MacroExpansionConfig { bitflags: true },
        ..Default::default()
    };
    const LICENSE: &str = "\
// Copyright (c) Facebook, Inc. and its affiliates.
//
// This source code is licensed under the MIT license found in the
// LICENSE file in the \"hack\" directory of this source tree.";
    const WARNING: &str = "\
// Warning, this file is autogenerated. Don't modify it manually!";
    let mut builder = Builder::new()
        .with_config(config)
        .with_header(LICENSE)
        .with_autogen_warning(WARNING)
        .with_pragma_once(true);
    for src in opts.srcs.iter() {
        builder = builder.with_src(src)
    }
    for inc in opts.includes.iter() {
        if inc.is_empty() {
            continue;
        }
        builder = builder.with_include(inc)
    }
    match &opts.namespaces[..] {
        [namespace, namespaces @ ..] => builder
            .with_namespace(namespace)
            .with_namespaces(namespaces),
        [] => builder,
    }
}

fn main() {
    let opts = Opt::from_args();
    let header: &path::PathBuf = &opts.header;
    mk_builder(&opts)
        .generate()
        .unwrap_or_else(|_| {
            panic!(
                "[ffi_cbindgen] Generation of \"{}\" failed.",
                header.display()
            )
        })
        .write_to_file(header);
}
