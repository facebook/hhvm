// @generated by hh_manual
interface IBox {}

class Box<T> implements IBox {
  public function __construct(public T $data)[] {}
}

enum class Boxes: IBox {
  Box<int> Age = new Box(42);
  Box<string> Color = new Box('red');
  Box<int> Year = new Box(2021);
}

function get<T>(\HH\MemberOf<Boxes, Box<T>> $box): T {
  return $box->data;
}

function test0(): void {
  get(Boxes::Age); // ok, of type int, returns 42
  get(Boxes::Color); // ok, of type string, returns 'red'
  get(Boxes::Year); // ok, of type int, returns 2021
}

enum class EBase: IBox {
  Box<int> Age = new Box(42);
}

enum class EExtend: IBox extends EBase {
  Box<string> Color = new Box('red');
}

enum class E: IBox {
  Box<int> Age = new Box(42);
}

enum class F: IBox {
  Box<string> Name = new Box('foo');
}

enum class X: IBox extends E, F { } // ok, no ambiguity


enum class E0: IBox extends E {
  Box<int> Color = new Box(0);
}

enum class E1: IBox extends E {
  Box<string> Color = new Box('red');
}

// enum class Y: IBox extends E0, E1 { }
// type error, Y::Color is declared twice, in E0 and in E1
// only he name is use for ambiguity

enum class DiamondBase: IBox {
  Box<int> Age = new Box(42);
}

enum class D1: IBox extends DiamondBase {
  Box<string> Name1 = new Box('foo');
}

enum class D2: IBox extends DiamondBase {
  Box<string> Name2 = new Box('bar');
}

enum class D3: IBox extends D1, D2 {}

<<__EntryPoint>>
function main(): void {
  echo D3::Age->data;
}
