// Autogenerated by Thrift for thrift/annotation/cpp.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package cpp

import (
    "fmt"
    "strings"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = strings.Split
var _ = thrift.ZERO


type RefType int32

const (
    RefType_Unique RefType = 0
    RefType_Shared RefType = 1
    RefType_SharedMutable RefType = 2
)

// Enum value maps for RefType
var (
    RefTypeToName = map[RefType]string {
        RefType_Unique: "Unique",
        RefType_Shared: "Shared",
        RefType_SharedMutable: "SharedMutable",
    }

    RefTypeToValue = map[string]RefType {
        "Unique": RefType_Unique,
        "Shared": RefType_Shared,
        "SharedMutable": RefType_SharedMutable,
    }
)

func (x RefType) String() string {
    if v, ok := RefTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x RefType) Ptr() *RefType {
    return &x
}

// Deprecated: Use RefTypeToValue instead (e.g. `x, ok := RefTypeToValue["name"]`).
func RefTypeFromString(s string) (RefType, error) {
    if v, ok := RefTypeToValue[s]; ok {
        return v, nil
    }
    return RefType(0), fmt.Errorf("not a valid RefType string")
}


type EnumUnderlyingType int32

const (
    EnumUnderlyingType_I8 EnumUnderlyingType = 0
    EnumUnderlyingType_U8 EnumUnderlyingType = 1
    EnumUnderlyingType_I16 EnumUnderlyingType = 2
    EnumUnderlyingType_U16 EnumUnderlyingType = 3
    EnumUnderlyingType_U32 EnumUnderlyingType = 4
)

// Enum value maps for EnumUnderlyingType
var (
    EnumUnderlyingTypeToName = map[EnumUnderlyingType]string {
        EnumUnderlyingType_I8: "I8",
        EnumUnderlyingType_U8: "U8",
        EnumUnderlyingType_I16: "I16",
        EnumUnderlyingType_U16: "U16",
        EnumUnderlyingType_U32: "U32",
    }

    EnumUnderlyingTypeToValue = map[string]EnumUnderlyingType {
        "I8": EnumUnderlyingType_I8,
        "U8": EnumUnderlyingType_U8,
        "I16": EnumUnderlyingType_I16,
        "U16": EnumUnderlyingType_U16,
        "U32": EnumUnderlyingType_U32,
    }
)

func (x EnumUnderlyingType) String() string {
    if v, ok := EnumUnderlyingTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x EnumUnderlyingType) Ptr() *EnumUnderlyingType {
    return &x
}

// Deprecated: Use EnumUnderlyingTypeToValue instead (e.g. `x, ok := EnumUnderlyingTypeToValue["name"]`).
func EnumUnderlyingTypeFromString(s string) (EnumUnderlyingType, error) {
    if v, ok := EnumUnderlyingTypeToValue[s]; ok {
        return v, nil
    }
    return EnumUnderlyingType(0), fmt.Errorf("not a valid EnumUnderlyingType string")
}


type Type struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Template string `thrift:"template,2" json:"template" db:"template"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Type)(nil)

func NewType() *Type {
    return (&Type{}).
        SetNameNonCompat("").
        SetTemplateNonCompat("")
}

func (x *Type) GetName() string {
    return x.Name
}

func (x *Type) GetTemplate() string {
    return x.Template
}

func (x *Type) SetNameNonCompat(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetName(value string) *Type {
    x.Name = value
    return x
}

func (x *Type) SetTemplateNonCompat(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) SetTemplate(value string) *Type {
    x.Template = value
    return x
}

func (x *Type) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) writeField2(p thrift.Encoder) error {  // Template
    if err := p.WriteFieldBegin("template", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Template
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Type) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Name = result
    return nil
}

func (x *Type) readField2(p thrift.Decoder) error {  // Template
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Template = result
    return nil
}

func (x *Type) toString1() string {  // Name
    return fmt.Sprintf("%v", x.Name)
}

func (x *Type) toString2() string {  // Template
    return fmt.Sprintf("%v", x.Template)
}



func (x *Type) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Type"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Type) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // name
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRING)):  // template
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Type) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Type({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Template:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type Ref struct {
    Type RefType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Ref)(nil)

func NewRef() *Ref {
    return (&Ref{}).
        SetTypeNonCompat(0)
}

func (x *Ref) GetType() RefType {
    return x.Type
}

func (x *Ref) SetTypeNonCompat(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) SetType(value RefType) *Ref {
    x.Type = value
    return x
}

func (x *Ref) writeField1(p thrift.Encoder) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Type
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Ref) readField1(p thrift.Decoder) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := RefType(enumResult)

    x.Type = result
    return nil
}

func (x *Ref) toString1() string {  // Type
    return fmt.Sprintf("%v", x.Type)
}



func (x *Ref) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Ref"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Ref) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // type
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Ref) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Ref({")
    sb.WriteString(fmt.Sprintf("Type:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Name struct {
    Value string `thrift:"value,1" json:"value" db:"value"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Name)(nil)

func NewName() *Name {
    return (&Name{}).
        SetValueNonCompat("")
}

func (x *Name) GetValue() string {
    return x.Value
}

func (x *Name) SetValueNonCompat(value string) *Name {
    x.Value = value
    return x
}

func (x *Name) SetValue(value string) *Name {
    x.Value = value
    return x
}

func (x *Name) writeField1(p thrift.Encoder) error {  // Value
    if err := p.WriteFieldBegin("value", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Value
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Name) readField1(p thrift.Decoder) error {  // Value
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Value = result
    return nil
}

func (x *Name) toString1() string {  // Value
    return fmt.Sprintf("%v", x.Value)
}



func (x *Name) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Name"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Name) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // value
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Name) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Name({")
    sb.WriteString(fmt.Sprintf("Value:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Lazy struct {
    Ref bool `thrift:"ref,1" json:"ref" db:"ref"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Lazy)(nil)

func NewLazy() *Lazy {
    return (&Lazy{}).
        SetRefNonCompat(false)
}

func (x *Lazy) GetRef() bool {
    return x.Ref
}

func (x *Lazy) SetRefNonCompat(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) SetRef(value bool) *Lazy {
    x.Ref = value
    return x
}

func (x *Lazy) writeField1(p thrift.Encoder) error {  // Ref
    if err := p.WriteFieldBegin("ref", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Ref
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Lazy) readField1(p thrift.Decoder) error {  // Ref
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.Ref = result
    return nil
}

func (x *Lazy) toString1() string {  // Ref
    return fmt.Sprintf("%v", x.Ref)
}



func (x *Lazy) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Lazy"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Lazy) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.BOOL)):  // ref
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Lazy) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Lazy({")
    sb.WriteString(fmt.Sprintf("Ref:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type DisableLazyChecksum struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*DisableLazyChecksum)(nil)

func NewDisableLazyChecksum() *DisableLazyChecksum {
    return (&DisableLazyChecksum{})
}



func (x *DisableLazyChecksum) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("DisableLazyChecksum"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *DisableLazyChecksum) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *DisableLazyChecksum) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("DisableLazyChecksum({")
    sb.WriteString("})")

    return sb.String()
}

type Adapter struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    AdaptedType string `thrift:"adaptedType,2" json:"adaptedType" db:"adaptedType"`
    UnderlyingName string `thrift:"underlyingName,3" json:"underlyingName" db:"underlyingName"`
    ExtraNamespace string `thrift:"extraNamespace,4" json:"extraNamespace" db:"extraNamespace"`
    MoveOnly bool `thrift:"moveOnly,5" json:"moveOnly" db:"moveOnly"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*Adapter)(nil)

func NewAdapter() *Adapter {
    return (&Adapter{}).
        SetNameNonCompat("").
        SetAdaptedTypeNonCompat("").
        SetUnderlyingNameNonCompat("").
        SetExtraNamespaceNonCompat("").
        SetMoveOnlyNonCompat(false)
}

func (x *Adapter) GetName() string {
    return x.Name
}

func (x *Adapter) GetAdaptedType() string {
    return x.AdaptedType
}

func (x *Adapter) GetUnderlyingName() string {
    return x.UnderlyingName
}

func (x *Adapter) GetExtraNamespace() string {
    return x.ExtraNamespace
}

func (x *Adapter) GetMoveOnly() bool {
    return x.MoveOnly
}

func (x *Adapter) SetNameNonCompat(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetName(value string) *Adapter {
    x.Name = value
    return x
}

func (x *Adapter) SetAdaptedTypeNonCompat(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetAdaptedType(value string) *Adapter {
    x.AdaptedType = value
    return x
}

func (x *Adapter) SetUnderlyingNameNonCompat(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetUnderlyingName(value string) *Adapter {
    x.UnderlyingName = value
    return x
}

func (x *Adapter) SetExtraNamespaceNonCompat(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetExtraNamespace(value string) *Adapter {
    x.ExtraNamespace = value
    return x
}

func (x *Adapter) SetMoveOnlyNonCompat(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) SetMoveOnly(value bool) *Adapter {
    x.MoveOnly = value
    return x
}

func (x *Adapter) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField2(p thrift.Encoder) error {  // AdaptedType
    if err := p.WriteFieldBegin("adaptedType", thrift.STRING, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.AdaptedType
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField3(p thrift.Encoder) error {  // UnderlyingName
    if err := p.WriteFieldBegin("underlyingName", thrift.STRING, 3); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.UnderlyingName
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField4(p thrift.Encoder) error {  // ExtraNamespace
    if err := p.WriteFieldBegin("extraNamespace", thrift.STRING, 4); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.ExtraNamespace
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) writeField5(p thrift.Encoder) error {  // MoveOnly
    if err := p.WriteFieldBegin("moveOnly", thrift.BOOL, 5); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.MoveOnly
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Adapter) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Name = result
    return nil
}

func (x *Adapter) readField2(p thrift.Decoder) error {  // AdaptedType
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.AdaptedType = result
    return nil
}

func (x *Adapter) readField3(p thrift.Decoder) error {  // UnderlyingName
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.UnderlyingName = result
    return nil
}

func (x *Adapter) readField4(p thrift.Decoder) error {  // ExtraNamespace
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.ExtraNamespace = result
    return nil
}

func (x *Adapter) readField5(p thrift.Decoder) error {  // MoveOnly
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.MoveOnly = result
    return nil
}

func (x *Adapter) toString1() string {  // Name
    return fmt.Sprintf("%v", x.Name)
}

func (x *Adapter) toString2() string {  // AdaptedType
    return fmt.Sprintf("%v", x.AdaptedType)
}

func (x *Adapter) toString3() string {  // UnderlyingName
    return fmt.Sprintf("%v", x.UnderlyingName)
}

func (x *Adapter) toString4() string {  // ExtraNamespace
    return fmt.Sprintf("%v", x.ExtraNamespace)
}

func (x *Adapter) toString5() string {  // MoveOnly
    return fmt.Sprintf("%v", x.MoveOnly)
}



func (x *Adapter) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Adapter"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := x.writeField3(p); err != nil {
        return err
    }

    if err := x.writeField4(p); err != nil {
        return err
    }

    if err := x.writeField5(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Adapter) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // name
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.STRING)):  // adaptedType
            if err := x.readField2(p); err != nil {
                return err
            }
        case (id == 3 && wireType == thrift.Type(thrift.STRING)):  // underlyingName
            if err := x.readField3(p); err != nil {
                return err
            }
        case (id == 4 && wireType == thrift.Type(thrift.STRING)):  // extraNamespace
            if err := x.readField4(p); err != nil {
                return err
            }
        case (id == 5 && wireType == thrift.Type(thrift.BOOL)):  // moveOnly
            if err := x.readField5(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Adapter) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Adapter({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("AdaptedType:%s ", x.toString2()))
    sb.WriteString(fmt.Sprintf("UnderlyingName:%s ", x.toString3()))
    sb.WriteString(fmt.Sprintf("ExtraNamespace:%s ", x.toString4()))
    sb.WriteString(fmt.Sprintf("MoveOnly:%s", x.toString5()))
    sb.WriteString("})")

    return sb.String()
}

type PackIsset struct {
    Atomic bool `thrift:"atomic,1" json:"atomic" db:"atomic"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*PackIsset)(nil)

func NewPackIsset() *PackIsset {
    return (&PackIsset{}).
        SetAtomicNonCompat(true)
}

func (x *PackIsset) GetAtomic() bool {
    return x.Atomic
}

func (x *PackIsset) SetAtomicNonCompat(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) SetAtomic(value bool) *PackIsset {
    x.Atomic = value
    return x
}

func (x *PackIsset) writeField1(p thrift.Encoder) error {  // Atomic
    if err := p.WriteFieldBegin("atomic", thrift.BOOL, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Atomic
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) readField1(p thrift.Decoder) error {  // Atomic
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.Atomic = result
    return nil
}

func (x *PackIsset) toString1() string {  // Atomic
    return fmt.Sprintf("%v", x.Atomic)
}



func (x *PackIsset) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("PackIsset"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *PackIsset) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.BOOL)):  // atomic
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *PackIsset) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("PackIsset({")
    sb.WriteString(fmt.Sprintf("Atomic:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type MinimizePadding struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*MinimizePadding)(nil)

func NewMinimizePadding() *MinimizePadding {
    return (&MinimizePadding{})
}



func (x *MinimizePadding) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("MinimizePadding"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *MinimizePadding) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *MinimizePadding) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("MinimizePadding({")
    sb.WriteString("})")

    return sb.String()
}

type ScopedEnumAsUnionType struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*ScopedEnumAsUnionType)(nil)

func NewScopedEnumAsUnionType() *ScopedEnumAsUnionType {
    return (&ScopedEnumAsUnionType{})
}



func (x *ScopedEnumAsUnionType) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ScopedEnumAsUnionType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ScopedEnumAsUnionType) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ScopedEnumAsUnionType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ScopedEnumAsUnionType({")
    sb.WriteString("})")

    return sb.String()
}

type FieldInterceptor struct {
    Name string `thrift:"name,1" json:"name" db:"name"`
    Noinline bool `thrift:"noinline,2" json:"noinline" db:"noinline"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*FieldInterceptor)(nil)

func NewFieldInterceptor() *FieldInterceptor {
    return (&FieldInterceptor{}).
        SetNameNonCompat("").
        SetNoinlineNonCompat(false)
}

func (x *FieldInterceptor) GetName() string {
    return x.Name
}

func (x *FieldInterceptor) GetNoinline() bool {
    return x.Noinline
}

func (x *FieldInterceptor) SetNameNonCompat(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetName(value string) *FieldInterceptor {
    x.Name = value
    return x
}

func (x *FieldInterceptor) SetNoinlineNonCompat(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) SetNoinline(value bool) *FieldInterceptor {
    x.Noinline = value
    return x
}

func (x *FieldInterceptor) writeField1(p thrift.Encoder) error {  // Name
    if err := p.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Name
    if err := p.WriteString(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) writeField2(p thrift.Encoder) error {  // Noinline
    if err := p.WriteFieldBegin("noinline", thrift.BOOL, 2); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Noinline
    if err := p.WriteBool(item); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) readField1(p thrift.Decoder) error {  // Name
    result, err := p.ReadString()
if err != nil {
    return err
}

    x.Name = result
    return nil
}

func (x *FieldInterceptor) readField2(p thrift.Decoder) error {  // Noinline
    result, err := p.ReadBool()
if err != nil {
    return err
}

    x.Noinline = result
    return nil
}

func (x *FieldInterceptor) toString1() string {  // Name
    return fmt.Sprintf("%v", x.Name)
}

func (x *FieldInterceptor) toString2() string {  // Noinline
    return fmt.Sprintf("%v", x.Noinline)
}



func (x *FieldInterceptor) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("FieldInterceptor"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := x.writeField2(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *FieldInterceptor) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.STRING)):  // name
            if err := x.readField1(p); err != nil {
                return err
            }
        case (id == 2 && wireType == thrift.Type(thrift.BOOL)):  // noinline
            if err := x.readField2(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *FieldInterceptor) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("FieldInterceptor({")
    sb.WriteString(fmt.Sprintf("Name:%s ", x.toString1()))
    sb.WriteString(fmt.Sprintf("Noinline:%s", x.toString2()))
    sb.WriteString("})")

    return sb.String()
}

type UseOpEncode struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*UseOpEncode)(nil)

func NewUseOpEncode() *UseOpEncode {
    return (&UseOpEncode{})
}



func (x *UseOpEncode) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("UseOpEncode"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseOpEncode) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *UseOpEncode) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("UseOpEncode({")
    sb.WriteString("})")

    return sb.String()
}

type EnumType struct {
    Type EnumUnderlyingType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = (*EnumType)(nil)

func NewEnumType() *EnumType {
    return (&EnumType{}).
        SetTypeNonCompat(0)
}

func (x *EnumType) GetType() EnumUnderlyingType {
    return x.Type
}

func (x *EnumType) SetTypeNonCompat(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) SetType(value EnumUnderlyingType) *EnumType {
    x.Type = value
    return x
}

func (x *EnumType) writeField1(p thrift.Encoder) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.Type
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *EnumType) readField1(p thrift.Decoder) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := EnumUnderlyingType(enumResult)

    x.Type = result
    return nil
}

func (x *EnumType) toString1() string {  // Type
    return fmt.Sprintf("%v", x.Type)
}



func (x *EnumType) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("EnumType"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *EnumType) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // type
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *EnumType) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("EnumType({")
    sb.WriteString(fmt.Sprintf("Type:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Frozen2Exclude struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*Frozen2Exclude)(nil)

func NewFrozen2Exclude() *Frozen2Exclude {
    return (&Frozen2Exclude{})
}



func (x *Frozen2Exclude) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Frozen2Exclude"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2Exclude) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2Exclude) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Frozen2Exclude({")
    sb.WriteString("})")

    return sb.String()
}

type Frozen2RequiresCompleteContainerParams struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*Frozen2RequiresCompleteContainerParams)(nil)

func NewFrozen2RequiresCompleteContainerParams() *Frozen2RequiresCompleteContainerParams {
    return (&Frozen2RequiresCompleteContainerParams{})
}



func (x *Frozen2RequiresCompleteContainerParams) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("Frozen2RequiresCompleteContainerParams"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Frozen2RequiresCompleteContainerParams) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Frozen2RequiresCompleteContainerParams({")
    sb.WriteString("})")

    return sb.String()
}

type ProcessInEbThreadUnsafe struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*ProcessInEbThreadUnsafe)(nil)

func NewProcessInEbThreadUnsafe() *ProcessInEbThreadUnsafe {
    return (&ProcessInEbThreadUnsafe{})
}



func (x *ProcessInEbThreadUnsafe) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("ProcessInEbThreadUnsafe"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *ProcessInEbThreadUnsafe) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *ProcessInEbThreadUnsafe) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("ProcessInEbThreadUnsafe({")
    sb.WriteString("})")

    return sb.String()
}

type RuntimeAnnotation struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*RuntimeAnnotation)(nil)

func NewRuntimeAnnotation() *RuntimeAnnotation {
    return (&RuntimeAnnotation{})
}



func (x *RuntimeAnnotation) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("RuntimeAnnotation"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *RuntimeAnnotation) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *RuntimeAnnotation) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("RuntimeAnnotation({")
    sb.WriteString("})")

    return sb.String()
}

type UseCursorSerialization struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*UseCursorSerialization)(nil)

func NewUseCursorSerialization() *UseCursorSerialization {
    return (&UseCursorSerialization{})
}



func (x *UseCursorSerialization) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("UseCursorSerialization"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *UseCursorSerialization) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *UseCursorSerialization) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("UseCursorSerialization({")
    sb.WriteString("})")

    return sb.String()
}

type GenerateDeprecatedHeaderClientMethods struct {
}
// Compile time interface enforcer
var _ thrift.Struct = (*GenerateDeprecatedHeaderClientMethods)(nil)

func NewGenerateDeprecatedHeaderClientMethods() *GenerateDeprecatedHeaderClientMethods {
    return (&GenerateDeprecatedHeaderClientMethods{})
}



func (x *GenerateDeprecatedHeaderClientMethods) Write(p thrift.Encoder) error {
    if err := p.WriteStructBegin("GenerateDeprecatedHeaderClientMethods"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *GenerateDeprecatedHeaderClientMethods) Read(p thrift.Decoder) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *GenerateDeprecatedHeaderClientMethods) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("GenerateDeprecatedHeaderClientMethods({")
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Type", func() any { return NewType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Ref", func() any { return NewRef() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Name", func() any { return NewName() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Lazy", func() any { return NewLazy() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/DisableLazyChecksum", func() any { return NewDisableLazyChecksum() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Adapter", func() any { return NewAdapter() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/PackIsset", func() any { return NewPackIsset() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/MinimizePadding", func() any { return NewMinimizePadding() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/ScopedEnumAsUnionType", func() any { return NewScopedEnumAsUnionType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/FieldInterceptor", func() any { return NewFieldInterceptor() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/UseOpEncode", func() any { return NewUseOpEncode() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumType", func() any { return NewEnumType() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2Exclude", func() any { return NewFrozen2Exclude() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/Frozen2RequiresCompleteContainerParams", func() any { return NewFrozen2RequiresCompleteContainerParams() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/ProcessInEbThreadUnsafe", func() any { return NewProcessInEbThreadUnsafe() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/RuntimeAnnotation", func() any { return NewRuntimeAnnotation() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/UseCursorSerialization", func() any { return NewUseCursorSerialization() })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/GenerateDeprecatedHeaderClientMethods", func() any { return NewGenerateDeprecatedHeaderClientMethods() })

    registry.RegisterType("facebook.com/thrift/annotation/cpp/RefType", func() any { return RefType(0) })
    registry.RegisterType("facebook.com/thrift/annotation/cpp/EnumUnderlyingType", func() any { return EnumUnderlyingType(0) })
}
