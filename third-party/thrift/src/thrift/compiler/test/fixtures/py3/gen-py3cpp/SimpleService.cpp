/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/py3/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/SimpleService.h"
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/SimpleService.tcc"
#include "thrift/compiler/test/fixtures/py3/gen-py3cpp/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::getProcessor() {
  return std::make_unique<::py3::simple::SimpleServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::py3::simple::SimpleService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::py3::simple::SimpleService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::py3::simple::SimpleServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::py3::simple::SimpleServiceServiceInfoHolder apache::thrift::ServiceHandler<::py3::simple::SimpleService>::__fbthrift_serviceInfoHolder;


::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_five() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_five");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_five() {
  return get_five();
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_five() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_get_five();
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_five() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_five(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_five() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_five(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_five();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_five(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_five.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_five(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_five();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_five();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_five(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_five();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_get_five());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::add_five(::std::int32_t /*num*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("add_five");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_add_five(::std::int32_t p_num) {
  return add_five(p_num);
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_add_five(::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_add_five(p_num);
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_add_five(::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_add_five(p_num), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_add_five(::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int32_t /*num*/>(p_num));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_add_five(apache::thrift::RequestParams /* params */, ::std::int32_t p_num) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_add_five.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_add_five(p_num);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_add_five(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, ::std::int32_t p_num) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_add_five.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_add_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_add_five(params, p_num);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_add_five.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_add_five(p_num);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_add_five(p_num);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_add_five(params, p_num);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_add_five(p_num);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_add_five(p_num));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_num) = std::move(ex).restoreArgs<::std::int32_t /*num*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::do_nothing() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("do_nothing");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_do_nothing() {
  return do_nothing();
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_do_nothing() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_do_nothing();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_do_nothing() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_do_nothing(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_do_nothing() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_do_nothing(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_do_nothing.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_do_nothing();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_do_nothing(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_do_nothing.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_do_nothing.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_do_nothing(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_do_nothing.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_do_nothing();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_do_nothing();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_do_nothing(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_do_nothing();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_do_nothing();
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::concat(::std::string& /*_return*/, std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("concat");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_concat(::std::string& _return, std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  return concat(_return, std::move(p_first), std::move(p_second));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_concat(std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_concat(*ret, std::move(p_first), std::move(p_second));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_concat(std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_concat(std::move(p_first), std::move(p_second)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_concat(std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/>(std::move(p_first), std::move(p_second)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_concat(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_concat.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_concat(std::move(p_first), std::move(p_second));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_concat(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_first, std::unique_ptr<::std::string> p_second) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_concat.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_concat.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_concat(params, std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_concat.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_concat(std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_concat(std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_concat(params, std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_concat(std::move(p_first), std::move(p_second));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_concat(_return, std::move(p_first), std::move(p_second));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_first, p_second) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_value(std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_value");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  return get_value(std::move(p_simple_struct));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_get_value(std::move(p_simple_struct));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_value(std::move(p_simple_struct)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_value(std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/>(std::move(p_simple_struct)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_value(apache::thrift::RequestParams /* params */, std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_value(std::move(p_simple_struct));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_value(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::py3::simple::SimpleStruct> p_simple_struct) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_value.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_value(params, std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_value(std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_value(std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_value(params, std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_value(std::move(p_simple_struct));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_get_value(std::move(p_simple_struct)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_simple_struct) = std::move(ex).restoreArgs<std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool apache::thrift::ServiceHandler<::py3::simple::SimpleService>::negate(bool /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("negate");
}

bool apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_negate(bool p_input) {
  return negate(p_input);
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_negate(bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_negate(p_input);
}

folly::Future<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_negate(bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_negate(p_input), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_negate(bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<bool /*input*/>(p_input));
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_negate(apache::thrift::RequestParams /* params */, bool p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_negate.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_negate(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_negate(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, bool p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_negate.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_negate.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_negate(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_negate.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_negate(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_negate(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_negate(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_negate(p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_negate(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<bool /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int8_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::tiny(::std::int8_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("tiny");
}

::std::int8_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_tiny(::std::int8_t p_input) {
  return tiny(p_input);
}

folly::SemiFuture<::std::int8_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_tiny(::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_tiny(p_input);
}

folly::Future<::std::int8_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_tiny(::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_tiny(p_input), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int8_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_tiny(::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int8_t /*input*/>(p_input));
}

folly::coro::Task<::std::int8_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_tiny(apache::thrift::RequestParams /* params */, ::std::int8_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_tiny.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_tiny(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_tiny(std::unique_ptr<apache::thrift::HandlerCallback<::std::int8_t>> callback, ::std::int8_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_tiny.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_tiny.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_tiny(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_tiny.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_tiny(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_tiny(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_tiny(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_tiny(p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_tiny(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<::std::int8_t /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::small(::std::int16_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("small");
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_small(::std::int16_t p_input) {
  return small(p_input);
}

folly::SemiFuture<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_small(::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_small(p_input);
}

folly::Future<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_small(::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_small(p_input), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_small(::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int16_t /*input*/>(p_input));
}

folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_small(apache::thrift::RequestParams /* params */, ::std::int16_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_small.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_small(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_small(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, ::std::int16_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_small.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_small.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_small(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_small.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_small(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_small(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_small(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_small(p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_small(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<::std::int16_t /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int64_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::big(::std::int64_t /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("big");
}

::std::int64_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_big(::std::int64_t p_input) {
  return big(p_input);
}

folly::SemiFuture<::std::int64_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_big(::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_big(p_input);
}

folly::Future<::std::int64_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_big(::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_big(p_input), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_big(::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int64_t /*input*/>(p_input));
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_big(apache::thrift::RequestParams /* params */, ::std::int64_t p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_big.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_big(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_big(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback, ::std::int64_t p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_big.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_big.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_big(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_big.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_big(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_big(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_big(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_big(p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_big(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<::std::int64_t /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

double apache::thrift::ServiceHandler<::py3::simple::SimpleService>::two(double /*input*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("two");
}

double apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_two(double p_input) {
  return two(p_input);
}

folly::SemiFuture<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_two(double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_two(p_input);
}

folly::Future<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_two(double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_two(p_input), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_two(double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<double /*input*/>(p_input));
}

folly::coro::Task<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_two(apache::thrift::RequestParams /* params */, double p_input) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_two.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_two(p_input);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_two(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback, double p_input) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_two.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_two.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_two(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_two.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_two(p_input);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_two(p_input);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_two(params, p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_two(p_input);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_two(p_input));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_input) = std::move(ex).restoreArgs<double /*input*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::expected_exception() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("expected_exception");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_expected_exception() {
  return expected_exception();
}

folly::SemiFuture<folly::Unit> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_expected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  sync_expected_exception();
  return folly::makeSemiFuture();
}

folly::Future<folly::Unit> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_expected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_expected_exception(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<void> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_expected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<void> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_expected_exception(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_expected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_expected_exception();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_expected_exception(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_expected_exception.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_expected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_expected_exception(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_expected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_expected_exception();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_expected_exception();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_expected_exception(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_expected_exception();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        sync_expected_exception();
        callback->done();
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::unexpected_exception() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("unexpected_exception");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_unexpected_exception() {
  return unexpected_exception();
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_unexpected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_unexpected_exception();
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_unexpected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_unexpected_exception(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_unexpected_exception() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_unexpected_exception(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_unexpected_exception.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_unexpected_exception();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_unexpected_exception(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_unexpected_exception.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_unexpected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_unexpected_exception(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_unexpected_exception.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_unexpected_exception();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_unexpected_exception();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_unexpected_exception(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_unexpected_exception();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_unexpected_exception());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i16_list");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  return sum_i16_list(std::move(p_numbers));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_sum_i16_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i16_list(std::move(p_numbers)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/>(std::move(p_numbers)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i16_list(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum_i16_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_sum_i16_list(std::move(p_numbers));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_sum_i16_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int16_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_sum_i16_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i16_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i16_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i16_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i16_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i16_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i16_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_sum_i16_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_sum_i16_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_numbers) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i32_list");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  return sum_i32_list(std::move(p_numbers));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_sum_i32_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i32_list(std::move(p_numbers)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/>(std::move(p_numbers)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i32_list(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum_i32_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_sum_i32_list(std::move(p_numbers));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_sum_i32_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int32_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_sum_i32_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i32_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i32_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i32_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i32_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i32_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i32_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_sum_i32_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_sum_i32_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_numbers) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_i64_list");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  return sum_i64_list(std::move(p_numbers));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_sum_i64_list(std::move(p_numbers));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_i64_list(std::move(p_numbers)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/>(std::move(p_numbers)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_i64_list(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum_i64_list.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_sum_i64_list(std::move(p_numbers));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_sum_i64_list(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::std::int64_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_sum_i64_list.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i64_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i64_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_i64_list.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_i64_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_i64_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_i64_list(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_sum_i64_list(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_sum_i64_list(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_numbers) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::concat_many(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("concat_many");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_concat_many(::std::string& _return, std::unique_ptr<::std::vector<::std::string>> p_words) {
  return concat_many(_return, std::move(p_words));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_concat_many(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_concat_many(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_concat_many(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_concat_many(std::move(p_words)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_concat_many(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>(std::move(p_words)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_concat_many(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_concat_many.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_concat_many(std::move(p_words));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_concat_many(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_concat_many.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_concat_many.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_concat_many(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_concat_many.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_concat_many(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_concat_many(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_concat_many(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_concat_many(std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_concat_many(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_words) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("count_structs");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  return count_structs(std::move(p_items));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_count_structs(std::move(p_items));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_count_structs(std::move(p_items)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/>(std::move(p_items)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_count_structs(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_count_structs.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_count_structs(std::move(p_items));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_count_structs(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_count_structs.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_count_structs.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_count_structs(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_count_structs.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_count_structs(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_count_structs(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_count_structs(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_count_structs(std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_count_structs(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_items) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sum_set(std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_set");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  return sum_set(std::move(p_numbers));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_sum_set(std::move(p_numbers));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_set(std::move(p_numbers)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_set(std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/>(std::move(p_numbers)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_set(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum_set.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_sum_set(std::move(p_numbers));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_sum_set(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::set<::std::int32_t>> p_numbers) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_sum_set.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_set.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_set(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_set.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_set(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_set(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_set(params, std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_sum_set(std::move(p_numbers));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_sum_set(std::move(p_numbers)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_numbers) = std::move(ex).restoreArgs<std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

bool apache::thrift::ServiceHandler<::py3::simple::SimpleService>::contains_word(std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contains_word");
}

bool apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  return contains_word(std::move(p_words), std::move(p_word));
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_contains_word(std::move(p_words), std::move(p_word));
}

folly::Future<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contains_word(std::move(p_words), std::move(p_word)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contains_word(std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/>(std::move(p_words), std::move(p_word)));
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contains_word(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_contains_word.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_contains_word(std::move(p_words), std::move(p_word));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_contains_word(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback, std::unique_ptr<::std::set<::std::string>> p_words, std::unique_ptr<::std::string> p_word) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_contains_word.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contains_word.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contains_word(params, std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contains_word.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contains_word(std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contains_word(std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contains_word(params, std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_contains_word(std::move(p_words), std::move(p_word));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_contains_word(std::move(p_words), std::move(p_word)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_words, p_word) = std::move(ex).restoreArgs<std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_map_value(::std::string& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_map_value");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_map_value(::std::string& _return, std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  return get_map_value(_return, std::move(p_words), std::move(p_key));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_map_value(std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_get_map_value(*ret, std::move(p_words), std::move(p_key));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_map_value(std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_map_value(std::move(p_words), std::move(p_key)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_map_value(std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/>(std::move(p_words), std::move(p_key)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_map_value(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_map_value.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_map_value(std::move(p_words), std::move(p_key));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_map_value(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::map<::std::string, ::std::string>> p_words, std::unique_ptr<::std::string> p_key) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_map_value.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_map_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_map_value(params, std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_map_value.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_map_value(std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_map_value(std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_map_value(params, std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_map_value(std::move(p_words), std::move(p_key));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_get_map_value(_return, std::move(p_words), std::move(p_key));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_words, p_key) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("map_length");
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  return map_length(std::move(p_items));
}

folly::SemiFuture<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_map_length(std::move(p_items));
}

folly::Future<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_map_length(std::move(p_items)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/>(std::move(p_items)));
}

folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_map_length(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_map_length.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_map_length(std::move(p_items));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_map_length(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_map_length.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_map_length.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_map_length(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_map_length.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_map_length(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_map_length(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_map_length(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_map_length(std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_map_length(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_items) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("sum_map_values");
}

::std::int16_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  return sum_map_values(std::move(p_items));
}

folly::SemiFuture<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_sum_map_values(std::move(p_items));
}

folly::Future<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_sum_map_values(std::move(p_items)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/>(std::move(p_items)));
}

folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_sum_map_values(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_sum_map_values.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_sum_map_values(std::move(p_items));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_sum_map_values(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback, std::unique_ptr<::std::map<::std::string, ::std::int16_t>> p_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_sum_map_values.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_map_values.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_map_values(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_sum_map_values.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_sum_map_values(std::move(p_items));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_sum_map_values(std::move(p_items));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_sum_map_values(params, std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_sum_map_values(std::move(p_items));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_sum_map_values(std::move(p_items)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_items) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("complex_sum_i32");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  return complex_sum_i32(std::move(p_counter));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_complex_sum_i32(std::move(p_counter));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_complex_sum_i32(std::move(p_counter)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/>(std::move(p_counter)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_complex_sum_i32(apache::thrift::RequestParams /* params */, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_complex_sum_i32(std::move(p_counter));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_complex_sum_i32(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_complex_sum_i32.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_complex_sum_i32(params, std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_complex_sum_i32.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_complex_sum_i32(std::move(p_counter));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_complex_sum_i32(std::move(p_counter));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_complex_sum_i32(params, std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_complex_sum_i32(std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_complex_sum_i32(std::move(p_counter)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_counter) = std::move(ex).restoreArgs<std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::repeat_name(::std::string& /*_return*/, std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("repeat_name");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_repeat_name(::std::string& _return, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  return repeat_name(_return, std::move(p_counter));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_repeat_name(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_repeat_name(*ret, std::move(p_counter));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_repeat_name(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_repeat_name(std::move(p_counter)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_repeat_name(std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/>(std::move(p_counter)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_repeat_name(apache::thrift::RequestParams /* params */, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_repeat_name.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_repeat_name(std::move(p_counter));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_repeat_name(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::py3::simple::ComplexStruct> p_counter) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_repeat_name.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_repeat_name.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_repeat_name(params, std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_repeat_name.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_repeat_name(std::move(p_counter));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_repeat_name(std::move(p_counter));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_repeat_name(params, std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_repeat_name(std::move(p_counter));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_repeat_name(_return, std::move(p_counter));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_counter) = std::move(ex).restoreArgs<std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_struct(::py3::simple::SimpleStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_struct");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_struct(::py3::simple::SimpleStruct& _return) {
  return get_struct(_return);
}

folly::SemiFuture<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_struct() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::py3::simple::SimpleStruct>();
  sync_get_struct(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_struct() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_struct(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_struct() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_struct(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_struct();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_struct(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::SimpleStruct>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_struct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_struct(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_struct();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_struct();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_struct(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_struct();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::py3::simple::SimpleStruct _return;
        sync_get_struct(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::fib(::std::vector<::std::int32_t>& /*_return*/, ::std::int16_t /*n*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("fib");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_fib(::std::vector<::std::int32_t>& _return, ::std::int16_t p_n) {
  return fib(_return, p_n);
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_fib(::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::int32_t>>();
  sync_fib(*ret, p_n);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_fib(::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_fib(p_n), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_fib(::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int16_t /*n*/>(p_n));
}

folly::coro::Task<std::unique_ptr<::std::vector<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_fib(apache::thrift::RequestParams /* params */, ::std::int16_t p_n) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_fib.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_fib(p_n);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_fib(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::int32_t>>>> callback, ::std::int16_t p_n) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_fib.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_fib.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_fib(params, p_n);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_fib.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_fib(p_n);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_fib(p_n);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_fib(params, p_n);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_fib(p_n);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::int32_t> _return;
        sync_fib(_return, p_n);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_n) = std::move(ex).restoreArgs<::std::int16_t /*n*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::unique_words(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("unique_words");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_unique_words(::std::set<::std::string>& _return, std::unique_ptr<::std::vector<::std::string>> p_words) {
  return unique_words(_return, std::move(p_words));
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_unique_words(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  sync_unique_words(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_unique_words(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_unique_words(std::move(p_words)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_unique_words(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>(std::move(p_words)));
}

folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_unique_words(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_unique_words.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_unique_words(std::move(p_words));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_unique_words(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_unique_words.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_unique_words.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_unique_words(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_unique_words.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_unique_words(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_unique_words(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_unique_words(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_unique_words(std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        sync_unique_words(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_words) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::words_count(::std::map<::std::string, ::std::int16_t>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("words_count");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_words_count(::std::map<::std::string, ::std::int16_t>& _return, std::unique_ptr<::std::vector<::std::string>> p_words) {
  return words_count(_return, std::move(p_words));
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_words_count(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::int16_t>>();
  sync_words_count(*ret, std::move(p_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_words_count(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_words_count(std::move(p_words)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_words_count(std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>(std::move(p_words)));
}

folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_words_count(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::string>> p_words) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_words_count.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_words_count(std::move(p_words));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_words_count(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::int16_t>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_words_count.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_words_count.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_words_count(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_words_count.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_words_count(std::move(p_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_words_count(std::move(p_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_words_count(params, std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_words_count(std::move(p_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::int16_t> _return;
        sync_words_count(_return, std::move(p_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_words) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::string>> /*words*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::py3::simple::AnEnum apache::thrift::ServiceHandler<::py3::simple::SimpleService>::set_enum(::py3::simple::AnEnum /*in_enum*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("set_enum");
}

::py3::simple::AnEnum apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_set_enum(::py3::simple::AnEnum p_in_enum) {
  return set_enum(p_in_enum);
}

folly::SemiFuture<::py3::simple::AnEnum> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_set_enum(::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_set_enum(p_in_enum);
}

folly::Future<::py3::simple::AnEnum> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_set_enum(::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_set_enum(p_in_enum), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::py3::simple::AnEnum> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_set_enum(::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::py3::simple::AnEnum /*in_enum*/>(p_in_enum));
}

folly::coro::Task<::py3::simple::AnEnum> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_set_enum(apache::thrift::RequestParams /* params */, ::py3::simple::AnEnum p_in_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_set_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_set_enum(p_in_enum);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_set_enum(std::unique_ptr<apache::thrift::HandlerCallback<::py3::simple::AnEnum>> callback, ::py3::simple::AnEnum p_in_enum) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_set_enum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_set_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_set_enum(params, p_in_enum);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_set_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_set_enum(p_in_enum);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_set_enum(p_in_enum);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_set_enum(params, p_in_enum);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_set_enum(p_in_enum);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_set_enum(p_in_enum));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_in_enum) = std::move(ex).restoreArgs<::py3::simple::AnEnum /*in_enum*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::list_of_lists(::std::vector<::std::vector<::std::int32_t>>& /*_return*/, ::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_of_lists");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_list_of_lists(::std::vector<::std::vector<::std::int32_t>>& _return, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  return list_of_lists(_return, p_num_lists, p_num_items);
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::vector<::std::int32_t>>>();
  sync_list_of_lists(*ret, p_num_lists, p_num_items);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_of_lists(p_num_lists, p_num_items), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_list_of_lists(::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/>(p_num_lists, p_num_items));
}

folly::coro::Task<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_list_of_lists(apache::thrift::RequestParams /* params */, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_list_of_lists.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_list_of_lists(p_num_lists, p_num_items);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_list_of_lists(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::vector<::std::int32_t>>>>> callback, ::std::int16_t p_num_lists, ::std::int16_t p_num_items) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_list_of_lists.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_of_lists.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_of_lists(params, p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_of_lists.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_of_lists(p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_of_lists(p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_of_lists(params, p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_list_of_lists(p_num_lists, p_num_items);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::vector<::std::int32_t>> _return;
        sync_list_of_lists(_return, p_num_lists, p_num_items);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_num_lists, p_num_items) = std::move(ex).restoreArgs<::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& /*_return*/, std::unique_ptr<::std::string> /*sentence*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("word_character_frequency");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& _return, std::unique_ptr<::std::string> p_sentence) {
  return word_character_frequency(_return, std::move(p_sentence));
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_word_character_frequency(std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>();
  sync_word_character_frequency(*ret, std::move(p_sentence));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_word_character_frequency(std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_word_character_frequency(std::move(p_sentence)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_word_character_frequency(std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*sentence*/>(std::move(p_sentence)));
}

folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_word_character_frequency(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_sentence) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_word_character_frequency.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_word_character_frequency(std::move(p_sentence));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_word_character_frequency(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>>>> callback, std::unique_ptr<::std::string> p_sentence) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_word_character_frequency.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_word_character_frequency.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_word_character_frequency(params, std::move(p_sentence));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_word_character_frequency.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_word_character_frequency(std::move(p_sentence));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_word_character_frequency(std::move(p_sentence));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_word_character_frequency(params, std::move(p_sentence));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_word_character_frequency(std::move(p_sentence));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>> _return;
        sync_word_character_frequency(_return, std::move(p_sentence));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_sentence) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*sentence*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::list_of_sets(::std::vector<::std::set<::std::string>>& /*_return*/, std::unique_ptr<::std::string> /*some_words*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_of_sets");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_list_of_sets(::std::vector<::std::set<::std::string>>& _return, std::unique_ptr<::std::string> p_some_words) {
  return list_of_sets(_return, std::move(p_some_words));
}

folly::SemiFuture<std::unique_ptr<::std::vector<::std::set<::std::string>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_list_of_sets(std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::std::set<::std::string>>>();
  sync_list_of_sets(*ret, std::move(p_some_words));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::std::set<::std::string>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_list_of_sets(std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_of_sets(std::move(p_some_words)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::std::set<::std::string>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_list_of_sets(std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*some_words*/>(std::move(p_some_words)));
}

folly::coro::Task<std::unique_ptr<::std::vector<::std::set<::std::string>>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_list_of_sets(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_some_words) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_list_of_sets.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_list_of_sets(std::move(p_some_words));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_list_of_sets(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::std::set<::std::string>>>>> callback, std::unique_ptr<::std::string> p_some_words) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_list_of_sets.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_of_sets.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_of_sets(params, std::move(p_some_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_of_sets.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_of_sets(std::move(p_some_words));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_of_sets(std::move(p_some_words));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_of_sets(params, std::move(p_some_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_list_of_sets(std::move(p_some_words));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::std::set<::std::string>> _return;
        sync_list_of_sets(_return, std::move(p_some_words));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_some_words) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*some_words*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("nested_map_argument");
}

::std::int32_t apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  return nested_map_argument(std::move(p_struct_map));
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_nested_map_argument(std::move(p_struct_map));
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_nested_map_argument(std::move(p_struct_map)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/>(std::move(p_struct_map)));
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_nested_map_argument(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_nested_map_argument.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_nested_map_argument(std::move(p_struct_map));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_nested_map_argument(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback, std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> p_struct_map) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_nested_map_argument.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_nested_map_argument.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_nested_map_argument(params, std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_nested_map_argument.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_nested_map_argument(std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_nested_map_argument(std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_nested_map_argument(params, std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_nested_map_argument(std::move(p_struct_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_nested_map_argument(std::move(p_struct_map)));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_struct_map) = std::move(ex).restoreArgs<std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::make_sentence(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("make_sentence");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_make_sentence(::std::string& _return, std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  return make_sentence(_return, std::move(p_word_chars));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_make_sentence(std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_make_sentence(*ret, std::move(p_word_chars));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_make_sentence(std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_make_sentence(std::move(p_word_chars)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_make_sentence(std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/>(std::move(p_word_chars)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_make_sentence(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_make_sentence.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_make_sentence(std::move(p_word_chars));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_make_sentence(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::vector<::std::vector<::std::string>>> p_word_chars) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_make_sentence.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_make_sentence.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_make_sentence(params, std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_make_sentence.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_make_sentence(std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_make_sentence(std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_make_sentence(params, std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_make_sentence(std::move(p_word_chars));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_make_sentence(_return, std::move(p_word_chars));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_word_chars) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_union(::std::set<::std::int32_t>& /*_return*/, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_union");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_union(::std::set<::std::int32_t>& _return, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  return get_union(_return, std::move(p_sets));
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_union(std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::int32_t>>();
  sync_get_union(*ret, std::move(p_sets));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_union(std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_union(std::move(p_sets)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_union(std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/>(std::move(p_sets)));
}

folly::coro::Task<std::unique_ptr<::std::set<::std::int32_t>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_union(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_union.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_union(std::move(p_sets));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_union(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::int32_t>>>> callback, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> p_sets) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_union.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_union.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_union(params, std::move(p_sets));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_union.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_union(std::move(p_sets));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_union(std::move(p_sets));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_union(params, std::move(p_sets));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_union(std::move(p_sets));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::int32_t> _return;
        sync_get_union(_return, std::move(p_sets));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_sets) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_keys(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_keys");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_keys(::std::set<::std::string>& _return, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  return get_keys(_return, std::move(p_string_map));
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_keys(std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  sync_get_keys(*ret, std::move(p_string_map));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_keys(std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_keys(std::move(p_string_map)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_keys(std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/>(std::move(p_string_map)));
}

folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_keys(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_keys.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_keys(std::move(p_string_map));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_keys(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> p_string_map) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_keys.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_keys.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_keys(params, std::move(p_string_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_keys.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_keys(std::move(p_string_map));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_keys(std::move(p_string_map));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_keys(params, std::move(p_string_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_keys(std::move(p_string_map));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        sync_get_keys(_return, std::move(p_string_map));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_string_map) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

double apache::thrift::ServiceHandler<::py3::simple::SimpleService>::lookup_double(::std::int32_t /*key*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("lookup_double");
}

double apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_lookup_double(::std::int32_t p_key) {
  return lookup_double(p_key);
}

folly::SemiFuture<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_lookup_double(::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_lookup_double(p_key);
}

folly::Future<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_lookup_double(::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_lookup_double(p_key), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_lookup_double(::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int32_t /*key*/>(p_key));
}

folly::coro::Task<double> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_lookup_double(apache::thrift::RequestParams /* params */, ::std::int32_t p_key) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_lookup_double.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_lookup_double(p_key);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_lookup_double(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback, ::std::int32_t p_key) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_lookup_double.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_lookup_double.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_lookup_double(params, p_key);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_lookup_double.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_lookup_double(p_key);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_lookup_double(p_key);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_lookup_double(params, p_key);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_lookup_double(p_key);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_lookup_double(p_key));
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_key) = std::move(ex).restoreArgs<::std::int32_t /*key*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::retrieve_binary(::std::string& /*_return*/, std::unique_ptr<::std::string> /*something*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("retrieve_binary");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_retrieve_binary(::std::string& _return, std::unique_ptr<::std::string> p_something) {
  return retrieve_binary(_return, std::move(p_something));
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_retrieve_binary(std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_retrieve_binary(*ret, std::move(p_something));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_retrieve_binary(std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_retrieve_binary(std::move(p_something)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_retrieve_binary(std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::string> /*something*/>(std::move(p_something)));
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_retrieve_binary(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::string> p_something) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_retrieve_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_retrieve_binary(std::move(p_something));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_retrieve_binary(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback, std::unique_ptr<::std::string> p_something) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_retrieve_binary.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_retrieve_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_retrieve_binary(params, std::move(p_something));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_retrieve_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_retrieve_binary(std::move(p_something));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_retrieve_binary(std::move(p_something));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_retrieve_binary(params, std::move(p_something));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_retrieve_binary(std::move(p_something));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_retrieve_binary(_return, std::move(p_something));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_something) = std::move(ex).restoreArgs<std::unique_ptr<::std::string> /*something*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::contain_binary(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*binaries*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contain_binary");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_contain_binary(::std::set<::std::string>& _return, std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  return contain_binary(_return, std::move(p_binaries));
}

folly::SemiFuture<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_contain_binary(std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::std::string>>();
  sync_contain_binary(*ret, std::move(p_binaries));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_contain_binary(std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contain_binary(std::move(p_binaries)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contain_binary(std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::std::string>> /*binaries*/>(std::move(p_binaries)));
}

folly::coro::Task<std::unique_ptr<::std::set<::std::string>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contain_binary(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_contain_binary.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_contain_binary(std::move(p_binaries));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_contain_binary(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::std::string>>>> callback, std::unique_ptr<::std::vector<::std::string>> p_binaries) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_contain_binary.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contain_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contain_binary(params, std::move(p_binaries));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contain_binary.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contain_binary(std::move(p_binaries));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contain_binary(std::move(p_binaries));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contain_binary(params, std::move(p_binaries));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_contain_binary(std::move(p_binaries));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::std::string> _return;
        sync_contain_binary(_return, std::move(p_binaries));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_binaries) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::std::string>> /*binaries*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::contain_enum(::std::vector<::py3::simple::AnEnum>& /*_return*/, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("contain_enum");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_contain_enum(::std::vector<::py3::simple::AnEnum>& _return, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  return contain_enum(_return, std::move(p_the_enum));
}

folly::SemiFuture<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_contain_enum(std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::py3::simple::AnEnum>>();
  sync_contain_enum(*ret, std::move(p_the_enum));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_contain_enum(std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_contain_enum(std::move(p_the_enum)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contain_enum(std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/>(std::move(p_the_enum)));
}

folly::coro::Task<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_contain_enum(apache::thrift::RequestParams /* params */, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_contain_enum.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_contain_enum(std::move(p_the_enum));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_contain_enum(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::py3::simple::AnEnum>>>> callback, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> p_the_enum) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_contain_enum.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contain_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contain_enum(params, std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_contain_enum.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_contain_enum(std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_contain_enum(std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_contain_enum(params, std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_contain_enum(std::move(p_the_enum));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::py3::simple::AnEnum> _return;
        sync_contain_enum(_return, std::move(p_the_enum));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_the_enum) = std::move(ex).restoreArgs<std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_binary_union_struct(::py3::simple::BinaryUnionStruct& /*_return*/, std::unique_ptr<::py3::simple::BinaryUnion> /*u*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_binary_union_struct");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_binary_union_struct(::py3::simple::BinaryUnionStruct& _return, std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  return get_binary_union_struct(_return, std::move(p_u));
}

folly::SemiFuture<std::unique_ptr<::py3::simple::BinaryUnionStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_binary_union_struct(std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::py3::simple::BinaryUnionStruct>();
  sync_get_binary_union_struct(*ret, std::move(p_u));
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::py3::simple::BinaryUnionStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_binary_union_struct(std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_binary_union_struct(std::move(p_u)), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::py3::simple::BinaryUnionStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_binary_union_struct(std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<std::unique_ptr<::py3::simple::BinaryUnion> /*u*/>(std::move(p_u)));
}

folly::coro::Task<std::unique_ptr<::py3::simple::BinaryUnionStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_binary_union_struct(apache::thrift::RequestParams /* params */, std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_binary_union_struct(std::move(p_u));
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_binary_union_struct(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::BinaryUnionStruct>>> callback, std::unique_ptr<::py3::simple::BinaryUnion> p_u) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_binary_union_struct.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_binary_union_struct(params, std::move(p_u));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_binary_union_struct.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_binary_union_struct(std::move(p_u));
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_binary_union_struct(std::move(p_u));
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_binary_union_struct(params, std::move(p_u));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_binary_union_struct(std::move(p_u));
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::py3::simple::BinaryUnionStruct _return;
        sync_get_binary_union_struct(_return, std::move(p_u));
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_u) = std::move(ex).restoreArgs<std::unique_ptr<::py3::simple::BinaryUnion> /*u*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::get_struct_hidden(::py3::simple::SimpleStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("get_struct_hidden");
}

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::sync_get_struct_hidden(::py3::simple::SimpleStruct& _return) {
  return get_struct_hidden(_return);
}

folly::SemiFuture<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::semifuture_get_struct_hidden() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::py3::simple::SimpleStruct>();
  sync_get_struct_hidden(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::future_get_struct_hidden() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_get_struct_hidden(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_struct_hidden() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::py3::simple::SimpleStruct>> apache::thrift::ServiceHandler<::py3::simple::SimpleService>::co_get_struct_hidden(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_get_struct_hidden();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::py3::simple::SimpleService>::async_tm_get_struct_hidden(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::py3::simple::SimpleStruct>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_get_struct_hidden.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_struct_hidden(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_get_struct_hidden.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_get_struct_hidden();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_get_struct_hidden();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_get_struct_hidden(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_get_struct_hidden();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::py3::simple::SimpleStruct _return;
        sync_get_struct_hidden(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}


namespace py3 { namespace simple {

::std::int32_t SimpleServiceSvNull::get_five() {
  return 0;
}

::std::int32_t SimpleServiceSvNull::add_five(::std::int32_t /*num*/) {
  return 0;
}

void SimpleServiceSvNull::do_nothing() {
  return;
}

void SimpleServiceSvNull::concat(::std::string& /*_return*/, std::unique_ptr<::std::string> /*first*/, std::unique_ptr<::std::string> /*second*/) {}

::std::int32_t SimpleServiceSvNull::get_value(std::unique_ptr<::py3::simple::SimpleStruct> /*simple_struct*/) {
  return 0;
}

bool SimpleServiceSvNull::negate(bool /*input*/) {
  return 0;
}

::std::int8_t SimpleServiceSvNull::tiny(::std::int8_t /*input*/) {
  return 0;
}

::std::int16_t SimpleServiceSvNull::small(::std::int16_t /*input*/) {
  return 0;
}

::std::int64_t SimpleServiceSvNull::big(::std::int64_t /*input*/) {
  return 0;
}

double SimpleServiceSvNull::two(double /*input*/) {
  return 0;
}

void SimpleServiceSvNull::expected_exception() {
  return;
}

::std::int32_t SimpleServiceSvNull::unexpected_exception() {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i16_list(std::unique_ptr<::std::vector<::std::int16_t>> /*numbers*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i32_list(std::unique_ptr<::std::vector<::std::int32_t>> /*numbers*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_i64_list(std::unique_ptr<::std::vector<::std::int64_t>> /*numbers*/) {
  return 0;
}

void SimpleServiceSvNull::concat_many(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

::std::int32_t SimpleServiceSvNull::count_structs(std::unique_ptr<::std::vector<::py3::simple::SimpleStruct>> /*items*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::sum_set(std::unique_ptr<::std::set<::std::int32_t>> /*numbers*/) {
  return 0;
}

bool SimpleServiceSvNull::contains_word(std::unique_ptr<::std::set<::std::string>> /*words*/, std::unique_ptr<::std::string> /*word*/) {
  return 0;
}

void SimpleServiceSvNull::get_map_value(::std::string& /*_return*/, std::unique_ptr<::std::map<::std::string, ::std::string>> /*words*/, std::unique_ptr<::std::string> /*key*/) {}

::std::int16_t SimpleServiceSvNull::map_length(std::unique_ptr<::std::map<::std::string, ::py3::simple::SimpleStruct>> /*items*/) {
  return 0;
}

::std::int16_t SimpleServiceSvNull::sum_map_values(std::unique_ptr<::std::map<::std::string, ::std::int16_t>> /*items*/) {
  return 0;
}

::std::int32_t SimpleServiceSvNull::complex_sum_i32(std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {
  return 0;
}

void SimpleServiceSvNull::repeat_name(::std::string& /*_return*/, std::unique_ptr<::py3::simple::ComplexStruct> /*counter*/) {}

void SimpleServiceSvNull::get_struct(::py3::simple::SimpleStruct& /*_return*/) {}

void SimpleServiceSvNull::fib(::std::vector<::std::int32_t>& /*_return*/, ::std::int16_t /*n*/) {}

void SimpleServiceSvNull::unique_words(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

void SimpleServiceSvNull::words_count(::std::map<::std::string, ::std::int16_t>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*words*/) {}

::py3::simple::AnEnum SimpleServiceSvNull::set_enum(::py3::simple::AnEnum /*in_enum*/) {
  return (::py3::simple::AnEnum)0;
}

void SimpleServiceSvNull::list_of_lists(::std::vector<::std::vector<::std::int32_t>>& /*_return*/, ::std::int16_t /*num_lists*/, ::std::int16_t /*num_items*/) {}

void SimpleServiceSvNull::word_character_frequency(::std::map<::std::string, ::std::map<::std::string, ::std::int32_t>>& /*_return*/, std::unique_ptr<::std::string> /*sentence*/) {}

void SimpleServiceSvNull::list_of_sets(::std::vector<::std::set<::std::string>>& /*_return*/, std::unique_ptr<::std::string> /*some_words*/) {}

::std::int32_t SimpleServiceSvNull::nested_map_argument(std::unique_ptr<::std::map<::std::string, ::std::vector<::py3::simple::SimpleStruct>>> /*struct_map*/) {
  return 0;
}

void SimpleServiceSvNull::make_sentence(::std::string& /*_return*/, std::unique_ptr<::std::vector<::std::vector<::std::string>>> /*word_chars*/) {}

void SimpleServiceSvNull::get_union(::std::set<::std::int32_t>& /*_return*/, std::unique_ptr<::std::vector<::std::set<::std::int32_t>>> /*sets*/) {}

void SimpleServiceSvNull::get_keys(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::map<::std::string, ::std::string>>> /*string_map*/) {}

double SimpleServiceSvNull::lookup_double(::std::int32_t /*key*/) {
  return 0;
}

void SimpleServiceSvNull::retrieve_binary(::std::string& /*_return*/, std::unique_ptr<::std::string> /*something*/) {}

void SimpleServiceSvNull::contain_binary(::std::set<::std::string>& /*_return*/, std::unique_ptr<::std::vector<::std::string>> /*binaries*/) {}

void SimpleServiceSvNull::contain_enum(::std::vector<::py3::simple::AnEnum>& /*_return*/, std::unique_ptr<::std::vector<::py3::simple::AnEnum>> /*the_enum*/) {}

void SimpleServiceSvNull::get_binary_union_struct(::py3::simple::BinaryUnionStruct& /*_return*/, std::unique_ptr<::py3::simple::BinaryUnion> /*u*/) {}

void SimpleServiceSvNull::get_struct_hidden(::py3::simple::SimpleStruct& /*_return*/) {}


const char* SimpleServiceAsyncProcessor::getServiceName() {
  return "SimpleService";
}

void SimpleServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::py3::simple::SimpleService>>::gen(response);
}

void SimpleServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void SimpleServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const SimpleServiceAsyncProcessor::ProcessMap& SimpleServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const SimpleServiceAsyncProcessor::ProcessMap SimpleServiceAsyncProcessor::kOwnProcessMap_ {
  {"get_five",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"add_five",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_add_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_add_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_add_five<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_add_five<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"do_nothing",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_do_nothing<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_do_nothing<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_do_nothing<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_do_nothing<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"concat",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_concat<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_concat<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_concat<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_concat<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_value",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"negate",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_negate<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_negate<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_negate<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_negate<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"tiny",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_tiny<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_tiny<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_tiny<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_tiny<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"small",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_small<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_small<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_small<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_small<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"big",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_big<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_big<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_big<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_big<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"two",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_two<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_two<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_two<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_two<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"expected_exception",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_expected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_expected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_expected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_expected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"unexpected_exception",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_unexpected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_unexpected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_unexpected_exception<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_unexpected_exception<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i16_list",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i16_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i16_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i16_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i16_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i32_list",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i32_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i32_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i32_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i32_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_i64_list",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_i64_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_sum_i64_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i64_list<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_i64_list<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"concat_many",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_concat_many<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_concat_many<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_concat_many<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_concat_many<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"count_structs",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_count_structs<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_count_structs<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_count_structs<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_count_structs<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_set",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_set<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_sum_set<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_set<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_set<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contains_word",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_contains_word<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_contains_word<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contains_word<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contains_word<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_map_value",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_map_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_map_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_map_value<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_map_value<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"map_length",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_map_length<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_map_length<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_map_length<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_map_length<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"sum_map_values",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_sum_map_values<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_sum_map_values<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_map_values<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_sum_map_values<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"complex_sum_i32",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_complex_sum_i32<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_complex_sum_i32<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_complex_sum_i32<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_complex_sum_i32<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"repeat_name",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_repeat_name<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_repeat_name<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_repeat_name<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_repeat_name<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_struct",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"fib",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_fib<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_fib<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_fib<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_fib<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"unique_words",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_unique_words<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_unique_words<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_unique_words<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_unique_words<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"words_count",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_words_count<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_words_count<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_words_count<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_words_count<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"set_enum",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_set_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_set_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_set_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_set_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_of_lists",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_list_of_lists<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_list_of_lists<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_list_of_lists<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_list_of_lists<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"word_character_frequency",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_word_character_frequency<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_word_character_frequency<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_word_character_frequency<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_word_character_frequency<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_of_sets",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_list_of_sets<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_list_of_sets<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_list_of_sets<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_list_of_sets<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"nested_map_argument",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_nested_map_argument<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_nested_map_argument<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_nested_map_argument<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_nested_map_argument<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"make_sentence",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_make_sentence<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_make_sentence<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_make_sentence<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_make_sentence<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_union",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_union<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_union<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_union<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_union<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_keys",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_keys<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_keys<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_keys<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_keys<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"lookup_double",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_lookup_double<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_lookup_double<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_lookup_double<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_lookup_double<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"retrieve_binary",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_retrieve_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_retrieve_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_retrieve_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_retrieve_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contain_binary",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_contain_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_contain_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contain_binary<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contain_binary<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"contain_enum",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_contain_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_contain_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contain_enum<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_contain_enum<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_binary_union_struct",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_binary_union_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_binary_union_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_binary_union_struct<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_binary_union_struct<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"get_struct_hidden",
    {&SimpleServiceAsyncProcessor::setUpAndProcess_get_struct_hidden<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::setUpAndProcess_get_struct_hidden<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_struct_hidden<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &SimpleServiceAsyncProcessor::executeRequest_get_struct_hidden<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& SimpleServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap SimpleServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"get_five",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_five",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"add_five",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.add_five",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"do_nothing",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.do_nothing",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"concat",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.concat",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_value",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_value",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"negate",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.negate",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"tiny",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.tiny",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"small",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.small",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"big",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.big",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"two",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.two",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"expected_exception",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.expected_exception",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"unexpected_exception",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.unexpected_exception",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"sum_i16_list",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.sum_i16_list",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"sum_i32_list",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.sum_i32_list",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"sum_i64_list",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.sum_i64_list",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"concat_many",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.concat_many",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"count_structs",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.count_structs",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"sum_set",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.sum_set",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"contains_word",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.contains_word",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_map_value",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_map_value",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"map_length",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.map_length",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"sum_map_values",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.sum_map_values",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"complex_sum_i32",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.complex_sum_i32",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"repeat_name",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.repeat_name",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_struct",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_struct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"fib",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.fib",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"unique_words",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.unique_words",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"words_count",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.words_count",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"set_enum",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.set_enum",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"list_of_lists",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.list_of_lists",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"word_character_frequency",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.word_character_frequency",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"list_of_sets",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.list_of_sets",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"nested_map_argument",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.nested_map_argument",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"make_sentence",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.make_sentence",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_union",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_union",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_keys",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_keys",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"lookup_double",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.lookup_double",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"retrieve_binary",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.retrieve_binary",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"contain_binary",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.contain_binary",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"contain_enum",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.contain_enum",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_binary_union_struct",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_binary_union_struct",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"get_struct_hidden",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "SimpleService.get_struct_hidden",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  };

  return requestInfoMap;
}
}} // py3::simple
