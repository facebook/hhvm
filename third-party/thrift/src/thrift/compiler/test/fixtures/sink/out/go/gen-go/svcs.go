// Autogenerated by Thrift for thrift/compiler/test/fixtures/sink/src/module.thrift
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//  @generated

package module

import (
    "context"
    "errors"
    "fmt"
    "io"
    "iter"
    "reflect"
    "sync"

    thrift "github.com/facebook/fbthrift/thrift/lib/go/thrift/types"
    metadata "github.com/facebook/fbthrift/thrift/lib/thrift/metadata"
)

// (needed to ensure safety because of naive import list construction)
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = io.EOF
var _ = iter.Pull[bool]
var _ = reflect.Ptr
var _ = sync.OnceFunc
var _ = thrift.VOID
var _ = metadata.GoUnusedProtection__


type SinkService interface {
}

type SinkServiceClient interface {
    io.Closer
    Method(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodAndReponse(ctx context.Context) (*InitialResponse, func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodSinkThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFinalThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodBothThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
    MethodFast(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error)
}

type sinkServiceClientImpl struct {
    ch thrift.RequestChannel
}
// Compile time interface enforcer
var _ SinkServiceClient = (*sinkServiceClientImpl)(nil)

func NewSinkServiceChannelClient(channel thrift.RequestChannel) SinkServiceClient {
    return &sinkServiceClientImpl{
        ch: channel,
    }
}

func init() {
    thrift.InternalRegisterClientConstructor[SinkServiceClient](NewSinkServiceChannelClient)
}

func (c *sinkServiceClientImpl) Close() error {
    return c.ch.Close()
}

func (c *sinkServiceClientImpl) Method(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodAndReponse(ctx context.Context) (*InitialResponse, func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodSinkThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodFinalThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodBothThrow(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}

func (c *sinkServiceClientImpl) MethodFast(ctx context.Context) (func(iter.Seq2[*SinkPayload, error]) (*FinalResponse, error), error) {
    panic("sink not implemented")
}


type SinkServiceProcessor struct {
    processorFunctionMap map[string]thrift.ProcessorFunction
    functionServiceMap   map[string]string
    handler              SinkService
}

func NewSinkServiceProcessor(handler SinkService) *SinkServiceProcessor {
    p := &SinkServiceProcessor{
        handler:              handler,
        processorFunctionMap: make(map[string]thrift.ProcessorFunction),
        functionServiceMap:   make(map[string]string),
    }

    return p
}

func (p *SinkServiceProcessor) AddToProcessorFunctionMap(key string, processorFunction thrift.ProcessorFunction) {
    p.processorFunctionMap[key] = processorFunction
}

func (p *SinkServiceProcessor) AddToFunctionServiceMap(key, service string) {
    p.functionServiceMap[key] = service
}

func (p *SinkServiceProcessor) GetProcessorFunction(key string) (processor thrift.ProcessorFunction) {
    return p.processorFunctionMap[key]
}

func (p *SinkServiceProcessor) ProcessorFunctionMap() map[string]thrift.ProcessorFunction {
    return p.processorFunctionMap
}

func (p *SinkServiceProcessor) FunctionServiceMap() map[string]string {
    return p.functionServiceMap
}

func (p *SinkServiceProcessor) PackageName() string {
    return "module"
}

func (p *SinkServiceProcessor) GetInteractionProcessors() []thrift.Processor {
    return []thrift.Processor{}
}

func (p *SinkServiceProcessor) GetThriftMetadata() *metadata.ThriftMetadata {
    return GetThriftMetadataForService("module.SinkService")
}


