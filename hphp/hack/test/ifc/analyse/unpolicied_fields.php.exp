Analyzing __construct:
* pc: pc
* This: \C<\C, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: { $cd -> \D<\D, lump'2>; $cx -> <$cx>; $cy -> <$cy> }
* Final environment:
  Deps: {}
  Locals:
    lvars: { $cd -> \D<\D, lump'2>; $cx -> <$cx>; $cy -> <$cy> }
Constraints:
  [\C = PUBLIC, $cx = PUBLIC, pc = PUBLIC, \C < lump'1, $cy < lump'1,
   pc < lump'1, \C < lump'1, lump'2 = lump'1, \D < lump'1, pc < lump'1]

Analyzing testGetUnpolicied:
* pc: pc
* This: \C<\C, lump'1>
* Return: \D<\D, lump'2>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: {}
* Final environment:
  Deps: {}
  Locals:
    lvars: {}
Constraints:
  [lump'1 < .cd, \C < .cd, lump'1 = lump'2, .cd < \D]

Analyzing testSetMultipleUnpolicied:
* pc: pc
* This: \C<\C, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: { $d -> \D<\D, lump'2> }
* Final environment:
  Deps: {}
  Locals:
    lvars: { $d -> \D<\D, lump'2> }
Constraints:
  [\C < lump'1, PUBLIC < lump'1, pc < lump'1, \C < lump'1, lump'2 = lump'1,
   \D < lump'1, pc < lump'1]

Analyzing testSetDeep:
* pc: pc
* This: \C<\C, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: { $i -> <$i> }
* Final environment:
  Deps: {}
  Locals:
    lvars: { $i -> <$i> }
Constraints:
  [lump'1 < .cd, \C < .cd, .cd < lump'1, $i < lump'1, pc < lump'1]

Analyzing __construct:
* pc: pc
* This: \D<\D, lump'1>
* Return: <ret>
* Exception: \Exception<\Exception, lump>
* Params:
  lvars: { $di -> <$di> }
* Final environment:
  Deps: {}
  Locals:
    lvars: { $di -> <$di> }
Constraints:
  [\D < lump'1, $di < lump'1, pc < lump'1]

