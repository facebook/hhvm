#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
cimport cython as __cython
from cpython.object cimport PyTypeObject, Py_LT, Py_LE, Py_EQ, Py_NE, Py_GT, Py_GE
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from cython.operator cimport dereference as deref, preincrement as inc, address as ptr_address
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.std_libcpp cimport sv_to_str as __sv_to_str, string_view as __cstring_view
from thrift.py3.types cimport (
    cSetOp as __cSetOp,
    richcmp as __richcmp,
    set_op as __set_op,
    setcmp as __setcmp,
    list_index as __list_index,
    list_count as __list_count,
    list_slice as __list_slice,
    list_getitem as __list_getitem,
    set_iter as __set_iter,
    map_iter as __map_iter,
    map_contains as __map_contains,
    map_getitem as __map_getitem,
    reference_shared_ptr as __reference_shared_ptr,
    get_field_name_by_index as __get_field_name_by_index,
    reset_field as __reset_field,
    translate_cpp_enum_to_python,
    SetMetaClass as __SetMetaClass,
    const_pointer_cast,
    constant_shared_ptr,
    NOTSET as __NOTSET,
    EnumData as __EnumData,
    EnumFlagsData as __EnumFlagsData,
    UnionTypeEnumData as __UnionTypeEnumData,
    createEnumDataForUnionType as __createEnumDataForUnionType,
)
cimport thrift.py3.std_libcpp as std_libcpp
cimport thrift.py3.serializer as serializer
import folly.iobuf as _fbthrift_iobuf
from folly.optional cimport cOptional
from folly.memory cimport to_shared_ptr as __to_shared_ptr
from folly.range cimport Range as __cRange

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
import weakref as __weakref
import builtins as _builtins
cimport facebook.thrift.annotation.cpp.types as _facebook_thrift_annotation_cpp_types
import facebook.thrift.annotation.cpp.types as _facebook_thrift_annotation_cpp_types

cimport module.types_reflection as _types_reflection


cdef __EnumData __MyEnum_enum_data  = __EnumData._fbthrift_create(thrift.py3.types.createEnumData[cMyEnum](), MyEnum)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyEnumMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __MyEnum_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __MyEnum_enum_data.get_all_names()

    def __len__(cls):
        return __MyEnum_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __MyEnum_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class MyEnum(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyEnum_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cMyEnum].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyEnum"

    def _to_python(self):
        import importlib
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return python_types.MyEnum(self.value)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self.value


__SetMetaClass(<PyTypeObject*> MyEnum, <PyTypeObject*> __MyEnumMeta)


cdef __EnumData __TypedEnum_enum_data  = __EnumData._fbthrift_create(thrift.py3.types.createEnumData[cTypedEnum](), TypedEnum)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __TypedEnumMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __TypedEnum_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __TypedEnum_enum_data.get_all_names()

    def __len__(cls):
        return __TypedEnum_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __TypedEnum_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class TypedEnum(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __TypedEnum_enum_data.get_by_name(name)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        EnumMetadata[cTypedEnum].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.TypedEnum"

    def _to_python(self):
        import importlib
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return python_types.TypedEnum(self.value)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self.value


__SetMetaClass(<PyTypeObject*> TypedEnum, <PyTypeObject*> __TypedEnumMeta)



cdef __UnionTypeEnumData __MyUnion_union_type_enum_data  = __UnionTypeEnumData._fbthrift_create(
    __createEnumDataForUnionType[cMyUnion](),
    __MyUnionType,
)


@__cython.internal
@__cython.auto_pickle(False)
cdef class __MyUnion_Union_TypeMeta(thrift.py3.types.EnumMeta):
    def _fbthrift_get_by_value(cls, int value):
        return __MyUnion_union_type_enum_data.get_by_value(value)

    def _fbthrift_get_all_names(cls):
        return __MyUnion_union_type_enum_data.get_all_names()

    def __len__(cls):
        return __MyUnion_union_type_enum_data.size()

    def __getattribute__(cls, str name not None):
        if name.startswith("__") or name.startswith("_fbthrift_") or name == "mro":
            return super().__getattribute__(name)
        return __MyUnion_union_type_enum_data.get_by_name(name)


@__cython.final
@__cython.auto_pickle(False)
cdef class __MyUnionType(thrift.py3.types.CompiledEnum):
    cdef get_by_name(self, str name):
        return __MyUnion_union_type_enum_data.get_by_name(name)


__SetMetaClass(<PyTypeObject*> __MyUnionType, <PyTypeObject*> __MyUnion_Union_TypeMeta)




@__cython.auto_pickle(False)
cdef class MyUnion(thrift.py3.types.Union):
    Type = __MyUnionType

    def __init__(
        self, *,
        anInteger=None,
        str aString=None
    ):
        if anInteger is not None:
            if not isinstance(anInteger, int):
                raise TypeError(f'anInteger is not a { int !r}.')
            anInteger = <cint32_t> anInteger

        self._cpp_obj = __to_shared_ptr(cmove(MyUnion._make_instance(
          NULL,
          anInteger,
          aString,
        )))
        self._load_cache()

    @staticmethod
    def fromValue(value):
        if value is None:
            return MyUnion()
        if isinstance(value, int):
            if not isinstance(value, pbool):
                try:
                    <cint32_t> value
                    return MyUnion(anInteger=value)
                except OverflowError:
                    pass
        if isinstance(value, str):
            return MyUnion(aString=value)
        raise ValueError(f"Unable to derive correct union field for value: {value}")

    @staticmethod
    cdef unique_ptr[cMyUnion] _make_instance(
        cMyUnion* base_instance,
        object anInteger,
        str aString
    ) except *:
        cdef unique_ptr[cMyUnion] c_inst = make_unique[cMyUnion]()
        cdef bint any_set = False
        if anInteger is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_anInteger(cint32_t(deref((<cint32_t?>anInteger)._cpp_obj)))
            any_set = True
        if aString is not None:
            if any_set:
                raise TypeError("At most one field may be set when initializing a union")
            deref(c_inst).set_aString(string(deref((<str?>aString)._cpp_obj)))
            any_set = True
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return cmove(c_inst)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cMyUnion] cpp_obj):
        __fbthrift_inst = <MyUnion>MyUnion.__new__(MyUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        __fbthrift_inst._load_cache()
        return __fbthrift_inst

    @property
    def anInteger(self):
        if self.type.value != 1:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not anInteger')
        return self.value

    @property
    def aString(self):
        if self.type.value != 2:
            raise AttributeError(f'Union contains a value of type {self.type.name}, not aString')
        return self.value


    def __hash__(MyUnion self):
        return  super().__hash__()

    cdef _load_cache(MyUnion self):
        self.type = MyUnion.Type(<int>(deref(self._cpp_obj).getType()))
        cdef int type = self.type.value
        if type == 0:    # Empty
            self.value = None
        elif type == 1:
            if not deref(self._cpp_obj).get_anInteger():
                self.value = None
            else:
                self.value = cint32_t._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).get_anInteger()), self._cpp_obj))
        elif type == 2:
            if not deref(self._cpp_obj).get_aString():
                self.value = None
            else:
                self.value = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).get_aString()), self._cpp_obj))

    def __copy__(MyUnion self):
        cdef shared_ptr[cMyUnion] cpp_obj = make_shared[cMyUnion](
            deref(self._cpp_obj)
        )
        return MyUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyUnion](
            self._cpp_obj,
            (<MyUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cMyUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(MyUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(MyUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyUnion]()
        with nogil:
            needed = serializer.cdeserialize[cMyUnion](buf, self._cpp_obj.get(), proto)
        # force a cache reload since the underlying data's changed
        self._load_cache()
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.MyUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyUnion, self)
@__cython.auto_pickle(False)
cdef class MyField(thrift.py3.types.Struct):
    def __init__(MyField self, **kwargs):
        self._cpp_obj = make_shared[cMyField]()
        self._fields_setter = _fbthrift_types_fields.__MyField_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(MyField self, **kwargs):
        if not kwargs:
            return self
        cdef MyField __fbthrift_inst = MyField.__new__(MyField)
        __fbthrift_inst._cpp_obj = make_shared[cMyField](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__MyField_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("MyField", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cMyField] cpp_obj):
        __fbthrift_inst = <MyField>MyField.__new__(MyField)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline opt_value_impl(self):

        if self.__fbthrift_cached_opt_value is None:
            if not deref(self._cpp_obj).opt_value_ref():
                return None
            self.__fbthrift_cached_opt_value = cint64_t._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_value

    @property
    def opt_value(self):
        return self.opt_value_impl()

    cdef inline value_impl(self):

        if self.__fbthrift_cached_value is None:
            if not deref(self._cpp_obj).value_ref():
                return None
            self.__fbthrift_cached_value = cint64_t._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_value

    @property
    def value(self):
        return self.value_impl()

    cdef inline req_value_impl(self):

        if self.__fbthrift_cached_req_value is None:
            if not deref(self._cpp_obj).req_value_ref():
                return None
            self.__fbthrift_cached_req_value = cint64_t._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_value

    @property
    def req_value(self):
        return self.req_value_impl()

    cdef inline opt_enum_value_impl(self):

        if self.__fbthrift_cached_opt_enum_value is None:
            if not deref(self._cpp_obj).opt_enum_value_ref():
                return None
            self.__fbthrift_cached_opt_enum_value = MyEnum._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_enum_value

    @property
    def opt_enum_value(self):
        return self.opt_enum_value_impl()

    cdef inline enum_value_impl(self):

        if self.__fbthrift_cached_enum_value is None:
            if not deref(self._cpp_obj).enum_value_ref():
                return None
            self.__fbthrift_cached_enum_value = MyEnum._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_enum_value

    @property
    def enum_value(self):
        return self.enum_value_impl()

    cdef inline req_enum_value_impl(self):

        if self.__fbthrift_cached_req_enum_value is None:
            if not deref(self._cpp_obj).req_enum_value_ref():
                return None
            self.__fbthrift_cached_req_enum_value = MyEnum._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_enum_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_enum_value

    @property
    def req_enum_value(self):
        return self.req_enum_value_impl()

    cdef inline opt_str_value_impl(self):

        if self.__fbthrift_cached_opt_str_value is None:
            if not deref(self._cpp_obj).opt_str_value_ref():
                return None
            self.__fbthrift_cached_opt_str_value = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_str_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_str_value

    @property
    def opt_str_value(self):
        return self.opt_str_value_impl()

    cdef inline str_value_impl(self):

        if self.__fbthrift_cached_str_value is None:
            if not deref(self._cpp_obj).str_value_ref():
                return None
            self.__fbthrift_cached_str_value = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).str_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_str_value

    @property
    def str_value(self):
        return self.str_value_impl()

    cdef inline req_str_value_impl(self):

        if self.__fbthrift_cached_req_str_value is None:
            if not deref(self._cpp_obj).req_str_value_ref():
                return None
            self.__fbthrift_cached_req_str_value = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_str_value_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_str_value

    @property
    def req_str_value(self):
        return self.req_str_value_impl()


    def __hash__(MyField self):
        return super().__hash__()

    def __repr__(MyField self):
        return super().__repr__()

    def __str__(MyField self):
        return super().__str__()


    def __copy__(MyField self):
        cdef shared_ptr[cMyField] cpp_obj = make_shared[cMyField](
            deref(self._cpp_obj)
        )
        return MyField._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyField](
            self._cpp_obj,
            (<MyField>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyField()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyField].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyField"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cMyField](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 9

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(MyField self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyField](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(MyField self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyField]()
        with nogil:
            needed = serializer.cdeserialize[cMyField](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.MyField, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyField, self)
@__cython.auto_pickle(False)
cdef class MyStruct(thrift.py3.types.Struct):
    def __init__(MyStruct self, **kwargs):
        self._cpp_obj = make_shared[cMyStruct]()
        self._fields_setter = _fbthrift_types_fields.__MyStruct_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(MyStruct self, **kwargs):
        if not kwargs:
            return self
        cdef MyStruct __fbthrift_inst = MyStruct.__new__(MyStruct)
        __fbthrift_inst._cpp_obj = make_shared[cMyStruct](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__MyStruct_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("MyStruct", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cMyStruct] cpp_obj):
        __fbthrift_inst = <MyStruct>MyStruct.__new__(MyStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline opt_ref_impl(self):

        if self.__fbthrift_cached_opt_ref is None:
            if not deref(self._cpp_obj).opt_ref_ref():
                return None
            self.__fbthrift_cached_opt_ref = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_ref

    @property
    def opt_ref(self):
        return self.opt_ref_impl()

    cdef inline ref_impl(self):

        if self.__fbthrift_cached_ref is None:
            if not deref(self._cpp_obj).ref_ref():
                return None
            self.__fbthrift_cached_ref = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_ref

    @property
    def ref(self):
        return self.ref_impl()

    cdef inline req_ref_impl(self):

        if self.__fbthrift_cached_req_ref is None:
            if not deref(self._cpp_obj).req_ref_ref():
                return None
            self.__fbthrift_cached_req_ref = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_ref

    @property
    def req_ref(self):
        return self.req_ref_impl()


    def __hash__(MyStruct self):
        return super().__hash__()

    def __repr__(MyStruct self):
        return super().__repr__()

    def __str__(MyStruct self):
        return super().__str__()


    def __copy__(MyStruct self):
        cdef shared_ptr[cMyStruct] cpp_obj = make_shared[cMyStruct](
            deref(self._cpp_obj)
        )
        return MyStruct._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cMyStruct](
            self._cpp_obj,
            (<MyStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__MyStruct()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cMyStruct].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.MyStruct"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cMyStruct](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(MyStruct self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cMyStruct](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(MyStruct self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cMyStruct]()
        with nogil:
            needed = serializer.cdeserialize[cMyStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.MyStruct, self)
@__cython.auto_pickle(False)
cdef class StructWithUnion(thrift.py3.types.Struct):
    def __init__(StructWithUnion self, **kwargs):
        self._cpp_obj = make_shared[cStructWithUnion]()
        self._fields_setter = _fbthrift_types_fields.__StructWithUnion_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithUnion self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithUnion __fbthrift_inst = StructWithUnion.__new__(StructWithUnion)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithUnion](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithUnion_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithUnion", {
          "f": deref(self._cpp_obj).f_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithUnion] cpp_obj):
        __fbthrift_inst = <StructWithUnion>StructWithUnion.__new__(StructWithUnion)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline u_impl(self):

        if self.__fbthrift_cached_u is None:
            if not deref(self._cpp_obj).u_ref():
                return None
            self.__fbthrift_cached_u = MyUnion._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).u_ref()), self._cpp_obj))
        return self.__fbthrift_cached_u

    @property
    def u(self):
        return self.u_impl()

    cdef inline aDouble_impl(self):

        if self.__fbthrift_cached_aDouble is None:
            if not deref(self._cpp_obj).aDouble_ref():
                return None
            self.__fbthrift_cached_aDouble = double._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).aDouble_ref()), self._cpp_obj))
        return self.__fbthrift_cached_aDouble

    @property
    def aDouble(self):
        return self.aDouble_impl()

    cdef inline f_impl(self):

        if self.__fbthrift_cached_f is None:
            self.__fbthrift_cached_f = MyField._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).f_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_f

    @property
    def f(self):
        return self.f_impl()


    def __hash__(StructWithUnion self):
        return super().__hash__()

    def __repr__(StructWithUnion self):
        return super().__repr__()

    def __str__(StructWithUnion self):
        return super().__str__()


    def __copy__(StructWithUnion self):
        cdef shared_ptr[cStructWithUnion] cpp_obj = make_shared[cStructWithUnion](
            deref(self._cpp_obj)
        )
        return StructWithUnion._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithUnion](
            self._cpp_obj,
            (<StructWithUnion>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithUnion()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithUnion].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithUnion"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithUnion](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithUnion self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithUnion](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithUnion self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithUnion]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithUnion](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithUnion, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithUnion, self)
@__cython.auto_pickle(False)
cdef class RecursiveStruct(thrift.py3.types.Struct):
    def __init__(RecursiveStruct self, **kwargs):
        self._cpp_obj = make_shared[cRecursiveStruct]()
        self._fields_setter = _fbthrift_types_fields.__RecursiveStruct_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(RecursiveStruct self, **kwargs):
        if not kwargs:
            return self
        cdef RecursiveStruct __fbthrift_inst = RecursiveStruct.__new__(RecursiveStruct)
        __fbthrift_inst._cpp_obj = make_shared[cRecursiveStruct](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__RecursiveStruct_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("RecursiveStruct", {
          "mes": deref(self._cpp_obj).mes_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cRecursiveStruct] cpp_obj):
        __fbthrift_inst = <RecursiveStruct>RecursiveStruct.__new__(RecursiveStruct)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline mes_impl(self):
        if not deref(self._cpp_obj).mes_ref().has_value():
            return None

        if self.__fbthrift_cached_mes is None:
            self.__fbthrift_cached_mes = List__RecursiveStruct._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).mes_ref().ref_unchecked(), self._cpp_obj))
        return self.__fbthrift_cached_mes

    @property
    def mes(self):
        return self.mes_impl()


    def __hash__(RecursiveStruct self):
        return super().__hash__()

    def __repr__(RecursiveStruct self):
        return super().__repr__()

    def __str__(RecursiveStruct self):
        return super().__str__()


    def __copy__(RecursiveStruct self):
        cdef shared_ptr[cRecursiveStruct] cpp_obj = make_shared[cRecursiveStruct](
            deref(self._cpp_obj)
        )
        return RecursiveStruct._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cRecursiveStruct](
            self._cpp_obj,
            (<RecursiveStruct>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__RecursiveStruct()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cRecursiveStruct].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.RecursiveStruct"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cRecursiveStruct](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 1

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(RecursiveStruct self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cRecursiveStruct](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(RecursiveStruct self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cRecursiveStruct]()
        with nogil:
            needed = serializer.cdeserialize[cRecursiveStruct](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.RecursiveStruct, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.RecursiveStruct, self)
@__cython.auto_pickle(False)
cdef class StructWithContainers(thrift.py3.types.Struct):
    def __init__(StructWithContainers self, **kwargs):
        self._cpp_obj = make_shared[cStructWithContainers]()
        self._fields_setter = _fbthrift_types_fields.__StructWithContainers_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithContainers self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithContainers __fbthrift_inst = StructWithContainers.__new__(StructWithContainers)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithContainers](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithContainers_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithContainers", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithContainers] cpp_obj):
        __fbthrift_inst = <StructWithContainers>StructWithContainers.__new__(StructWithContainers)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline list_ref_impl(self):

        if self.__fbthrift_cached_list_ref is None:
            if not deref(self._cpp_obj).list_ref_ref():
                return None
            self.__fbthrift_cached_list_ref = List__i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref

    @property
    def list_ref(self):
        return self.list_ref_impl()

    cdef inline set_ref_impl(self):

        if self.__fbthrift_cached_set_ref is None:
            if not deref(self._cpp_obj).set_ref_ref():
                return None
            self.__fbthrift_cached_set_ref = Set__i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).set_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_set_ref

    @property
    def set_ref(self):
        return self.set_ref_impl()

    cdef inline map_ref_impl(self):

        if self.__fbthrift_cached_map_ref is None:
            if not deref(self._cpp_obj).map_ref_ref():
                return None
            self.__fbthrift_cached_map_ref = Map__i32_i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).map_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_map_ref

    @property
    def map_ref(self):
        return self.map_ref_impl()

    cdef inline list_ref_unique_impl(self):

        if self.__fbthrift_cached_list_ref_unique is None:
            if not deref(self._cpp_obj).list_ref_unique_ref():
                return None
            self.__fbthrift_cached_list_ref_unique = List__i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_unique_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref_unique

    @property
    def list_ref_unique(self):
        return self.list_ref_unique_impl()

    cdef inline set_ref_shared_impl(self):

        if self.__fbthrift_cached_set_ref_shared is None:
            if not deref(self._cpp_obj).set_ref_shared_ref():
                return None
            self.__fbthrift_cached_set_ref_shared = Set__i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).set_ref_shared_ref()), self._cpp_obj))
        return self.__fbthrift_cached_set_ref_shared

    @property
    def set_ref_shared(self):
        return self.set_ref_shared_impl()

    cdef inline list_ref_shared_const_impl(self):

        if self.__fbthrift_cached_list_ref_shared_const is None:
            if not deref(self._cpp_obj).list_ref_shared_const_ref():
                return None
            self.__fbthrift_cached_list_ref_shared_const = List__i32._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).list_ref_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_list_ref_shared_const

    @property
    def list_ref_shared_const(self):
        return self.list_ref_shared_const_impl()


    def __hash__(StructWithContainers self):
        return super().__hash__()

    def __repr__(StructWithContainers self):
        return super().__repr__()

    def __str__(StructWithContainers self):
        return super().__str__()


    def __copy__(StructWithContainers self):
        cdef shared_ptr[cStructWithContainers] cpp_obj = make_shared[cStructWithContainers](
            deref(self._cpp_obj)
        )
        return StructWithContainers._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithContainers](
            self._cpp_obj,
            (<StructWithContainers>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithContainers()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithContainers].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithContainers"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithContainers](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 6

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithContainers self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithContainers](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithContainers self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithContainers]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithContainers](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithContainers, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithContainers, self)
@__cython.auto_pickle(False)
cdef class StructWithSharedConst(thrift.py3.types.Struct):
    def __init__(StructWithSharedConst self, **kwargs):
        self._cpp_obj = make_shared[cStructWithSharedConst]()
        self._fields_setter = _fbthrift_types_fields.__StructWithSharedConst_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithSharedConst self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithSharedConst __fbthrift_inst = StructWithSharedConst.__new__(StructWithSharedConst)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithSharedConst](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithSharedConst_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithSharedConst", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithSharedConst] cpp_obj):
        __fbthrift_inst = <StructWithSharedConst>StructWithSharedConst.__new__(StructWithSharedConst)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline opt_shared_const_impl(self):

        if self.__fbthrift_cached_opt_shared_const is None:
            if not deref(self._cpp_obj).opt_shared_const_ref():
                return None
            self.__fbthrift_cached_opt_shared_const = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_shared_const

    @property
    def opt_shared_const(self):
        return self.opt_shared_const_impl()

    cdef inline shared_const_impl(self):

        if self.__fbthrift_cached_shared_const is None:
            if not deref(self._cpp_obj).shared_const_ref():
                return None
            self.__fbthrift_cached_shared_const = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_shared_const

    @property
    def shared_const(self):
        return self.shared_const_impl()

    cdef inline req_shared_const_impl(self):

        if self.__fbthrift_cached_req_shared_const is None:
            if not deref(self._cpp_obj).req_shared_const_ref():
                return None
            self.__fbthrift_cached_req_shared_const = MyField._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_shared_const_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_shared_const

    @property
    def req_shared_const(self):
        return self.req_shared_const_impl()


    def __hash__(StructWithSharedConst self):
        return super().__hash__()

    def __repr__(StructWithSharedConst self):
        return super().__repr__()

    def __str__(StructWithSharedConst self):
        return super().__str__()


    def __copy__(StructWithSharedConst self):
        cdef shared_ptr[cStructWithSharedConst] cpp_obj = make_shared[cStructWithSharedConst](
            deref(self._cpp_obj)
        )
        return StructWithSharedConst._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithSharedConst](
            self._cpp_obj,
            (<StructWithSharedConst>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithSharedConst()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithSharedConst].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithSharedConst"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithSharedConst](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithSharedConst self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithSharedConst](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithSharedConst self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithSharedConst]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithSharedConst](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithSharedConst, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithSharedConst, self)
@__cython.auto_pickle(False)
cdef class Empty(thrift.py3.types.Struct):
    def __init__(Empty self, **kwargs):
        self._cpp_obj = make_shared[cEmpty]()
        self._fields_setter = _fbthrift_types_fields.__Empty_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(Empty self, **kwargs):
        return self

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("Empty", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cEmpty] cpp_obj):
        __fbthrift_inst = <Empty>Empty.__new__(Empty)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst


    def __hash__(Empty self):
        return super().__hash__()

    def __repr__(Empty self):
        return super().__repr__()

    def __str__(Empty self):
        return super().__str__()


    def __copy__(Empty self):
        cdef shared_ptr[cEmpty] cpp_obj = make_shared[cEmpty](
            deref(self._cpp_obj)
        )
        return Empty._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cEmpty](
            self._cpp_obj,
            (<Empty>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Empty()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cEmpty].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.Empty"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cEmpty](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 0

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(Empty self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cEmpty](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(Empty self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cEmpty]()
        with nogil:
            needed = serializer.cdeserialize[cEmpty](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.Empty, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.Empty, self)
@__cython.auto_pickle(False)
cdef class StructWithRef(thrift.py3.types.Struct):
    def __init__(StructWithRef self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRef]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRef_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRef self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRef __fbthrift_inst = StructWithRef.__new__(StructWithRef)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRef](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRef_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRef", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithRef] cpp_obj):
        __fbthrift_inst = <StructWithRef>StructWithRef.__new__(StructWithRef)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_field_impl(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def def_field(self):
        return self.def_field_impl()

    cdef inline opt_field_impl(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def opt_field(self):
        return self.opt_field_impl()

    cdef inline req_field_impl(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field

    @property
    def req_field(self):
        return self.req_field_impl()


    def __hash__(StructWithRef self):
        return super().__hash__()

    def __repr__(StructWithRef self):
        return super().__repr__()

    def __str__(StructWithRef self):
        return super().__str__()


    def __copy__(StructWithRef self):
        cdef shared_ptr[cStructWithRef] cpp_obj = make_shared[cStructWithRef](
            deref(self._cpp_obj)
        )
        return StructWithRef._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRef](
            self._cpp_obj,
            (<StructWithRef>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRef()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRef].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRef"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithRef](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithRef self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRef](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithRef self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRef]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRef](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithRef, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithRef, self)
@__cython.auto_pickle(False)
cdef class StructWithBox(thrift.py3.types.Struct):
    def __init__(StructWithBox self, **kwargs):
        self._cpp_obj = make_shared[cStructWithBox]()
        self._fields_setter = _fbthrift_types_fields.__StructWithBox_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithBox self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithBox __fbthrift_inst = StructWithBox.__new__(StructWithBox)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithBox](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithBox_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithBox", {
          "a": deref(self._cpp_obj).a_ref().has_value(),
          "b": deref(self._cpp_obj).b_ref().has_value(),
          "c": deref(self._cpp_obj).c_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithBox] cpp_obj):
        __fbthrift_inst = <StructWithBox>StructWithBox.__new__(StructWithBox)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline a_impl(self):
        if not deref(self._cpp_obj).a_ref().has_value():
            return None

        return (<bytes>deref(self._cpp_obj).a_ref().value()).decode('UTF-8')

    @property
    def a(self):
        return self.a_impl()

    cdef inline b_impl(self):
        if not deref(self._cpp_obj).b_ref().has_value():
            return None

        if self.__fbthrift_cached_b is None:
            self.__fbthrift_cached_b = List__i64._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).b_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_b

    @property
    def b(self):
        return self.b_impl()

    cdef inline c_impl(self):
        if not deref(self._cpp_obj).c_ref().has_value():
            return None

        if self.__fbthrift_cached_c is None:
            self.__fbthrift_cached_c = StructWithRef._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).c_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_c

    @property
    def c(self):
        return self.c_impl()


    def __hash__(StructWithBox self):
        return super().__hash__()

    def __repr__(StructWithBox self):
        return super().__repr__()

    def __str__(StructWithBox self):
        return super().__str__()


    def __copy__(StructWithBox self):
        cdef shared_ptr[cStructWithBox] cpp_obj = make_shared[cStructWithBox](
            deref(self._cpp_obj)
        )
        return StructWithBox._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithBox](
            self._cpp_obj,
            (<StructWithBox>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithBox()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithBox].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithBox"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithBox](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithBox self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithBox](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithBox self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithBox]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithBox](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithBox, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithBox, self)
@__cython.auto_pickle(False)
cdef class StructWithNonOptionalBox(thrift.py3.types.Struct):
    def __init__(StructWithNonOptionalBox self, **kwargs):
        self._cpp_obj = make_shared[cStructWithNonOptionalBox]()
        self._fields_setter = _fbthrift_types_fields.__StructWithNonOptionalBox_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithNonOptionalBox self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithNonOptionalBox __fbthrift_inst = StructWithNonOptionalBox.__new__(StructWithNonOptionalBox)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithNonOptionalBox](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithNonOptionalBox_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithNonOptionalBox", {
          "a": deref(self._cpp_obj).a_ref().has_value(),
          "b": deref(self._cpp_obj).b_ref().has_value(),
          "c": deref(self._cpp_obj).c_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithNonOptionalBox] cpp_obj):
        __fbthrift_inst = <StructWithNonOptionalBox>StructWithNonOptionalBox.__new__(StructWithNonOptionalBox)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline a_impl(self):

        return (<bytes>deref(self._cpp_obj).a_ref().value()).decode('UTF-8')

    @property
    def a(self):
        return self.a_impl()

    cdef inline b_impl(self):

        if self.__fbthrift_cached_b is None:
            self.__fbthrift_cached_b = List__i64._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).b_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_b

    @property
    def b(self):
        return self.b_impl()

    cdef inline c_impl(self):

        if self.__fbthrift_cached_c is None:
            self.__fbthrift_cached_c = StructWithRef._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).c_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_c

    @property
    def c(self):
        return self.c_impl()


    def __hash__(StructWithNonOptionalBox self):
        return super().__hash__()

    def __repr__(StructWithNonOptionalBox self):
        return super().__repr__()

    def __str__(StructWithNonOptionalBox self):
        return super().__str__()


    def __copy__(StructWithNonOptionalBox self):
        cdef shared_ptr[cStructWithNonOptionalBox] cpp_obj = make_shared[cStructWithNonOptionalBox](
            deref(self._cpp_obj)
        )
        return StructWithNonOptionalBox._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithNonOptionalBox](
            self._cpp_obj,
            (<StructWithNonOptionalBox>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithNonOptionalBox()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithNonOptionalBox].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithNonOptionalBox"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithNonOptionalBox](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithNonOptionalBox self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithNonOptionalBox](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithNonOptionalBox self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithNonOptionalBox]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithNonOptionalBox](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithNonOptionalBox, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithNonOptionalBox, self)
@__cython.auto_pickle(False)
cdef class StructWithInternBox(thrift.py3.types.Struct):
    def __init__(StructWithInternBox self, **kwargs):
        self._cpp_obj = make_shared[cStructWithInternBox]()
        self._fields_setter = _fbthrift_types_fields.__StructWithInternBox_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithInternBox self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithInternBox __fbthrift_inst = StructWithInternBox.__new__(StructWithInternBox)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithInternBox](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithInternBox_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithInternBox", {
          "field1": deref(self._cpp_obj).field1_ref().has_value(),
          "field2": deref(self._cpp_obj).field2_ref().has_value(),
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithInternBox] cpp_obj):
        __fbthrift_inst = <StructWithInternBox>StructWithInternBox.__new__(StructWithInternBox)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline field1_impl(self):

        if self.__fbthrift_cached_field1 is None:
            self.__fbthrift_cached_field1 = Empty._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).field1_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_field1

    @property
    def field1(self):
        return self.field1_impl()

    cdef inline field2_impl(self):

        if self.__fbthrift_cached_field2 is None:
            self.__fbthrift_cached_field2 = MyField._fbthrift_create(__reference_shared_ptr(deref(self._cpp_obj).field2_ref().ref(), self._cpp_obj))
        return self.__fbthrift_cached_field2

    @property
    def field2(self):
        return self.field2_impl()


    def __hash__(StructWithInternBox self):
        return super().__hash__()

    def __repr__(StructWithInternBox self):
        return super().__repr__()

    def __str__(StructWithInternBox self):
        return super().__str__()


    def __copy__(StructWithInternBox self):
        cdef shared_ptr[cStructWithInternBox] cpp_obj = make_shared[cStructWithInternBox](
            deref(self._cpp_obj)
        )
        return StructWithInternBox._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithInternBox](
            self._cpp_obj,
            (<StructWithInternBox>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithInternBox()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithInternBox].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithInternBox"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithInternBox](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 2

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithInternBox self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithInternBox](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithInternBox self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithInternBox]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithInternBox](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithInternBox, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithInternBox, self)
@__cython.auto_pickle(False)
cdef class StructWithRefTypeUnique(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeUnique self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeUnique]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeUnique_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeUnique self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeUnique __fbthrift_inst = StructWithRefTypeUnique.__new__(StructWithRefTypeUnique)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeUnique](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeUnique_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeUnique", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithRefTypeUnique] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeUnique>StructWithRefTypeUnique.__new__(StructWithRefTypeUnique)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_field_impl(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def def_field(self):
        return self.def_field_impl()

    cdef inline opt_field_impl(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def opt_field(self):
        return self.opt_field_impl()

    cdef inline req_field_impl(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field

    @property
    def req_field(self):
        return self.req_field_impl()


    def __hash__(StructWithRefTypeUnique self):
        return super().__hash__()

    def __repr__(StructWithRefTypeUnique self):
        return super().__repr__()

    def __str__(StructWithRefTypeUnique self):
        return super().__str__()


    def __copy__(StructWithRefTypeUnique self):
        cdef shared_ptr[cStructWithRefTypeUnique] cpp_obj = make_shared[cStructWithRefTypeUnique](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeUnique._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeUnique](
            self._cpp_obj,
            (<StructWithRefTypeUnique>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeUnique()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeUnique].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeUnique"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithRefTypeUnique](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithRefTypeUnique self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeUnique](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithRefTypeUnique self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeUnique]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeUnique](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithRefTypeUnique, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithRefTypeUnique, self)
@__cython.auto_pickle(False)
cdef class StructWithRefTypeShared(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeShared self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeShared]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeShared_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeShared self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeShared __fbthrift_inst = StructWithRefTypeShared.__new__(StructWithRefTypeShared)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeShared](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeShared_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeShared", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithRefTypeShared] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeShared>StructWithRefTypeShared.__new__(StructWithRefTypeShared)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_field_impl(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def def_field(self):
        return self.def_field_impl()

    cdef inline opt_field_impl(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def opt_field(self):
        return self.opt_field_impl()

    cdef inline req_field_impl(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field

    @property
    def req_field(self):
        return self.req_field_impl()


    def __hash__(StructWithRefTypeShared self):
        return super().__hash__()

    def __repr__(StructWithRefTypeShared self):
        return super().__repr__()

    def __str__(StructWithRefTypeShared self):
        return super().__str__()


    def __copy__(StructWithRefTypeShared self):
        cdef shared_ptr[cStructWithRefTypeShared] cpp_obj = make_shared[cStructWithRefTypeShared](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeShared._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeShared](
            self._cpp_obj,
            (<StructWithRefTypeShared>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeShared()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeShared].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeShared"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithRefTypeShared](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithRefTypeShared self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeShared](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithRefTypeShared self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeShared]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeShared](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithRefTypeShared, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithRefTypeShared, self)
@__cython.auto_pickle(False)
cdef class StructWithRefTypeSharedConst(thrift.py3.types.Struct):
    def __init__(StructWithRefTypeSharedConst self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefTypeSharedConst]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefTypeSharedConst_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefTypeSharedConst self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefTypeSharedConst __fbthrift_inst = StructWithRefTypeSharedConst.__new__(StructWithRefTypeSharedConst)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefTypeSharedConst](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefTypeSharedConst_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefTypeSharedConst", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithRefTypeSharedConst] cpp_obj):
        __fbthrift_inst = <StructWithRefTypeSharedConst>StructWithRefTypeSharedConst.__new__(StructWithRefTypeSharedConst)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_field_impl(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def def_field(self):
        return self.def_field_impl()

    cdef inline opt_field_impl(self):

        if self.__fbthrift_cached_opt_field is None:
            if not deref(self._cpp_obj).opt_field_ref():
                return None
            self.__fbthrift_cached_opt_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).opt_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_opt_field

    @property
    def opt_field(self):
        return self.opt_field_impl()

    cdef inline req_field_impl(self):

        if self.__fbthrift_cached_req_field is None:
            if not deref(self._cpp_obj).req_field_ref():
                return None
            self.__fbthrift_cached_req_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).req_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_req_field

    @property
    def req_field(self):
        return self.req_field_impl()


    def __hash__(StructWithRefTypeSharedConst self):
        return super().__hash__()

    def __repr__(StructWithRefTypeSharedConst self):
        return super().__repr__()

    def __str__(StructWithRefTypeSharedConst self):
        return super().__str__()


    def __copy__(StructWithRefTypeSharedConst self):
        cdef shared_ptr[cStructWithRefTypeSharedConst] cpp_obj = make_shared[cStructWithRefTypeSharedConst](
            deref(self._cpp_obj)
        )
        return StructWithRefTypeSharedConst._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefTypeSharedConst](
            self._cpp_obj,
            (<StructWithRefTypeSharedConst>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefTypeSharedConst()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefTypeSharedConst].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefTypeSharedConst"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithRefTypeSharedConst](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 3

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithRefTypeSharedConst self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefTypeSharedConst](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithRefTypeSharedConst self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefTypeSharedConst]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefTypeSharedConst](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithRefTypeSharedConst, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithRefTypeSharedConst, self)
@__cython.auto_pickle(False)
cdef class StructWithRefAndAnnotCppNoexceptMoveCtor(thrift.py3.types.Struct):
    def __init__(StructWithRefAndAnnotCppNoexceptMoveCtor self, **kwargs):
        self._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor]()
        self._fields_setter = _fbthrift_types_fields.__StructWithRefAndAnnotCppNoexceptMoveCtor_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithRefAndAnnotCppNoexceptMoveCtor self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithRefAndAnnotCppNoexceptMoveCtor __fbthrift_inst = StructWithRefAndAnnotCppNoexceptMoveCtor.__new__(StructWithRefAndAnnotCppNoexceptMoveCtor)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithRefAndAnnotCppNoexceptMoveCtor_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithRefAndAnnotCppNoexceptMoveCtor", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithRefAndAnnotCppNoexceptMoveCtor] cpp_obj):
        __fbthrift_inst = <StructWithRefAndAnnotCppNoexceptMoveCtor>StructWithRefAndAnnotCppNoexceptMoveCtor.__new__(StructWithRefAndAnnotCppNoexceptMoveCtor)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_field_impl(self):

        if self.__fbthrift_cached_def_field is None:
            if not deref(self._cpp_obj).def_field_ref():
                return None
            self.__fbthrift_cached_def_field = Empty._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_field_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_field

    @property
    def def_field(self):
        return self.def_field_impl()


    def __hash__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        return super().__hash__()

    def __repr__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        return super().__repr__()

    def __str__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        return super().__str__()


    def __copy__(StructWithRefAndAnnotCppNoexceptMoveCtor self):
        cdef shared_ptr[cStructWithRefAndAnnotCppNoexceptMoveCtor] cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor](
            deref(self._cpp_obj)
        )
        return StructWithRefAndAnnotCppNoexceptMoveCtor._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithRefAndAnnotCppNoexceptMoveCtor](
            self._cpp_obj,
            (<StructWithRefAndAnnotCppNoexceptMoveCtor>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithRefAndAnnotCppNoexceptMoveCtor()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithRefAndAnnotCppNoexceptMoveCtor].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithRefAndAnnotCppNoexceptMoveCtor"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithRefAndAnnotCppNoexceptMoveCtor](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 1

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithRefAndAnnotCppNoexceptMoveCtor self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithRefAndAnnotCppNoexceptMoveCtor](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithRefAndAnnotCppNoexceptMoveCtor self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithRefAndAnnotCppNoexceptMoveCtor]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithRefAndAnnotCppNoexceptMoveCtor](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithRefAndAnnotCppNoexceptMoveCtor, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithRefAndAnnotCppNoexceptMoveCtor, self)
@__cython.auto_pickle(False)
cdef class StructWithString(thrift.py3.types.Struct):
    def __init__(StructWithString self, **kwargs):
        self._cpp_obj = make_shared[cStructWithString]()
        self._fields_setter = _fbthrift_types_fields.__StructWithString_FieldsSetter._fbthrift_create(self._cpp_obj.get())
        super().__init__(**kwargs)

    def __call__(StructWithString self, **kwargs):
        if not kwargs:
            return self
        cdef StructWithString __fbthrift_inst = StructWithString.__new__(StructWithString)
        __fbthrift_inst._cpp_obj = make_shared[cStructWithString](deref(self._cpp_obj))
        __fbthrift_inst._fields_setter = _fbthrift_types_fields.__StructWithString_FieldsSetter._fbthrift_create(__fbthrift_inst._cpp_obj.get())
        for __fbthrift_name, _fbthrift_value in kwargs.items():
            __fbthrift_inst._fbthrift_set_field(__fbthrift_name, _fbthrift_value)
        return __fbthrift_inst

    cdef void _fbthrift_set_field(self, str name, object value) except *:
        self._fields_setter.set_field(name.encode("utf-8"), value)

    cdef object _fbthrift_isset(self):
        return thrift.py3.types._IsSet("StructWithString", {
        })

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cStructWithString] cpp_obj):
        __fbthrift_inst = <StructWithString>StructWithString.__new__(StructWithString)
        __fbthrift_inst._cpp_obj = cmove(cpp_obj)
        return __fbthrift_inst

    cdef inline def_unique_string_ref_impl(self):

        if self.__fbthrift_cached_def_unique_string_ref is None:
            if not deref(self._cpp_obj).def_unique_string_ref_ref():
                return None
            self.__fbthrift_cached_def_unique_string_ref = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_unique_string_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_unique_string_ref

    @property
    def def_unique_string_ref(self):
        return self.def_unique_string_ref_impl()

    cdef inline def_shared_string_ref_impl(self):

        if self.__fbthrift_cached_def_shared_string_ref is None:
            if not deref(self._cpp_obj).def_shared_string_ref_ref():
                return None
            self.__fbthrift_cached_def_shared_string_ref = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_shared_string_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_shared_string_ref

    @property
    def def_shared_string_ref(self):
        return self.def_shared_string_ref_impl()

    cdef inline def_shared_string_const_ref_impl(self):

        if self.__fbthrift_cached_def_shared_string_const_ref is None:
            if not deref(self._cpp_obj).def_shared_string_const_ref_ref():
                return None
            self.__fbthrift_cached_def_shared_string_const_ref = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).def_shared_string_const_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_def_shared_string_const_ref

    @property
    def def_shared_string_const_ref(self):
        return self.def_shared_string_const_ref_impl()

    cdef inline unique_string_ref_impl(self):

        if self.__fbthrift_cached_unique_string_ref is None:
            if not deref(self._cpp_obj).unique_string_ref_ref():
                return None
            self.__fbthrift_cached_unique_string_ref = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).unique_string_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_unique_string_ref

    @property
    def unique_string_ref(self):
        return self.unique_string_ref_impl()

    cdef inline shared_string_ref_impl(self):

        if self.__fbthrift_cached_shared_string_ref is None:
            if not deref(self._cpp_obj).shared_string_ref_ref():
                return None
            self.__fbthrift_cached_shared_string_ref = str._fbthrift_create(__reference_shared_ptr(deref(deref(self._cpp_obj).shared_string_ref_ref()), self._cpp_obj))
        return self.__fbthrift_cached_shared_string_ref

    @property
    def shared_string_ref(self):
        return self.shared_string_ref_impl()


    def __hash__(StructWithString self):
        return super().__hash__()

    def __repr__(StructWithString self):
        return super().__repr__()

    def __str__(StructWithString self):
        return super().__str__()


    def __copy__(StructWithString self):
        cdef shared_ptr[cStructWithString] cpp_obj = make_shared[cStructWithString](
            deref(self._cpp_obj)
        )
        return StructWithString._fbthrift_create(cmove(cpp_obj))

    def __richcmp__(self, other, int op):
        r = self._fbthrift_cmp_sametype(other, op)
        return __richcmp[cStructWithString](
            self._cpp_obj,
            (<StructWithString>other)._cpp_obj,
            op,
        ) if r is None else r

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__StructWithString()

    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftMetadata meta
        StructMetadata[cStructWithString].gen(meta)
        return __MetadataBox.box(cmove(meta))

    @staticmethod
    def __get_thrift_name__():
        return "module.StructWithString"

    @classmethod
    def _fbthrift_get_field_name_by_index(cls, idx):
        return __sv_to_str(__get_field_name_by_index[cStructWithString](idx))

    @classmethod
    def _fbthrift_get_struct_size(cls):
        return 5

    cdef _fbthrift_iobuf.IOBuf _fbthrift_serialize(StructWithString self, __Protocol proto):
        cdef unique_ptr[_fbthrift_iobuf.cIOBuf] data
        with nogil:
            data = cmove(serializer.cserialize[cStructWithString](self._cpp_obj.get(), proto))
        return _fbthrift_iobuf.from_unique_ptr(cmove(data))

    cdef cuint32_t _fbthrift_deserialize(StructWithString self, const _fbthrift_iobuf.cIOBuf* buf, __Protocol proto) except? 0:
        cdef cuint32_t needed
        self._cpp_obj = make_shared[cStructWithString]()
        with nogil:
            needed = serializer.cdeserialize[cStructWithString](buf, self._cpp_obj.get(), proto)
        return needed

    def _to_python(self):
        import importlib
        import thrift.python.converter
        python_types = importlib.import_module(
            "module.thrift_types"
        )
        return thrift.python.converter.to_python_struct(python_types.StructWithString, self)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        import importlib
        import thrift.util.converter
        py_deprecated_types = importlib.import_module("module.ttypes")
        return thrift.util.converter.to_py_struct(py_deprecated_types.StructWithString, self)
@__cython.auto_pickle(False)
cdef class List__RecursiveStruct(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__RecursiveStruct):
            self._cpp_obj = (<List__RecursiveStruct> items)._cpp_obj
        else:
            self._cpp_obj = List__RecursiveStruct._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[vector[cRecursiveStruct]] c_items):
        __fbthrift_inst = <List__RecursiveStruct>List__RecursiveStruct.__new__(List__RecursiveStruct)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__RecursiveStruct self):
        cdef shared_ptr[vector[cRecursiveStruct]] cpp_obj = make_shared[vector[cRecursiveStruct]](
            deref(self._cpp_obj)
        )
        return List__RecursiveStruct._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cRecursiveStruct]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cRecursiveStruct]] c_inst = make_shared[vector[cRecursiveStruct]]()
        if items is not None:
            for item in items:
                if not isinstance(item, RecursiveStruct):
                    raise TypeError(f"{item!r} is not of type RecursiveStruct")
                deref(c_inst).push_back(deref((<RecursiveStruct>item)._cpp_obj))
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__RecursiveStruct._fbthrift_create(
            __list_slice[vector[cRecursiveStruct]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef shared_ptr[cRecursiveStruct] citem
        __list_getitem(self._cpp_obj, index, citem)
        return RecursiveStruct._fbthrift_create(citem)

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, RecursiveStruct):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cRecursiveStruct citem = deref((<RecursiveStruct>item)._cpp_obj)
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cRecursiveStruct]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cRecursiveStruct citem = deref((<RecursiveStruct>item)._cpp_obj)
        return __list_count[vector[cRecursiveStruct]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__RecursiveStruct()


Sequence.register(List__RecursiveStruct)

@__cython.auto_pickle(False)
cdef class List__i32(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = List__i32._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[vector[cint32_t]] c_items):
        __fbthrift_inst = <List__i32>List__i32.__new__(List__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i32 self):
        cdef shared_ptr[vector[cint32_t]] cpp_obj = make_shared[vector[cint32_t]](
            deref(self._cpp_obj)
        )
        return List__i32._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint32_t]] c_inst = make_shared[vector[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i32._fbthrift_create(
            __list_slice[vector[cint32_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint32_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint32_t citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cint32_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint32_t citem = item
        return __list_count[vector[cint32_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i32()


Sequence.register(List__i32)

@__cython.auto_pickle(False)
cdef class Set__i32(thrift.py3.types.Set):
    def __init__(self, items=None):
        if isinstance(items, Set__i32):
            self._cpp_obj = (<Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = Set__i32._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cset[cint32_t]] c_items):
        __fbthrift_inst = <Set__i32>Set__i32.__new__(Set__i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Set__i32 self):
        cdef shared_ptr[cset[cint32_t]] cpp_obj = make_shared[cset[cint32_t]](
            deref(self._cpp_obj)
        )
        return Set__i32._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cset[cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cset[cint32_t]] c_inst = make_shared[cset[cint32_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item
                deref(c_inst).insert(item)
        return c_inst

    def __contains__(self, item):
        if not self or item is None:
            return False
        if not isinstance(item, int):
            return False
        return pbool(deref(self._cpp_obj).count(item))


    def __iter__(self):
        if not self:
            return
        cdef __set_iter[cset[cint32_t]] itr = __set_iter[cset[cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNext(self._cpp_obj, citem)
            yield citem

    def __hash__(self):
        return super().__hash__()

    def __richcmp__(self, other, int op):
        if isinstance(other, Set__i32):
            # C level comparisons
            return __setcmp(
                self._cpp_obj,
                (<Set__i32> other)._cpp_obj,
                op,
            )
        return self._fbthrift_py_richcmp(other, op)

    cdef _fbthrift_do_set_op(self, other, __cSetOp op):
        if not isinstance(other, Set__i32):
            other = Set__i32(other)
        cdef shared_ptr[cset[cint32_t]] result
        return Set__i32._fbthrift_create(__set_op[cset[cint32_t]](
            self._cpp_obj,
            (<Set__i32>other)._cpp_obj,
            op,
        ))

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Set__i32()


Set.register(Set__i32)

@__cython.auto_pickle(False)
cdef class Map__i32_i32(thrift.py3.types.Map):
    def __init__(self, items=None):
        if isinstance(items, Map__i32_i32):
            self._cpp_obj = (<Map__i32_i32> items)._cpp_obj
        else:
            self._cpp_obj = Map__i32_i32._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[cmap[cint32_t,cint32_t]] c_items):
        __fbthrift_inst = <Map__i32_i32>Map__i32_i32.__new__(Map__i32_i32)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(Map__i32_i32 self):
        cdef shared_ptr[cmap[cint32_t,cint32_t]] cpp_obj = make_shared[cmap[cint32_t,cint32_t]](
            deref(self._cpp_obj)
        )
        return Map__i32_i32._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[cmap[cint32_t,cint32_t]] _make_instance(object items) except *:
        cdef shared_ptr[cmap[cint32_t,cint32_t]] c_inst = make_shared[cmap[cint32_t,cint32_t]]()
        if items is not None:
            for key, item in items.items():
                if not isinstance(key, int):
                    raise TypeError(f"{key!r} is not of type int")
                key = <cint32_t> key
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint32_t> item

                deref(c_inst)[key] = item
        return c_inst

    cdef _check_key_type(self, key):
        if not self or key is None:
            return
        if isinstance(key, int):
            return key

    def __getitem__(self, key):
        err = KeyError(f'{key}')
        key = self._check_key_type(key)
        if key is None:
            raise err
        cdef cint32_t ckey = key
        if not __map_contains(self._cpp_obj, ckey):
            raise err
        cdef cint32_t citem = 0
        __map_getitem(self._cpp_obj, ckey, citem)
        return citem

    def __iter__(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextKey(self._cpp_obj, citem)
            yield citem

    def __contains__(self, key):
        key = self._check_key_type(key)
        if key is None:
            return False
        cdef cint32_t ckey = key
        return __map_contains(self._cpp_obj, ckey)

    def values(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextValue(self._cpp_obj, citem)
            yield citem

    def items(self):
        if not self:
            return
        cdef __map_iter[cmap[cint32_t,cint32_t]] itr = __map_iter[cmap[cint32_t,cint32_t]](self._cpp_obj)
        cdef cint32_t ckey = 0
        cdef cint32_t citem = 0
        for i in range(deref(self._cpp_obj).size()):
            itr.genNextItem(self._cpp_obj, ckey, citem)
            yield (ckey, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__Map__i32_i32()

Mapping.register(Map__i32_i32)

@__cython.auto_pickle(False)
cdef class List__i64(thrift.py3.types.List):
    def __init__(self, items=None):
        if isinstance(items, List__i64):
            self._cpp_obj = (<List__i64> items)._cpp_obj
        else:
            self._cpp_obj = List__i64._make_instance(items)

    @staticmethod
    cdef _fbthrift_create(shared_ptr[vector[cint64_t]] c_items):
        __fbthrift_inst = <List__i64>List__i64.__new__(List__i64)
        __fbthrift_inst._cpp_obj = cmove(c_items)
        return __fbthrift_inst

    def __copy__(List__i64 self):
        cdef shared_ptr[vector[cint64_t]] cpp_obj = make_shared[vector[cint64_t]](
            deref(self._cpp_obj)
        )
        return List__i64._fbthrift_create(cmove(cpp_obj))

    def __len__(self):
        return deref(self._cpp_obj).size()

    @staticmethod
    cdef shared_ptr[vector[cint64_t]] _make_instance(object items) except *:
        cdef shared_ptr[vector[cint64_t]] c_inst = make_shared[vector[cint64_t]]()
        if items is not None:
            for item in items:
                if not isinstance(item, int):
                    raise TypeError(f"{item!r} is not of type int")
                item = <cint64_t> item
                deref(c_inst).push_back(item)
        return c_inst

    cdef _get_slice(self, slice index_obj):
        cdef int start, stop, step
        start, stop, step = index_obj.indices(deref(self._cpp_obj).size())
        return List__i64._fbthrift_create(
            __list_slice[vector[cint64_t]](self._cpp_obj, start, stop, step)
        )

    cdef _get_single_item(self, size_t index):
        cdef cint64_t citem = 0
        __list_getitem(self._cpp_obj, index, citem)
        return citem

    cdef _check_item_type(self, item):
        if not self or item is None:
            return
        if isinstance(item, int):
            return item

    def index(self, item, start=0, stop=None):
        err = ValueError(f'{item} is not in list')
        item = self._check_item_type(item)
        if item is None:
            raise err
        cdef (int, int, int) indices = slice(start, stop).indices(deref(self._cpp_obj).size())
        cdef cint64_t citem = item
        cdef std_libcpp.optional[size_t] found = __list_index[vector[cint64_t]](self._cpp_obj, indices[0], indices[1], citem)
        if not found.has_value():
            raise err
        return found.value()

    def count(self, item):
        item = self._check_item_type(item)
        if item is None:
            return 0
        cdef cint64_t citem = item
        return __list_count[vector[cint64_t]](self._cpp_obj, citem)

    @staticmethod
    def __get_reflection__():
        return _types_reflection.get_reflection__List__i64()


Sequence.register(List__i64)

kStructWithRef = StructWithRef._fbthrift_create(constant_shared_ptr(ckStructWithRef()))
kStructWithRefTypeUnique = StructWithRefTypeUnique._fbthrift_create(constant_shared_ptr(ckStructWithRefTypeUnique()))
kStructWithRefTypeShared = StructWithRefTypeShared._fbthrift_create(constant_shared_ptr(ckStructWithRefTypeShared()))
kStructWithRefTypeSharedConst = StructWithRefTypeSharedConst._fbthrift_create(constant_shared_ptr(ckStructWithRefTypeSharedConst()))
