<?php
/**
 * Automatically generated by running "php schema.php array".
 *
 * You may modify the file, but re-running schema.php against this file will
 * standardize the format without losing your schema changes. It does lose
 * any changes that are not part of schema. Use "note" field to comment on
 * schema itself, and "note" fields are not used in any code generation but
 * only staying within this file.
 */
///////////////////////////////////////////////////////////////////////////////
// Preamble: C++ code inserted at beginning of ext_{name}.h

DefinePreamble(<<<CPP

CPP
);

///////////////////////////////////////////////////////////////////////////////
// Constants
//
// array (
//   'name' => name of the constant
//   'type' => type of the constant
//   'note' => additional note about this constant's schema
// )

DefineConstant(
  array(
    'name'   => "UCOL_DEFAULT",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_PRIMARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_SECONDARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_TERTIARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_DEFAULT_STRENGTH",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_QUATERNARY",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_IDENTICAL",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_OFF",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_ON",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_SHIFTED",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_NON_IGNORABLE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_LOWER_FIRST",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_UPPER_FIRST",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_FRENCH_COLLATION",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_ALTERNATE_HANDLING",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_CASE_FIRST",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_CASE_LEVEL",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_NORMALIZATION_MODE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_STRENGTH",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_HIRAGANA_QUATERNARY_MODE",
    'type'   => Int64,
  ));

DefineConstant(
  array(
    'name'   => "UCOL_NUMERIC_COLLATION",
    'type'   => Int64,
  ));


///////////////////////////////////////////////////////////////////////////////
// Functions
//
// array (
//   'name'   => name of the function
//   'desc'   => description of the function's purpose
//   'flags'  => attributes of the function, see base.php for possible values
//   'opt'    => optimization callback function's name for compiler
//   'note'   => additional note about this function's schema
//   'return' =>
//      array (
//        'type'  => return type, use Reference for ref return
//        'desc'  => description of the return value
//      )
//   'args'   => arguments
//      array (
//        'name'  => name of the argument
//        'type'  => type of the argument, use Reference for output parameter
//        'value' => default value of the argument
//        'desc'  => description of the argument
//      )
// )

DefineFunction(
  array(
    'name'   => "array_change_key_case",
    'desc'   => "Returns an array with all keys from input lowercased or uppercased. Numbered indices are left as is.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array with its keys lower or uppercased, or FALSE if input is not an array.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The array to work on",
      ),
      array(
        'name'   => "upper",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Either CASE_UPPER or CASE_LOWER (default)",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_chunk",
    'desc'   => "Chunks an array into size large chunks. The last chunk may contain less than size elements.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a multidimensional numerically indexed array, starting with zero, with each dimension containing size elements.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The array to work on",
      ),
      array(
        'name'   => "size",
        'type'   => Int32,
        'desc'   => "The size of each chunk",
      ),
      array(
        'name'   => "preserve_keys",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "When set to TRUE keys will be preserved. Default is FALSE which will reindex the chunk numerically",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_combine",
    'desc'   => "Creates an array by using the values from the keys array as keys and the values from the values array as the corresponding values.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the combined array, FALSE if the number of elements for each array isn't equal or if the arrays are empty.",
    ),
    'args'   => array(
      array(
        'name'   => "keys",
        'type'   => Variant,
        'desc'   => "Array of keys to be used. Illegal values for key will be converted to string.",
      ),
      array(
        'name'   => "values",
        'type'   => Variant,
        'desc'   => "Array of values to be used",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_count_values",
    'desc'   => "array_count_values() returns an array using the values of the input array as keys and their frequency in input as values.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an associative array of values from input as keys and their count as value.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The array of values to count",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_fill_keys",
    'desc'   => "Fills an array with the value of the value parameter, using the values of the keys array as keys.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the filled array",
    ),
    'args'   => array(
      array(
        'name'   => "keys",
        'type'   => Variant,
        'desc'   => "Array of values that will be used as keys. Illegal values for key will be converted to string.",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "Value to use for filling",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_fill",
    'desc'   => "Fills an array with num entries of the value of the value parameter, keys starting at the start_index parameter.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the filled array",
    ),
    'args'   => array(
      array(
        'name'   => "start_index",
        'type'   => Int32,
        'desc'   => "The first index of the returned array. Supports non-negative indexes only.",
      ),
      array(
        'name'   => "num",
        'type'   => Int32,
        'desc'   => "Number of elements to insert",
      ),
      array(
        'name'   => "value",
        'type'   => Variant,
        'desc'   => "Value to use for filling",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_filter",
    'desc'   => "Iterates over each value in the input array passing them to the callback function. If the callback function returns true, the current value from input is returned into the result array. Array keys are preserved.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the filtered array.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The array to iterate over",
      ),
      array(
        'name'   => "callback",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "The callback function to use\n\nIf no callback is supplied, all entries of input equal to FALSE (see converting to boolean) will be removed.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_flip",
    'desc'   => "array_flip() returns an array in flip order, i.e. keys from trans become values and values from trans become keys.\n\nNote that the values of trans need to be valid keys, i.e. they need to be either integer or string. A warning will be emitted if a value has the wrong type, and the key/value pair in question will not be flipped.\n\nIf a value has several occurrences, the latest key will be used as its values, and all others will be lost.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the flipped array on success and NULL on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "trans",
        'type'   => Variant,
        'desc'   => "An array of key/value pairs to be flipped.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_key_exists",
    'desc'   => "array_key_exists() returns TRUE if the given key is set in the array. key can be any value possible for an array index.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
        'desc'   => "Value to check.",
      ),
      array(
        'name'   => "search",
        'type'   => Variant,
        'desc'   => "An array with keys to check.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "key_exists",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Boolean,
    ),
    'args'   => array(
      array(
        'name'   => "key",
        'type'   => Variant,
      ),
      array(
        'name'   => "search",
        'type'   => Variant,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_keys",
    'desc'   => "array_keys() returns the keys, numeric and string, from the input array.\n\nIf the optional search_value is specified, then only the keys for that value are returned. Otherwise, all the keys from the input are returned.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array of all the keys in input.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "An array containing keys to return.",
      ),
      array(
        'name'   => "search_value",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If specified, then only keys containing these values are returned.",
      ),
      array(
        'name'   => "strict",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Determines if strict comparison (===) should be used during the search.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_map",
    'desc'   => "array_map() returns an array containing all the elements of arr1 after applying the callback function to each one. The number of parameters that the callback function accepts should match the number of arrays passed to the array_map()",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the elements of arr1 after applying the callback function to each one.",
    ),
    'args'   => array(
      array(
        'name'   => "callback",
        'type'   => Variant,
        'desc'   => "Callback function to run for each element in each array.",
      ),
      array(
        'name'   => "arr1",
        'type'   => Variant,
        'desc'   => "An array to run through the callback function.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_merge_recursive",
    'desc'   => "array_merge_recursive() merges the elements of one or more arrays together so that the values of one are appended to the end of the previous one. It returns the resulting array.\n\nIf the input arrays have the same string keys, then the values for these keys are merged together into an array, and this is done recursively, so that if one of the values is an array itself, the function will merge it with a corresponding entry in another array too. If, however, the arrays have the same numeric key, the later value will not overwrite the original value, but will be appended.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "An array of values resulted from merging the arguments together.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "Initial array to merge.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_merge",
    'desc'   => "Merges the elements of one or more arrays together so that the values of one are appended to the end of the previous one. It returns the resulting array.\n\nIf the input arrays have the same string keys, then the later value for that key will overwrite the previous one. If, however, the arrays contain numeric keys, the later value will not overwrite the original value, but will be appended.\n\nIf all of the arrays contain only numeric keys, the resulting array is given incrementing keys starting from zero.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the resulting array.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "Initial array to merge.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_replace_recursive",
    'desc'   => "array_replace_recursive() replaces the values of the first array with the same values from all the following arrays. If a key from the first array exists in the second array, its value will be replaced by the value from the second array. If the key exists in the second array, and not the first, it will be created in the first array. If a key only exists in the first array, it will be left as is. If several arrays are passed for replacement, they will be processed in order, the later array overwriting the previous values.\n\narray_replace_recursive() is recursive : it will recurse into arrays and apply the same process to the inner value.\n\nWhen the value in array is scalar, it will be replaced by the value in array1, may it be scalar or array. When the value in array and array1 are both arrays, array_replace_recursive() will replace their respective value recursively.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array, or NULL if an error occurs.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array in which elements are replaced.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_replace",
    'desc'   => "array_replace() replaces the values of the first array with the same values from all the following arrays. If a key from the first array exists in the second array, its value will be replaced by the value from the second array. If the key exists in the second array, and not the first, it will be created in the first array. If a key only exists in the first array, it will be left as is. If several arrays are passed for replacement, they will be processed in order, the later arrays overwriting the previous values.\n\narray_replace() is not recursive : it will replace values in the first array by whatever type is in the second array.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array, or NULL if an error occurs.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array in which elements are replaced.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_multisort",
    'desc'   => "array_multisort() can be used to sort several arrays at once, or a multi-dimensional array by one or more dimensions.\n\nAssociative (string) keys will be maintained, but numeric keys will be re-indexed.",
    'flags'  =>  HasDocComment | MixedVariableArguments,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "ar1",
        'type'   => Variant | Reference,
        'desc'   => "An array being sorted.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_pad",
    'desc'   => "array_pad() returns a copy of the input padded to size specified by pad_size with value pad_value. If pad_size is positive then the array is padded on the right, if it's negative then on the left. If the absolute value of pad_size is less than or equal to the length of the input then no padding takes place. It is possible to add most 1048576 elements at a time.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns a copy of the input padded to size specified by pad_size with value pad_value. If pad_size is positive then the array is padded on the right, if it's negative then on the left. If the absolute value of pad_size is less than or equal to the length of the input then no padding takes place.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "Initial array of values to pad.",
      ),
      array(
        'name'   => "pad_size",
        'type'   => Int32,
        'desc'   => "New size of the array.",
      ),
      array(
        'name'   => "pad_value",
        'type'   => Variant,
        'desc'   => "Value to pad if input is less than pad_size.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_pop",
    'desc'   => "array_pop() pops and returns the last value of the array, shortening the array by one element. If array is empty (or is not an array), NULL will be returned. Will additionally produce a Warning when called on a non-array. This function will reset() the array pointer after use.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the last value of array. If array is empty (or is not an array), NULL will be returned.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array to get the value from.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_product",
    'desc'   => "array_product() returns the product of values in an array.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the product as an integer or float.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_push",
    'desc'   => "array_push() treats array as a stack, and pushes the passed variables onto the end of array. The length of array increases by the number of variables pushed. Has the same effect as:\n\nrepeated for each var. If you use array_push() to add one element to the array it's better to use \$array[] = because in that way there is no overhead of calling a function. array_push() will raise a warning if the first argument is not an array. This differs from the \$var[] behaviour where a new array is created.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the new number of elements in the array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "var",
        'type'   => Variant,
        'desc'   => "The pushed value.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_rand",
    'desc'   => "Picks one ore more random entries out of an array, and returns the key (or keys) of the random entries.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "If you are picking only one entry, array_rand() returns the key for a random entry. Otherwise, it returns an array of keys for the random entries. This is done so that you can pick random keys as well as values out of the array.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "num_req",
        'type'   => Int32,
        'value'  => "1",
        'desc'   => "Specifies how many entries you want to pick. Trying to pick more elements than there are in the array will result in an E_WARNING level error.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_reduce",
    'desc'   => "array_reduce() applies iteratively the function function to the elements of the array input, so as to reduce the array to a single value.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the resulting value.\n\nIf the array is empty and initial is not passed, array_reduce() returns NULL.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "callback",
        'type'   => Variant,
        'desc'   => "The callback function.",
      ),
      array(
        'name'   => "initial",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If the optional initial is available, it will be used at the beginning of the process, or as a final result in case the array is empty.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_reverse",
    'desc'   => "Takes an input array and returns a new array with the order of the elements reversed.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the reversed array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "preserve_keys",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "If set to TRUE keys are preserved.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_search",
    'desc'   => "Searches haystack for needle.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the key for needle if it is found in the array, FALSE otherwise.\n\nIf needle is found in haystack more than once, the first matching key is returned. To return the keys for all matching values, use array_keys() with the optional search_value parameter instead. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "needle",
        'type'   => Variant,
        'desc'   => "The searched value.\n\nIf needle is a string, the comparison is done in a case-sensitive manner.",
      ),
      array(
        'name'   => "haystack",
        'type'   => Variant,
        'desc'   => "The array.",
      ),
      array(
        'name'   => "strict",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "If the third parameter strict is set to TRUE then the array_search() function will search for identical elements in the haystack. This means it will also check the types of the needle in the haystack, and objects must be the same instance.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_shift",
    'desc'   => "array_shift() shifts the first value of the array off and returns it, shortening the array by one element and moving everything down. All numerical array keys will be modified to start counting from zero while literal keys won't be touched. This function will reset() the array pointer after use.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the shifted value, or NULL if array is empty or is not an array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_slice",
    'desc'   => "array_slice() returns the sequence of elements from the array array as specified by the offset and length parameters. This function will reset() the array pointer after use.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the slice.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'desc'   => "If offset is non-negative, the sequence will start at that offset in the array. If offset is negative, the sequence will start that far from the end of the array.",
      ),
      array(
        'name'   => "length",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If length is given and is positive, then the sequence will have that many elements in it. If length is given and is negative then the sequence will stop that many elements from the end of the array. If it is omitted, then the sequence will have everything from offset up until the end of the array.",
      ),
      array(
        'name'   => "preserve_keys",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "Note that array_slice() will reorder and reset the array indices by default. You can change this behaviour by setting preserve_keys to TRUE.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_splice",
    'desc'   => "Removes the elements designated by offset and length from the input array, and replaces them with the elements of the replacement array, if supplied.\n\nNote that numeric keys in input are not preserved. If replacement is not an array, it will be typecast to one (i.e. (array) \$parameter). This may result in unexpected behavior when using an object or NULL replacement.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the array consisting of the extracted elements.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "offset",
        'type'   => Int32,
        'desc'   => "If offset is positive then the start of removed portion is at that offset from the beginning of the input array. If offset is negative then it starts that far from the end of the input array.",
      ),
      array(
        'name'   => "length",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If length is omitted, removes everything from offset to the end of the array. If length is specified and is positive, then that many elements will be removed. If length is specified and is negative then the end of the removed portion will be that many elements from the end of the array. Tip: to remove everything from offset to the end of the array when replacement is also specified, use count(\$input) for length.",
      ),
      array(
        'name'   => "replacement",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If replacement array is specified, then the removed elements are replaced with elements from this array.\n\nIf offset and length are such that nothing is removed, then the elements from the replacement array are inserted in the place specified by the offset. Note that keys in replacement array are not preserved.\n\nIf replacement is just one element it is not necessary to put array() around it, unless the element is an array itself, an object or NULL.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_sum",
    'desc'   => "array_sum() returns the sum of values in an array.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the sum of values as an integer or float.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_unique",
    'desc'   => "Takes an input array and returns a new array without duplicate values.\n\nNote that keys are preserved. array_unique() sorts the values treated as string at first, then will keep the first key encountered for every value, and ignore all following keys. It does not mean that the key of the first related value from the unsorted array will be kept. Two elements are considered equal if and only if (string) \$elem1 === (string) \$elem2. In words: when the string representation is the same. The first element will be used.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the filtered array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "2",
        'desc'   => "The optional second parameter sort_flags may be used to modify the sorting behavior using these values:\n\nSorting type flags: SORT_REGULAR - compare items normally (don't change types) SORT_NUMERIC - compare items numerically SORT_STRING - compare items as strings SORT_LOCALE_STRING - compare items as strings, based on the current locale.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_unshift",
    'desc'   => "array_unshift() prepends passed elements to the front of the array. Note that the list of elements is prepended as a whole, so that the prepended elements stay in the same order. All numerical array keys will be modified to start counting from zero while literal keys won't be touched.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Int32,
      'desc'   => "Returns the new number of elements in the array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "var",
        'type'   => Variant,
        'desc'   => "The prepended variable.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_values",
    'desc'   => "array_values() returns all the values from the input array and indexes numerically the array.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an indexed array of values.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_walk_recursive",
    'desc'   => "Applies the user-defined function funcname to each element of the input array. This function will recur into deeper arrays.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "funcname",
        'type'   => Variant,
        'desc'   => "Typically, funcname takes on two parameters. The input parameter's value being the first, and the key/index second.\n\nIf funcname needs to be working with the actual values of the array, specify the first parameter of funcname as a reference. Then, any changes made to those elements will be made in the original array itself.",
      ),
      array(
        'name'   => "userdata",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If the optional userdata parameter is supplied, it will be passed as the third parameter to the callback funcname.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_walk",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "input",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "funcname",
        'type'   => Variant,
        'desc'   => "Typically, funcname takes on two parameters. The array parameter's value being the first, and the key/index second.\n\nIf funcname needs to be working with the actual values of the array, specify the first parameter of funcname as a reference. Then, any changes made to those elements will be made in the original array itself.\n\nUsers may not change the array itself from the callback function. e.g. Add/delete elements, unset elements, etc. If the array that array_walk() is applied to is changed, the behavior of this function is undefined, and unpredictable.",
      ),
      array(
        'name'   => "userdata",
        'type'   => Variant,
        'value'  => "null_variant",
        'desc'   => "If the optional userdata parameter is supplied, it will be passed as the third parameter to the callback funcname.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "compact",
    'desc'   => "Creates an array containing variables and their values.\n\nFor each of these, compact() looks for a variable with that name in the current symbol table and adds it to the output array such that the variable name becomes the key and the contents of the variable become the value for that key. In short, it does the opposite of extract().\n\nAny strings that are not set will simply be skipped.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => VariantMap,
      'desc'   => "Returns the output array with all the variables added to it.",
    ),
    'args'   => array(
      array(
        'name'   => "varname",
        'type'   => Variant,
        'desc'   => "compact() takes a variable number of parameters. Each parameter can be either a string containing the name of the variable, or an array of variable names. The array can contain other arrays of variable names inside it; compact() handles it recursively.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "shuffle",
    'desc'   => "This function shuffles (randomizes the order of the elements in) an array.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "count",
    'desc'   => "Counts all elements in an array, or properties in an object.\n\nFor objects, if you have SPL installed, you can hook into count() by implementing interface Countable. The interface has exactly one method, count(), which returns the return value for the count() function.\n\nPlease see the Array section of the manual for a detailed explanation of how arrays are implemented and used in PHP.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Int32,
      'desc'   => "Returns the number of elements in var, which is typically an array, since anything else will have one element.\n\nIf var is not an array or an object with implemented Countable interface, 1 will be returned. There is one exception, if var is NULL, 0 will be returned. Caution\n\ncount() may return 0 for a variable that isn't set, but it may also return 0 for a variable that has been initialized with an empty array. Use isset() to test if a variable is set.",
    ),
    'args'   => array(
      array(
        'name'   => "var",
        'type'   => Variant,
        'desc'   => "The array.",
      ),
      array(
        'name'   => "recursive",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "If the optional mode parameter is set to COUNT_RECURSIVE (or 1), count() will recursively count the array. This is particularly useful for counting all the elements of a multidimensional array. count() does not detect infinite recursion.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "sizeof",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Int32,
    ),
    'args'   => array(
      array(
        'name'   => "var",
        'type'   => Variant,
      ),
      array(
        'name'   => "recursive",
        'type'   => Boolean,
        'value'  => "false",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "each",
    'desc'   => "Return the current key and value pair from an array and advance the array cursor.\n\nAfter each() has executed, the array cursor will be left on the next element of the array, or past the last element if it hits the end of the array. You have to use reset() if you want to traverse the array again using each.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the current key and value pair from the array array. This pair is returned in a four-element array, with the keys 0, 1, key, and value. Elements 0 and key contain the key name of the array element, and 1 and value contain the data.\n\nIf the internal pointer for the array points past the end of the array contents, each() returns FALSE.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "current",
    'desc'   => "Every array has an internal pointer to its \"current\" element, which is initialized to the first element inserted into the array.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The current() function simply returns the value of the array element that's currently being pointed to by the internal pointer. It does not move the pointer in any way. If the internal pointer points beyond the end of the elements list or the array is empty, current() returns FALSE. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "hphp_current_ref",
    'desc'   => "Similar to current(), but hphp_current_ref() returns a reference to the current value in the array.",
    'flags'  => HasDocComment,
    'return' => array(
      'type'   => Variant | Reference,
      'desc'   => "Reference to the current value in the array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "next",
    'desc'   => "next() behaves like current(), with one difference. It advances the internal array pointer one place forward before returning the element value. That means it returns the next array value and advances the internal array pointer by one.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the array value in the next place that's pointed to by the internal array pointer, or FALSE if there are no more elements. WarningThis function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE, such as 0 or \"\". Please read the section on Booleans for more information. Use the === operator for testing the return value of this function.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array being affected.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "pos",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "prev",
    'desc'   => "Rewind the internal array pointer.\n\nprev() behaves just like next(), except it rewinds the internal array pointer one place instead of advancing it.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the array value in the previous place that's pointed to by the internal array pointer, or FALSE if there are no more elements.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "reset",
    'desc'   => "reset() rewinds array's internal pointer to the first element and returns the value of the first array element.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the value of the first array element, or FALSE if the array is empty.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "end",
    'desc'   => "end() advances array's internal pointer to the last element, and returns its value.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the value of the last element or FALSE for empty array.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array. This array is passed by reference because it is modified by the function. This means you must pass it a real variable and not a function returning an array because only actual variables may be passed by reference.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "key",
    'desc'   => "key() returns the index element of the current array position.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The key() function simply returns the key of the array element that's currently being pointed to by the internal pointer. It does not move the pointer in any way. If the internal pointer points beyond the end of the elements list or the array is empty, key() returns NULL.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "hphp_get_iterator",
    'desc'   => "hphp_get_iterator() returns an iterator object for an array or an object.",
    'flags'  => HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "The hphp_get_iterator() function returns an iterator object for an array or an object. It could be mutable, but only for arrays and objects that are not instances of Iterator or IteratorAggregate.",
    ),
    'args'   => array(
      array(
        'name'   => "iterable",
        'type'   => Variant | Reference,
        'desc'   => "The array or object to iterate on.",
      ),
      array(
        'name'   => "isMutable",
        'type'   => Boolean,
        'desc'   => "Whether it is a mutable iterator.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "in_array",
    'desc'   => "Searches haystack for needle.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE if needle is found in the array, FALSE otherwise.",
    ),
    'args'   => array(
      array(
        'name'   => "needle",
        'type'   => Variant,
        'desc'   => "The searched value.\n\nIf needle is a string, the comparison is done in a case-sensitive manner.",
      ),
      array(
        'name'   => "haystack",
        'type'   => Variant,
        'desc'   => "The array.",
      ),
      array(
        'name'   => "strict",
        'type'   => Boolean,
        'value'  => "false",
        'desc'   => "If the third parameter strict is set to TRUE then the in_array() function will also check the types of the needle in the haystack.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "range",
    'desc'   => "Create an array containing a range of elements.",
    'flags'  =>  HasDocComment | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array of elements from low to high, inclusive. If low > high, the sequence will be from high to low.",
    ),
    'args'   => array(
      array(
        'name'   => "low",
        'type'   => Variant,
        'desc'   => "Low value.",
      ),
      array(
        'name'   => "high",
        'type'   => Variant,
        'desc'   => "High value.",
      ),
      array(
        'name'   => "step",
        'type'   => Variant,
        'value'  => "1",
        'desc'   => "If a step value is given, it will be used as the increment between elements in the sequence. step should be given as a positive number. If not specified, step will default to 1.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_diff",
    'desc'   => "Compares array1 against array2 and returns the difference.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the entries from array1 that are not present in any of the other arrays.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array to compare from",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare against",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_udiff",
    'desc'   => "Computes the difference of arrays by using a callback function for data comparison. This is unlike array_diff() which uses an internal function for comparing the data.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values of array1 that are not present in any of the other arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "The callback comparison function.\n\nThe user supplied callback function is used for comparison. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_diff_assoc",
    'desc'   => "Compares array1 against array2 and returns the difference. Unlike array_diff() the array keys are used in the comparison.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values from array1 that are not present in any of the other arrays.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array to compare from",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare against",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_diff_uassoc",
    'desc'   => "Compares array1 against array2 and returns the difference. Unlike array_diff() the array keys are used in the comparison.\n\nUnlike array_diff_assoc() an user supplied callback function is used for the indices comparison, not internal function.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the entries from array1 that are not present in any of the other arrays.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array to compare from",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare against",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "More arrays to compare against",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_udiff_assoc",
    'desc'   => "Computes the difference of arrays with additional index check, compares data by a callback function. Please note that this function only checks one dimension of a n-dimensional array. Of course you can check deeper dimensions by using, for example, array_udiff_assoc(\$array1[0], \$array2[0], \"some_comparison_func\");.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "array_udiff_assoc() returns an array containing all the values from array1 that are not present in any of the other arguments. Note that the keys are used in the comparison unlike array_diff() and array_udiff(). The comparison of arrays' data is performed by using an user-supplied callback. In this aspect the behaviour is opposite to the behaviour of array_diff_assoc() which uses internal function for comparison.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "The callback comparison function.\n\nThe user supplied callback function is used for comparison. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_udiff_uassoc",
    'desc'   => "Computes the difference of arrays with additional index check, compares data and indexes by a callback function.\n\nNote that the keys are used in the comparison unlike array_diff() and array_udiff().",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values from array1 that are not present in any of the other arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "The callback comparison function.\n\nThe user supplied callback function is used for comparison. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.\n\nThe comparison of arrays' data is performed by using an user-supplied callback : data_compare_func. In this aspect the behaviour is opposite to the behaviour of array_diff_assoc() which uses internal function for comparison.",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "The comparison of keys (indices) is done also by the callback function key_compare_func. This behaviour is unlike what array_udiff_assoc() does, since the latter compares the indices by using an internal function.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_diff_key",
    'desc'   => "Compares the keys from array1 against the keys from array2 and returns the difference. This function is like array_diff() except the comparison is done on the keys instead of the values.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the entries from array1 whose keys are not present in any of the other arrays.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array to compare from",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare against",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_diff_ukey",
    'desc'   => "Compares the keys from array1 against the keys from array2 and returns the difference. This function is like array_diff() except the comparison is done on the keys instead of the values.\n\nUnlike array_diff_key() an user supplied callback function is used for the indices comparison, not internal function.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the entries from array1 that are not present in any of the other arrays.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array to compare from",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare against",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "More arrays to compare against",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_intersect",
    'desc'   => "array_intersect() returns an array containing all the values of array1 that are present in all the arguments. Note that keys are preserved.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all of the values in array1 whose values exist in all of the parameters.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array with master values to check.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare values against.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_uintersect",
    'desc'   => "Computes the intersection of arrays, compares data by a callback function.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values of array1 that are present in all the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "The callback comparison function.\n\nThe user supplied callback function is used for comparison. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_intersect_assoc",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an associative array containing all the values in array1 that are present in all of the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array with master values to check.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare values against.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_intersect_uassoc",
    'desc'   => "array_intersect_uassoc() returns an array containing all the values of array1 that are present in all the arguments. Note that the keys are used in the comparison unlike in array_intersect().\n\nThe index comparison is done by a user supplied callback function. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the values of array1 whose values exist in all of the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "Initial array for comparison of the arrays.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "First array to compare keys against.",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "Variable list of array arguments to compare values against.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_uintersect_assoc",
    'desc'   => "Computes the intersection of arrays with additional index check, compares data by a callback function.\n\nNote that the keys are used in the comparison unlike in array_uintersect(). The data is compared by using a callback function.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values of array1 that are present in all the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "For comparison is used the user supplied callback function. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_uintersect_uassoc",
    'desc'   => "Computes the intersection of arrays with additional index check, compares data and indexes by a callback functions Note that the keys are used in the comparison unlike in array_uintersect(). Both the data and the indexes are compared by using separate callback functions.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an array containing all the values of array1 that are present in all the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The first array.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "The second array.",
      ),
      array(
        'name'   => "data_compare_func",
        'type'   => Variant,
        'desc'   => "For comparison is used the user supplied callback function. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "Key comparison callback function.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_intersect_key",
    'desc'   => "array_intersect_key() returns an array containing all the entries of array1 which have keys that are present in all the arguments.",
    'flags'  =>  HasDocComment | VariableArguments | FunctionIsFoldable,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns an associative array containing all the entries of array1 which have keys that are present in all arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "The array with master keys to check.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "An array to compare keys against.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "array_intersect_ukey",
    'desc'   => "array_intersect_ukey() returns an array containing all the values of array1 which have matching keys that are present in all the arguments.\n\nThis comparison is done by a user supplied callback function. It must return an integer less than, equal to, or greater than zero if the first key is considered to be respectively less than, equal to, or greater than the second.",
    'flags'  =>  HasDocComment | VariableArguments,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns the values of array1 whose keys exist in all the arguments.",
    ),
    'args'   => array(
      array(
        'name'   => "array1",
        'type'   => Variant,
        'desc'   => "Initial array for comparison of the arrays.",
      ),
      array(
        'name'   => "array2",
        'type'   => Variant,
        'desc'   => "First array to compare keys against.",
      ),
      array(
        'name'   => "key_compare_func",
        'type'   => Variant,
        'desc'   => "Variable list of array arguments to compare keys against.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "sort",
    'desc'   => "This function sorts an array. Elements will be arranged from lowest to highest when this function has completed.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "The optional second parameter sort_flags may be used to modify the sorting behavior using these values:\n\nSorting type flags: SORT_REGULAR - compare items normally (don't change types) SORT_NUMERIC - compare items numerically SORT_STRING - compare items as strings SORT_LOCALE_STRING - compare items as strings, based on the current locale. Added in PHP 4.4.0 and 5.0.2, it uses the system locale, which can be changed using setlocale().",
      ),
      array(
        'name'   => "use_collator",
        'type'   => Boolean,
        'value'  => "false",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "rsort",
    'desc'   => "This function sorts an array in reverse order (highest to lowest).",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort().",
      ),
      array(
        'name'   => "use_collator",
        'type'   => Boolean,
        'value'  => "false",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "asort",
    'desc'   => "This function sorts an array such that array indices maintain their correlation with the array elements they are associated with. This is used mainly when sorting associative arrays where the actual element order is significant.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort().",
      ),
      array(
        'name'   => "use_collator",
        'type'   => Boolean,
        'value'  => "false",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "arsort",
    'desc'   => "This function sorts an array such that array indices maintain their correlation with the array elements they are associated with.\n\nThis is used mainly when sorting associative arrays where the actual element order is significant.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort().",
      ),
      array(
        'name'   => "use_collator",
        'type'   => Boolean,
        'value'  => "false",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "ksort",
    'desc'   => "Sorts an array by key, maintaining key to data correlations. This is useful mainly for associative arrays.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort().",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "krsort",
    'desc'   => "Sorts an array by key in reverse order, maintaining key to data correlations. This is useful mainly for associative arrays.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "sort_flags",
        'type'   => Int32,
        'value'  => "0",
        'desc'   => "You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort().",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "usort",
    'desc'   => "This function will sort an array by its values using a user-supplied comparison function. If the array you wish to sort needs to be sorted by some non-trivial criteria, you should use this function.\n\nIf two members compare as equal, their order in the sorted array is undefined. This function assigns new keys to the elements in array. It will remove any existing keys that may have been assigned, rather than just reordering the keys.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "cmp_function",
        'type'   => Variant,
        'desc'   => "The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "uasort",
    'desc'   => "This function sorts an array such that array indices maintain their correlation with the array elements they are associated with, using a user-defined comparison function.\n\nThis is used mainly when sorting associative arrays where the actual element order is significant.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "cmp_function",
        'type'   => Variant,
        'desc'   => "See usort() and uksort() for examples of user-defined comparison functions.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "uksort",
    'desc'   => "uksort() will sort the keys of an array using a user-supplied comparison function. If the array you wish to sort needs to be sorted by some non-trivial criteria, you should use this function.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
      array(
        'name'   => "cmp_function",
        'type'   => Variant,
        'desc'   => "The callback comparison function.\n\nFunction cmp_function should accept two parameters which will be filled by pairs of array keys. The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "natsort",
    'desc'   => "This function implements a sort algorithm that orders alphanumeric strings in the way a human being would while maintaining key/value associations. This is described as a \"natural ordering\". An example of the difference between this algorithm and the regular computer string sorting algorithms (used in sort()) can be seen in the example below.",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "natcasesort",
    'desc'   => "natcasesort() is a case insensitive version of natsort().\n\nThis function implements a sort algorithm that orders alphanumeric strings in the way a human being would while maintaining key/value associations. This is described as a \"natural ordering\".",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
      'desc'   => "Returns TRUE on success or FALSE on failure.",
    ),
    'args'   => array(
      array(
        'name'   => "array",
        'type'   => Variant | Reference,
        'desc'   => "The input array.",
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "i18n_loc_get_default",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => String,
    ),
  ));

DefineFunction(
  array(
    'name'   => "i18n_loc_set_default",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
    ),
    'args'   => array(
      array(
        'name'   => "locale",
        'type'   => String,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "i18n_loc_set_attribute",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
    ),
    'args'   => array(
      array(
        'name'   => "attr",
        'type'   => Int64,
      ),
      array(
        'name'   => "val",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "i18n_loc_set_strength",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Boolean,
    ),
    'args'   => array(
      array(
        'name'   => "strength",
        'type'   => Int64,
      ),
    ),
  ));

DefineFunction(
  array(
    'name'   => "i18n_loc_get_error_code",
    'flags'  =>  HasDocComment,
    'return' => array(
      'type'   => Variant,
    ),
  ));


///////////////////////////////////////////////////////////////////////////////
// Classes
//
// BeginClass
// array (
//   'name'   => name of the class
//   'desc'   => description of the class's purpose
//   'flags'  => attributes of the class, see base.php for possible values
//   'note'   => additional note about this class's schema
//   'parent' => parent class name, if any
//   'ifaces' => array of interfaces tihs class implements
//   'bases'  => extra internal and special base classes this class requires
//   'footer' => extra C++ inserted at end of class declaration
// )
//
// DefineConstant(..)
// DefineConstant(..)
// ...
// DefineFunction(..)
// DefineFunction(..)
// ...
// DefineProperty
// DefineProperty
//
// array (
//   'name'  => name of the property
//   'type'  => type of the property
//   'flags' => attributes of the property
//   'desc'  => description of the property
//   'note'  => additional note about this property's schema
// )
//
// EndClass()

