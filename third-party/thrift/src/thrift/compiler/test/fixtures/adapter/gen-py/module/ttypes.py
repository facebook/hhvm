#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import ::my
import my


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass

def __EXPAND_THRIFT_SPEC(spec):
    next_id = 0
    for item in spec:
        if next_id >= 0 and item[0] < 0:
            next_id = item[0]
        if item[0] != next_id:
            for _ in range(next_id, item[0]):
                yield None
        yield item
        next_id = item[0] + 1

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'Color', 'ThriftAdaptedEnum', 'MyAnnotation', 'Foo', 'Baz', 'Bar', 'DirectlyAdapted', 'IndependentDirectlyAdapted', 'StructWithFieldAdapter', 'TerseAdaptedFields', 'B', 'A', 'Config', 'MyStruct', 'AdaptTestStruct', 'AdaptTemplatedTestStruct', 'AdaptTemplatedNestedTestStruct', 'AdaptTestUnion', 'AdaptedStruct', 'DirectlyAdaptedStruct', 'StructFieldAdaptedStruct', 'CircularAdaptee', 'CircularStruct', 'ReorderedStruct', 'DeclaredAfterStruct', 'RenamedStruct', 'SameNamespaceStruct', 'HeapAllocated', 'MoveOnly', 'AlsoMoveOnly', 'ApplyAdapter', 'TransitiveAdapted', 'CountingStruct', 'Person', 'Person2', 'SetWithAdapter', 'StringWithAdapter', 'ListWithElemAdapter', 'ListWithElemAdapter_withAdapter', 'MyI64', 'DoubleTypedefI64', 'MyI32', 'FooWithAdapter', 'StructWithAdapter', 'UnionWithAdapter', 'AdaptedA', 'DurationMs', 'AdaptedBool', 'AdaptedByte', 'AdaptedShort', 'AdaptedInteger', 'AdaptedLong', 'AdaptedDouble', 'AdaptedString', 'DoubleTypedefBool', 'IOBuf', 'CustomProtocolType', 'IndirectionString', 'AdaptedEnum', 'AdaptedTypedef', 'TypedefOfDirect', 'AdaptedCircularAdaptee', 'CountingInt', 'FooWithAdapter_9317', 'ListWithElemAdapter_withAdapter_2312', 'MyI32_4873', 'StringWithAdapter_7208']

class Color:
  UNKNOWN = 0
  RED = 1
  GREEN = 2
  BLUE = 3

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "RED",
    2: "GREEN",
    3: "BLUE",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "RED": 1,
    "GREEN": 2,
    "BLUE": 3,
  }

class ThriftAdaptedEnum:
  Zero = 0
  One = 1

  _VALUES_TO_NAMES = {
    0: "Zero",
    1: "One",
  }

  _NAMES_TO_VALUES = {
    "Zero": 0,
    "One": 1,
  }

class MyAnnotation:
  r"""
  Attributes:
   - signature
   - color
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.signature = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.color = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyAnnotation')
    if self.signature != None:
      oprot.writeFieldBegin('signature', TType.STRING, 1)
      oprot.writeString(self.signature.encode('utf-8')) if UTF8STRINGS and not isinstance(self.signature, bytes) else oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    if self.color != None:
      oprot.writeFieldBegin('color', TType.I32, 2)
      oprot.writeI32(self.color)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'signature' in json_obj and json_obj['signature'] is not None:
      self.signature = json_obj['signature']
    if 'color' in json_obj and json_obj['color'] is not None:
      self.color = json_obj['color']
      if not self.color in Color._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type Color' % self.color
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.signature is not None:
      value = pprint.pformat(self.signature, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    signature=%s' % (value))
    if self.color is not None:
      value = pprint.pformat(self.color, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    color=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'signature',
      'color',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyAnnotation, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyAnnotation, self)

  def _to_py_deprecated(self):
    return self

class Foo:
  r"""
  Attributes:
   - intField
   - optionalIntField
   - intFieldWithDefault
   - setField
   - optionalSetField
   - mapField
   - optionalMapField
   - binaryField
   - longField
   - adaptedLongField
   - doubleAdaptedField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.optionalIntField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intFieldWithDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.setField = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.optionalSetField = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.mapField = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = []
              (_etype24, _size21) = iprot.readListBegin()
              if _size21 >= 0:
                for _i25 in range(_size21):
                  _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem26)
              else: 
                while iprot.peekList():
                  _elem27 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem27)
              iprot.readListEnd()
              self.mapField[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = []
              (_etype33, _size30) = iprot.readListBegin()
              if _size30 >= 0:
                for _i34 in range(_size30):
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem35)
              else: 
                while iprot.peekList():
                  _elem36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem36)
              iprot.readListEnd()
              self.mapField[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.optionalMapField = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in range(_size44):
                  _elem49 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.optionalMapField[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in range(_size53):
                  _elem58 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.optionalMapField[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryField = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.longField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.adaptedLongField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.doubleAdaptedField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Foo')
    if self.intField != None:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      oprot.writeI32(self.intField)
      oprot.writeFieldEnd()
    if self.optionalIntField != None:
      oprot.writeFieldBegin('optionalIntField', TType.I32, 2)
      oprot.writeI32(self.optionalIntField)
      oprot.writeFieldEnd()
    if self.intFieldWithDefault != None:
      oprot.writeFieldBegin('intFieldWithDefault', TType.I32, 3)
      oprot.writeI32(self.intFieldWithDefault)
      oprot.writeFieldEnd()
    if self.setField != None:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.setField))
      for iter60 in self.setField:
        oprot.writeString(iter60.encode('utf-8')) if UTF8STRINGS and not isinstance(iter60, bytes) else oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optionalSetField != None:
      oprot.writeFieldBegin('optionalSetField', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.optionalSetField))
      for iter61 in self.optionalSetField:
        oprot.writeString(iter61.encode('utf-8')) if UTF8STRINGS and not isinstance(iter61, bytes) else oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mapField != None:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapField))
      for kiter62,viter63 in self.mapField.items():
        oprot.writeString(kiter62.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter62, bytes) else oprot.writeString(kiter62)
        oprot.writeListBegin(TType.STRING, len(viter63))
        for iter64 in viter63:
          oprot.writeString(iter64.encode('utf-8')) if UTF8STRINGS and not isinstance(iter64, bytes) else oprot.writeString(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optionalMapField != None:
      oprot.writeFieldBegin('optionalMapField', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.optionalMapField))
      for kiter65,viter66 in self.optionalMapField.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        oprot.writeListBegin(TType.STRING, len(viter66))
        for iter67 in viter66:
          oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.binaryField != None:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      oprot.writeString(self.binaryField)
      oprot.writeFieldEnd()
    if self.longField != None:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      oprot.writeI64(self.longField)
      oprot.writeFieldEnd()
    if self.adaptedLongField != None:
      oprot.writeFieldBegin('adaptedLongField', TType.I64, 10)
      oprot.writeI64(self.adaptedLongField)
      oprot.writeFieldEnd()
    if self.doubleAdaptedField != None:
      oprot.writeFieldBegin('doubleAdaptedField', TType.I64, 11)
      oprot.writeI64(self.doubleAdaptedField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'intField' in json_obj and json_obj['intField'] is not None:
      self.intField = json_obj['intField']
      if self.intField > 0x7fffffff or self.intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optionalIntField' in json_obj and json_obj['optionalIntField'] is not None:
      self.optionalIntField = json_obj['optionalIntField']
      if self.optionalIntField > 0x7fffffff or self.optionalIntField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'intFieldWithDefault' in json_obj and json_obj['intFieldWithDefault'] is not None:
      self.intFieldWithDefault = json_obj['intFieldWithDefault']
      if self.intFieldWithDefault > 0x7fffffff or self.intFieldWithDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'setField' in json_obj and json_obj['setField'] is not None:
      self.setField = set_cls()
      for _tmp_e68 in json_obj['setField']:
        self.setField.add(_tmp_e68)
    if 'optionalSetField' in json_obj and json_obj['optionalSetField'] is not None:
      self.optionalSetField = set_cls()
      for _tmp_e69 in json_obj['optionalSetField']:
        self.optionalSetField.add(_tmp_e69)
    if 'mapField' in json_obj and json_obj['mapField'] is not None:
      self.mapField = dict_cls()
      for _tmp_k70, _tmp_v71 in json_obj['mapField'].items():
        _tmp_kp72 = _tmp_k70
        _list73 = []
        for _tmp_e74 in _tmp_v71:
          _list73.append(_tmp_e74)
        self.mapField[_tmp_kp72] = _list73
    if 'optionalMapField' in json_obj and json_obj['optionalMapField'] is not None:
      self.optionalMapField = dict_cls()
      for _tmp_k75, _tmp_v76 in json_obj['optionalMapField'].items():
        _tmp_kp77 = _tmp_k75
        _list78 = []
        for _tmp_e79 in _tmp_v76:
          _list78.append(_tmp_e79)
        self.optionalMapField[_tmp_kp77] = _list78
    if 'binaryField' in json_obj and json_obj['binaryField'] is not None:
      self.binaryField = json_obj['binaryField']
    if 'longField' in json_obj and json_obj['longField'] is not None:
      self.longField = long(json_obj['longField'])
    if 'adaptedLongField' in json_obj and json_obj['adaptedLongField'] is not None:
      self.adaptedLongField = long(json_obj['adaptedLongField'])
    if 'doubleAdaptedField' in json_obj and json_obj['doubleAdaptedField'] is not None:
      self.doubleAdaptedField = long(json_obj['doubleAdaptedField'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.intField is not None:
      value = pprint.pformat(self.intField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intField=%s' % (value))
    if self.optionalIntField is not None:
      value = pprint.pformat(self.optionalIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalIntField=%s' % (value))
    if self.intFieldWithDefault is not None:
      value = pprint.pformat(self.intFieldWithDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intFieldWithDefault=%s' % (value))
    if self.setField is not None:
      value = pprint.pformat(self.setField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    setField=%s' % (value))
    if self.optionalSetField is not None:
      value = pprint.pformat(self.optionalSetField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalSetField=%s' % (value))
    if self.mapField is not None:
      value = pprint.pformat(self.mapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapField=%s' % (value))
    if self.optionalMapField is not None:
      value = pprint.pformat(self.optionalMapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalMapField=%s' % (value))
    if self.binaryField is not None:
      value = pprint.pformat(self.binaryField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryField=%s' % (value))
    if self.longField is not None:
      value = pprint.pformat(self.longField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    longField=%s' % (value))
    if self.adaptedLongField is not None:
      value = pprint.pformat(self.adaptedLongField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedLongField=%s' % (value))
    if self.doubleAdaptedField is not None:
      value = pprint.pformat(self.doubleAdaptedField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleAdaptedField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'intField',
      'optionalIntField',
      'intFieldWithDefault',
      'setField',
      'optionalSetField',
      'mapField',
      'optionalMapField',
      'binaryField',
      'longField',
      'adaptedLongField',
      'doubleAdaptedField',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Foo, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Foo, self)

  def _to_py_deprecated(self):
    return self

class Baz(object):
  r"""
  Attributes:
   - intField
   - setField
   - mapField
   - binaryField
   - longField
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INTFIELD = 1
  SETFIELD = 4
  MAPFIELD = 6
  BINARYFIELD = 8
  LONGFIELD = 9
  
  @staticmethod
  def isUnion():
    return True

  def get_intField(self):
    assert self.field == 1
    return self.value

  def get_setField(self):
    assert self.field == 4
    return self.value

  def get_mapField(self):
    assert self.field == 6
    return self.value

  def get_binaryField(self):
    assert self.field == 8
    return self.value

  def get_longField(self):
    assert self.field == 9
    return self.value

  def set_intField(self, value):
    self.field = 1
    self.value = value

  def set_setField(self, value):
    self.field = 4
    self.value = value

  def set_mapField(self, value):
    self.field = 6
    self.value = value

  def set_binaryField(self, value):
    self.field = 8
    self.value = value

  def set_longField(self, value):
    self.field = 9
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('intField', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('setField', value)
    if self.field == 6:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mapField', value)
    if self.field == 8:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binaryField', value)
    if self.field == 9:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('longField', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_intField = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_intField(_fbthrift_intField)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          _fbthrift_setField = set()
          (_etype83, _size80) = iprot.readSetBegin()
          if _size80 >= 0:
            for _i84 in range(_size80):
              _elem85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem85)
          else: 
            while iprot.peekSet():
              _elem86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem86)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_setField(_fbthrift_setField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          _fbthrift_mapField = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          if _size87 >= 0:
            for _i91 in range(_size87):
              _key92 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val93 = []
              (_etype97, _size94) = iprot.readListBegin()
              if _size94 >= 0:
                for _i98 in range(_size94):
                  _elem99 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem99)
              else: 
                while iprot.peekList():
                  _elem100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem100)
              iprot.readListEnd()
              _fbthrift_mapField[_key92] = _val93
          else: 
            while iprot.peekMap():
              _key101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val102 = []
              (_etype106, _size103) = iprot.readListBegin()
              if _size103 >= 0:
                for _i107 in range(_size103):
                  _elem108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem108)
              else: 
                while iprot.peekList():
                  _elem109 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem109)
              iprot.readListEnd()
              _fbthrift_mapField[_key101] = _val102
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_mapField(_fbthrift_mapField)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          _fbthrift_binaryField = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binaryField(_fbthrift_binaryField)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          _fbthrift_longField = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_longField(_fbthrift_longField)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Baz')
    if self.field == 1:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      intField = self.value
      oprot.writeI32(intField)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      setField = self.value
      oprot.writeSetBegin(TType.STRING, len(setField))
      for iter110 in setField:
        oprot.writeString(iter110.encode('utf-8')) if UTF8STRINGS and not isinstance(iter110, bytes) else oprot.writeString(iter110)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      mapField = self.value
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(mapField))
      for kiter111,viter112 in mapField.items():
        oprot.writeString(kiter111.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter111, bytes) else oprot.writeString(kiter111)
        oprot.writeListBegin(TType.STRING, len(viter112))
        for iter113 in viter112:
          oprot.writeString(iter113.encode('utf-8')) if UTF8STRINGS and not isinstance(iter113, bytes) else oprot.writeString(iter113)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      binaryField = self.value
      oprot.writeString(binaryField)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      longField = self.value
      oprot.writeI64(longField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'intField' in obj:
      _fbthrift_intField = obj['intField']
      if _fbthrift_intField > 0x7fffffff or _fbthrift_intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_intField(_fbthrift_intField)
    if 'setField' in obj:
      _fbthrift_setField = set_cls()
      for _tmp_e114 in obj['setField']:
        _fbthrift_setField.add(_tmp_e114)
      self.set_setField(_fbthrift_setField)
    if 'mapField' in obj:
      _fbthrift_mapField = dict_cls()
      for _tmp_k115, _tmp_v116 in obj['mapField'].items():
        _tmp_kp117 = _tmp_k115
        _list118 = []
        for _tmp_e119 in _tmp_v116:
          _list118.append(_tmp_e119)
        _fbthrift_mapField[_tmp_kp117] = _list118
      self.set_mapField(_fbthrift_mapField)
    if 'binaryField' in obj:
      _fbthrift_binaryField = obj['binaryField']
      self.set_binaryField(_fbthrift_binaryField)
    if 'longField' in obj:
      _fbthrift_longField = long(obj['longField'])
      self.set_longField(_fbthrift_longField)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Baz, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Baz, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  r"""
  Attributes:
   - structField
   - optionalStructField
   - structListField
   - optionalStructListField
   - unionField
   - optionalUnionField
   - adaptedStructField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.structField = Foo()
          self.structField.read(iprot)
          self.structField = ::my.Adapter1.from_thrift(self.structField)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optionalStructField = Foo()
          self.optionalStructField.read(iprot)
          self.optionalStructField = my.Adapter1.from_thrift(self.optionalStructField)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.structListField = []
          (_etype123, _size120) = iprot.readListBegin()
          if _size120 >= 0:
            for _i124 in range(_size120):
              _elem125 = Foo()
              _elem125.read(iprot)
              _elem125 = my.Adapter1.from_thrift(_elem125)
              self.structListField.append(_elem125)
          else: 
            while iprot.peekList():
              _elem126 = Foo()
              _elem126.read(iprot)
              _elem126 = my.Adapter1.from_thrift(_elem126)
              self.structListField.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.optionalStructListField = []
          (_etype130, _size127) = iprot.readListBegin()
          if _size127 >= 0:
            for _i131 in range(_size127):
              _elem132 = Foo()
              _elem132.read(iprot)
              _elem132 = my.Adapter1.from_thrift(_elem132)
              self.optionalStructListField.append(_elem132)
          else: 
            while iprot.peekList():
              _elem133 = Foo()
              _elem133.read(iprot)
              _elem133 = my.Adapter1.from_thrift(_elem133)
              self.optionalStructListField.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.unionField = Baz()
          self.unionField.read(iprot)
          self.unionField = my.Adapter1.from_thrift(self.unionField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.optionalUnionField = Baz()
          self.optionalUnionField.read(iprot)
          self.optionalUnionField = my.Adapter1.from_thrift(self.optionalUnionField)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.adaptedStructField = DirectlyAdapted()
          self.adaptedStructField.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.structField != None:
      oprot.writeFieldBegin('structField', TType.STRUCT, 1)
      adpt134 = ::my.Adapter1.to_thrift(self.structField)
      adpt134.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalStructField != None:
      oprot.writeFieldBegin('optionalStructField', TType.STRUCT, 2)
      adpt135 = my.Adapter1.to_thrift(self.optionalStructField)
      adpt135.write(oprot)
      oprot.writeFieldEnd()
    if self.structListField != None:
      oprot.writeFieldBegin('structListField', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.structListField))
      for iter136 in self.structListField:
        adpt137 = my.Adapter1.to_thrift(iter136)
        adpt137.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optionalStructListField != None:
      oprot.writeFieldBegin('optionalStructListField', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.optionalStructListField))
      for iter138 in self.optionalStructListField:
        adpt139 = my.Adapter1.to_thrift(iter138)
        adpt139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unionField != None:
      oprot.writeFieldBegin('unionField', TType.STRUCT, 5)
      adpt140 = my.Adapter1.to_thrift(self.unionField)
      adpt140.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalUnionField != None:
      oprot.writeFieldBegin('optionalUnionField', TType.STRUCT, 6)
      adpt141 = my.Adapter1.to_thrift(self.optionalUnionField)
      adpt141.write(oprot)
      oprot.writeFieldEnd()
    if self.adaptedStructField != None:
      oprot.writeFieldBegin('adaptedStructField', TType.STRUCT, 7)
      self.adaptedStructField.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structField' in json_obj and json_obj['structField'] is not None:
      self.structField = Foo()
      self.structField.readFromJson(json_obj['structField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalStructField' in json_obj and json_obj['optionalStructField'] is not None:
      self.optionalStructField = Foo()
      self.optionalStructField.readFromJson(json_obj['optionalStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structListField' in json_obj and json_obj['structListField'] is not None:
      self.structListField = []
      for _tmp_e142 in json_obj['structListField']:
        _struct143 = Foo()
        _struct143.readFromJson(_tmp_e142, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.structListField.append(_struct143)
    if 'optionalStructListField' in json_obj and json_obj['optionalStructListField'] is not None:
      self.optionalStructListField = []
      for _tmp_e144 in json_obj['optionalStructListField']:
        _struct145 = Foo()
        _struct145.readFromJson(_tmp_e144, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.optionalStructListField.append(_struct145)
    if 'unionField' in json_obj and json_obj['unionField'] is not None:
      self.unionField = Baz()
      self.unionField.readFromJson(json_obj['unionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalUnionField' in json_obj and json_obj['optionalUnionField'] is not None:
      self.optionalUnionField = Baz()
      self.optionalUnionField.readFromJson(json_obj['optionalUnionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'adaptedStructField' in json_obj and json_obj['adaptedStructField'] is not None:
      self.adaptedStructField = DirectlyAdapted()
      self.adaptedStructField.readFromJson(json_obj['adaptedStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structField is not None:
      value = pprint.pformat(self.structField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structField=%s' % (value))
    if self.optionalStructField is not None:
      value = pprint.pformat(self.optionalStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructField=%s' % (value))
    if self.structListField is not None:
      value = pprint.pformat(self.structListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structListField=%s' % (value))
    if self.optionalStructListField is not None:
      value = pprint.pformat(self.optionalStructListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructListField=%s' % (value))
    if self.unionField is not None:
      value = pprint.pformat(self.unionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionField=%s' % (value))
    if self.optionalUnionField is not None:
      value = pprint.pformat(self.optionalUnionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalUnionField=%s' % (value))
    if self.adaptedStructField is not None:
      value = pprint.pformat(self.adaptedStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStructField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structField',
      'optionalStructField',
      'structListField',
      'optionalStructListField',
      'unionField',
      'optionalUnionField',
      'adaptedStructField',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class DirectlyAdapted:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirectlyAdapted')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DirectlyAdapted, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DirectlyAdapted, self)

  def _to_py_deprecated(self):
    return self

class IndependentDirectlyAdapted:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IndependentDirectlyAdapted')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.IndependentDirectlyAdapted, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.IndependentDirectlyAdapted, self)

  def _to_py_deprecated(self):
    return self

class StructWithFieldAdapter:
  r"""
  Attributes:
   - field
   - shared_field
   - opt_shared_field
   - opt_boxed_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.opt_shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.opt_boxed_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithFieldAdapter')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.shared_field != None:
      oprot.writeFieldBegin('shared_field', TType.I32, 2)
      oprot.writeI32(self.shared_field)
      oprot.writeFieldEnd()
    if self.opt_shared_field != None:
      oprot.writeFieldBegin('opt_shared_field', TType.I32, 3)
      oprot.writeI32(self.opt_shared_field)
      oprot.writeFieldEnd()
    if self.opt_boxed_field != None:
      oprot.writeFieldBegin('opt_boxed_field', TType.I32, 4)
      oprot.writeI32(self.opt_boxed_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'shared_field' in json_obj and json_obj['shared_field'] is not None:
      self.shared_field = json_obj['shared_field']
      if self.shared_field > 0x7fffffff or self.shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_shared_field' in json_obj and json_obj['opt_shared_field'] is not None:
      self.opt_shared_field = json_obj['opt_shared_field']
      if self.opt_shared_field > 0x7fffffff or self.opt_shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_boxed_field' in json_obj and json_obj['opt_boxed_field'] is not None:
      self.opt_boxed_field = json_obj['opt_boxed_field']
      if self.opt_boxed_field > 0x7fffffff or self.opt_boxed_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.shared_field is not None:
      value = pprint.pformat(self.shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    shared_field=%s' % (value))
    if self.opt_shared_field is not None:
      value = pprint.pformat(self.opt_shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_shared_field=%s' % (value))
    if self.opt_boxed_field is not None:
      value = pprint.pformat(self.opt_boxed_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_boxed_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'shared_field',
      'opt_shared_field',
      'opt_boxed_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructWithFieldAdapter, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructWithFieldAdapter, self)

  def _to_py_deprecated(self):
    return self

class TerseAdaptedFields:
  r"""
  Attributes:
   - int_field
   - string_field
   - set_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype149, _size146) = iprot.readSetBegin()
          if _size146 >= 0:
            for _i150 in range(_size146):
              _elem151 = iprot.readI32()
              self.set_field.add(_elem151)
          else: 
            while iprot.peekSet():
              _elem152 = iprot.readI32()
              self.set_field.add(_elem152)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseAdaptedFields')
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 1)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 2)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 3)
      oprot.writeSetBegin(TType.I32, len(self.set_field))
      for iter153 in self.set_field:
        oprot.writeI32(iter153)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e154 in json_obj['set_field']:
        if _tmp_e154 > 0x7fffffff or _tmp_e154 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e154)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'int_field',
      'string_field',
      'set_field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseAdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseAdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class B:
  r"""
  Attributes:
   - a
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.a = A()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('B')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRUCT, 1)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'a' in json_obj and json_obj['a'] is not None:
      self.a = A()
      self.a.readFromJson(json_obj['a'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.B, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.B, self)

  def _to_py_deprecated(self):
    return self

class A:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('A')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.A, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.A, self)

  def _to_py_deprecated(self):
    return self

class Config:
  r"""
  Attributes:
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Config')
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path.encode('utf-8')) if UTF8STRINGS and not isinstance(self.path, bytes) else oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'path' in json_obj and json_obj['path'] is not None:
      self.path = json_obj['path']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'path',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Config, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Config, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  r"""
  Attributes:
   - field
   - set_string
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.set_string = set()
          (_etype158, _size155) = iprot.readSetBegin()
          if _size155 >= 0:
            for _i159 in range(_size155):
              _elem160 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem160)
          else: 
            while iprot.peekSet():
              _elem161 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem161)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.set_string != None:
      oprot.writeFieldBegin('set_string', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.set_string))
      for iter162 in self.set_string:
        oprot.writeString(iter162.encode('utf-8')) if UTF8STRINGS and not isinstance(iter162, bytes) else oprot.writeString(iter162)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'set_string' in json_obj and json_obj['set_string'] is not None:
      self.set_string = set_cls()
      for _tmp_e163 in json_obj['set_string']:
        self.set_string.add(_tmp_e163)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.set_string is not None:
      value = pprint.pformat(self.set_string, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_string=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'set_string',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

class AdaptTestStruct:
  r"""
  Attributes:
   - delay
   - custom
   - timeout
   - data
   - meta
   - indirectionString
   - string_data
   - double_wrapped_bool
   - double_wrapped_integer
   - binary_data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.delay = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.custom = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timeout = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.data = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.meta = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.indirectionString = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.string_data = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.double_wrapped_bool = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.double_wrapped_integer = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.binary_data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptTestStruct')
    if self.delay != None:
      oprot.writeFieldBegin('delay', TType.I64, 1)
      oprot.writeI64(self.delay)
      oprot.writeFieldEnd()
    if self.custom != None:
      oprot.writeFieldBegin('custom', TType.STRING, 2)
      oprot.writeString(self.custom)
      oprot.writeFieldEnd()
    if self.timeout != None:
      oprot.writeFieldBegin('timeout', TType.I64, 3)
      oprot.writeI64(self.timeout)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.I64, 4)
      oprot.writeI64(self.data)
      oprot.writeFieldEnd()
    if self.meta != None:
      oprot.writeFieldBegin('meta', TType.STRING, 5)
      oprot.writeString(self.meta.encode('utf-8')) if UTF8STRINGS and not isinstance(self.meta, bytes) else oprot.writeString(self.meta)
      oprot.writeFieldEnd()
    if self.indirectionString != None:
      oprot.writeFieldBegin('indirectionString', TType.STRING, 6)
      oprot.writeString(self.indirectionString.encode('utf-8')) if UTF8STRINGS and not isinstance(self.indirectionString, bytes) else oprot.writeString(self.indirectionString)
      oprot.writeFieldEnd()
    if self.string_data != None:
      oprot.writeFieldBegin('string_data', TType.STRING, 7)
      oprot.writeString(self.string_data.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_data, bytes) else oprot.writeString(self.string_data)
      oprot.writeFieldEnd()
    if self.double_wrapped_bool != None:
      oprot.writeFieldBegin('double_wrapped_bool', TType.BOOL, 8)
      oprot.writeBool(self.double_wrapped_bool)
      oprot.writeFieldEnd()
    if self.double_wrapped_integer != None:
      oprot.writeFieldBegin('double_wrapped_integer', TType.I32, 9)
      oprot.writeI32(self.double_wrapped_integer)
      oprot.writeFieldEnd()
    if self.binary_data != None:
      oprot.writeFieldBegin('binary_data', TType.STRING, 10)
      oprot.writeString(self.binary_data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'delay' in json_obj and json_obj['delay'] is not None:
      self.delay = long(json_obj['delay'])
    if 'custom' in json_obj and json_obj['custom'] is not None:
      self.custom = json_obj['custom']
    if 'timeout' in json_obj and json_obj['timeout'] is not None:
      self.timeout = long(json_obj['timeout'])
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = long(json_obj['data'])
    if 'meta' in json_obj and json_obj['meta'] is not None:
      self.meta = json_obj['meta']
    if 'indirectionString' in json_obj and json_obj['indirectionString'] is not None:
      self.indirectionString = json_obj['indirectionString']
    if 'string_data' in json_obj and json_obj['string_data'] is not None:
      self.string_data = json_obj['string_data']
    if 'double_wrapped_bool' in json_obj and json_obj['double_wrapped_bool'] is not None:
      self.double_wrapped_bool = json_obj['double_wrapped_bool']
    if 'double_wrapped_integer' in json_obj and json_obj['double_wrapped_integer'] is not None:
      self.double_wrapped_integer = json_obj['double_wrapped_integer']
      if self.double_wrapped_integer > 0x7fffffff or self.double_wrapped_integer < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'binary_data' in json_obj and json_obj['binary_data'] is not None:
      self.binary_data = json_obj['binary_data']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.delay is not None:
      value = pprint.pformat(self.delay, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    delay=%s' % (value))
    if self.custom is not None:
      value = pprint.pformat(self.custom, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    custom=%s' % (value))
    if self.timeout is not None:
      value = pprint.pformat(self.timeout, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    timeout=%s' % (value))
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    if self.meta is not None:
      value = pprint.pformat(self.meta, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    meta=%s' % (value))
    if self.indirectionString is not None:
      value = pprint.pformat(self.indirectionString, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    indirectionString=%s' % (value))
    if self.string_data is not None:
      value = pprint.pformat(self.string_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_data=%s' % (value))
    if self.double_wrapped_bool is not None:
      value = pprint.pformat(self.double_wrapped_bool, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_wrapped_bool=%s' % (value))
    if self.double_wrapped_integer is not None:
      value = pprint.pformat(self.double_wrapped_integer, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    double_wrapped_integer=%s' % (value))
    if self.binary_data is not None:
      value = pprint.pformat(self.binary_data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binary_data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'delay',
      'custom',
      'timeout',
      'data',
      'meta',
      'indirectionString',
      'string_data',
      'double_wrapped_bool',
      'double_wrapped_integer',
      'binary_data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptTestStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptTestStruct, self)

  def _to_py_deprecated(self):
    return self

class AdaptTemplatedTestStruct:
  r"""
  Attributes:
   - adaptedBool
   - adaptedByte
   - adaptedShort
   - adaptedInteger
   - adaptedLong
   - adaptedDouble
   - adaptedString
   - adaptedList
   - adaptedSet
   - adaptedMap
   - adaptedBoolDefault
   - adaptedByteDefault
   - adaptedShortDefault
   - adaptedIntegerDefault
   - adaptedLongDefault
   - adaptedDoubleDefault
   - adaptedStringDefault
   - adaptedEnum
   - adaptedListDefault
   - adaptedSetDefault
   - adaptedMapDefault
   - doubleTypedefBool
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.adaptedBool = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.adaptedByte = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.adaptedShort = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.adaptedInteger = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.adaptedLong = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.adaptedDouble = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.adaptedString = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.adaptedList = []
          (_etype167, _size164) = iprot.readListBegin()
          if _size164 >= 0:
            for _i168 in range(_size164):
              _elem169 = iprot.readI64()
              self.adaptedList.append(_elem169)
          else: 
            while iprot.peekList():
              _elem170 = iprot.readI64()
              self.adaptedList.append(_elem170)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.SET:
          self.adaptedSet = set()
          (_etype174, _size171) = iprot.readSetBegin()
          if _size171 >= 0:
            for _i175 in range(_size171):
              _elem176 = iprot.readI64()
              self.adaptedSet.add(_elem176)
          else: 
            while iprot.peekSet():
              _elem177 = iprot.readI64()
              self.adaptedSet.add(_elem177)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.adaptedMap = {}
          (_ktype179, _vtype180, _size178 ) = iprot.readMapBegin() 
          if _size178 >= 0:
            for _i182 in range(_size178):
              _key183 = iprot.readI64()
              _val184 = iprot.readI64()
              self.adaptedMap[_key183] = _val184
          else: 
            while iprot.peekMap():
              _key185 = iprot.readI64()
              _val186 = iprot.readI64()
              self.adaptedMap[_key185] = _val186
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.adaptedBoolDefault = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BYTE:
          self.adaptedByteDefault = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I16:
          self.adaptedShortDefault = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.adaptedIntegerDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.adaptedLongDefault = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.DOUBLE:
          self.adaptedDoubleDefault = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRING:
          self.adaptedStringDefault = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I32:
          self.adaptedEnum = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.LIST:
          self.adaptedListDefault = []
          (_etype190, _size187) = iprot.readListBegin()
          if _size187 >= 0:
            for _i191 in range(_size187):
              _elem192 = iprot.readI64()
              self.adaptedListDefault.append(_elem192)
          else: 
            while iprot.peekList():
              _elem193 = iprot.readI64()
              self.adaptedListDefault.append(_elem193)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.SET:
          self.adaptedSetDefault = set()
          (_etype197, _size194) = iprot.readSetBegin()
          if _size194 >= 0:
            for _i198 in range(_size194):
              _elem199 = iprot.readI64()
              self.adaptedSetDefault.add(_elem199)
          else: 
            while iprot.peekSet():
              _elem200 = iprot.readI64()
              self.adaptedSetDefault.add(_elem200)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.MAP:
          self.adaptedMapDefault = {}
          (_ktype202, _vtype203, _size201 ) = iprot.readMapBegin() 
          if _size201 >= 0:
            for _i205 in range(_size201):
              _key206 = iprot.readI64()
              _val207 = iprot.readI64()
              self.adaptedMapDefault[_key206] = _val207
          else: 
            while iprot.peekMap():
              _key208 = iprot.readI64()
              _val209 = iprot.readI64()
              self.adaptedMapDefault[_key208] = _val209
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.BOOL:
          self.doubleTypedefBool = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptTemplatedTestStruct')
    if self.adaptedBool != None:
      oprot.writeFieldBegin('adaptedBool', TType.BOOL, 1)
      oprot.writeBool(self.adaptedBool)
      oprot.writeFieldEnd()
    if self.adaptedByte != None:
      oprot.writeFieldBegin('adaptedByte', TType.BYTE, 2)
      oprot.writeByte(self.adaptedByte)
      oprot.writeFieldEnd()
    if self.adaptedShort != None:
      oprot.writeFieldBegin('adaptedShort', TType.I16, 3)
      oprot.writeI16(self.adaptedShort)
      oprot.writeFieldEnd()
    if self.adaptedInteger != None:
      oprot.writeFieldBegin('adaptedInteger', TType.I32, 4)
      oprot.writeI32(self.adaptedInteger)
      oprot.writeFieldEnd()
    if self.adaptedLong != None:
      oprot.writeFieldBegin('adaptedLong', TType.I64, 5)
      oprot.writeI64(self.adaptedLong)
      oprot.writeFieldEnd()
    if self.adaptedDouble != None:
      oprot.writeFieldBegin('adaptedDouble', TType.DOUBLE, 6)
      oprot.writeDouble(self.adaptedDouble)
      oprot.writeFieldEnd()
    if self.adaptedString != None:
      oprot.writeFieldBegin('adaptedString', TType.STRING, 7)
      oprot.writeString(self.adaptedString.encode('utf-8')) if UTF8STRINGS and not isinstance(self.adaptedString, bytes) else oprot.writeString(self.adaptedString)
      oprot.writeFieldEnd()
    if self.adaptedList != None:
      oprot.writeFieldBegin('adaptedList', TType.LIST, 8)
      oprot.writeListBegin(TType.I64, len(self.adaptedList))
      for iter210 in self.adaptedList:
        oprot.writeI64(iter210)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.adaptedSet != None:
      oprot.writeFieldBegin('adaptedSet', TType.SET, 9)
      oprot.writeSetBegin(TType.I64, len(self.adaptedSet))
      for iter211 in self.adaptedSet:
        oprot.writeI64(iter211)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.adaptedMap != None:
      oprot.writeFieldBegin('adaptedMap', TType.MAP, 10)
      oprot.writeMapBegin(TType.I64, TType.I64, len(self.adaptedMap))
      for kiter212,viter213 in self.adaptedMap.items():
        oprot.writeI64(kiter212)
        oprot.writeI64(viter213)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.adaptedBoolDefault != None:
      oprot.writeFieldBegin('adaptedBoolDefault', TType.BOOL, 11)
      oprot.writeBool(self.adaptedBoolDefault)
      oprot.writeFieldEnd()
    if self.adaptedByteDefault != None:
      oprot.writeFieldBegin('adaptedByteDefault', TType.BYTE, 12)
      oprot.writeByte(self.adaptedByteDefault)
      oprot.writeFieldEnd()
    if self.adaptedShortDefault != None:
      oprot.writeFieldBegin('adaptedShortDefault', TType.I16, 13)
      oprot.writeI16(self.adaptedShortDefault)
      oprot.writeFieldEnd()
    if self.adaptedIntegerDefault != None:
      oprot.writeFieldBegin('adaptedIntegerDefault', TType.I32, 14)
      oprot.writeI32(self.adaptedIntegerDefault)
      oprot.writeFieldEnd()
    if self.adaptedLongDefault != None:
      oprot.writeFieldBegin('adaptedLongDefault', TType.I64, 15)
      oprot.writeI64(self.adaptedLongDefault)
      oprot.writeFieldEnd()
    if self.adaptedDoubleDefault != None:
      oprot.writeFieldBegin('adaptedDoubleDefault', TType.DOUBLE, 16)
      oprot.writeDouble(self.adaptedDoubleDefault)
      oprot.writeFieldEnd()
    if self.adaptedStringDefault != None:
      oprot.writeFieldBegin('adaptedStringDefault', TType.STRING, 17)
      oprot.writeString(self.adaptedStringDefault.encode('utf-8')) if UTF8STRINGS and not isinstance(self.adaptedStringDefault, bytes) else oprot.writeString(self.adaptedStringDefault)
      oprot.writeFieldEnd()
    if self.adaptedEnum != None:
      oprot.writeFieldBegin('adaptedEnum', TType.I32, 18)
      oprot.writeI32(self.adaptedEnum)
      oprot.writeFieldEnd()
    if self.adaptedListDefault != None:
      oprot.writeFieldBegin('adaptedListDefault', TType.LIST, 19)
      oprot.writeListBegin(TType.I64, len(self.adaptedListDefault))
      for iter214 in self.adaptedListDefault:
        oprot.writeI64(iter214)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.adaptedSetDefault != None:
      oprot.writeFieldBegin('adaptedSetDefault', TType.SET, 20)
      oprot.writeSetBegin(TType.I64, len(self.adaptedSetDefault))
      for iter215 in self.adaptedSetDefault:
        oprot.writeI64(iter215)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.adaptedMapDefault != None:
      oprot.writeFieldBegin('adaptedMapDefault', TType.MAP, 21)
      oprot.writeMapBegin(TType.I64, TType.I64, len(self.adaptedMapDefault))
      for kiter216,viter217 in self.adaptedMapDefault.items():
        oprot.writeI64(kiter216)
        oprot.writeI64(viter217)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.doubleTypedefBool != None:
      oprot.writeFieldBegin('doubleTypedefBool', TType.BOOL, 22)
      oprot.writeBool(self.doubleTypedefBool)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'adaptedBool' in json_obj and json_obj['adaptedBool'] is not None:
      self.adaptedBool = json_obj['adaptedBool']
    if 'adaptedByte' in json_obj and json_obj['adaptedByte'] is not None:
      self.adaptedByte = json_obj['adaptedByte']
      if self.adaptedByte > 0x7f or self.adaptedByte < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedShort' in json_obj and json_obj['adaptedShort'] is not None:
      self.adaptedShort = json_obj['adaptedShort']
      if self.adaptedShort > 0x7fff or self.adaptedShort < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedInteger' in json_obj and json_obj['adaptedInteger'] is not None:
      self.adaptedInteger = json_obj['adaptedInteger']
      if self.adaptedInteger > 0x7fffffff or self.adaptedInteger < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedLong' in json_obj and json_obj['adaptedLong'] is not None:
      self.adaptedLong = long(json_obj['adaptedLong'])
    if 'adaptedDouble' in json_obj and json_obj['adaptedDouble'] is not None:
      self.adaptedDouble = float(json_obj['adaptedDouble'])
    if 'adaptedString' in json_obj and json_obj['adaptedString'] is not None:
      self.adaptedString = json_obj['adaptedString']
    if 'adaptedList' in json_obj and json_obj['adaptedList'] is not None:
      self.adaptedList = []
      for _tmp_e218 in json_obj['adaptedList']:
        self.adaptedList.append(_tmp_e218)
    if 'adaptedSet' in json_obj and json_obj['adaptedSet'] is not None:
      self.adaptedSet = set_cls()
      for _tmp_e219 in json_obj['adaptedSet']:
        self.adaptedSet.add(_tmp_e219)
    if 'adaptedMap' in json_obj and json_obj['adaptedMap'] is not None:
      self.adaptedMap = dict_cls()
      for _tmp_k220, _tmp_v221 in json_obj['adaptedMap'].items():
        _tmp_kp222 = long(_tmp_k220)
        self.adaptedMap[_tmp_kp222] = _tmp_v221
    if 'adaptedBoolDefault' in json_obj and json_obj['adaptedBoolDefault'] is not None:
      self.adaptedBoolDefault = json_obj['adaptedBoolDefault']
    if 'adaptedByteDefault' in json_obj and json_obj['adaptedByteDefault'] is not None:
      self.adaptedByteDefault = json_obj['adaptedByteDefault']
      if self.adaptedByteDefault > 0x7f or self.adaptedByteDefault < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedShortDefault' in json_obj and json_obj['adaptedShortDefault'] is not None:
      self.adaptedShortDefault = json_obj['adaptedShortDefault']
      if self.adaptedShortDefault > 0x7fff or self.adaptedShortDefault < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedIntegerDefault' in json_obj and json_obj['adaptedIntegerDefault'] is not None:
      self.adaptedIntegerDefault = json_obj['adaptedIntegerDefault']
      if self.adaptedIntegerDefault > 0x7fffffff or self.adaptedIntegerDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'adaptedLongDefault' in json_obj and json_obj['adaptedLongDefault'] is not None:
      self.adaptedLongDefault = long(json_obj['adaptedLongDefault'])
    if 'adaptedDoubleDefault' in json_obj and json_obj['adaptedDoubleDefault'] is not None:
      self.adaptedDoubleDefault = float(json_obj['adaptedDoubleDefault'])
    if 'adaptedStringDefault' in json_obj and json_obj['adaptedStringDefault'] is not None:
      self.adaptedStringDefault = json_obj['adaptedStringDefault']
    if 'adaptedEnum' in json_obj and json_obj['adaptedEnum'] is not None:
      self.adaptedEnum = json_obj['adaptedEnum']
      if not self.adaptedEnum in ThriftAdaptedEnum._VALUES_TO_NAMES:
        msg = 'Integer value ''%s'' is not a recognized value of enum type ThriftAdaptedEnum' % self.adaptedEnum
        if relax_enum_validation:
            warnings.warn(msg)
        else:
            raise TProtocolException(TProtocolException.INVALID_DATA, msg)
    if 'adaptedListDefault' in json_obj and json_obj['adaptedListDefault'] is not None:
      self.adaptedListDefault = []
      for _tmp_e223 in json_obj['adaptedListDefault']:
        self.adaptedListDefault.append(_tmp_e223)
    if 'adaptedSetDefault' in json_obj and json_obj['adaptedSetDefault'] is not None:
      self.adaptedSetDefault = set_cls()
      for _tmp_e224 in json_obj['adaptedSetDefault']:
        self.adaptedSetDefault.add(_tmp_e224)
    if 'adaptedMapDefault' in json_obj and json_obj['adaptedMapDefault'] is not None:
      self.adaptedMapDefault = dict_cls()
      for _tmp_k225, _tmp_v226 in json_obj['adaptedMapDefault'].items():
        _tmp_kp227 = long(_tmp_k225)
        self.adaptedMapDefault[_tmp_kp227] = _tmp_v226
    if 'doubleTypedefBool' in json_obj and json_obj['doubleTypedefBool'] is not None:
      self.doubleTypedefBool = json_obj['doubleTypedefBool']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.adaptedBool is not None:
      value = pprint.pformat(self.adaptedBool, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedBool=%s' % (value))
    if self.adaptedByte is not None:
      value = pprint.pformat(self.adaptedByte, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedByte=%s' % (value))
    if self.adaptedShort is not None:
      value = pprint.pformat(self.adaptedShort, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedShort=%s' % (value))
    if self.adaptedInteger is not None:
      value = pprint.pformat(self.adaptedInteger, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedInteger=%s' % (value))
    if self.adaptedLong is not None:
      value = pprint.pformat(self.adaptedLong, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedLong=%s' % (value))
    if self.adaptedDouble is not None:
      value = pprint.pformat(self.adaptedDouble, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedDouble=%s' % (value))
    if self.adaptedString is not None:
      value = pprint.pformat(self.adaptedString, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedString=%s' % (value))
    if self.adaptedList is not None:
      value = pprint.pformat(self.adaptedList, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedList=%s' % (value))
    if self.adaptedSet is not None:
      value = pprint.pformat(self.adaptedSet, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedSet=%s' % (value))
    if self.adaptedMap is not None:
      value = pprint.pformat(self.adaptedMap, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedMap=%s' % (value))
    if self.adaptedBoolDefault is not None:
      value = pprint.pformat(self.adaptedBoolDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedBoolDefault=%s' % (value))
    if self.adaptedByteDefault is not None:
      value = pprint.pformat(self.adaptedByteDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedByteDefault=%s' % (value))
    if self.adaptedShortDefault is not None:
      value = pprint.pformat(self.adaptedShortDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedShortDefault=%s' % (value))
    if self.adaptedIntegerDefault is not None:
      value = pprint.pformat(self.adaptedIntegerDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedIntegerDefault=%s' % (value))
    if self.adaptedLongDefault is not None:
      value = pprint.pformat(self.adaptedLongDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedLongDefault=%s' % (value))
    if self.adaptedDoubleDefault is not None:
      value = pprint.pformat(self.adaptedDoubleDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedDoubleDefault=%s' % (value))
    if self.adaptedStringDefault is not None:
      value = pprint.pformat(self.adaptedStringDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStringDefault=%s' % (value))
    if self.adaptedEnum is not None:
      value = pprint.pformat(self.adaptedEnum, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedEnum=%s' % (value))
    if self.adaptedListDefault is not None:
      value = pprint.pformat(self.adaptedListDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedListDefault=%s' % (value))
    if self.adaptedSetDefault is not None:
      value = pprint.pformat(self.adaptedSetDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedSetDefault=%s' % (value))
    if self.adaptedMapDefault is not None:
      value = pprint.pformat(self.adaptedMapDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedMapDefault=%s' % (value))
    if self.doubleTypedefBool is not None:
      value = pprint.pformat(self.doubleTypedefBool, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleTypedefBool=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'adaptedBool',
      'adaptedByte',
      'adaptedShort',
      'adaptedInteger',
      'adaptedLong',
      'adaptedDouble',
      'adaptedString',
      'adaptedList',
      'adaptedSet',
      'adaptedMap',
      'adaptedBoolDefault',
      'adaptedByteDefault',
      'adaptedShortDefault',
      'adaptedIntegerDefault',
      'adaptedLongDefault',
      'adaptedDoubleDefault',
      'adaptedStringDefault',
      'adaptedEnum',
      'adaptedListDefault',
      'adaptedSetDefault',
      'adaptedMapDefault',
      'doubleTypedefBool',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptTemplatedTestStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptTemplatedTestStruct, self)

  def _to_py_deprecated(self):
    return self

class AdaptTemplatedNestedTestStruct:
  r"""
  Attributes:
   - adaptedStruct
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.adaptedStruct = AdaptTemplatedTestStruct()
          self.adaptedStruct.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptTemplatedNestedTestStruct')
    if self.adaptedStruct != None:
      oprot.writeFieldBegin('adaptedStruct', TType.STRUCT, 1)
      self.adaptedStruct.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'adaptedStruct' in json_obj and json_obj['adaptedStruct'] is not None:
      self.adaptedStruct = AdaptTemplatedTestStruct()
      self.adaptedStruct.readFromJson(json_obj['adaptedStruct'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.adaptedStruct is not None:
      value = pprint.pformat(self.adaptedStruct, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStruct=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'adaptedStruct',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptTemplatedNestedTestStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptTemplatedNestedTestStruct, self)

  def _to_py_deprecated(self):
    return self

class AdaptTestUnion(object):
  r"""
  Attributes:
   - delay
   - custom
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  DELAY = 1
  CUSTOM = 2
  
  @staticmethod
  def isUnion():
    return True

  def get_delay(self):
    assert self.field == 1
    return self.value

  def get_custom(self):
    assert self.field == 2
    return self.value

  def set_delay(self, value):
    self.field = 1
    self.value = value

  def set_custom(self, value):
    self.field = 2
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 6
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('delay', value)
    if self.field == 2:
      padding = ' ' * 7
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('custom', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I64:
          _fbthrift_delay = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_delay(_fbthrift_delay)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          _fbthrift_custom = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_custom(_fbthrift_custom)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('AdaptTestUnion')
    if self.field == 1:
      oprot.writeFieldBegin('delay', TType.I64, 1)
      delay = self.value
      oprot.writeI64(delay)
      oprot.writeFieldEnd()
    if self.field == 2:
      oprot.writeFieldBegin('custom', TType.STRING, 2)
      custom = self.value
      oprot.writeString(custom)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'delay' in obj:
      _fbthrift_delay = long(obj['delay'])
      self.set_delay(_fbthrift_delay)
    if 'custom' in obj:
      _fbthrift_custom = obj['custom']
      self.set_custom(_fbthrift_custom)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptTestUnion, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptTestUnion, self)

  def _to_py_deprecated(self):
    return self

class AdaptedStruct:
  r"""
  Attributes:
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.data = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdaptedStruct')
    if self.data != None:
      oprot.writeFieldBegin('data', TType.I64, 1)
      oprot.writeI64(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = long(json_obj['data'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AdaptedStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AdaptedStruct, self)

  def _to_py_deprecated(self):
    return self

class DirectlyAdaptedStruct:
  r"""
  Attributes:
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.data = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirectlyAdaptedStruct')
    if self.data != None:
      oprot.writeFieldBegin('data', TType.I64, 1)
      oprot.writeI64(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = long(json_obj['data'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DirectlyAdaptedStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DirectlyAdaptedStruct, self)

  def _to_py_deprecated(self):
    return self

class StructFieldAdaptedStruct:
  r"""
  Attributes:
   - adaptedStruct
   - adaptedTypedef
   - directlyAdapted
   - typedefOfAdapted
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.adaptedStruct = AdaptedStruct()
          self.adaptedStruct.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.adaptedTypedef = AdaptedStruct()
          self.adaptedTypedef.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.directlyAdapted = DirectlyAdaptedStruct()
          self.directlyAdapted.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.typedefOfAdapted = DirectlyAdaptedStruct()
          self.typedefOfAdapted.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructFieldAdaptedStruct')
    if self.adaptedStruct != None:
      oprot.writeFieldBegin('adaptedStruct', TType.STRUCT, 1)
      self.adaptedStruct.write(oprot)
      oprot.writeFieldEnd()
    if self.adaptedTypedef != None:
      oprot.writeFieldBegin('adaptedTypedef', TType.STRUCT, 2)
      self.adaptedTypedef.write(oprot)
      oprot.writeFieldEnd()
    if self.directlyAdapted != None:
      oprot.writeFieldBegin('directlyAdapted', TType.STRUCT, 3)
      self.directlyAdapted.write(oprot)
      oprot.writeFieldEnd()
    if self.typedefOfAdapted != None:
      oprot.writeFieldBegin('typedefOfAdapted', TType.STRUCT, 4)
      self.typedefOfAdapted.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'adaptedStruct' in json_obj and json_obj['adaptedStruct'] is not None:
      self.adaptedStruct = AdaptedStruct()
      self.adaptedStruct.readFromJson(json_obj['adaptedStruct'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'adaptedTypedef' in json_obj and json_obj['adaptedTypedef'] is not None:
      self.adaptedTypedef = AdaptedStruct()
      self.adaptedTypedef.readFromJson(json_obj['adaptedTypedef'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'directlyAdapted' in json_obj and json_obj['directlyAdapted'] is not None:
      self.directlyAdapted = DirectlyAdaptedStruct()
      self.directlyAdapted.readFromJson(json_obj['directlyAdapted'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'typedefOfAdapted' in json_obj and json_obj['typedefOfAdapted'] is not None:
      self.typedefOfAdapted = DirectlyAdaptedStruct()
      self.typedefOfAdapted.readFromJson(json_obj['typedefOfAdapted'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.adaptedStruct is not None:
      value = pprint.pformat(self.adaptedStruct, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStruct=%s' % (value))
    if self.adaptedTypedef is not None:
      value = pprint.pformat(self.adaptedTypedef, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedTypedef=%s' % (value))
    if self.directlyAdapted is not None:
      value = pprint.pformat(self.directlyAdapted, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    directlyAdapted=%s' % (value))
    if self.typedefOfAdapted is not None:
      value = pprint.pformat(self.typedefOfAdapted, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    typedefOfAdapted=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'adaptedStruct',
      'adaptedTypedef',
      'directlyAdapted',
      'typedefOfAdapted',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructFieldAdaptedStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructFieldAdaptedStruct, self)

  def _to_py_deprecated(self):
    return self

class CircularAdaptee:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.field = CircularStruct()
          self.field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CircularAdaptee')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRUCT, 1)
      self.field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = CircularStruct()
      self.field.readFromJson(json_obj['field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CircularAdaptee, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CircularAdaptee, self)

  def _to_py_deprecated(self):
    return self

class CircularStruct:
  r"""
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.field = CircularAdaptee()
          self.field.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CircularStruct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.STRUCT, 1)
      self.field.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = CircularAdaptee()
      self.field.readFromJson(json_obj['field'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CircularStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CircularStruct, self)

  def _to_py_deprecated(self):
    return self

class ReorderedStruct:
  r"""
  Attributes:
   - reordered_dependent_adapted
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.reordered_dependent_adapted = DeclaredAfterStruct()
          self.reordered_dependent_adapted.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ReorderedStruct')
    if self.reordered_dependent_adapted != None:
      oprot.writeFieldBegin('reordered_dependent_adapted', TType.STRUCT, 1)
      self.reordered_dependent_adapted.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'reordered_dependent_adapted' in json_obj and json_obj['reordered_dependent_adapted'] is not None:
      self.reordered_dependent_adapted = DeclaredAfterStruct()
      self.reordered_dependent_adapted.readFromJson(json_obj['reordered_dependent_adapted'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.reordered_dependent_adapted is not None:
      value = pprint.pformat(self.reordered_dependent_adapted, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    reordered_dependent_adapted=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'reordered_dependent_adapted',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ReorderedStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ReorderedStruct, self)

  def _to_py_deprecated(self):
    return self

class DeclaredAfterStruct:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DeclaredAfterStruct')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DeclaredAfterStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DeclaredAfterStruct, self)

  def _to_py_deprecated(self):
    return self

class RenamedStruct:
  r"""
  Attributes:
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.data = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RenamedStruct')
    if self.data != None:
      oprot.writeFieldBegin('data', TType.I64, 1)
      oprot.writeI64(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = long(json_obj['data'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.RenamedStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.RenamedStruct, self)

  def _to_py_deprecated(self):
    return self

class SameNamespaceStruct:
  r"""
  Attributes:
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.data = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SameNamespaceStruct')
    if self.data != None:
      oprot.writeFieldBegin('data', TType.I64, 1)
      oprot.writeI64(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'data' in json_obj and json_obj['data'] is not None:
      self.data = long(json_obj['data'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.data is not None:
      value = pprint.pformat(self.data, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    data=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'data',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.SameNamespaceStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.SameNamespaceStruct, self)

  def _to_py_deprecated(self):
    return self

class HeapAllocated:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('HeapAllocated')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.HeapAllocated, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.HeapAllocated, self)

  def _to_py_deprecated(self):
    return self

class MoveOnly:
  r"""
  Attributes:
   - ptr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ptr = HeapAllocated()
          self.ptr.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MoveOnly')
    if self.ptr != None:
      oprot.writeFieldBegin('ptr', TType.STRUCT, 1)
      self.ptr.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'ptr' in json_obj and json_obj['ptr'] is not None:
      self.ptr = HeapAllocated()
      self.ptr.readFromJson(json_obj['ptr'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ptr is not None:
      value = pprint.pformat(self.ptr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ptr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'ptr',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MoveOnly, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MoveOnly, self)

  def _to_py_deprecated(self):
    return self

class AlsoMoveOnly:
  r"""
  Attributes:
   - ptr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ptr = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AlsoMoveOnly')
    if self.ptr != None:
      oprot.writeFieldBegin('ptr', TType.I64, 1)
      oprot.writeI64(self.ptr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'ptr' in json_obj and json_obj['ptr'] is not None:
      self.ptr = long(json_obj['ptr'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.ptr is not None:
      value = pprint.pformat(self.ptr, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    ptr=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'ptr',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AlsoMoveOnly, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AlsoMoveOnly, self)

  def _to_py_deprecated(self):
    return self

class ApplyAdapter:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ApplyAdapter')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.ApplyAdapter, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.ApplyAdapter, self)

  def _to_py_deprecated(self):
    return self

class TransitiveAdapted:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TransitiveAdapted')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TransitiveAdapted, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TransitiveAdapted, self)

  def _to_py_deprecated(self):
    return self

class CountingStruct:
  r"""
  Attributes:
   - regularInt
   - countingInt
   - regularString
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.regularInt = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.countingInt = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.regularString = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('CountingStruct')
    if self.regularInt != None:
      oprot.writeFieldBegin('regularInt', TType.I64, 1)
      oprot.writeI64(self.regularInt)
      oprot.writeFieldEnd()
    if self.countingInt != None:
      oprot.writeFieldBegin('countingInt', TType.I64, 2)
      oprot.writeI64(self.countingInt)
      oprot.writeFieldEnd()
    if self.regularString != None:
      oprot.writeFieldBegin('regularString', TType.STRING, 3)
      oprot.writeString(self.regularString.encode('utf-8')) if UTF8STRINGS and not isinstance(self.regularString, bytes) else oprot.writeString(self.regularString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'regularInt' in json_obj and json_obj['regularInt'] is not None:
      self.regularInt = long(json_obj['regularInt'])
    if 'countingInt' in json_obj and json_obj['countingInt'] is not None:
      self.countingInt = long(json_obj['countingInt'])
    if 'regularString' in json_obj and json_obj['regularString'] is not None:
      self.regularString = json_obj['regularString']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.regularInt is not None:
      value = pprint.pformat(self.regularInt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    regularInt=%s' % (value))
    if self.countingInt is not None:
      value = pprint.pformat(self.countingInt, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    countingInt=%s' % (value))
    if self.regularString is not None:
      value = pprint.pformat(self.regularString, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    regularString=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'regularInt',
      'countingInt',
      'regularString',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.CountingStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.CountingStruct, self)

  def _to_py_deprecated(self):
    return self

class Person:
  r"""
  Attributes:
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Person')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'name',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Person, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Person, self)

  def _to_py_deprecated(self):
    return self

class Person2:
  r"""
  Attributes:
   - name
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Person2')
    if self.name != None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name.encode('utf-8')) if UTF8STRINGS and not isinstance(self.name, bytes) else oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'name' in json_obj and json_obj['name'] is not None:
      self.name = json_obj['name']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.name is not None:
      value = pprint.pformat(self.name, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    name=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'name',
    )

  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Person2, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Person2, self)

  def _to_py_deprecated(self):
    return self

SetWithAdapter = UnimplementedTypedef()
StringWithAdapter = UnimplementedTypedef()
ListWithElemAdapter = UnimplementedTypedef()
ListWithElemAdapter_withAdapter = ListWithElemAdapter
MyI64 = UnimplementedTypedef()
DoubleTypedefI64 = MyI64
MyI32 = UnimplementedTypedef()
FooWithAdapter = Foo
StructWithAdapter = my.Adapter2.Type
UnionWithAdapter = my.Adapter2.Type
AdaptedA = A
DurationMs = UnimplementedTypedef()
AdaptedBool = UnimplementedTypedef()
AdaptedByte = UnimplementedTypedef()
AdaptedShort = UnimplementedTypedef()
AdaptedInteger = UnimplementedTypedef()
AdaptedLong = UnimplementedTypedef()
AdaptedDouble = UnimplementedTypedef()
AdaptedString = UnimplementedTypedef()
DoubleTypedefBool = AdaptedBool
IOBuf = UnimplementedTypedef()
CustomProtocolType = IOBuf
IndirectionString = UnimplementedTypedef()
AdaptedEnum = ThriftAdaptedEnum
AdaptedTypedef = AdaptedStruct
TypedefOfDirect = DirectlyAdaptedStruct
AdaptedCircularAdaptee = CircularAdaptee
CountingInt = UnimplementedTypedef()
FooWithAdapter_9317 = my.Adapter1.Type
ListWithElemAdapter_withAdapter_2312 = ListWithElemAdapter_withAdapter
MyI32_4873 = MyI32
StringWithAdapter_7208 = StringWithAdapter
all_structs.append(MyAnnotation)
MyAnnotation.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'signature', True, None, 2, ), # 1
  (2, TType.I32, 'color', Color,   1, 2, ), # 2
)))

MyAnnotation.thrift_struct_annotations = {
}
MyAnnotation.thrift_field_annotations = {
}

def MyAnnotation__init__(self, signature=None, color=MyAnnotation.thrift_spec[2][4],):
  self.signature = signature
  self.color = color

MyAnnotation.__init__ = MyAnnotation__init__

def MyAnnotation__setstate__(self, state):
  state.setdefault('signature', None)
  state.setdefault('color',   1)
  self.__dict__ = state

MyAnnotation.__getstate__ = lambda self: self.__dict__.copy()
MyAnnotation.__setstate__ = MyAnnotation__setstate__

all_structs.append(Foo)
Foo.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (2, TType.I32, 'optionalIntField', None, None, 1, ), # 2
  (3, TType.I32, 'intFieldWithDefault', None, 13, 2, ), # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (5, TType.SET, 'optionalSetField', (TType.STRING,True), None, 1, ), # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (7, TType.MAP, 'optionalMapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 1, ), # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
  (10, TType.I64, 'adaptedLongField', None, None, 2, ), # 10
  (11, TType.I64, 'doubleAdaptedField', None, None, 2, ), # 11
)))

Foo.thrift_struct_annotations = {
  "thrift.uri": "facebook.com/thrift/compiler/test/fixtures/adapter/src/module/Foo",
}
Foo.thrift_field_annotations = {
}

def Foo__init__(self, intField=None, optionalIntField=None, intFieldWithDefault=Foo.thrift_spec[3][4], setField=None, optionalSetField=None, mapField=None, optionalMapField=None, binaryField=None, longField=None, adaptedLongField=None, doubleAdaptedField=None,):
  self.intField = intField
  self.optionalIntField = optionalIntField
  self.intFieldWithDefault = intFieldWithDefault
  self.setField = setField
  self.optionalSetField = optionalSetField
  self.mapField = mapField
  self.optionalMapField = optionalMapField
  self.binaryField = binaryField
  self.longField = longField
  self.adaptedLongField = adaptedLongField
  self.doubleAdaptedField = doubleAdaptedField

Foo.__init__ = Foo__init__

def Foo__setstate__(self, state):
  state.setdefault('intField', None)
  state.setdefault('optionalIntField', None)
  state.setdefault('intFieldWithDefault', 13)
  state.setdefault('setField', None)
  state.setdefault('optionalSetField', None)
  state.setdefault('mapField', None)
  state.setdefault('optionalMapField', None)
  state.setdefault('binaryField', None)
  state.setdefault('longField', None)
  state.setdefault('adaptedLongField', None)
  state.setdefault('doubleAdaptedField', None)
  self.__dict__ = state

Foo.__getstate__ = lambda self: self.__dict__.copy()
Foo.__setstate__ = Foo__setstate__

all_structs.append(Baz)
Baz.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
)))

Baz.thrift_struct_annotations = {
}
Baz.thrift_field_annotations = {
}

def Baz__init__(self, intField=None, setField=None, mapField=None, binaryField=None, longField=None,):
  self.field = 0
  self.value = None
  if intField is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = intField
  if setField is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = setField
  if mapField is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = mapField
  if binaryField is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = binaryField
  if longField is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = longField

Baz.__init__ = Baz__init__

all_structs.append(Bar)
Bar.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'structField', [Foo, Foo.thrift_spec, False, ::my.Adapter1], None, 2, ), # 1
  (2, TType.STRUCT, 'optionalStructField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 1, ), # 2
  (3, TType.LIST, 'structListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 2, ), # 3
  (4, TType.LIST, 'optionalStructListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 1, ), # 4
  (5, TType.STRUCT, 'unionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 2, ), # 5
  (6, TType.STRUCT, 'optionalUnionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 1, ), # 6
  (7, TType.STRUCT, 'adaptedStructField', [DirectlyAdapted, DirectlyAdapted.thrift_spec, False], None, 2, ), # 7
)))

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, structField=None, optionalStructField=None, structListField=None, optionalStructListField=None, unionField=None, optionalUnionField=None, adaptedStructField=None,):
  self.structField = structField
  self.optionalStructField = optionalStructField
  self.structListField = structListField
  self.optionalStructListField = optionalStructListField
  self.unionField = unionField
  self.optionalUnionField = optionalUnionField
  self.adaptedStructField = adaptedStructField

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('structField', None)
  state.setdefault('optionalStructField', None)
  state.setdefault('structListField', None)
  state.setdefault('optionalStructListField', None)
  state.setdefault('unionField', None)
  state.setdefault('optionalUnionField', None)
  state.setdefault('adaptedStructField', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(DirectlyAdapted)
DirectlyAdapted.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field', None, None, 2, ), # 1
)))

DirectlyAdapted.thrift_struct_annotations = {
}
DirectlyAdapted.thrift_field_annotations = {
}

def DirectlyAdapted__init__(self, field=None,):
  self.field = field

DirectlyAdapted.__init__ = DirectlyAdapted__init__

def DirectlyAdapted__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

DirectlyAdapted.__getstate__ = lambda self: self.__dict__.copy()
DirectlyAdapted.__setstate__ = DirectlyAdapted__setstate__

all_structs.append(IndependentDirectlyAdapted)
IndependentDirectlyAdapted.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field', None, None, 2, ), # 1
)))

IndependentDirectlyAdapted.thrift_struct_annotations = {
}
IndependentDirectlyAdapted.thrift_field_annotations = {
}

def IndependentDirectlyAdapted__init__(self, field=None,):
  self.field = field

IndependentDirectlyAdapted.__init__ = IndependentDirectlyAdapted__init__

def IndependentDirectlyAdapted__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

IndependentDirectlyAdapted.__getstate__ = lambda self: self.__dict__.copy()
IndependentDirectlyAdapted.__setstate__ = IndependentDirectlyAdapted__setstate__

all_structs.append(StructWithFieldAdapter)
StructWithFieldAdapter.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.I32, 'shared_field', None, None, 2, ), # 2
  (3, TType.I32, 'opt_shared_field', None, None, 1, ), # 3
  (4, TType.I32, 'opt_boxed_field', None, None, 1, ), # 4
)))

StructWithFieldAdapter.thrift_struct_annotations = {
}
StructWithFieldAdapter.thrift_field_annotations = {
}

def StructWithFieldAdapter__init__(self, field=None, shared_field=None, opt_shared_field=None, opt_boxed_field=None,):
  self.field = field
  self.shared_field = shared_field
  self.opt_shared_field = opt_shared_field
  self.opt_boxed_field = opt_boxed_field

StructWithFieldAdapter.__init__ = StructWithFieldAdapter__init__

def StructWithFieldAdapter__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('shared_field', None)
  state.setdefault('opt_shared_field', None)
  state.setdefault('opt_boxed_field', None)
  self.__dict__ = state

StructWithFieldAdapter.__getstate__ = lambda self: self.__dict__.copy()
StructWithFieldAdapter.__setstate__ = StructWithFieldAdapter__setstate__

all_structs.append(TerseAdaptedFields)
TerseAdaptedFields.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'int_field', None, None, 3, ), # 1
  (2, TType.STRING, 'string_field', True, None, 3, ), # 2
  (3, TType.SET, 'set_field', (TType.I32,None), None, 3, ), # 3
)))

TerseAdaptedFields.thrift_struct_annotations = {
}
TerseAdaptedFields.thrift_field_annotations = {
}

def TerseAdaptedFields__init__(self, int_field=None, string_field=None, set_field=None,):
  self.int_field = int_field
  self.string_field = string_field
  self.set_field = set_field

TerseAdaptedFields.__init__ = TerseAdaptedFields__init__

def TerseAdaptedFields__setstate__(self, state):
  state.setdefault('int_field', None)
  state.setdefault('string_field', None)
  state.setdefault('set_field', None)
  self.__dict__ = state

TerseAdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
TerseAdaptedFields.__setstate__ = TerseAdaptedFields__setstate__

all_structs.append(B)
B.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'a', [A, A.thrift_spec, False], None, 2, ), # 1
)))

B.thrift_struct_annotations = {
}
B.thrift_field_annotations = {
}

def B__init__(self, a=None,):
  self.a = a

B.__init__ = B__init__

def B__setstate__(self, state):
  state.setdefault('a', None)
  self.__dict__ = state

B.__getstate__ = lambda self: self.__dict__.copy()
B.__setstate__ = B__setstate__

all_structs.append(A)
A.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

A.thrift_struct_annotations = {
}
A.thrift_field_annotations = {
}

all_structs.append(Config)
Config.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'path', True, None, 2, ), # 1
)))

Config.thrift_struct_annotations = {
}
Config.thrift_field_annotations = {
}

def Config__init__(self, path=None,):
  self.path = path

Config.__init__ = Config__init__

def Config__setstate__(self, state):
  state.setdefault('path', None)
  self.__dict__ = state

Config.__getstate__ = lambda self: self.__dict__.copy()
Config.__setstate__ = Config__setstate__

all_structs.append(MyStruct)
MyStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.SET, 'set_string', (TType.STRING,True), None, 2, ), # 2
)))

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, field=None, set_string=None,):
  self.field = field
  self.set_string = set_string

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('set_string', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

all_structs.append(AdaptTestStruct)
AdaptTestStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'delay', None, None, 2, ), # 1
  (2, TType.STRING, 'custom', False, None, 2, ), # 2
  (3, TType.I64, 'timeout', None, None, 2, ), # 3
  (4, TType.I64, 'data', None, None, 2, ), # 4
  (5, TType.STRING, 'meta', True, None, 2, ), # 5
  (6, TType.STRING, 'indirectionString', True, None, 2, ), # 6
  (7, TType.STRING, 'string_data', True, None, 2, ), # 7
  (8, TType.BOOL, 'double_wrapped_bool', None, None, 2, ), # 8
  (9, TType.I32, 'double_wrapped_integer', None, None, 2, ), # 9
  (10, TType.STRING, 'binary_data', False, None, 2, ), # 10
)))

AdaptTestStruct.thrift_struct_annotations = {
}
AdaptTestStruct.thrift_field_annotations = {
}

def AdaptTestStruct__init__(self, delay=None, custom=None, timeout=None, data=None, meta=None, indirectionString=None, string_data=None, double_wrapped_bool=None, double_wrapped_integer=None, binary_data=None,):
  self.delay = delay
  self.custom = custom
  self.timeout = timeout
  self.data = data
  self.meta = meta
  self.indirectionString = indirectionString
  self.string_data = string_data
  self.double_wrapped_bool = double_wrapped_bool
  self.double_wrapped_integer = double_wrapped_integer
  self.binary_data = binary_data

AdaptTestStruct.__init__ = AdaptTestStruct__init__

def AdaptTestStruct__setstate__(self, state):
  state.setdefault('delay', None)
  state.setdefault('custom', None)
  state.setdefault('timeout', None)
  state.setdefault('data', None)
  state.setdefault('meta', None)
  state.setdefault('indirectionString', None)
  state.setdefault('string_data', None)
  state.setdefault('double_wrapped_bool', None)
  state.setdefault('double_wrapped_integer', None)
  state.setdefault('binary_data', None)
  self.__dict__ = state

AdaptTestStruct.__getstate__ = lambda self: self.__dict__.copy()
AdaptTestStruct.__setstate__ = AdaptTestStruct__setstate__

all_structs.append(AdaptTemplatedTestStruct)
AdaptTemplatedTestStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.BOOL, 'adaptedBool', None, None, 2, ), # 1
  (2, TType.BYTE, 'adaptedByte', None, None, 2, ), # 2
  (3, TType.I16, 'adaptedShort', None, None, 2, ), # 3
  (4, TType.I32, 'adaptedInteger', None, None, 2, ), # 4
  (5, TType.I64, 'adaptedLong', None, None, 2, ), # 5
  (6, TType.DOUBLE, 'adaptedDouble', None, None, 2, ), # 6
  (7, TType.STRING, 'adaptedString', True, None, 2, ), # 7
  (8, TType.LIST, 'adaptedList', (TType.I64,None), None, 2, ), # 8
  (9, TType.SET, 'adaptedSet', (TType.I64,None), None, 2, ), # 9
  (10, TType.MAP, 'adaptedMap', (TType.I64,None,TType.I64,None), None, 2, ), # 10
  (11, TType.BOOL, 'adaptedBoolDefault', None, True, 2, ), # 11
  (12, TType.BYTE, 'adaptedByteDefault', None, 1, 2, ), # 12
  (13, TType.I16, 'adaptedShortDefault', None, 2, 2, ), # 13
  (14, TType.I32, 'adaptedIntegerDefault', None, 3, 2, ), # 14
  (15, TType.I64, 'adaptedLongDefault', None, 4, 2, ), # 15
  (16, TType.DOUBLE, 'adaptedDoubleDefault', None, 5, 2, ), # 16
  (17, TType.STRING, 'adaptedStringDefault', True, "6", 2, ), # 17
  (18, TType.I32, 'adaptedEnum', ThriftAdaptedEnum,   1, 2, ), # 18
  (19, TType.LIST, 'adaptedListDefault', (TType.I64,None), [
    1,
  ], 2, ), # 19
  (20, TType.SET, 'adaptedSetDefault', (TType.I64,None), set([
    1,
  ]), 2, ), # 20
  (21, TType.MAP, 'adaptedMapDefault', (TType.I64,None,TType.I64,None), {
    1 : 1,
  }, 2, ), # 21
  (22, TType.BOOL, 'doubleTypedefBool', None, None, 2, ), # 22
)))

AdaptTemplatedTestStruct.thrift_struct_annotations = {
}
AdaptTemplatedTestStruct.thrift_field_annotations = {
}

def AdaptTemplatedTestStruct__init__(self, adaptedBool=None, adaptedByte=None, adaptedShort=None, adaptedInteger=None, adaptedLong=None, adaptedDouble=None, adaptedString=None, adaptedList=None, adaptedSet=None, adaptedMap=None, adaptedBoolDefault=AdaptTemplatedTestStruct.thrift_spec[11][4], adaptedByteDefault=AdaptTemplatedTestStruct.thrift_spec[12][4], adaptedShortDefault=AdaptTemplatedTestStruct.thrift_spec[13][4], adaptedIntegerDefault=AdaptTemplatedTestStruct.thrift_spec[14][4], adaptedLongDefault=AdaptTemplatedTestStruct.thrift_spec[15][4], adaptedDoubleDefault=AdaptTemplatedTestStruct.thrift_spec[16][4], adaptedStringDefault=AdaptTemplatedTestStruct.thrift_spec[17][4], adaptedEnum=AdaptTemplatedTestStruct.thrift_spec[18][4], adaptedListDefault=AdaptTemplatedTestStruct.thrift_spec[19][4], adaptedSetDefault=AdaptTemplatedTestStruct.thrift_spec[20][4], adaptedMapDefault=AdaptTemplatedTestStruct.thrift_spec[21][4], doubleTypedefBool=None,):
  self.adaptedBool = adaptedBool
  self.adaptedByte = adaptedByte
  self.adaptedShort = adaptedShort
  self.adaptedInteger = adaptedInteger
  self.adaptedLong = adaptedLong
  self.adaptedDouble = adaptedDouble
  self.adaptedString = adaptedString
  self.adaptedList = adaptedList
  self.adaptedSet = adaptedSet
  self.adaptedMap = adaptedMap
  if adaptedBoolDefault is self.thrift_spec[11][4]:
    adaptedBoolDefault = True
  self.adaptedBoolDefault = adaptedBoolDefault
  if adaptedByteDefault is self.thrift_spec[12][4]:
    adaptedByteDefault = 1
  self.adaptedByteDefault = adaptedByteDefault
  if adaptedShortDefault is self.thrift_spec[13][4]:
    adaptedShortDefault = 2
  self.adaptedShortDefault = adaptedShortDefault
  if adaptedIntegerDefault is self.thrift_spec[14][4]:
    adaptedIntegerDefault = 3
  self.adaptedIntegerDefault = adaptedIntegerDefault
  if adaptedLongDefault is self.thrift_spec[15][4]:
    adaptedLongDefault = 4
  self.adaptedLongDefault = adaptedLongDefault
  if adaptedDoubleDefault is self.thrift_spec[16][4]:
    adaptedDoubleDefault = 5
  self.adaptedDoubleDefault = adaptedDoubleDefault
  if adaptedStringDefault is self.thrift_spec[17][4]:
    adaptedStringDefault = "6"
  self.adaptedStringDefault = adaptedStringDefault
  if adaptedEnum is self.thrift_spec[18][4]:
    adaptedEnum =   1
  self.adaptedEnum = adaptedEnum
  if adaptedListDefault is self.thrift_spec[19][4]:
    adaptedListDefault = [
    1,
  ]
  self.adaptedListDefault = adaptedListDefault
  if adaptedSetDefault is self.thrift_spec[20][4]:
    adaptedSetDefault = set([
    1,
  ])
  self.adaptedSetDefault = adaptedSetDefault
  if adaptedMapDefault is self.thrift_spec[21][4]:
    adaptedMapDefault = {
    1 : 1,
  }
  self.adaptedMapDefault = adaptedMapDefault
  self.doubleTypedefBool = doubleTypedefBool

AdaptTemplatedTestStruct.__init__ = AdaptTemplatedTestStruct__init__

def AdaptTemplatedTestStruct__setstate__(self, state):
  state.setdefault('adaptedBool', None)
  state.setdefault('adaptedByte', None)
  state.setdefault('adaptedShort', None)
  state.setdefault('adaptedInteger', None)
  state.setdefault('adaptedLong', None)
  state.setdefault('adaptedDouble', None)
  state.setdefault('adaptedString', None)
  state.setdefault('adaptedList', None)
  state.setdefault('adaptedSet', None)
  state.setdefault('adaptedMap', None)
  state.setdefault('adaptedBoolDefault', True)
  state.setdefault('adaptedByteDefault', 1)
  state.setdefault('adaptedShortDefault', 2)
  state.setdefault('adaptedIntegerDefault', 3)
  state.setdefault('adaptedLongDefault', 4)
  state.setdefault('adaptedDoubleDefault', 5)
  state.setdefault('adaptedStringDefault', "6")
  state.setdefault('adaptedEnum',   1)
  state.setdefault('adaptedListDefault', [
    1,
  ])
  state.setdefault('adaptedSetDefault', set([
    1,
  ]))
  state.setdefault('adaptedMapDefault', {
    1 : 1,
  })
  state.setdefault('doubleTypedefBool', None)
  self.__dict__ = state

AdaptTemplatedTestStruct.__getstate__ = lambda self: self.__dict__.copy()
AdaptTemplatedTestStruct.__setstate__ = AdaptTemplatedTestStruct__setstate__

all_structs.append(AdaptTemplatedNestedTestStruct)
AdaptTemplatedNestedTestStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'adaptedStruct', [AdaptTemplatedTestStruct, AdaptTemplatedTestStruct.thrift_spec, False], None, 2, ), # 1
)))

AdaptTemplatedNestedTestStruct.thrift_struct_annotations = {
}
AdaptTemplatedNestedTestStruct.thrift_field_annotations = {
}

def AdaptTemplatedNestedTestStruct__init__(self, adaptedStruct=None,):
  self.adaptedStruct = adaptedStruct

AdaptTemplatedNestedTestStruct.__init__ = AdaptTemplatedNestedTestStruct__init__

def AdaptTemplatedNestedTestStruct__setstate__(self, state):
  state.setdefault('adaptedStruct', None)
  self.__dict__ = state

AdaptTemplatedNestedTestStruct.__getstate__ = lambda self: self.__dict__.copy()
AdaptTemplatedNestedTestStruct.__setstate__ = AdaptTemplatedNestedTestStruct__setstate__

all_structs.append(AdaptTestUnion)
AdaptTestUnion.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'delay', None, None, 2, ), # 1
  (2, TType.STRING, 'custom', False, None, 2, ), # 2
)))

AdaptTestUnion.thrift_struct_annotations = {
  "cpp.name": "ThriftAdaptTestUnion",
}
AdaptTestUnion.thrift_field_annotations = {
}

def AdaptTestUnion__init__(self, delay=None, custom=None,):
  self.field = 0
  self.value = None
  if delay is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = delay
  if custom is not None:
    assert self.field == 0 and self.value is None
    self.field = 2
    self.value = custom

AdaptTestUnion.__init__ = AdaptTestUnion__init__

all_structs.append(AdaptedStruct)
AdaptedStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'data', None, None, 2, ), # 1
)))

AdaptedStruct.thrift_struct_annotations = {
  "cpp.name": "ThriftAdaptedStruct",
}
AdaptedStruct.thrift_field_annotations = {
}

def AdaptedStruct__init__(self, data=None,):
  self.data = data

AdaptedStruct.__init__ = AdaptedStruct__init__

def AdaptedStruct__setstate__(self, state):
  state.setdefault('data', None)
  self.__dict__ = state

AdaptedStruct.__getstate__ = lambda self: self.__dict__.copy()
AdaptedStruct.__setstate__ = AdaptedStruct__setstate__

all_structs.append(DirectlyAdaptedStruct)
DirectlyAdaptedStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'data', None, None, 2, ), # 1
)))

DirectlyAdaptedStruct.thrift_struct_annotations = {
}
DirectlyAdaptedStruct.thrift_field_annotations = {
}

def DirectlyAdaptedStruct__init__(self, data=None,):
  self.data = data

DirectlyAdaptedStruct.__init__ = DirectlyAdaptedStruct__init__

def DirectlyAdaptedStruct__setstate__(self, state):
  state.setdefault('data', None)
  self.__dict__ = state

DirectlyAdaptedStruct.__getstate__ = lambda self: self.__dict__.copy()
DirectlyAdaptedStruct.__setstate__ = DirectlyAdaptedStruct__setstate__

all_structs.append(StructFieldAdaptedStruct)
StructFieldAdaptedStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'adaptedStruct', [AdaptedStruct, AdaptedStruct.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRUCT, 'adaptedTypedef', [AdaptedStruct, AdaptedStruct.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'directlyAdapted', [DirectlyAdaptedStruct, DirectlyAdaptedStruct.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'typedefOfAdapted', [DirectlyAdaptedStruct, DirectlyAdaptedStruct.thrift_spec, False], None, 2, ), # 4
)))

StructFieldAdaptedStruct.thrift_struct_annotations = {
}
StructFieldAdaptedStruct.thrift_field_annotations = {
}

def StructFieldAdaptedStruct__init__(self, adaptedStruct=None, adaptedTypedef=None, directlyAdapted=None, typedefOfAdapted=None,):
  self.adaptedStruct = adaptedStruct
  self.adaptedTypedef = adaptedTypedef
  self.directlyAdapted = directlyAdapted
  self.typedefOfAdapted = typedefOfAdapted

StructFieldAdaptedStruct.__init__ = StructFieldAdaptedStruct__init__

def StructFieldAdaptedStruct__setstate__(self, state):
  state.setdefault('adaptedStruct', None)
  state.setdefault('adaptedTypedef', None)
  state.setdefault('directlyAdapted', None)
  state.setdefault('typedefOfAdapted', None)
  self.__dict__ = state

StructFieldAdaptedStruct.__getstate__ = lambda self: self.__dict__.copy()
StructFieldAdaptedStruct.__setstate__ = StructFieldAdaptedStruct__setstate__

all_structs.append(CircularAdaptee)
CircularAdaptee.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'field', [CircularStruct, CircularStruct.thrift_spec, False], None, 2, ), # 1
)))

CircularAdaptee.thrift_struct_annotations = {
}
CircularAdaptee.thrift_field_annotations = {
}

def CircularAdaptee__init__(self, field=None,):
  self.field = field

CircularAdaptee.__init__ = CircularAdaptee__init__

def CircularAdaptee__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

CircularAdaptee.__getstate__ = lambda self: self.__dict__.copy()
CircularAdaptee.__setstate__ = CircularAdaptee__setstate__

all_structs.append(CircularStruct)
CircularStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'field', [CircularAdaptee, CircularAdaptee.thrift_spec, False], None, 1, ), # 1
)))

CircularStruct.thrift_struct_annotations = {
}
CircularStruct.thrift_field_annotations = {
}

def CircularStruct__init__(self, field=None,):
  self.field = field

CircularStruct.__init__ = CircularStruct__init__

def CircularStruct__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

CircularStruct.__getstate__ = lambda self: self.__dict__.copy()
CircularStruct.__setstate__ = CircularStruct__setstate__

all_structs.append(ReorderedStruct)
ReorderedStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'reordered_dependent_adapted', [DeclaredAfterStruct, DeclaredAfterStruct.thrift_spec, False], None, 2, ), # 1
)))

ReorderedStruct.thrift_struct_annotations = {
}
ReorderedStruct.thrift_field_annotations = {
}

def ReorderedStruct__init__(self, reordered_dependent_adapted=None,):
  self.reordered_dependent_adapted = reordered_dependent_adapted

ReorderedStruct.__init__ = ReorderedStruct__init__

def ReorderedStruct__setstate__(self, state):
  state.setdefault('reordered_dependent_adapted', None)
  self.__dict__ = state

ReorderedStruct.__getstate__ = lambda self: self.__dict__.copy()
ReorderedStruct.__setstate__ = ReorderedStruct__setstate__

all_structs.append(DeclaredAfterStruct)
DeclaredAfterStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

DeclaredAfterStruct.thrift_struct_annotations = {
}
DeclaredAfterStruct.thrift_field_annotations = {
}

all_structs.append(RenamedStruct)
RenamedStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'data', None, None, 2, ), # 1
)))

RenamedStruct.thrift_struct_annotations = {
}
RenamedStruct.thrift_field_annotations = {
}

def RenamedStruct__init__(self, data=None,):
  self.data = data

RenamedStruct.__init__ = RenamedStruct__init__

def RenamedStruct__setstate__(self, state):
  state.setdefault('data', None)
  self.__dict__ = state

RenamedStruct.__getstate__ = lambda self: self.__dict__.copy()
RenamedStruct.__setstate__ = RenamedStruct__setstate__

all_structs.append(SameNamespaceStruct)
SameNamespaceStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'data', None, None, 2, ), # 1
)))

SameNamespaceStruct.thrift_struct_annotations = {
}
SameNamespaceStruct.thrift_field_annotations = {
}

def SameNamespaceStruct__init__(self, data=None,):
  self.data = data

SameNamespaceStruct.__init__ = SameNamespaceStruct__init__

def SameNamespaceStruct__setstate__(self, state):
  state.setdefault('data', None)
  self.__dict__ = state

SameNamespaceStruct.__getstate__ = lambda self: self.__dict__.copy()
SameNamespaceStruct.__setstate__ = SameNamespaceStruct__setstate__

all_structs.append(HeapAllocated)
HeapAllocated.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

HeapAllocated.thrift_struct_annotations = {
}
HeapAllocated.thrift_field_annotations = {
}

all_structs.append(MoveOnly)
MoveOnly.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRUCT, 'ptr', [HeapAllocated, HeapAllocated.thrift_spec, False], None, 2, ), # 1
)))

MoveOnly.thrift_struct_annotations = {
}
MoveOnly.thrift_field_annotations = {
}

def MoveOnly__init__(self, ptr=None,):
  self.ptr = ptr

MoveOnly.__init__ = MoveOnly__init__

def MoveOnly__setstate__(self, state):
  state.setdefault('ptr', None)
  self.__dict__ = state

MoveOnly.__getstate__ = lambda self: self.__dict__.copy()
MoveOnly.__setstate__ = MoveOnly__setstate__

all_structs.append(AlsoMoveOnly)
AlsoMoveOnly.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'ptr', None, None, 2, ), # 1
)))

AlsoMoveOnly.thrift_struct_annotations = {
}
AlsoMoveOnly.thrift_field_annotations = {
}

def AlsoMoveOnly__init__(self, ptr=None,):
  self.ptr = ptr

AlsoMoveOnly.__init__ = AlsoMoveOnly__init__

def AlsoMoveOnly__setstate__(self, state):
  state.setdefault('ptr', None)
  self.__dict__ = state

AlsoMoveOnly.__getstate__ = lambda self: self.__dict__.copy()
AlsoMoveOnly.__setstate__ = AlsoMoveOnly__setstate__

all_structs.append(ApplyAdapter)
ApplyAdapter.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

ApplyAdapter.thrift_struct_annotations = {
}
ApplyAdapter.thrift_field_annotations = {
}

all_structs.append(TransitiveAdapted)
TransitiveAdapted.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
)))

TransitiveAdapted.thrift_struct_annotations = {
}
TransitiveAdapted.thrift_field_annotations = {
}

all_structs.append(CountingStruct)
CountingStruct.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.I64, 'regularInt', None, None, 1, ), # 1
  (2, TType.I64, 'countingInt', None, None, 1, ), # 2
  (3, TType.STRING, 'regularString', True, None, 1, ), # 3
)))

CountingStruct.thrift_struct_annotations = {
}
CountingStruct.thrift_field_annotations = {
}

def CountingStruct__init__(self, regularInt=None, countingInt=None, regularString=None,):
  self.regularInt = regularInt
  self.countingInt = countingInt
  self.regularString = regularString

CountingStruct.__init__ = CountingStruct__init__

def CountingStruct__setstate__(self, state):
  state.setdefault('regularInt', None)
  state.setdefault('countingInt', None)
  state.setdefault('regularString', None)
  self.__dict__ = state

CountingStruct.__getstate__ = lambda self: self.__dict__.copy()
CountingStruct.__setstate__ = CountingStruct__setstate__

all_structs.append(Person)
Person.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'name', True, None, 2, ), # 1
)))

Person.thrift_struct_annotations = {
}
Person.thrift_field_annotations = {
}

def Person__init__(self, name=None,):
  self.name = name

Person.__init__ = Person__init__

def Person__setstate__(self, state):
  state.setdefault('name', None)
  self.__dict__ = state

Person.__getstate__ = lambda self: self.__dict__.copy()
Person.__setstate__ = Person__setstate__

all_structs.append(Person2)
Person2.thrift_spec = tuple(__EXPAND_THRIFT_SPEC((
  (1, TType.STRING, 'name', True, None, 2, ), # 1
)))

Person2.thrift_struct_annotations = {
}
Person2.thrift_field_annotations = {
}

def Person2__init__(self, name=None,):
  self.name = name

Person2.__init__ = Person2__init__

def Person2__setstate__(self, state):
  state.setdefault('name', None)
  self.__dict__ = state

Person2.__getstate__ = lambda self: self.__dict__.copy()
Person2.__setstate__ = Person2__setstate__

fix_spec(all_structs)
del all_structs
