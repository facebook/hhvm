#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.thrift.ttypes
import thrift.annotation.scope.ttypes
import thrift.annotation.cpp.ttypes
import thrift.lib.thrift.standard.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'PatchOp', 'GeneratePatch', 'AssignOnlyPatch', 'BoolPatch', 'BytePatch', 'I16Patch', 'I32Patch', 'I64Patch', 'FloatPatch', 'DoublePatch', 'StringPatch', 'BinaryPatch', 'ListPatchIndex']

class PatchOp:
  r"""
  The meaning of the patch op field ids, in all properly formulated patch
  definitions.
  
  Patch field ids are interpreted at runtime, as a dynamic patch protocol,
  without any additional schema derived from IDL patch definitions.
  """
  Assign = 1
  Clear = 2
  PatchPrior = 3
  EnsureUnion = 4
  EnsureStruct = 5
  PatchAfter = 6
  Remove = 7
  Add = 8
  Put = 9
  Unspecified = 0

  _VALUES_TO_NAMES = {
    1: "Assign",
    2: "Clear",
    3: "PatchPrior",
    4: "EnsureUnion",
    5: "EnsureStruct",
    6: "PatchAfter",
    7: "Remove",
    8: "Add",
    9: "Put",
    0: "Unspecified",
  }

  _NAMES_TO_VALUES = {
    "Assign": 1,
    "Clear": 2,
    "PatchPrior": 3,
    "EnsureUnion": 4,
    "EnsureStruct": 5,
    "PatchAfter": 6,
    "Remove": 7,
    "Add": 8,
    "Put": 9,
    "Unspecified": 0,
  }

class GeneratePatch:
  r"""
  An annotation that indicates a patch representation
  should be generated for the associated definition.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('GeneratePatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.GeneratePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.GeneratePatch, self)

  def _to_py_deprecated(self):
    return self

class AssignOnlyPatch:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AssignOnlyPatch')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.AssignOnlyPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.AssignOnlyPatch, self)

  def _to_py_deprecated(self):
    return self

class BoolPatch:
  r"""
  A patch for a boolean value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - invert: If the bool value should be inverted.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.assign = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.invert = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BoolPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BOOL, 1)
      oprot.writeBool(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.invert != None:
      oprot.writeFieldBegin('invert', TType.BOOL, 9)
      oprot.writeBool(self.invert)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'invert' in json_obj and json_obj['invert'] is not None:
      self.invert = json_obj['invert']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.invert is not None:
      value = pprint.pformat(self.invert, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    invert=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'invert',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BoolPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BoolPatch, self)

  def _to_py_deprecated(self):
    return self

class BytePatch:
  r"""
  A patch for an 8-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.assign = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.add = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BytePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.BYTE, 1)
      oprot.writeByte(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.BYTE, 8)
      oprot.writeByte(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7f or self.assign < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7f or self.add < -0x80:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BytePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BytePatch, self)

  def _to_py_deprecated(self):
    return self

class I16Patch:
  r"""
  A patch for a 16-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.assign = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.add = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I16Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I16, 1)
      oprot.writeI16(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I16, 8)
      oprot.writeI16(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fff or self.assign < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fff or self.add < -0x8000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I16Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I16Patch, self)

  def _to_py_deprecated(self):
    return self

class I32Patch:
  r"""
  A patch for a 32-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clears any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.assign = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.add = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I32Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I32, 1)
      oprot.writeI32(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I32, 8)
      oprot.writeI32(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
      if self.assign > 0x7fffffff or self.assign < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = json_obj['add']
      if self.add > 0x7fffffff or self.add < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I32Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I32Patch, self)

  def _to_py_deprecated(self):
    return self

class I64Patch:
  r"""
  A patch for a 64-bit integer value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.assign = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I64:
          self.add = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('I64Patch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.I64, 1)
      oprot.writeI64(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.I64, 8)
      oprot.writeI64(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = long(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = long(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.I64Patch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.I64Patch, self)

  def _to_py_deprecated(self):
    return self

class FloatPatch:
  r"""
  A patch for a 32-bit floating point value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.FLOAT:
          self.assign = iprot.readFloat()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.FLOAT:
          self.add = iprot.readFloat()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FloatPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.FLOAT, 1)
      oprot.writeFloat(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.FLOAT, 8)
      oprot.writeFloat(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.FloatPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.FloatPatch, self)

  def _to_py_deprecated(self):
    return self

class DoublePatch:
  r"""
  A patch for an 64-bit floating point value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear any set value.
   - add: Add to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.assign = iprot.readDouble()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.DOUBLE:
          self.add = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DoublePatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.DOUBLE, 1)
      oprot.writeDouble(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.add != None:
      oprot.writeFieldBegin('add', TType.DOUBLE, 8)
      oprot.writeDouble(self.add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = float(json_obj['assign'])
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'add' in json_obj and json_obj['add'] is not None:
      self.add = float(json_obj['add'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.add is not None:
      value = pprint.pformat(self.add, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    add=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'add',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DoublePatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DoublePatch, self)

  def _to_py_deprecated(self):
    return self

class StringPatch:
  r"""
  A patch for a string value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear a given string.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StringPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign.encode('utf-8')) if UTF8STRINGS and not isinstance(self.assign, bytes) else oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend.encode('utf-8')) if UTF8STRINGS and not isinstance(self.prepend, bytes) else oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append.encode('utf-8')) if UTF8STRINGS and not isinstance(self.append, bytes) else oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StringPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StringPatch, self)

  def _to_py_deprecated(self):
    return self

class BinaryPatch:
  r"""
  A patch for a binary value.
  
  Attributes:
   - assign: Assigns to a (set) value.
  
  If set, all other patch operations are ignored.
  
  Note: Only modifies set field values.
   - clear: Clear a given binary.
   - prepend: Prepend to a given value.
   - append: Append to a given value.
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.assign = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.clear = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.prepend = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.append = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BinaryPatch')
    if self.assign != None:
      oprot.writeFieldBegin('assign', TType.STRING, 1)
      oprot.writeString(self.assign)
      oprot.writeFieldEnd()
    if self.clear != None:
      oprot.writeFieldBegin('clear', TType.BOOL, 2)
      oprot.writeBool(self.clear)
      oprot.writeFieldEnd()
    if self.prepend != None:
      oprot.writeFieldBegin('prepend', TType.STRING, 8)
      oprot.writeString(self.prepend)
      oprot.writeFieldEnd()
    if self.append != None:
      oprot.writeFieldBegin('append', TType.STRING, 9)
      oprot.writeString(self.append)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'assign' in json_obj and json_obj['assign'] is not None:
      self.assign = json_obj['assign']
    if 'clear' in json_obj and json_obj['clear'] is not None:
      self.clear = json_obj['clear']
    if 'prepend' in json_obj and json_obj['prepend'] is not None:
      self.prepend = json_obj['prepend']
    if 'append' in json_obj and json_obj['append'] is not None:
      self.append = json_obj['append']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.assign is not None:
      value = pprint.pformat(self.assign, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    assign=%s' % (value))
    if self.clear is not None:
      value = pprint.pformat(self.clear, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    clear=%s' % (value))
    if self.prepend is not None:
      value = pprint.pformat(self.prepend, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    prepend=%s' % (value))
    if self.append is not None:
      value = pprint.pformat(self.append, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    append=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'assign',
      'clear',
      'prepend',
      'append',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("apache.thrift.op.patch.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.BinaryPatch, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("apache.thrift.op.patch.types")
    return thrift.py3.converter.to_py3_struct(py3_types.BinaryPatch, self)

  def _to_py_deprecated(self):
    return self

ListPatchIndex = UnimplementedTypedef()
all_structs.append(GeneratePatch)
GeneratePatch.thrift_spec = (
)

GeneratePatch.thrift_struct_annotations = {
}
GeneratePatch.thrift_field_annotations = {
}

all_structs.append(AssignOnlyPatch)
AssignOnlyPatch.thrift_spec = (
)

AssignOnlyPatch.thrift_struct_annotations = {
}
AssignOnlyPatch.thrift_field_annotations = {
}

all_structs.append(BoolPatch)
BoolPatch.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  None, # 8
  (9, TType.BOOL, 'invert', None, None, 3, ), # 9
)

BoolPatch.thrift_struct_annotations = {
}
BoolPatch.thrift_field_annotations = {
}

def BoolPatch__init__(self, assign=None, clear=None, invert=None,):
  self.assign = assign
  self.clear = clear
  self.invert = invert

BoolPatch.__init__ = BoolPatch__init__

def BoolPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('invert', None)
  self.__dict__ = state

BoolPatch.__getstate__ = lambda self: self.__dict__.copy()
BoolPatch.__setstate__ = BoolPatch__setstate__

all_structs.append(BytePatch)
BytePatch.thrift_spec = (
  None, # 0
  (1, TType.BYTE, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.BYTE, 'add', None, None, 3, ), # 8
)

BytePatch.thrift_struct_annotations = {
}
BytePatch.thrift_field_annotations = {
}

def BytePatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

BytePatch.__init__ = BytePatch__init__

def BytePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

BytePatch.__getstate__ = lambda self: self.__dict__.copy()
BytePatch.__setstate__ = BytePatch__setstate__

all_structs.append(I16Patch)
I16Patch.thrift_spec = (
  None, # 0
  (1, TType.I16, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I16, 'add', None, None, 3, ), # 8
)

I16Patch.thrift_struct_annotations = {
}
I16Patch.thrift_field_annotations = {
}

def I16Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I16Patch.__init__ = I16Patch__init__

def I16Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I16Patch.__getstate__ = lambda self: self.__dict__.copy()
I16Patch.__setstate__ = I16Patch__setstate__

all_structs.append(I32Patch)
I32Patch.thrift_spec = (
  None, # 0
  (1, TType.I32, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I32, 'add', None, None, 3, ), # 8
)

I32Patch.thrift_struct_annotations = {
}
I32Patch.thrift_field_annotations = {
}

def I32Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I32Patch.__init__ = I32Patch__init__

def I32Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I32Patch.__getstate__ = lambda self: self.__dict__.copy()
I32Patch.__setstate__ = I32Patch__setstate__

all_structs.append(I64Patch)
I64Patch.thrift_spec = (
  None, # 0
  (1, TType.I64, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.I64, 'add', None, None, 3, ), # 8
)

I64Patch.thrift_struct_annotations = {
}
I64Patch.thrift_field_annotations = {
}

def I64Patch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

I64Patch.__init__ = I64Patch__init__

def I64Patch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

I64Patch.__getstate__ = lambda self: self.__dict__.copy()
I64Patch.__setstate__ = I64Patch__setstate__

all_structs.append(FloatPatch)
FloatPatch.thrift_spec = (
  None, # 0
  (1, TType.FLOAT, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.FLOAT, 'add', None, None, 3, ), # 8
)

FloatPatch.thrift_struct_annotations = {
}
FloatPatch.thrift_field_annotations = {
}

def FloatPatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

FloatPatch.__init__ = FloatPatch__init__

def FloatPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

FloatPatch.__getstate__ = lambda self: self.__dict__.copy()
FloatPatch.__setstate__ = FloatPatch__setstate__

all_structs.append(DoublePatch)
DoublePatch.thrift_spec = (
  None, # 0
  (1, TType.DOUBLE, 'assign', None, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.DOUBLE, 'add', None, None, 3, ), # 8
)

DoublePatch.thrift_struct_annotations = {
}
DoublePatch.thrift_field_annotations = {
}

def DoublePatch__init__(self, assign=None, clear=None, add=None,):
  self.assign = assign
  self.clear = clear
  self.add = add

DoublePatch.__init__ = DoublePatch__init__

def DoublePatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('add', None)
  self.__dict__ = state

DoublePatch.__getstate__ = lambda self: self.__dict__.copy()
DoublePatch.__setstate__ = DoublePatch__setstate__

all_structs.append(StringPatch)
StringPatch.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'assign', True, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.STRING, 'prepend', True, None, 3, ), # 8
  (9, TType.STRING, 'append', True, None, 3, ), # 9
)

StringPatch.thrift_struct_annotations = {
}
StringPatch.thrift_field_annotations = {
}

def StringPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

StringPatch.__init__ = StringPatch__init__

def StringPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

StringPatch.__getstate__ = lambda self: self.__dict__.copy()
StringPatch.__setstate__ = StringPatch__setstate__

all_structs.append(BinaryPatch)
BinaryPatch.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'assign', False, None, 1, ), # 1
  (2, TType.BOOL, 'clear', None, None, 3, ), # 2
  None, # 3
  None, # 4
  None, # 5
  None, # 6
  None, # 7
  (8, TType.STRING, 'prepend', False, None, 3, ), # 8
  (9, TType.STRING, 'append', False, None, 3, ), # 9
)

BinaryPatch.thrift_struct_annotations = {
}
BinaryPatch.thrift_field_annotations = {
}

def BinaryPatch__init__(self, assign=None, clear=None, prepend=None, append=None,):
  self.assign = assign
  self.clear = clear
  self.prepend = prepend
  self.append = append

BinaryPatch.__init__ = BinaryPatch__init__

def BinaryPatch__setstate__(self, state):
  state.setdefault('assign', None)
  state.setdefault('clear', None)
  state.setdefault('prepend', None)
  state.setdefault('append', None)
  self.__dict__ = state

BinaryPatch.__getstate__ = lambda self: self.__dict__.copy()
BinaryPatch.__setstate__ = BinaryPatch__setstate__

fix_spec(all_structs)
del all_structs
