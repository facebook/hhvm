/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/closure.h>
#include <php/classes/closure.fws.h>

// Dependencies
#include <php/classes/exception.h>
#include <php/classes/iterator.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
namespace hphp_impl_starter {}

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
extern CallInfo ci_;
/* preface finishes */
/* SRC: classes/closure.php line 6 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Closure
Variant c_Closure::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_RETURN_NAMSTR(0x44CC7F6BF50518ECLL, NAMSTR(s_sys_ss0f30800a, "vars"),
                         s_sys_sa00000000, 4);
      break;
    case 1:
      HASH_RETURN_NAMSTR(0x5BB82607943AE415LL, NAMSTR(s_sys_sse63d8c2d, "func"),
                         NAMSTR(s_sys_ss00000000, ""), 4);
      break;
    default:
      break;
  }
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Closure
Variant c_Closure::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Closure
Variant &c_Closure::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Closure
void c_Closure::o_getArray(Array &props, bool pubOnly) const {
  if (!pubOnly) if (isInitialized(m_func)) props.lvalAt(NAMSTR(s_sys_sse63d8c2d, "func"), AccessFlags::Key).setWithRef(m_func);
  if (!pubOnly) if (isInitialized(m_vars)) props.lvalAt(NAMSTR(s_sys_ss0f30800a, "vars"), AccessFlags::Key).setWithRef(m_vars);
  c_ObjectData::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Closure
void c_Closure::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Closure
Variant * c_Closure::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Closure
Variant * c_Closure::o_realPropPublic(CStrRef s, int flags) const {
  int64 hash = s->hash();
  switch (hash & 3) {
    case 0:
      HASH_REALPROP_STRING(0x44CC7F6BF50518ECLL, "vars", 4, vars);
      break;
    case 1:
      HASH_REALPROP_STRING(0x5BB82607943AE415LL, "func", 4, func);
      break;
    default:
      break;
  }
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Closure
Variant * c_Closure::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Closure
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Closure
Variant c_Closure::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Closure
IMPLEMENT_CLASS(Closure)
bool c_Closure::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_INSTANCEOF(0x3280F0C292E92A6CLL, NAMSTR(s_sys_ss2dd6aec3, "Closure"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_Closure::cloneImpl() {
  c_Closure *obj = NEW(c_Closure)();
  c_Closure::cloneSet(obj);
  return obj;
}
void c_Closure::cloneSet(ObjectData *cl) {
  c_Closure *clone = static_cast<c_Closure*>(cl);
  ObjectData::cloneSet(clone);
  clone->m_func.setWithRef(m_func);
  clone->m_vars.setWithRef(m_vars);
}
Variant c_Closure::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x56BE2A028130C7B2LL, NAMSTR(s_sys_ss23afce76, "setVars")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("Closure::setVars", count, 1, 1, 1);
        return (t_setvars(a0), null);
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Closure::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x72BA7745837A2236LL, NAMSTR(s_sys_ss63639ccf, "getVars")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Closure::getVars", 0, 1);
        return (t_getvars());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("Closure::__construct", count, 2, 2, 2);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Closure::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Closure::ci___tostring((void*)&c_Closure::i___tostring, (void*)&c_Closure::ifa___tostring, 0, 4, 0x0000000000000000LL);
CallInfo c_Closure::ci_getvars((void*)&c_Closure::i_getvars, (void*)&c_Closure::ifa_getvars, 0, 4, 0x0000000000000000LL);
CallInfo c_Closure::ci___construct((void*)&c_Closure::i___construct, (void*)&c_Closure::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_Closure::ci_setvars((void*)&c_Closure::i_setvars, (void*)&c_Closure::ifa_setvars, 1, 4, 0x0000000000000000LL);
Variant c_Closure::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Closure::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_Closure::i_getvars(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Closure::getVars", 0, 1);
  return (self->t_getvars());
}
Variant c_Closure::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("Closure::__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_Closure::i_setvars(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Closure::setVars", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setvars(arg0), null);
  }
}
Variant c_Closure::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Closure::__toString", 0, 1);
  return (self->t___tostring());
}
Variant c_Closure::ifa_getvars(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Closure::getVars", 0, 1);
  return (self->t_getvars());
}
Variant c_Closure::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("Closure::__construct", count, 2, 2, 2);
  CVarRef arg0((a0));
  CVarRef arg1((a1));
  return (self->t___construct(arg0, arg1), null);
}
Variant c_Closure::ifa_setvars(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Closure *self = NULL;
  p_Closure pobj;
  if (mcp.obj) {
    self = static_cast<c_Closure*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Closure::setVars", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_setvars(arg0), null);
}
bool c_Closure::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x56BE2A028130C7B2LL, NAMSTR(s_sys_ss23afce76, "setVars")) {
        mcp.ci = &c_Closure::ci_setvars;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        mcp.ci = &c_Closure::ci___tostring;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x72BA7745837A2236LL, NAMSTR(s_sys_ss63639ccf, "getVars")) {
        mcp.ci = &c_Closure::ci_getvars;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_Closure::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Closure::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Closure *c_Closure::create(Variant v_func, Variant v_vars) {
  CountableHelper h(this);
  init();
  t___construct(v_func, v_vars);
  return this;
}
void c_Closure::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("Closure::__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_Closure::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Closure::ci___construct;
  mcp.obj = this;
}
void c_Closure::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a1 = params[i]->eval(env);
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("Closure::__construct", count, 2, 2, 1);
  (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_Closure = {
  c_Closure::os_getInit,
  c_Closure::os_get,
  c_Closure::os_lval,
  c_Closure::os_invoke,
  c_Closure::os_constant,
  c_Closure::os_get_call_info
};
void c_Closure::init() {
  m_func = NAMSTR(s_sys_ss00000000, "");
  m_vars = s_sys_sa00000000;
}
/* SRC: classes/closure.php line 10 */
void c_Closure::t___construct(Variant v_func, Variant v_vars) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Closure, Closure::__construct);
  bool oldInCtor = gasInCtor(true);
  m_func = v_func;
  m_vars = v_vars;
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 15 */
String c_Closure::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Closure, Closure::__toString);
  {
    const String &tmp0((toString(m_func)));
    const String &tmp1((toString(x_hphp_object_pointer(GET_THIS_TYPED(Closure)))));
    return concat3(tmp0, NAMSTR(s_sys_ssdb381ae8, ":"), tmp1);
  }
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 19 */
Variant c_Closure::t_getvars() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Closure, Closure::getVars);
  return m_vars;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 22 */
void c_Closure::t_setvars(Variant v_vars) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Closure, Closure::setVars);
  v_vars.weakRemove(NAMSTR(s_sys_ssacf726a1, "__cont__"), true);
  m_vars = v_vars;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 31 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Continuation
Variant c_Continuation::os_getInit(CStrRef s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 15) {
    case 0:
      HASH_RETURN_NAMSTR(0x3BA4EC7C8E83E5E0LL, NAMSTR(s_sys_ss1491baad, "label"),
                         0LL, 5);
      HASH_RETURN_NAMSTR(0x3640AC1AE9A5E090LL, NAMSTR(s_sys_ss14e5c43c, "running"),
                         false, 7);
      break;
    case 1:
      HASH_RETURN_NAMSTR(0x6512738E63A43B01LL, NAMSTR(s_sys_ss305b0746, "received"),
                         null, 8);
      break;
    case 3:
      HASH_RETURN_NAMSTR(0x245E74B9CC12BFC3LL, NAMSTR(s_sys_ss0f61bd03, "obj"),
                         null, 3);
      break;
    case 7:
      HASH_RETURN_NAMSTR(0x021A52B45A788597LL, NAMSTR(s_sys_sse0c88471, "value"),
                         null, 5);
      break;
    case 9:
      HASH_RETURN_NAMSTR(0x5B300BEBB6379169LL, NAMSTR(s_sys_ss74691b30, "done"),
                         false, 4);
      break;
    case 14:
      HASH_RETURN_NAMSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ssf976719e, "args"),
                         null, 4);
      HASH_RETURN_NAMSTR(0x4B27521443880CAELL, NAMSTR(s_sys_ssc0ff3081, "index"),
                         -1LL, 5);
      break;
    default:
      break;
  }
  return c_Closure::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Continuation
Variant c_Continuation::os_get(CStrRef s) {
  return c_Closure::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Continuation
Variant &c_Continuation::os_lval(CStrRef s) {
  return c_Closure::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Continuation
void c_Continuation::o_getArray(Array &props, bool pubOnly) const {
  if (!pubOnly) if (isInitialized(m_obj)) props.lvalAt(NAMSTR(s_sys_ssc9ae0c06, "\000Continuation\000obj"), AccessFlags::Key).setWithRef(m_obj);
  if (!pubOnly) if (isInitialized(m_args)) props.lvalAt(NAMSTR(s_sys_ss9621feb5, "\000Continuation\000args"), AccessFlags::Key).setWithRef(m_args);
  if (!pubOnly) if (isInitialized(m_label)) props.lvalAt(NAMSTR(s_sys_ss40877955, "\000Continuation\000label"), AccessFlags::Key).setWithRef(m_label);
  if (!pubOnly) props.add(NAMSTR(s_sys_ss837e9a25, "\000Continuation\000done"), m_done, true);
  if (!pubOnly) props.add(NAMSTR(s_sys_sscbecc3ad, "\000Continuation\000index"), m_index, true);
  if (!pubOnly) if (isInitialized(m_value)) props.lvalAt(NAMSTR(s_sys_ss4e65aff3, "\000Continuation\000value"), AccessFlags::Key).setWithRef(m_value);
  if (!pubOnly) props.add(NAMSTR(s_sys_ssde0dbfb2, "\000Continuation\000running"), m_running, true);
  if (!pubOnly) if (isInitialized(m_received)) props.lvalAt(NAMSTR(s_sys_ss19136311, "\000Continuation\000received"), AccessFlags::Key).setWithRef(m_received);
  c_Closure::o_getArray(props, pubOnly);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Continuation
void c_Continuation::o_setArray(CArrRef props) {
  props->load(NAMSTR(s_sys_ssc9ae0c06, "\000Continuation\000obj"), m_obj);
  props->load(NAMSTR(s_sys_ss9621feb5, "\000Continuation\000args"), m_args);
  props->load(NAMSTR(s_sys_ss40877955, "\000Continuation\000label"), m_label);
  if (props->exists(NAMSTR(s_sys_ss837e9a25, "\000Continuation\000done"))) m_done = props->get(NAMSTR(s_sys_ss837e9a25, "\000Continuation\000done"));
  if (props->exists(NAMSTR(s_sys_sscbecc3ad, "\000Continuation\000index"))) m_index = props->get(NAMSTR(s_sys_sscbecc3ad, "\000Continuation\000index"));
  props->load(NAMSTR(s_sys_ss4e65aff3, "\000Continuation\000value"), m_value);
  if (props->exists(NAMSTR(s_sys_ssde0dbfb2, "\000Continuation\000running"))) m_running = props->get(NAMSTR(s_sys_ssde0dbfb2, "\000Continuation\000running"));
  props->load(NAMSTR(s_sys_ss19136311, "\000Continuation\000received"), m_received);
  c_Closure::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Continuation
Variant * c_Continuation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  CStrRef s = context.isNull() ? FrameInjection::GetClassName(false) : context;
  int64 hash = s->hash();
  switch (hash & 1) {
    case 0:
      HASH_GUARD_STRING(0x61DD21ABF790E9E2LL, Continuation) { return o_realPropPrivate(prop, flags); }
      break;
    default:
      break;
  }
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Continuation
Variant * c_Continuation::o_realPropPublic(CStrRef s, int flags) const {
  return c_Closure::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Continuation
Variant * c_Continuation::o_realPropPrivate(CStrRef s, int flags) const {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 15) {
    case 0:
      HASH_REALPROP_STRING(0x3BA4EC7C8E83E5E0LL, "label", 5, label);
      HASH_REALPROP_TYPED_STRING(0x3640AC1AE9A5E090LL, "running", 7, running);
      break;
    case 1:
      HASH_REALPROP_STRING(0x6512738E63A43B01LL, "received", 8, received);
      break;
    case 3:
      HASH_REALPROP_STRING(0x245E74B9CC12BFC3LL, "obj", 3, obj);
      break;
    case 7:
      HASH_REALPROP_STRING(0x021A52B45A788597LL, "value", 5, value);
      break;
    case 9:
      HASH_REALPROP_TYPED_STRING(0x5B300BEBB6379169LL, "done", 4, done);
      break;
    case 14:
      HASH_REALPROP_STRING(0x7A24AFD8ADE43B8ELL, "args", 4, args);
      HASH_REALPROP_TYPED_STRING(0x4B27521443880CAELL, "index", 5, index);
      break;
    default:
      break;
  }
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Continuation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Continuation
Variant c_Continuation::os_constant(const char *s) {
  return c_Closure::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Continuation
IMPLEMENT_CLASS(Continuation)
bool c_Continuation::o_instanceof(CStrRef s) const {
  int64 hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_INSTANCEOF(0x66679538C5E6F0A1LL, NAMSTR(s_sys_ss22bfe43e, "Traversable"));
      break;
    case 2:
      HASH_INSTANCEOF(0x61DD21ABF790E9E2LL, NAMSTR(s_sys_ss474ef858, "Continuation"));
      break;
    case 4:
      HASH_INSTANCEOF(0x3280F0C292E92A6CLL, NAMSTR(s_sys_ss2dd6aec3, "Closure"));
      break;
    case 6:
      HASH_INSTANCEOF(0x0636A5F84AF9D29ELL, NAMSTR(s_sys_ssc64ebfff, "Iterator"));
      break;
    default:
      break;
  }
  return false;
}
ObjectData *c_Continuation::cloneImpl() {
  c_Continuation *obj = NEW(c_Continuation)();
  c_Continuation::cloneSet(obj);
  return obj;
}
void c_Continuation::cloneSet(ObjectData *cl) {
  c_Continuation *clone = static_cast<c_Continuation*>(cl);
  c_Closure::cloneSet(clone);
  clone->m_obj.setWithRef(m_obj);
  clone->m_args.setWithRef(m_args);
  clone->m_label.setWithRef(m_label);
  clone->m_done = m_done;
  clone->m_index = m_index;
  clone->m_value.setWithRef(m_value);
  clone->m_running = m_running;
  clone->m_received.setWithRef(m_received);
}
Variant c_Continuation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x1402C6C4A8D472A0LL, NAMSTR(s_sys_ssf2460018, "update")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("Continuation::update", count, 3, 3, 1);
        return (t_update(a0, a1, a2), null);
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss9943cbf4, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("Continuation::send", count, 1, 1, 1);
        return (t_send(a0), null);
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x5B300BEBB6379169LL, NAMSTR(s_sys_ss74691b30, "done")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::done", 0, 1);
        return (t_done(), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss941ca25f, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::rewind", 0, 1);
        return (t_rewind(), null);
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0B7AD2197102D150LL, NAMSTR(s_sys_ssb5d283cb, "receive")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::receive", 0, 1);
        return (t_receive());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::key", 0, 1);
        return (t_key());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::next", 0, 1);
        return (t_next(), null);
      }
      HASH_GUARD_LITSTR(0x05B742E84600B778LL, NAMSTR(s_sys_ss0bbec676, "getLabel")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::getLabel", 0, 1);
        return (t_getlabel());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5A90056E9F9DC839LL, NAMSTR(s_sys_ss26fb679a, "get_args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::get_args", 0, 1);
        return (t_get_args());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ssb3a5c1b3, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x45F223F256990E3DLL, NAMSTR(s_sys_ss11603299, "get_arg")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("Continuation::get_arg", count, 1, 1, 1);
        return (t_get_arg(a0));
      }
      HASH_GUARD_LITSTR(0x59E62E16AF84FCFDLL, NAMSTR(s_sys_ss07445cb3, "num_args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::num_args", 0, 1);
        return (t_num_args());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x413DAE82ACEC621FLL, NAMSTR(s_sys_ss42161ae0, "nextImpl")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("Continuation::nextImpl", 0, 1);
        return (t_nextimpl(), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        unsigned int i = 0;
        do {
          if (i == params.size()) break;
          a0 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a1 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a2 = params[i]->eval(env);
          i++;
          if (i == params.size()) break;
          a3 = params[i]->eval(env);
          i++;
        } while(false);
        for (; i != params.size(); ++i) {
          params[i]->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("Continuation::__construct", count, 2, 4, 2);
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    default:
      break;
  }
  return c_Closure::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Continuation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Closure::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Continuation::ci_next((void*)&c_Continuation::i_next, (void*)&c_Continuation::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_key((void*)&c_Continuation::i_key, (void*)&c_Continuation::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_getlabel((void*)&c_Continuation::i_getlabel, (void*)&c_Continuation::ifa_getlabel, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_valid((void*)&c_Continuation::i_valid, (void*)&c_Continuation::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_get_args((void*)&c_Continuation::i_get_args, (void*)&c_Continuation::ifa_get_args, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_nextimpl((void*)&c_Continuation::i_nextimpl, (void*)&c_Continuation::ifa_nextimpl, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_get_arg((void*)&c_Continuation::i_get_arg, (void*)&c_Continuation::ifa_get_arg, 1, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci___construct((void*)&c_Continuation::i___construct, (void*)&c_Continuation::ifa___construct, 4, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_done((void*)&c_Continuation::i_done, (void*)&c_Continuation::ifa_done, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_num_args((void*)&c_Continuation::i_num_args, (void*)&c_Continuation::ifa_num_args, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_receive((void*)&c_Continuation::i_receive, (void*)&c_Continuation::ifa_receive, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_current((void*)&c_Continuation::i_current, (void*)&c_Continuation::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_send((void*)&c_Continuation::i_send, (void*)&c_Continuation::ifa_send, 1, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_rewind((void*)&c_Continuation::i_rewind, (void*)&c_Continuation::ifa_rewind, 0, 4, 0x0000000000000000LL);
CallInfo c_Continuation::ci_update((void*)&c_Continuation::i_update, (void*)&c_Continuation::ifa_update, 3, 4, 0x0000000000000000LL);
Variant c_Continuation::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_Continuation::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::key", 0, 1);
  return (self->t_key());
}
Variant c_Continuation::i_getlabel(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::getLabel", 0, 1);
  return (self->t_getlabel());
}
Variant c_Continuation::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::valid", 0, 1);
  return (self->t_valid());
}
Variant c_Continuation::i_get_args(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::get_args", 0, 1);
  return (self->t_get_args());
}
Variant c_Continuation::i_nextimpl(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::nextImpl", 0, 1);
  return (self->t_nextimpl(), null);
}
Variant c_Continuation::i_get_arg(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Continuation::get_arg", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_get_arg(arg0));
  }
}
Variant c_Continuation::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("Continuation::__construct", count, 2, 4, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_Continuation::i_done(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::done", 0, 1);
  return (self->t_done(), null);
}
Variant c_Continuation::i_num_args(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::num_args", 0, 1);
  return (self->t_num_args());
}
Variant c_Continuation::i_receive(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::receive", 0, 1);
  return (self->t_receive());
}
Variant c_Continuation::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::current", 0, 1);
  return (self->t_current());
}
Variant c_Continuation::i_send(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Continuation::send", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_send(arg0), null);
  }
}
Variant c_Continuation::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_Continuation::i_update(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("Continuation::update", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_update(arg0, arg1, arg2), null);
  }
}
Variant c_Continuation::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::next", 0, 1);
  return (self->t_next(), null);
}
Variant c_Continuation::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::key", 0, 1);
  return (self->t_key());
}
Variant c_Continuation::ifa_getlabel(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::getLabel", 0, 1);
  return (self->t_getlabel());
}
Variant c_Continuation::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::valid", 0, 1);
  return (self->t_valid());
}
Variant c_Continuation::ifa_get_args(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::get_args", 0, 1);
  return (self->t_get_args());
}
Variant c_Continuation::ifa_nextimpl(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::nextImpl", 0, 1);
  return (self->t_nextimpl(), null);
}
Variant c_Continuation::ifa_get_arg(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Continuation::get_arg", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_get_arg(arg0));
}
Variant c_Continuation::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("Continuation::__construct", count, 2, 4, 2);
  CVarRef arg0((a0));
  CVarRef arg1((a1));
  if (count <= 2) return (self->t___construct(arg0, arg1), null);
  CVarRef arg2((a2));
  if (count <= 3) return (self->t___construct(arg0, arg1, arg2), null);
  CVarRef arg3((a3));
  return (self->t___construct(arg0, arg1, arg2, arg3), null);
}
Variant c_Continuation::ifa_done(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::done", 0, 1);
  return (self->t_done(), null);
}
Variant c_Continuation::ifa_num_args(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::num_args", 0, 1);
  return (self->t_num_args());
}
Variant c_Continuation::ifa_receive(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::receive", 0, 1);
  return (self->t_receive());
}
Variant c_Continuation::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::current", 0, 1);
  return (self->t_current());
}
Variant c_Continuation::ifa_send(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("Continuation::send", count, 1, 1, 1);
  CVarRef arg0((a0));
  return (self->t_send(arg0), null);
}
Variant c_Continuation::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("Continuation::rewind", 0, 1);
  return (self->t_rewind(), null);
}
Variant c_Continuation::ifa_update(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Continuation *self = NULL;
  p_Continuation pobj;
  if (mcp.obj) {
    self = static_cast<c_Continuation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("Continuation::update", count, 3, 3, 1);
  CVarRef arg0((a0));
  CVarRef arg1((a1));
  CVarRef arg2((a2));
  return (self->t_update(arg0, arg1, arg2), null);
}
bool c_Continuation::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (*mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x1402C6C4A8D472A0LL, NAMSTR(s_sys_ssf2460018, "update")) {
        mcp.ci = &c_Continuation::ci_update;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss9943cbf4, "valid")) {
        mcp.ci = &c_Continuation::ci_valid;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        mcp.ci = &c_Continuation::ci_send;
        return true;
      }
      break;
    case 9:
      HASH_GUARD_LITSTR(0x5B300BEBB6379169LL, NAMSTR(s_sys_ss74691b30, "done")) {
        mcp.ci = &c_Continuation::ci_done;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss941ca25f, "rewind")) {
        mcp.ci = &c_Continuation::ci_rewind;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0B7AD2197102D150LL, NAMSTR(s_sys_ssb5d283cb, "receive")) {
        mcp.ci = &c_Continuation::ci_receive;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        mcp.ci = &c_Continuation::ci_key;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        mcp.ci = &c_Continuation::ci_next;
        return true;
      }
      HASH_GUARD_LITSTR(0x05B742E84600B778LL, NAMSTR(s_sys_ss0bbec676, "getLabel")) {
        mcp.ci = &c_Continuation::ci_getlabel;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5A90056E9F9DC839LL, NAMSTR(s_sys_ss26fb679a, "get_args")) {
        mcp.ci = &c_Continuation::ci_get_args;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ssb3a5c1b3, "current")) {
        mcp.ci = &c_Continuation::ci_current;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x45F223F256990E3DLL, NAMSTR(s_sys_ss11603299, "get_arg")) {
        mcp.ci = &c_Continuation::ci_get_arg;
        return true;
      }
      HASH_GUARD_LITSTR(0x59E62E16AF84FCFDLL, NAMSTR(s_sys_ss07445cb3, "num_args")) {
        mcp.ci = &c_Continuation::ci_num_args;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x413DAE82ACEC621FLL, NAMSTR(s_sys_ss42161ae0, "nextImpl")) {
        mcp.ci = &c_Continuation::ci_nextimpl;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ssa1b87da7, "__construct")) {
        mcp.ci = &c_Continuation::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Closure::os_get_call_info(mcp, hash);
}
bool c_Continuation::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Continuation *c_Continuation::create(Variant v_func, Variant v_vars, Variant v_obj //  = null
, Variant v_args //  = s_sys_sa00000000
) {
  CountableHelper h(this);
  init();
  t___construct(v_func, v_vars, v_obj, v_args);
  return this;
}
void c_Continuation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) throw_wrong_arguments("Continuation::__construct", count, 2, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_Continuation::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Continuation::ci___construct;
  mcp.obj = this;
}
void c_Continuation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  unsigned int i = 0;
  do {
    if (i == params.size()) break;
    a0 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a1 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a2 = params[i]->eval(env);
    i++;
    if (i == params.size()) break;
    a3 = params[i]->eval(env);
    i++;
  } while(false);
  for (; i != params.size(); ++i) {
    params[i]->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 4) throw_wrong_arguments("Continuation::__construct", count, 2, 4, 1);
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
struct ObjectStaticCallbacks cw_Continuation = {
  c_Continuation::os_getInit,
  c_Continuation::os_get,
  c_Continuation::os_lval,
  c_Continuation::os_invoke,
  c_Continuation::os_constant,
  c_Continuation::os_get_call_info
};
void c_Continuation::init() {
  c_Closure::init();
  m_obj = null;
  m_args = null;
  m_label = 0LL;
  m_done = false;
  m_index = -1LL;
  m_value = null;
  m_running = false;
  m_received = null;
}
/* SRC: classes/closure.php line 41 */
void c_Continuation::t___construct(Variant v_func, Variant v_vars, Variant v_obj //  = null
, Variant v_args //  = s_sys_sa00000000
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::__construct);
  bool oldInCtor = gasInCtor(true);
  c_Closure::t___construct(v_func, v_vars);
  m_obj = v_obj;
  m_args = v_args;
  gasInCtor(oldInCtor);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 46 */
void c_Continuation::t_update(CVarRef v_label, CVarRef v_value, CVarRef v_vars) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::update);
  m_label = v_label;
  m_value = v_value;
  c_Closure::t_setvars(v_vars);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 51 */
void c_Continuation::t_done() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::done);
  m_done = true;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 55 */
Variant c_Continuation::t_getlabel() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::getLabel);
  return m_label;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 59 */
int c_Continuation::t_num_args() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::num_args);
  return x_count(m_args);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 62 */
Variant c_Continuation::t_get_args() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::get_args);
  return m_args;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 65 */
Variant c_Continuation::t_get_arg(CVarRef v_id) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::get_arg);
  {
    bool tmp0;
    {
      bool tmp1 = (less(v_id, 0LL));
      if (!tmp1) {
        int tmp2((x_count(m_args)));
        tmp1 = (not_less(v_id, tmp2));
      }
      tmp0 = (tmp1);
    }
    if (tmp0) {
      {
        return false;
      }
    }
  }
  return m_args.rvalAt(v_id, AccessFlags::Error);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 72 */
Variant c_Continuation::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::current);
  if (less(m_index, 0LL)) {
    {
      throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ss791c5872, "Need to call next() first"))));
    }
  }
  return m_value;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 78 */
int64 c_Continuation::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::key);
  if (less(m_index, 0LL)) {
    {
      throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ss791c5872, "Need to call next() first"))));
    }
  }
  return m_index;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 84 */
void c_Continuation::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::next);
  m_received = null;
  t_nextimpl();
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 88 */
void c_Continuation::t_nextimpl() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::nextImpl);
  Variant v_tokens;
  Variant v_func;
  Object v_e;

  if (m_done) {
    {
      throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ssd222d509, "Continuation is already finished"))));
    }
  }
  if (m_running) {
    {
      throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ssee112c62, "Continuation is already running"))));
    }
  }
  m_running = true;
  ++m_index;
  try {
    if (toBoolean(m_obj)) {
      {
        {
          const Variant &tmp0((x_explode(NAMSTR(s_sys_ss819481f3, "::"), toString(m_func))));
          v_tokens = tmp0;
        }
        {
          Variant tmp0((v_tokens.rvalAt(1LL, AccessFlags::Error)));
          v_func = tmp0;
        }
        {
          MethodCallPackage mcp0;
          CVarRef obj0 = m_obj;
          CStrRef mth0 = toString(v_func);
          mcp0.methodCall((obj0), mth0, -1);
          const CallInfo *cit0 __attribute__((__unused__)) = mcp0.ci;
          (mcp0.bindClass(fi)->getMeth1Args())(mcp0, 1, GET_THIS_TYPED(Continuation));
        }
      }
    }
    else {
      {
        x_call_user_func(2, m_func, Array(ArrayInit(1, true).setRef(Variant(GET_THIS())).create()));
      }
    }
  } catch (Object e) {
    if (e.instanceof(NAMSTR(s_sys_ssae8717ad, "exception"))) {
      v_e = e;
      m_running = false;
      m_done = true;
      throw_exception(v_e);
    } else {
      throw;
    }
  }
  m_running = false;
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 114 */
void c_Continuation::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::rewind);
  throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ssfb726449, "Cannot rewind on a Continuation object"))));
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 117 */
bool c_Continuation::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::valid);
  return !(m_done);
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 121 */
void c_Continuation::t_send(CVarRef v_v) {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::send);
  if (less(m_index, 0LL)) {
    {
      throw_exception(p_Exception((NEWOBJ(c_Exception)())->create(NAMSTR(s_sys_ss791c5872, "Need to call next() first"))));
    }
  }
  m_received = v_v;
  t_nextimpl();
}
namespace hphp_impl_splitter {}
/* SRC: classes/closure.php line 128 */
Variant c_Continuation::t_receive() {
  INSTANCE_METHOD_INJECTION_BUILTIN(Continuation, Continuation::receive);
  return m_received;
}
namespace hphp_impl_splitter {}
Object co_Closure(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Closure)())->dynCreate(params, init));
}
Object coo_Closure() {
  Object r(NEW(c_Closure)());
  r->init();
  return r;
}
Object co_Continuation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Continuation)())->dynCreate(params, init));
}
Object coo_Continuation() {
  Object r(NEW(c_Continuation)());
  r->init();
  return r;
}
Variant pm_php$classes$closure_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/closure.php, pm_php$classes$closure_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
}
namespace hphp_impl_splitter {}

///////////////////////////////////////////////////////////////////////////////
}
