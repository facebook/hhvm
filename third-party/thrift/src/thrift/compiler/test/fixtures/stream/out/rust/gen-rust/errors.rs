// @generated by Thrift for thrift/compiler/test/fixtures/stream/src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift error definitions for `module`.

/// Error definitions for `PubSubStreamingService`.
pub mod pub_sub_streaming_service {

    pub trait AsFooEx {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx>;
    }

    impl AsFooEx for ::anyhow::Error {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            for cause in self.chain() {
                if let Some(ServicethrowsError::e(e)) = cause.downcast_ref::<ServicethrowsError>() {
                    return Some(e);
                }
                if let Some(Servicethrows2Error::e1(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return Some(e);
                }
                if let Some(BoththrowsError::e(e)) = cause.downcast_ref::<BoththrowsError>() {
                    return Some(e);
                }
                if let Some(ResponseandstreamservicethrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamservicethrowsError>() {
                    return Some(e);
                }
                if let Some(ResponseandstreamboththrowsError::e(e)) = cause.downcast_ref::<ResponseandstreamboththrowsError>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub trait AsFooEx2 {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2>;
    }

    impl AsFooEx2 for ::anyhow::Error {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2> {
            for cause in self.chain() {
                if let Some(Servicethrows2Error::e2(e)) = cause.downcast_ref::<Servicethrows2Error>() {
                    return Some(e);
                }
            }
            None
        }
    }

    pub type ReturnstreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamStreamError>>, ReturnstreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::ReturnstreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamResponseExn> for
        ::std::result::Result<(), ReturnstreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ReturnstreamResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamError::ApplicationException(aexn)),
            }
        }
    }

    pub type ReturnstreamStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamStreamExn> for
        ::std::result::Result<::std::primitive::i32, ReturnstreamStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ReturnstreamStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamStreamError::ApplicationException(aexn)),
            }
        }
    }

    pub type StreamthrowsError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::StreamthrowsStreamError>>, StreamthrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::StreamthrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamthrowsError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsResponseExn> for
        ::std::result::Result<(), StreamthrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::StreamthrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamthrowsError::ApplicationException(aexn)),
            }
        }
    }

    #[derive(Debug)]
    pub enum StreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for StreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::streamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::streamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::streamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for StreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for StreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for StreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for StreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::StreamthrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, StreamthrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::StreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(StreamthrowsStreamError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::StreamthrowsStreamExn::e(exn) =>
                    ::std::result::Result::Err(StreamthrowsStreamError::e(exn)),
            }
        }
    }

    /// Errors for servicethrows (client side).
    #[derive(Debug)]
    pub enum ServicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ServicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ServicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ServicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ServicethrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ServicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ServicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ServicethrowsStreamError>>, ServicethrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::ServicethrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ServicethrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ServicethrowsExn::e(exn) =>
                    ::std::result::Result::Err(ServicethrowsError::e(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsResponseExn> for
        ::std::result::Result<(), ServicethrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ServicethrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ServicethrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ServicethrowsResponseExn::e(exn) =>
                    ::std::result::Result::Err(ServicethrowsError::e(exn)),
            }
        }
    }

    pub type ServicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ServicethrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, ServicethrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ServicethrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ServicethrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ServicethrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ServicethrowsStreamError::ApplicationException(aexn)),
            }
        }
    }

    /// Errors for servicethrows2 (client side).
    #[derive(Debug)]
    pub enum Servicethrows2Error {
        e1(crate::types::FooEx),
        e2(crate::types::FooEx2),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for Servicethrows2Error {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e1(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e1`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e1(FooEx)")?;
                    }
                }
                Self::e2(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with variant `e2`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::servicethrows2 failed with e2(FooEx2)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::servicethrows2 failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for Servicethrows2Error {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e1(ref inner) => {
                    Some(inner)
                }
                Self::e2(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for Servicethrows2Error {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e1(e)
        }
    }

    impl AsFooEx for Servicethrows2Error {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e1(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx2> for Servicethrows2Error {
        fn from(e: crate::types::FooEx2) -> Self {
            Self::e2(e)
        }
    }

    impl AsFooEx2 for Servicethrows2Error {
        fn as_foo_ex2(&self) -> Option<&crate::types::FooEx2> {
            match self {
                Self::e2(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for Servicethrows2Error {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for Servicethrows2Error {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2Exn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::Servicethrows2StreamError>>, Servicethrows2Error>
    {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2Exn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(Servicethrows2Error::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e1(exn) =>
                    ::std::result::Result::Err(Servicethrows2Error::e1(exn)),
                crate::services::pub_sub_streaming_service::Servicethrows2Exn::e2(exn) =>
                    ::std::result::Result::Err(Servicethrows2Error::e2(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn> for
        ::std::result::Result<(), Servicethrows2Error>
    {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(Servicethrows2Error::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn::e1(exn) =>
                    ::std::result::Result::Err(Servicethrows2Error::e1(exn)),
                crate::services::pub_sub_streaming_service::Servicethrows2ResponseExn::e2(exn) =>
                    ::std::result::Result::Err(Servicethrows2Error::e2(exn)),
            }
        }
    }

    pub type Servicethrows2StreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::Servicethrows2StreamExn> for
        ::std::result::Result<::std::primitive::i32, Servicethrows2StreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::Servicethrows2StreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::Servicethrows2StreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::Servicethrows2StreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(Servicethrows2StreamError::ApplicationException(aexn)),
            }
        }
    }

    /// Errors for boththrows (client side).
    #[derive(Debug)]
    pub enum BoththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for BoththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for BoththrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::BoththrowsStreamError>>, BoththrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::BoththrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(BoththrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::BoththrowsExn::e(exn) =>
                    ::std::result::Result::Err(BoththrowsError::e(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsResponseExn> for
        ::std::result::Result<(), BoththrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::BoththrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(BoththrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::BoththrowsResponseExn::e(exn) =>
                    ::std::result::Result::Err(BoththrowsError::e(exn)),
            }
        }
    }

    #[derive(Debug)]
    pub enum BoththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for BoththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::boththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::boththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::boththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for BoththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for BoththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for BoththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for BoththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::BoththrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, BoththrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::BoththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(BoththrowsStreamError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::BoththrowsStreamExn::e(exn) =>
                    ::std::result::Result::Err(BoththrowsStreamError::e(exn)),
            }
        }
    }

    pub type ResponseandstreamstreamthrowsError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn> for
        ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamError>>), ResponseandstreamstreamthrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let (resp, stream) = res;
                    ::std::result::Result::Ok((resp, stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed()))
                }
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamstreamthrowsError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsResponseExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamstreamthrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamstreamthrowsError::ApplicationException(aexn)),
            }
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamstreamthrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamstreamthrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamstreamthrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamstreamthrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamstreamthrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamstreamthrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamstreamthrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamstreamthrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamstreamthrowsStreamError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamstreamthrowsStreamExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamstreamthrowsStreamError::e(exn)),
            }
        }
    }

    /// Errors for responseandstreamservicethrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamservicethrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamservicethrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamservicethrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamservicethrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamservicethrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamservicethrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamservicethrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamservicethrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn> for
        ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamError>>), ResponseandstreamservicethrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let (resp, stream) = res;
                    ::std::result::Result::Ok((resp, stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed()))
                }
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamservicethrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamservicethrowsError::e(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsResponseExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamservicethrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamservicethrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsResponseExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamservicethrowsError::e(exn)),
            }
        }
    }

    pub type ResponseandstreamservicethrowsStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamservicethrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamservicethrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamservicethrowsStreamError::ApplicationException(aexn)),
            }
        }
    }

    /// Errors for responseandstreamboththrows (client side).
    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsError {
        e(crate::types::FooEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooEx> for ResponseandstreamboththrowsError {
        fn from(e: crate::types::FooEx) -> Self {
            Self::e(e)
        }
    }

    impl AsFooEx for ResponseandstreamboththrowsError {
        fn as_foo_ex(&self) -> Option<&crate::types::FooEx> {
            match self {
                Self::e(inner) => Some(inner),
                _ => None,
            }
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }
    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn> for
        ::std::result::Result<(::std::primitive::i32, ::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ResponseandstreamboththrowsStreamError>>), ResponseandstreamboththrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let (resp, stream) = res;
                    ::std::result::Result::Ok((resp, stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed()))
                }
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsError::e(exn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsResponseExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamboththrowsError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsResponseExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsError::e(exn)),
            }
        }
    }

    #[derive(Debug)]
    pub enum ResponseandstreamboththrowsStreamError {
        e(crate::types::FooStreamEx),
        ApplicationException(::fbthrift::ApplicationException),
        ThriftError(::anyhow::Error),
    }

    /// Human-readable string representation of the Thrift client error.
    ///
    /// By default, this will not print the full cause chain. If you would like to print the underlying error
    /// cause, either use `format!("{:?}", anyhow::Error::from(client_err))` or print this using the
    /// alternate formatter `{:#}` instead of just `{}`.
    impl ::std::fmt::Display for ResponseandstreamboththrowsStreamError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::result::Result<(), ::std::fmt::Error> {
            match self {
                Self::e(inner) => {
                    if f.alternate() {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with variant `e`: {:#}", inner)?;
                    } else {
                        write!(f, "PubSubStreamingService::responseandstreamboththrows failed with e(FooStreamEx)")?;
                    }
                }
                Self::ApplicationException(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ApplicationException")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
                Self::ThriftError(inner) => {
                    write!(f, "PubSubStreamingService::responseandstreamboththrows failed with ThriftError")?;

                    if f.alternate() {
                      write!(f, ": {:#}", inner)?;
                    }
                }
            }

            Ok(())
        }
    }

    impl ::std::error::Error for ResponseandstreamboththrowsStreamError {
        fn source(&self) -> ::std::option::Option<&(dyn ::std::error::Error + 'static)> {
            match self {
                Self::e(ref inner) => {
                    Some(inner)
                }
                Self::ApplicationException(ref inner) => {
                    Some(inner)
                }
                Self::ThriftError(ref inner) => {
                    Some(inner.as_ref())
                }
            }
        }
    }

    impl ::std::convert::From<crate::types::FooStreamEx> for ResponseandstreamboththrowsStreamError {
        fn from(e: crate::types::FooStreamEx) -> Self {
            Self::e(e)
        }
    }

    impl ::std::convert::From<::anyhow::Error> for ResponseandstreamboththrowsStreamError {
        fn from(err: ::anyhow::Error) -> Self {
            Self::ThriftError(err)
        }
    }

    impl ::std::convert::From<::fbthrift::ApplicationException> for ResponseandstreamboththrowsStreamError {
        fn from(ae: ::fbthrift::ApplicationException) -> Self {
            Self::ApplicationException(ae)
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn> for
        ::std::result::Result<::std::primitive::i32, ResponseandstreamboththrowsStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsStreamError::ApplicationException(aexn)),
                crate::services::pub_sub_streaming_service::ResponseandstreamboththrowsStreamExn::e(exn) =>
                    ::std::result::Result::Err(ResponseandstreamboththrowsStreamError::e(exn)),
            }
        }
    }

    pub type ReturnstreamFastError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamFastExn> for
        ::std::result::Result<::futures::stream::BoxStream<'static, ::std::result::Result<::std::primitive::i32, crate::errors::pub_sub_streaming_service::ReturnstreamFastStreamError>>, ReturnstreamFastError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamFastExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamFastExn::Success(res) => {
                    use ::futures::stream::StreamExt;
                    let stream = res;
                    ::std::result::Result::Ok(stream.map(|res| match res {
                        ::std::result::Result::Ok(item) => ::std::result::Result::Ok(item),
                        ::std::result::Result::Err(exn) => exn.into(),
                    }).boxed())
                }
                crate::services::pub_sub_streaming_service::ReturnstreamFastExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamFastError::ApplicationException(aexn)),
            }
        }
    }

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamFastResponseExn> for
        ::std::result::Result<(), ReturnstreamFastError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamFastResponseExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamFastResponseExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ReturnstreamFastResponseExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamFastError::ApplicationException(aexn)),
            }
        }
    }

    pub type ReturnstreamFastStreamError = ::fbthrift::NonthrowingFunctionError;

    impl ::std::convert::From<crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn> for
        ::std::result::Result<::std::primitive::i32, ReturnstreamFastStreamError>
    {
        fn from(e: crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn) -> Self {
            match e {
                crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn::Success(res) =>
                    ::std::result::Result::Ok(res),
                crate::services::pub_sub_streaming_service::ReturnstreamFastStreamExn::ApplicationException(aexn) =>
                    ::std::result::Result::Err(ReturnstreamFastStreamError::ApplicationException(aexn)),
            }
        }
    }

}

