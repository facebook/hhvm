#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#
from libc.stdint cimport (
    int8_t as cint8_t,
    int16_t as cint16_t,
    int32_t as cint32_t,
    int64_t as cint64_t,
)
from libcpp.memory cimport shared_ptr, make_shared, unique_ptr
from libcpp.string cimport string
from libcpp cimport bool as cbool
from cpython cimport bool as pbool
from libcpp.vector cimport vector
from libcpp.set cimport set as cset
from libcpp.map cimport map as cmap
from libcpp.utility cimport move as cmove
from cython.operator cimport dereference as deref, typeid
from cpython.ref cimport PyObject
from thrift.py3.client cimport cRequestChannel_ptr, makeClientWrapper, cClientWrapper
from thrift.py3.exceptions cimport try_make_shared_exception
from thrift.python.exceptions cimport create_py_exception
from folly cimport cFollyTry, cFollyUnit, c_unit
from folly.cast cimport down_cast_ptr
from libcpp.typeinfo cimport type_info
import thrift.py3.types
cimport thrift.py3.types
from thrift.py3.types cimport make_unique
import thrift.py3.client
cimport thrift.py3.client
from thrift.python.common cimport (
    RpcOptions as __RpcOptions,
    cThriftServiceMetadataResponse as __fbthrift_cThriftServiceMetadataResponse,
    ServiceMetadata,
    MetadataBox as __MetadataBox,
)

from folly.futures cimport bridgeFutureWith
from folly.executor cimport get_executor
cimport folly.iobuf as _fbthrift_iobuf
import folly.iobuf as _fbthrift_iobuf
from folly.iobuf cimport move as move_iobuf
cimport cython

import sys
import types as _py_types
from asyncio import get_event_loop as asyncio_get_event_loop, shield as asyncio_shield, InvalidStateError as asyncio_InvalidStateError

cimport module.types as _module_types
cimport module.cbindings as _module_cbindings
import module.types as _module_types
cimport includes.types as _includes_types
cimport includes.cbindings as _includes_cbindings
import includes.types as _includes_types

cimport module.services_interface as _fbthrift_services_interface

from module.clients_wrapper cimport cEmptyServiceAsyncClient, cEmptyServiceClientWrapper
from module.clients_wrapper cimport cReturnServiceAsyncClient, cReturnServiceClientWrapper
from module.clients_wrapper cimport cParamServiceAsyncClient, cParamServiceClientWrapper


cdef void ReturnService_noReturn_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_boolReturn_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i16Return_callback(
    cFollyTry[cint16_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i32Return_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_i64Return_callback(
    cFollyTry[cint64_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_floatReturn_callback(
    cFollyTry[float]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_doubleReturn_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_stringReturn_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_binaryReturn_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_mapReturn_callback(
    cFollyTry[cmap[string,cint64_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_i64__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_simpleTypedefReturn_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_complexTypedefReturn_callback(
    cFollyTry[vector[cmap[_module_cbindings.cEmpty,_module_cbindings.cMyStruct]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__Map__Empty_MyStruct__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_mostComplexTypedefReturn_callback(
    cFollyTry[vector[vector[vector[cmap[_module_cbindings.cEmpty,_module_cbindings.cMyStruct]]]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__List__List__Map__Empty_MyStruct__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_enumReturn_callback(
    cFollyTry[_module_cbindings.cMyEnumA]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_EnumReturn_callback(
    cFollyTry[vector[_module_cbindings.cMyEnumA]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__MyEnumA__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_structReturn_callback(
    cFollyTry[_module_cbindings.cMyStruct]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.MyStruct._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cMyStruct](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_set_StructReturn_callback(
    cFollyTry[cset[_module_cbindings.cMyStruct]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__MyStruct__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_unionReturn_callback(
    cFollyTry[_module_cbindings.cComplexUnion]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.ComplexUnion._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cComplexUnion](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_list_UnionReturn_callback(
    cFollyTry[vector[_module_cbindings.cComplexUnion]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__ComplexUnion__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_readDataEb_callback(
    cFollyTry[_fbthrift_iobuf.cIOBuf]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_fbthrift_iobuf.from_unique_ptr(result.value().clone()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ReturnService_readData_callback(
    cFollyTry[unique_ptr[_fbthrift_iobuf.cIOBuf]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_fbthrift_iobuf.from_unique_ptr(move_iobuf(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_byte_i16_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_setlist_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_map_typedef_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_enum_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_struct_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_void_ret_listunion_param_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_i32_i64_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_map_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_bool_ret_union_param_callback(
    cFollyTry[cbool]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(<bint>result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_float_double_param_callback(
    cFollyTry[cint64_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_string_typedef_param_callback(
    cFollyTry[cint64_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback(
    cFollyTry[cint64_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_double_ret_setstruct_param_callback(
    cFollyTry[double]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_string_ret_string_param_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value().data().decode('UTF-8'))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_binary_ret_binary_param_callback(
    cFollyTry[string]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_map_ret_bool_param_callback(
    cFollyTry[cmap[string,cint64_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Map__string_i64__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_list_ret_map_setlist_param_callback(
    cFollyTry[vector[cbool]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__bool__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback(
    cFollyTry[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Map__Set__List__i32_Map__List__Set__string_string__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_typedef_ret_i32_param_callback(
    cFollyTry[cint32_t]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(result.value())
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listtypedef_ret_typedef_param_callback(
    cFollyTry[vector[cint32_t]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__i32__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_enum_ret_double_param_callback(
    cFollyTry[_module_cbindings.cMyEnumA]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_enum_ret_double_enum_param_callback(
    cFollyTry[_module_cbindings.cMyEnumA]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.MyEnumA(<int> result.value()))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listenum_ret_map_param_callback(
    cFollyTry[vector[_module_cbindings.cMyEnumA]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__MyEnumA__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_struct_ret_i16_param_callback(
    cFollyTry[_module_cbindings.cMyStruct]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.MyStruct._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cMyStruct](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_setstruct_ret_set_param_callback(
    cFollyTry[cset[_module_cbindings.cMyStruct]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.Set__MyStruct__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_union_ret_i32_i32_param_callback(
    cFollyTry[_module_cbindings.cComplexUnion]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.ComplexUnion._create_FBTHRIFT_ONLY_DO_NOT_USE(make_shared[_module_cbindings.cComplexUnion](cmove(result.value()))))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_listunion_string_param_callback(
    cFollyTry[vector[_module_cbindings.cComplexUnion]]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(_module_types.List__ComplexUnion__from_cpp(cmove(result.value())))
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))

cdef void ParamService_annotatedParams_callback(
    cFollyTry[cFollyUnit]&& result,
    PyObject* userdata
) noexcept:
    client, pyfuture, options = <object> userdata  
    if result.hasException():
        pyfuture.set_exception(create_py_exception(result.exception(), <__RpcOptions>options))
    else:
        try:
            pyfuture.set_result(None)
        except Exception as ex:
            pyfuture.set_exception(ex.with_traceback(None))


cdef object _EmptyService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class EmptyService(thrift.py3.client.Client):
    annotations = _EmptyService_annotations

    cdef const type_info* _typeid(EmptyService self):
        return &typeid(cEmptyServiceAsyncClient)

    cdef bind_client(EmptyService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cEmptyServiceAsyncClient, cEmptyServiceClientWrapper](
            cmove(channel)
        )


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cEmptyServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.EmptyService"

cdef object _ReturnService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class ReturnService(thrift.py3.client.Client):
    annotations = _ReturnService_annotations

    cdef const type_info* _typeid(ReturnService self):
        return &typeid(cReturnServiceAsyncClient)

    cdef bind_client(ReturnService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cReturnServiceAsyncClient, cReturnServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_noReturn = {
        'return': 'None',
        
    }

    @cython.always_allow_keywords(True)
    def noReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).noReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_noReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_boolReturn = {
        'return': 'bool',
        
    }

    @cython.always_allow_keywords(True)
    def boolReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).boolReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_boolReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i16Return = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def i16Return(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint16_t](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).i16Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i16Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i32Return = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def i32Return(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).i32Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i32Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i64Return = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def i64Return(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint64_t](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).i64Return(rpc_options._cpp_obj, 
            ),
            ReturnService_i64Return_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_floatReturn = {
        'return': 'float',
        
    }

    @cython.always_allow_keywords(True)
    def floatReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[float](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).floatReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_floatReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_doubleReturn = {
        'return': 'float',
        
    }

    @cython.always_allow_keywords(True)
    def doubleReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).doubleReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_doubleReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_stringReturn = {
        'return': 'str',
        
    }

    @cython.always_allow_keywords(True)
    def stringReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).stringReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_stringReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_binaryReturn = {
        'return': 'bytes',
        
    }

    @cython.always_allow_keywords(True)
    def binaryReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).binaryReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_binaryReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_mapReturn = {
        'return': '_typing.Mapping[str, int]',
        
    }

    @cython.always_allow_keywords(True)
    def mapReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,cint64_t]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).mapReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_mapReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_simpleTypedefReturn = {
        'return': 'int',
        
    }

    @cython.always_allow_keywords(True)
    def simpleTypedefReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).simpleTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_simpleTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_complexTypedefReturn = {
        'return': '_typing.Sequence[_typing.Mapping[module.types.Empty, module.types.MyStruct]]',
        
    }

    @cython.always_allow_keywords(True)
    def complexTypedefReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cmap[_module_cbindings.cEmpty,_module_cbindings.cMyStruct]]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).complexTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_complexTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_mostComplexTypedefReturn = {
        'return': '_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Mapping[module.types.Empty, module.types.MyStruct]]]]',
        
    }

    @cython.always_allow_keywords(True)
    def list_mostComplexTypedefReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[vector[vector[cmap[_module_cbindings.cEmpty,_module_cbindings.cMyStruct]]]]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).list_mostComplexTypedefReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_mostComplexTypedefReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_enumReturn = {
        'return': 'module.types.MyEnumA',
        
    }

    @cython.always_allow_keywords(True)
    def enumReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cMyEnumA](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).enumReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_enumReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_EnumReturn = {
        'return': '_typing.Sequence[module.types.MyEnumA]',
        
    }

    @cython.always_allow_keywords(True)
    def list_EnumReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_cbindings.cMyEnumA]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).list_EnumReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_EnumReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_structReturn = {
        'return': 'module.types.MyStruct',
        
    }

    @cython.always_allow_keywords(True)
    def structReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cMyStruct](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).structReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_structReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_set_StructReturn = {
        'return': '_typing.AbstractSet[module.types.MyStruct]',
        
    }

    @cython.always_allow_keywords(True)
    def set_StructReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[_module_cbindings.cMyStruct]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).set_StructReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_set_StructReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_unionReturn = {
        'return': 'module.types.ComplexUnion',
        
    }

    @cython.always_allow_keywords(True)
    def unionReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cComplexUnion](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).unionReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_unionReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_UnionReturn = {
        'return': '_typing.Sequence[module.types.ComplexUnion]',
        
    }

    @cython.always_allow_keywords(True)
    def list_UnionReturn(
            ReturnService self,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_cbindings.cComplexUnion]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).list_UnionReturn(rpc_options._cpp_obj, 
            ),
            ReturnService_list_UnionReturn_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_readDataEb = {
        'return': '_fbthrift_iobuf.IOBuf',
        'size': 'int', 
    }

    @cython.always_allow_keywords(True)
    def readDataEb(
            ReturnService self,
            size not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(size, int):
            raise TypeError(f'size is not a {int !r}.')
        else:
            size = <cint64_t> size
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_fbthrift_iobuf.cIOBuf](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).readDataEb(rpc_options._cpp_obj, 
                size,
            ),
            ReturnService_readDataEb_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_readData = {
        'return': '_fbthrift_iobuf.IOBuf',
        'size': 'int', 
    }

    @cython.always_allow_keywords(True)
    def readData(
            ReturnService self,
            size not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(size, int):
            raise TypeError(f'size is not a {int !r}.')
        else:
            size = <cint64_t> size
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[unique_ptr[_fbthrift_iobuf.cIOBuf]](
            self._executor,
            down_cast_ptr[cReturnServiceClientWrapper, cClientWrapper](self._client.get()).readData(rpc_options._cpp_obj, 
                size,
            ),
            ReturnService_readData_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cReturnServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.ReturnService"

cdef object _ParamService_annotations = _py_types.MappingProxyType({
})


@cython.auto_pickle(False)
cdef class ParamService(thrift.py3.client.Client):
    annotations = _ParamService_annotations

    cdef const type_info* _typeid(ParamService self):
        return &typeid(cParamServiceAsyncClient)

    cdef bind_client(ParamService self, cRequestChannel_ptr&& channel):
        self._client = makeClientWrapper[cParamServiceAsyncClient, cParamServiceClientWrapper](
            cmove(channel)
        )

    _fbthrift_annotations_DO_NOT_USE_void_ret_i16_param = {
        'return': 'None',
        'param1': 'int', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_i16_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint16_t> param1
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_i16_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_void_ret_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_byte_i16_param = {
        'return': 'None',
        'param1': 'int', 'param2': 'int', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_byte_i16_param(
            ParamService self,
            param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint8_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            param2 = <cint16_t> param2
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_byte_i16_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_void_ret_byte_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_map_param = {
        'return': 'None',
        'param1': '_typing.Mapping[str, int]', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_map_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_map_param(rpc_options._cpp_obj, 
                _module_types.Map__string_i64__make_instance(param1),
            ),
            ParamService_void_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_map_setlist_param = {
        'return': 'None',
        'param1': '_typing.Mapping[str, int]', 'param2': '_typing.AbstractSet[_typing.Sequence[str]]', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_map_setlist_param(
            ParamService self,
            param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        if not isinstance(param2, _module_types.Set__List__string):
            param2 = _module_types.Set__List__string(param2)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_map_setlist_param(rpc_options._cpp_obj, 
                _module_types.Map__string_i64__make_instance(param1),
                _module_types.Set__List__string__make_instance(param2),
            ),
            ParamService_void_ret_map_setlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_map_typedef_param = {
        'return': 'None',
        'param1': 'int', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_map_typedef_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint32_t> param1
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_map_typedef_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_void_ret_map_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_enum_param = {
        'return': 'None',
        'param1': 'module.types.MyEnumA', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_enum_param(
            ParamService self,
            object param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_enum_param(rpc_options._cpp_obj, 
                <_module_cbindings.cMyEnumA><int>param1,
            ),
            ParamService_void_ret_enum_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_struct_param = {
        'return': 'None',
        'param1': 'module.types.MyStruct', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_struct_param(
            ParamService self,
            _module_types.MyStruct param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_struct_param(rpc_options._cpp_obj, 
                deref((<_module_types.MyStruct>param1)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            ParamService_void_ret_struct_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_void_ret_listunion_param = {
        'return': 'None',
        'param1': '_typing.Sequence[module.types.ComplexUnion]', 
    }

    @cython.always_allow_keywords(True)
    def void_ret_listunion_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__ComplexUnion):
            param1 = _module_types.List__ComplexUnion(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).void_ret_listunion_param(rpc_options._cpp_obj, 
                _module_types.List__ComplexUnion__make_instance(param1),
            ),
            ParamService_void_ret_listunion_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_bool_ret_i32_i64_param = {
        'return': 'bool',
        'param1': 'int', 'param2': 'int', 
    }

    @cython.always_allow_keywords(True)
    def bool_ret_i32_i64_param(
            ParamService self,
            param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            param2 = <cint64_t> param2
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).bool_ret_i32_i64_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_bool_ret_i32_i64_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_bool_ret_map_param = {
        'return': 'bool',
        'param1': '_typing.Mapping[str, int]', 
    }

    @cython.always_allow_keywords(True)
    def bool_ret_map_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).bool_ret_map_param(rpc_options._cpp_obj, 
                _module_types.Map__string_i64__make_instance(param1),
            ),
            ParamService_bool_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_bool_ret_union_param = {
        'return': 'bool',
        'param1': 'module.types.ComplexUnion', 
    }

    @cython.always_allow_keywords(True)
    def bool_ret_union_param(
            ParamService self,
            _module_types.ComplexUnion param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cbool](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).bool_ret_union_param(rpc_options._cpp_obj, 
                deref((<_module_types.ComplexUnion>param1)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            ParamService_bool_ret_union_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i64_ret_float_double_param = {
        'return': 'int',
        'param1': 'float', 'param2': 'float', 
    }

    @cython.always_allow_keywords(True)
    def i64_ret_float_double_param(
            ParamService self,
            float param1,
            double param2,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint64_t](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).i64_ret_float_double_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_i64_ret_float_double_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i64_ret_string_typedef_param = {
        'return': 'int',
        'param1': 'str', 'param2': '_typing.AbstractSet[_typing.Sequence[_typing.Sequence[_typing.Mapping[module.types.Empty, module.types.MyStruct]]]]', 
    }

    @cython.always_allow_keywords(True)
    def i64_ret_string_typedef_param(
            ParamService self,
            str param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param2, _module_types.Set__List__List__Map__Empty_MyStruct):
            param2 = _module_types.Set__List__List__Map__Empty_MyStruct(param2)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint64_t](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).i64_ret_string_typedef_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
                _module_types.Set__List__List__Map__Empty_MyStruct__make_instance(param2),
            ),
            ParamService_i64_ret_string_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_i64_ret_i32_i32_i32_i32_i32_param = {
        'return': 'int',
        'param1': 'int', 'param2': 'int', 'param3': 'int', 'param4': 'int', 'param5': 'int', 
    }

    @cython.always_allow_keywords(True)
    def i64_ret_i32_i32_i32_i32_i32_param(
            ParamService self,
            param1 not None,
            param2 not None,
            param3 not None,
            param4 not None,
            param5 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            param2 = <cint32_t> param2
        if not isinstance(param3, int):
            raise TypeError(f'param3 is not a {int !r}.')
        else:
            param3 = <cint32_t> param3
        if not isinstance(param4, int):
            raise TypeError(f'param4 is not a {int !r}.')
        else:
            param4 = <cint32_t> param4
        if not isinstance(param5, int):
            raise TypeError(f'param5 is not a {int !r}.')
        else:
            param5 = <cint32_t> param5
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint64_t](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).i64_ret_i32_i32_i32_i32_i32_param(rpc_options._cpp_obj, 
                param1,
                param2,
                param3,
                param4,
                param5,
            ),
            ParamService_i64_ret_i32_i32_i32_i32_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_double_ret_setstruct_param = {
        'return': 'float',
        'param1': '_typing.AbstractSet[module.types.MyStruct]', 
    }

    @cython.always_allow_keywords(True)
    def double_ret_setstruct_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Set__MyStruct):
            param1 = _module_types.Set__MyStruct(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[double](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).double_ret_setstruct_param(rpc_options._cpp_obj, 
                _module_types.Set__MyStruct__make_instance(param1),
            ),
            ParamService_double_ret_setstruct_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_string_ret_string_param = {
        'return': 'str',
        'param1': 'str', 
    }

    @cython.always_allow_keywords(True)
    def string_ret_string_param(
            ParamService self,
            str param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).string_ret_string_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
            ),
            ParamService_string_ret_string_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_binary_ret_binary_param = {
        'return': 'bytes',
        'param1': 'bytes', 
    }

    @cython.always_allow_keywords(True)
    def binary_ret_binary_param(
            ParamService self,
            bytes param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[string](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).binary_ret_binary_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_binary_ret_binary_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_map_ret_bool_param = {
        'return': '_typing.Mapping[str, int]',
        'param1': 'bool', 
    }

    @cython.always_allow_keywords(True)
    def map_ret_bool_param(
            ParamService self,
            pbool param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[string,cint64_t]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).map_ret_bool_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_map_ret_bool_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_list_ret_map_setlist_param = {
        'return': '_typing.Sequence[bool]',
        'param1': '_typing.Mapping[int, _typing.Sequence[str]]', 'param2': '_typing.Sequence[str]', 
    }

    @cython.always_allow_keywords(True)
    def list_ret_map_setlist_param(
            ParamService self,
            param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__i32_List__string):
            param1 = _module_types.Map__i32_List__string(param1)
        if not isinstance(param2, _module_types.List__string):
            param2 = _module_types.List__string(param2)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cbool]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).list_ret_map_setlist_param(rpc_options._cpp_obj, 
                _module_types.Map__i32_List__string__make_instance(param1),
                _module_types.List__string__make_instance(param2),
            ),
            ParamService_list_ret_map_setlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_mapsetlistmapliststring_ret_listlistlist_param = {
        'return': '_typing.Mapping[_typing.AbstractSet[_typing.Sequence[int]], _typing.Mapping[_typing.Sequence[_typing.AbstractSet[str]], str]]',
        'param1': '_typing.Sequence[_typing.Sequence[_typing.Sequence[_typing.Sequence[int]]]]', 
    }

    @cython.always_allow_keywords(True)
    def mapsetlistmapliststring_ret_listlistlist_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__List__List__List__i32):
            param1 = _module_types.List__List__List__List__i32(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cmap[cset[vector[cint32_t]],cmap[vector[cset[string]],string]]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).mapsetlistmapliststring_ret_listlistlist_param(rpc_options._cpp_obj, 
                _module_types.List__List__List__List__i32__make_instance(param1),
            ),
            ParamService_mapsetlistmapliststring_ret_listlistlist_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_typedef_ret_i32_param = {
        'return': 'int',
        'param1': 'int', 
    }

    @cython.always_allow_keywords(True)
    def typedef_ret_i32_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint32_t> param1
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cint32_t](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).typedef_ret_i32_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_typedef_ret_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_listtypedef_ret_typedef_param = {
        'return': '_typing.Sequence[int]',
        'param1': '_typing.Sequence[_typing.Mapping[module.types.Empty, module.types.MyStruct]]', 
    }

    @cython.always_allow_keywords(True)
    def listtypedef_ret_typedef_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.List__Map__Empty_MyStruct):
            param1 = _module_types.List__Map__Empty_MyStruct(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[cint32_t]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).listtypedef_ret_typedef_param(rpc_options._cpp_obj, 
                _module_types.List__Map__Empty_MyStruct__make_instance(param1),
            ),
            ParamService_listtypedef_ret_typedef_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_enum_ret_double_param = {
        'return': 'module.types.MyEnumA',
        'param1': 'float', 
    }

    @cython.always_allow_keywords(True)
    def enum_ret_double_param(
            ParamService self,
            double param1,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cMyEnumA](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).enum_ret_double_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_enum_ret_double_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_enum_ret_double_enum_param = {
        'return': 'module.types.MyEnumA',
        'param1': 'float', 'param2': 'module.types.MyEnumA', 
    }

    @cython.always_allow_keywords(True)
    def enum_ret_double_enum_param(
            ParamService self,
            double param1,
            object param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cMyEnumA](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).enum_ret_double_enum_param(rpc_options._cpp_obj, 
                param1,
                <_module_cbindings.cMyEnumA><int>param2,
            ),
            ParamService_enum_ret_double_enum_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_listenum_ret_map_param = {
        'return': '_typing.Sequence[module.types.MyEnumA]',
        'param1': '_typing.Mapping[str, int]', 
    }

    @cython.always_allow_keywords(True)
    def listenum_ret_map_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Map__string_i64):
            param1 = _module_types.Map__string_i64(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_cbindings.cMyEnumA]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).listenum_ret_map_param(rpc_options._cpp_obj, 
                _module_types.Map__string_i64__make_instance(param1),
            ),
            ParamService_listenum_ret_map_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_struct_ret_i16_param = {
        'return': 'module.types.MyStruct',
        'param1': 'int', 
    }

    @cython.always_allow_keywords(True)
    def struct_ret_i16_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint16_t> param1
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cMyStruct](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).struct_ret_i16_param(rpc_options._cpp_obj, 
                param1,
            ),
            ParamService_struct_ret_i16_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_setstruct_ret_set_param = {
        'return': '_typing.AbstractSet[module.types.MyStruct]',
        'param1': '_typing.AbstractSet[str]', 
    }

    @cython.always_allow_keywords(True)
    def setstruct_ret_set_param(
            ParamService self,
            param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, _module_types.Set__string):
            param1 = _module_types.Set__string(param1)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cset[_module_cbindings.cMyStruct]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).setstruct_ret_set_param(rpc_options._cpp_obj, 
                _module_types.Set__string__make_instance(param1),
            ),
            ParamService_setstruct_ret_set_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_union_ret_i32_i32_param = {
        'return': 'module.types.ComplexUnion',
        'param1': 'int', 'param2': 'int', 
    }

    @cython.always_allow_keywords(True)
    def union_ret_i32_i32_param(
            ParamService self,
            param1 not None,
            param2 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(param1, int):
            raise TypeError(f'param1 is not a {int !r}.')
        else:
            param1 = <cint32_t> param1
        if not isinstance(param2, int):
            raise TypeError(f'param2 is not a {int !r}.')
        else:
            param2 = <cint32_t> param2
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[_module_cbindings.cComplexUnion](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).union_ret_i32_i32_param(rpc_options._cpp_obj, 
                param1,
                param2,
            ),
            ParamService_union_ret_i32_i32_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_listunion_string_param = {
        'return': '_typing.Sequence[module.types.ComplexUnion]',
        'param1': 'str', 
    }

    @cython.always_allow_keywords(True)
    def listunion_string_param(
            ParamService self,
            str param1 not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[vector[_module_cbindings.cComplexUnion]](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).listunion_string_param(rpc_options._cpp_obj, 
                param1.encode('UTF-8'),
            ),
            ParamService_listunion_string_param_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)

    _fbthrift_annotations_DO_NOT_USE_annotatedParams = {
        'return': 'None',
        'no_annotation': 'module.types.containerStruct', 'opt_ref_type_shared': '_typing.AbstractSet[int]', 'base_type': 'int', 'list_type': '_typing.Sequence[int]', 'set_type': '_typing.AbstractSet[str]', 'map_type': '_typing.Mapping[int, float]', 'map_struct_type': '_typing.Mapping[str, module.types.containerStruct]', 'iobuf_type': '_fbthrift_iobuf.IOBuf', 'iobuf_ptr': '_fbthrift_iobuf.IOBuf', 'list_i32_template': '_typing.Sequence[int]', 'list_string_template': '_typing.Sequence[str]', 'set_template': '_typing.AbstractSet[str]', 'map_template': '_typing.Mapping[int, str]', 'typedef_list_template': '_typing.Sequence[int]', 'typedef_deque_template': '_typing.Sequence[str]', 'typedef_set_template': '_typing.AbstractSet[str]', 'typedef_map_template': '_typing.Mapping[int, str]', 'iobuf_type_val': '_fbthrift_iobuf.IOBuf', 'iobuf_ptr_val': '_fbthrift_iobuf.IOBuf', 'struct_struct': 'module.types.containerStruct', 
    }

    @cython.always_allow_keywords(True)
    def annotatedParams(
            ParamService self,
            _module_types.containerStruct no_annotation not None,
            opt_ref_type_shared not None,
            base_type not None,
            list_type not None,
            set_type not None,
            map_type not None,
            map_struct_type not None,
            _fbthrift_iobuf.IOBuf iobuf_type not None,
            _fbthrift_iobuf.IOBuf iobuf_ptr not None,
            list_i32_template not None,
            list_string_template not None,
            set_template not None,
            map_template not None,
            typedef_list_template not None,
            typedef_deque_template not None,
            typedef_set_template not None,
            typedef_map_template not None,
            _fbthrift_iobuf.IOBuf iobuf_type_val not None,
            _fbthrift_iobuf.IOBuf iobuf_ptr_val not None,
            _module_types.containerStruct struct_struct not None,
            *,
            __RpcOptions rpc_options=None
    ):
        if rpc_options is None:
            rpc_options = <__RpcOptions>__RpcOptions.__new__(__RpcOptions)
        if not isinstance(opt_ref_type_shared, _module_types.Set__i32):
            opt_ref_type_shared = _module_types.Set__i32(opt_ref_type_shared)
        if not isinstance(base_type, int):
            raise TypeError(f'base_type is not a {int !r}.')
        else:
            base_type = <cint32_t> base_type
        if not isinstance(list_type, _module_types.folly_small_vector_int64_t_8__List__i64):
            list_type = _module_types.folly_small_vector_int64_t_8__List__i64(list_type)
        if not isinstance(set_type, _module_types.folly_sorted_vector_set_std_string__Set__string):
            set_type = _module_types.folly_sorted_vector_set_std_string__Set__string(set_type)
        if not isinstance(map_type, _module_types.FakeMap__Map__i64_double):
            map_type = _module_types.FakeMap__Map__i64_double(map_type)
        if not isinstance(map_struct_type, _module_types.std_unordered_map_std_string_containerStruct__Map__string_containerStruct):
            map_struct_type = _module_types.std_unordered_map_std_string_containerStruct__Map__string_containerStruct(map_struct_type)
        if not isinstance(list_i32_template, _module_types.List__i32):
            list_i32_template = _module_types.List__i32(list_i32_template)
        if not isinstance(list_string_template, _module_types.List__string):
            list_string_template = _module_types.List__string(list_string_template)
        if not isinstance(set_template, _module_types.Set__string):
            set_template = _module_types.Set__string(set_template)
        if not isinstance(map_template, _module_types.Map__i64_string):
            map_template = _module_types.Map__i64_string(map_template)
        if not isinstance(typedef_list_template, _module_types.std_list__List__i32):
            typedef_list_template = _module_types.std_list__List__i32(typedef_list_template)
        if not isinstance(typedef_deque_template, _module_types.std_deque__List__string):
            typedef_deque_template = _module_types.std_deque__List__string(typedef_deque_template)
        if not isinstance(typedef_set_template, _module_types.folly_sorted_vector_set__Set__string):
            typedef_set_template = _module_types.folly_sorted_vector_set__Set__string(typedef_set_template)
        if not isinstance(typedef_map_template, _module_types.folly_sorted_vector_map__Map__i64_string):
            typedef_map_template = _module_types.folly_sorted_vector_map__Map__i64_string(typedef_map_template)
        self._check_connect_future()
        __loop = self._loop
        __future = __loop.create_future()
        __userdata = (self, __future, rpc_options)
        bridgeFutureWith[cFollyUnit](
            self._executor,
            down_cast_ptr[cParamServiceClientWrapper, cClientWrapper](self._client.get()).annotatedParams(rpc_options._cpp_obj, 
                deref((<_module_types.containerStruct>no_annotation)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
                _module_types.Set__i32__make_instance(opt_ref_type_shared),
                base_type,
                _module_types.folly_small_vector_int64_t_8__List__i64__make_instance(list_type),
                _module_types.folly_sorted_vector_set_std_string__Set__string__make_instance(set_type),
                _module_types.FakeMap__Map__i64_double__make_instance(map_type),
                _module_types.std_unordered_map_std_string_containerStruct__Map__string_containerStruct__make_instance(map_struct_type),
                deref((<_fbthrift_iobuf.IOBuf>iobuf_type).c_clone()),
                ((<_fbthrift_iobuf.IOBuf>iobuf_ptr).c_clone()),
                _module_types.List__i32__make_instance(list_i32_template),
                _module_types.List__string__make_instance(list_string_template),
                _module_types.Set__string__make_instance(set_template),
                _module_types.Map__i64_string__make_instance(map_template),
                _module_types.std_list__List__i32__make_instance(typedef_list_template),
                _module_types.std_deque__List__string__make_instance(typedef_deque_template),
                _module_types.folly_sorted_vector_set__Set__string__make_instance(typedef_set_template),
                _module_types.folly_sorted_vector_map__Map__i64_string__make_instance(typedef_map_template),
                deref((<_fbthrift_iobuf.IOBuf>iobuf_type_val).c_clone()),
                ((<_fbthrift_iobuf.IOBuf>iobuf_ptr_val).c_clone()),
                deref((<_module_types.containerStruct>struct_struct)._cpp_obj_FBTHRIFT_ONLY_DO_NOT_USE),
            ),
            ParamService_annotatedParams_callback,
            <PyObject *> __userdata
        )
        return asyncio_shield(__future)


    @staticmethod
    def __get_metadata__():
        cdef __fbthrift_cThriftServiceMetadataResponse response
        ServiceMetadata[_fbthrift_services_interface.cParamServiceSvIf].gen(response)
        return __MetadataBox.box(cmove(deref(response.metadata())))

    @staticmethod
    def __get_thrift_name__():
        return "module.ParamService"

