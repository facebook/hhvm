<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

/**
 * Original thrift enum:-
 * has_bitwise_ops
 */
enum has_bitwise_ops: int {
  none = 0;
  zero = 1;
  one = 2;
  two = 4;
  three = 8;
}

class has_bitwise_ops_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "module.has_bitwise_ops",
        "elements" => dict[
          0 => "none",
          1 => "zero",
          2 => "one",
          4 => "two",
          8 => "three",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Original thrift enum:-
 * is_unscoped
 */
enum is_unscoped: int {
  hello = 0;
  world = 1;
}

class is_unscoped_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "module.is_unscoped",
        "elements" => dict[
          0 => "hello",
          1 => "world",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Original thrift enum:-
 * MyForwardRefEnum
 */
enum MyForwardRefEnum: int {
  ZERO = 0;
  NONZERO = 12;
}

class MyForwardRefEnum_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "module.MyForwardRefEnum",
        "elements" => dict[
          0 => "ZERO",
          12 => "NONZERO",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Original thrift enum:-
 * MyEnumA
 */
enum MyEnumA: int {
  fieldA = 1;
  fieldB = 2;
  fieldC = 4;
}

class MyEnumA_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "module.MyEnumA",
        "elements" => dict[
          1 => "fieldA",
          2 => "fieldB",
          4 => "fieldC",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[],
      'constants' => dict[
      ],
    );
  }
}

/**
 * Original thrift struct:-
 * decorated_struct
 */
class decorated_struct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'field',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'field' => 1,
  ];

  const type TConstructorShape = shape(
    ?'field' => ?string,
  );

  const int STRUCTURAL_ID = 6158382972310209096;
  /**
   * Original thrift field:-
   * 1: string field
   */
  public string $field;

  public function __construct(?string $field = null)[] {
    $this->field = $field ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'field'),
    );
  }

  public function getName()[]: string {
    return 'decorated_struct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.decorated_struct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "field",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'field') !== null) {
      $this->field = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['field']);
    }
  }

}

/**
 * Original thrift struct:-
 * ContainerStruct
 */
class ContainerStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    12 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'fieldB',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'fieldC',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'fieldD',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    5 => shape(
      'var' => 'fieldE',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    6 => shape(
      'var' => 'fieldF',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    7 => shape(
      'var' => 'fieldG',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
    8 => shape(
      'var' => 'fieldH',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 12,
    'fieldB' => 2,
    'fieldC' => 3,
    'fieldD' => 4,
    'fieldE' => 5,
    'fieldF' => 6,
    'fieldG' => 7,
    'fieldH' => 8,
  ];

  const type TConstructorShape = shape(
    ?'fieldA' => ?Vector<int>,
    ?'fieldB' => ?Vector<int>,
    ?'fieldC' => ?Vector<int>,
    ?'fieldD' => ?Vector<int>,
    ?'fieldE' => ?Vector<int>,
    ?'fieldF' => ?Set<int>,
    ?'fieldG' => ?Map<int, string>,
    ?'fieldH' => ?Map<int, string>,
  );

  const int STRUCTURAL_ID = 2901459969892394021;
  /**
   * Original thrift field:-
   * 12: list<i32> fieldA
   */
  public Vector<int> $fieldA;
  /**
   * Original thrift field:-
   * 2: list<i32> fieldB
   */
  public Vector<int> $fieldB;
  /**
   * Original thrift field:-
   * 3: list<i32> fieldC
   */
  public Vector<int> $fieldC;
  /**
   * Original thrift field:-
   * 4: list<i32> fieldD
   */
  public Vector<int> $fieldD;
  /**
   * Original thrift field:-
   * 5: list<i32> fieldE
   */
  public Vector<int> $fieldE;
  /**
   * Original thrift field:-
   * 6: set<i32> fieldF
   */
  public Set<int> $fieldF;
  /**
   * Original thrift field:-
   * 7: map<i32, string> fieldG
   */
  public Map<int, string> $fieldG;
  /**
   * Original thrift field:-
   * 8: map<i32, string> fieldH
   */
  public Map<int, string> $fieldH;

  public function __construct(?Vector<int> $fieldA = null, ?Vector<int> $fieldB = null, ?Vector<int> $fieldC = null, ?Vector<int> $fieldD = null, ?Vector<int> $fieldE = null, ?Set<int> $fieldF = null, ?Map<int, string> $fieldG = null, ?Map<int, string> $fieldH = null)[] {
    $this->fieldA = $fieldA ?? Vector {};
    $this->fieldB = $fieldB ?? Vector {};
    $this->fieldC = $fieldC ?? Vector {};
    $this->fieldD = $fieldD ?? Vector {};
    $this->fieldE = $fieldE ?? Vector {};
    $this->fieldF = $fieldF ?? Set {};
    $this->fieldG = $fieldG ?? Map {};
    $this->fieldH = $fieldH ?? Map {};
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'fieldA'),
      Shapes::idx($shape, 'fieldB'),
      Shapes::idx($shape, 'fieldC'),
      Shapes::idx($shape, 'fieldD'),
      Shapes::idx($shape, 'fieldE'),
      Shapes::idx($shape, 'fieldF'),
      Shapes::idx($shape, 'fieldG'),
      Shapes::idx($shape, 'fieldH'),
    );
  }

  public function getName()[]: string {
    return 'ContainerStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ContainerStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 12,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldA",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldB",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldC",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldD",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldE",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_set" => tmeta_ThriftSetType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldF",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldG",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.SomeMap",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_map" => tmeta_ThriftMapType::fromShape(
                            shape(
                              "keyType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                )
                              ),
                              "valueType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldH",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldA']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }
    if (idx($parsed, 'fieldB') !== null) {
      $_json10 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldB']);
      $_container11 = Vector {};
      foreach($_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11 []= $_elem12;
      }
      $this->fieldB = $_container11;
    }
    if (idx($parsed, 'fieldC') !== null) {
      $_json17 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldC']);
      $_container18 = Vector {};
      foreach($_json17 as $_key15 => $_value16) {
        $_elem19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem19 = (int)$_tmp20;
        }
        $_container18 []= $_elem19;
      }
      $this->fieldC = $_container18;
    }
    if (idx($parsed, 'fieldD') !== null) {
      $_json24 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldD']);
      $_container25 = Vector {};
      foreach($_json24 as $_key22 => $_value23) {
        $_elem26 = 0;
        $_tmp27 = (int)$_value23;
        if ($_tmp27 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem26 = (int)$_tmp27;
        }
        $_container25 []= $_elem26;
      }
      $this->fieldD = $_container25;
    }
    if (idx($parsed, 'fieldE') !== null) {
      $_json31 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldE']);
      $_container32 = Vector {};
      foreach($_json31 as $_key29 => $_value30) {
        $_elem33 = 0;
        $_tmp34 = (int)$_value30;
        if ($_tmp34 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem33 = (int)$_tmp34;
        }
        $_container32 []= $_elem33;
      }
      $this->fieldE = $_container32;
    }
    if (idx($parsed, 'fieldF') !== null) {
      $_json38 = HH\FIXME\UNSAFE_CAST<mixed, Set<int>>($parsed['fieldF']);
      $_container39 = Set {};
      foreach($_json38 as $_key36 => $_value37) {
        $_elem40 = 0;
        $_tmp41 = (int)$_value37;
        if ($_tmp41 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem40 = (int)$_tmp41;
        }
        $_container39->add($_elem40);
      }
      $this->fieldF = $_container39;
    }
    if (idx($parsed, 'fieldG') !== null) {
      $_json45 = HH\FIXME\UNSAFE_CAST<mixed, Map<int, string>>($parsed['fieldG']);
      $_container46 = Map {};
      foreach($_json45 as $_key43 => $_value44) {
        $_value47 = '';
        $_value47 = $_value44;
        $_container46[$_key43] = $_value47;
      }
      $this->fieldG = $_container46;
    }
    if (idx($parsed, 'fieldH') !== null) {
      $_json51 = HH\FIXME\UNSAFE_CAST<mixed, Map<int, string>>($parsed['fieldH']);
      $_container52 = Map {};
      foreach($_json51 as $_key49 => $_value50) {
        $_value53 = '';
        $_value53 = $_value50;
        $_container52[$_key49] = $_value53;
      }
      $this->fieldH = $_container52;
    }
  }

}

/**
 * Original thrift struct:-
 * CppTypeStruct
 */
class CppTypeStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'fieldA',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'fieldA' => 1,
  ];

  const type TConstructorShape = shape(
    ?'fieldA' => ?Vector<int>,
  );

  const int STRUCTURAL_ID = 9369458949141941;
  /**
   * Original thrift field:-
   * 1: list<i32> fieldA
   */
  public Vector<int> $fieldA;

  public function __construct(?Vector<int> $fieldA = null)[] {
    $this->fieldA = $fieldA ?? Vector {};
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'fieldA'),
    );
  }

  public function getName()[]: string {
    return 'CppTypeStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.CppTypeStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "fieldA",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'fieldA') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['fieldA']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->fieldA = $_container4;
    }
  }

}

/**
 * Original thrift struct:-
 * VirtualStruct
 */
class VirtualStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
  ];

  const type TConstructorShape = shape(
    ?'MyIntField' => ?int,
  );

  const int STRUCTURAL_ID = 7014352813131039231;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;

  public function __construct(?int $MyIntField = null)[] {
    $this->MyIntField = $MyIntField ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'MyIntField'),
    );
  }

  public function getName()[]: string {
    return 'VirtualStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.VirtualStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "MyIntField",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['MyIntField']);
    }
  }

}

/**
 * Original thrift struct:-
 * MyStructWithForwardRefEnum
 */
class MyStructWithForwardRefEnum implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::I32,
      'enum' => MyForwardRefEnum::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => ?MyForwardRefEnum,
    ?'b' => ?MyForwardRefEnum,
  );

  const int STRUCTURAL_ID = 6098225215594902198;
  /**
   * Original thrift field:-
   * 1: enum module.MyForwardRefEnum a
   */
  public ?MyForwardRefEnum $a;
  /**
   * Original thrift field:-
   * 2: enum module.MyForwardRefEnum b
   */
  public ?MyForwardRefEnum $b;

  public function __construct(?MyForwardRefEnum $a = null, ?MyForwardRefEnum $b = null)[] {
    $this->a = $a ?? MyForwardRefEnum::NONZERO;
    $this->b = $b ?? MyForwardRefEnum::NONZERO;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName()[]: string {
    return 'MyStructWithForwardRefEnum';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyStructWithForwardRefEnum",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.MyForwardRefEnum",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_enum" => tmeta_ThriftEnumType::fromShape(
                            shape(
                              "name" => "module.MyForwardRefEnum",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "a",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.MyForwardRefEnum",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_enum" => tmeta_ThriftEnumType::fromShape(
                            shape(
                              "name" => "module.MyForwardRefEnum",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "b",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = MyForwardRefEnum::coerce(HH\FIXME\UNSAFE_CAST<mixed, MyForwardRefEnum>($parsed['a']));
    }
    if (idx($parsed, 'b') !== null) {
      $this->b = MyForwardRefEnum::coerce(HH\FIXME\UNSAFE_CAST<mixed, MyForwardRefEnum>($parsed['b']));
    }
  }

}

/**
 * Original thrift struct:-
 * TrivialNumeric
 */
class TrivialNumeric implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => ?int,
    ?'b' => ?bool,
  );

  const int STRUCTURAL_ID = 3920068475021763685;
  /**
   * Original thrift field:-
   * 1: i32 a
   */
  public int $a;
  /**
   * Original thrift field:-
   * 2: bool b
   */
  public bool $b;

  public function __construct(?int $a = null, ?bool $b = null)[] {
    $this->a = $a ?? 0;
    $this->b = $b ?? false;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName()[]: string {
    return 'TrivialNumeric';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.TrivialNumeric",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "a",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "b",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['a']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->a = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'b') !== null) {
      $this->b = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['b']);
    }
  }

}

/**
 * Original thrift struct:-
 * TrivialNestedWithDefault
 */
class TrivialNestedWithDefault implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => TrivialNumeric::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];

  const type TConstructorShape = shape(
    ?'z' => ?int,
    ?'n' => ?TrivialNumeric,
  );

  const int STRUCTURAL_ID = 5012136746274172257;
  /**
   * Original thrift field:-
   * 1: i32 z
   */
  public int $z;
  /**
   * Original thrift field:-
   * 2: struct module.TrivialNumeric n
   */
  public ?TrivialNumeric $n;

  public function __construct(?int $z = null, ?TrivialNumeric $n = null)[] {
    $this->z = $z ?? 4;
    $this->n = $n;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'z'),
      Shapes::idx($shape, 'n'),
    );
  }

  public function getName()[]: string {
    return 'TrivialNestedWithDefault';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.TrivialNestedWithDefault",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "z",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.TrivialNumeric",
                    )
                  ),
                )
              ),
              "name" => "n",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['z']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->z = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'n') !== null) {
      $_tmp1 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, TrivialNumeric>($parsed['n']));
      $_tmp2 = TrivialNumeric::withDefaultValues();
      $_tmp2->readFromJson($_tmp1);
      $this->n = $_tmp2;
    }
  }

}

/**
 * Original thrift struct:-
 * ComplexString
 */
class ComplexString implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'a',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'b',
      'type' => \TType::MAP,
      'ktype' => \TType::STRING,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::STRING,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'a' => 1,
    'b' => 2,
  ];

  const type TConstructorShape = shape(
    ?'a' => ?string,
    ?'b' => ?Map<string, int>,
  );

  const int STRUCTURAL_ID = 5460740530481786095;
  /**
   * Original thrift field:-
   * 1: string a
   */
  public string $a;
  /**
   * Original thrift field:-
   * 2: map<string, i32> b
   */
  public Map<string, int> $b;

  public function __construct(?string $a = null, ?Map<string, int> $b = null)[] {
    $this->a = $a ?? '';
    $this->b = $b ?? Map {};
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'a'),
      Shapes::idx($shape, 'b'),
    );
  }

  public function getName()[]: string {
    return 'ComplexString';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ComplexString",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "a",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "b",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'a') !== null) {
      $this->a = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['a']);
    }
    if (idx($parsed, 'b') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Map<string, int>>($parsed['b']);
      $_container4 = Map {};
      foreach($_json3 as $_key1 => $_value2) {
        $_value5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_value5 = (int)$_tmp6;
        }
        $_container4[$_key1] = $_value5;
      }
      $this->b = $_container4;
    }
  }

}

/**
 * Original thrift struct:-
 * ComplexNestedWithDefault
 */
class ComplexNestedWithDefault implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'z',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'n',
      'type' => \TType::STRUCT,
      'class' => ComplexString::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'z' => 1,
    'n' => 2,
  ];

  const type TConstructorShape = shape(
    ?'z' => ?string,
    ?'n' => ?ComplexString,
  );

  const int STRUCTURAL_ID = 2913723608362321564;
  /**
   * Original thrift field:-
   * 1: string z
   */
  public string $z;
  /**
   * Original thrift field:-
   * 2: struct module.ComplexString n
   */
  public ?ComplexString $n;

  public function __construct(?string $z = null, ?ComplexString $n = null)[] {
    $this->z = $z ?? "4";
    $this->n = $n;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'z'),
      Shapes::idx($shape, 'n'),
    );
  }

  public function getName()[]: string {
    return 'ComplexNestedWithDefault';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ComplexNestedWithDefault",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "z",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.ComplexString",
                    )
                  ),
                )
              ),
              "name" => "n",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'z') !== null) {
      $this->z = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['z']);
    }
    if (idx($parsed, 'n') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, ComplexString>($parsed['n']));
      $_tmp1 = ComplexString::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->n = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * MinPadding
 */
class MinPadding implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'small',
      'type' => \TType::BYTE,
    ),
    2 => shape(
      'var' => 'big',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'medium',
      'type' => \TType::I16,
    ),
    4 => shape(
      'var' => 'biggish',
      'type' => \TType::I32,
    ),
    5 => shape(
      'var' => 'tiny',
      'type' => \TType::BYTE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'small' => 1,
    'big' => 2,
    'medium' => 3,
    'biggish' => 4,
    'tiny' => 5,
  ];

  const type TConstructorShape = shape(
    ?'small' => ?int,
    ?'big' => ?int,
    ?'medium' => ?int,
    ?'biggish' => ?int,
    ?'tiny' => ?int,
  );

  const int STRUCTURAL_ID = 723753448680843528;
  /**
   * Original thrift field:-
   * 1: byte small
   */
  public int $small;
  /**
   * Original thrift field:-
   * 2: i64 big
   */
  public int $big;
  /**
   * Original thrift field:-
   * 3: i16 medium
   */
  public int $medium;
  /**
   * Original thrift field:-
   * 4: i32 biggish
   */
  public int $biggish;
  /**
   * Original thrift field:-
   * 5: byte tiny
   */
  public int $tiny;

  public function __construct(?int $small = null, ?int $big = null, ?int $medium = null, ?int $biggish = null, ?int $tiny = null)[] {
    $this->small = $small ?? 0;
    $this->big = $big ?? 0;
    $this->medium = $medium ?? 0;
    $this->biggish = $biggish ?? 0;
    $this->tiny = $tiny ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'small'),
      Shapes::idx($shape, 'big'),
      Shapes::idx($shape, 'medium'),
      Shapes::idx($shape, 'biggish'),
      Shapes::idx($shape, 'tiny'),
    );
  }

  public function getName()[]: string {
    return 'MinPadding';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MinPadding",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "small",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "big",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "medium",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "biggish",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "tiny",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'small') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['small']);
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->small = (int)$_tmp0;
      }
    } else {
      throw new \TProtocolException("Required field small cannot be found.");
    }
    if (idx($parsed, 'big') !== null) {
      $this->big = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['big']);
    } else {
      throw new \TProtocolException("Required field big cannot be found.");
    }
    if (idx($parsed, 'medium') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['medium']);
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->medium = (int)$_tmp1;
      }
    } else {
      throw new \TProtocolException("Required field medium cannot be found.");
    }
    if (idx($parsed, 'biggish') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['biggish']);
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->biggish = (int)$_tmp2;
      }
    } else {
      throw new \TProtocolException("Required field biggish cannot be found.");
    }
    if (idx($parsed, 'tiny') !== null) {
      $_tmp3 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['tiny']);
      if ($_tmp3 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->tiny = (int)$_tmp3;
      }
    } else {
      throw new \TProtocolException("Required field tiny cannot be found.");
    }
  }

}

/**
 * Original thrift struct:-
 * MyStruct
 */
class MyStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    2 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    3 => shape(
      'var' => 'majorVer',
      'type' => \TType::I64,
    ),
    4 => shape(
      'var' => 'data',
      'type' => \TType::STRUCT,
      'class' => MyDataItem::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyIntField' => 1,
    'MyStringField' => 2,
    'majorVer' => 3,
    'data' => 4,
  ];

  const type TConstructorShape = shape(
    ?'MyIntField' => ?int,
    ?'MyStringField' => ?string,
    ?'majorVer' => ?int,
    ?'data' => ?MyDataItem,
  );

  const int STRUCTURAL_ID = 2472338421128341558;
  /**
   * Original thrift field:-
   * 1: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 2: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 3: i64 majorVer
   */
  public int $majorVer;
  /**
   * Original thrift field:-
   * 4: struct module.MyDataItem data
   */
  public ?MyDataItem $data;

  public function __construct(?int $MyIntField = null, ?string $MyStringField = null, ?int $majorVer = null, ?MyDataItem $data = null)[] {
    $this->MyIntField = $MyIntField ?? 0;
    $this->MyStringField = $MyStringField ?? '';
    $this->majorVer = $majorVer ?? 0;
    $this->data = $data;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'MyIntField'),
      Shapes::idx($shape, 'MyStringField'),
      Shapes::idx($shape, 'majorVer'),
      Shapes::idx($shape, 'data'),
    );
  }

  public function getName()[]: string {
    return 'MyStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "MyIntField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "MyStringField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "majorVer",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.MyDataItem",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "module.MyDataItem",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "data",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['MyIntField']);
    }
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyStringField']);
    }
    if (idx($parsed, 'majorVer') !== null) {
      $this->majorVer = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['majorVer']);
    }
    if (idx($parsed, 'data') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, MyDataItem>($parsed['data']));
      $_tmp1 = MyDataItem::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->data = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * MyDataItem
 */
class MyDataItem implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'MyDataItem';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.MyDataItem",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * Renaming
 */
class Renaming implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => ?int,
  );

  const int STRUCTURAL_ID = 2811793053530639830;
  /**
   * Original thrift field:-
   * 1: i64 foo
   */
  public int $foo;

  public function __construct(?int $foo = null)[] {
    $this->foo = $foo ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName()[]: string {
    return 'Renaming';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.Renaming",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "foo",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $this->foo = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['foo']);
    }
  }

}

/**
 * Original thrift struct:-
 * AnnotatedTypes
 */
class AnnotatedTypes implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'binary_field',
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    2 => shape(
      'var' => 'list_field',
      'type' => \TType::LST,
      'etype' => \TType::MAP,
      'elem' => shape(
        'type' => \TType::MAP,
        'ktype' => \TType::I32,
        'vtype' => \TType::STRING,
        'key' => shape(
          'type' => \TType::I32,
        ),
        'val' => shape(
          'type' => \TType::STRING,
        ),
        'format' => 'collection',
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'binary_field' => 1,
    'list_field' => 2,
  ];

  const type TConstructorShape = shape(
    ?'binary_field' => ?string,
    ?'list_field' => ?Vector<Map<int, string>>,
  );

  const int STRUCTURAL_ID = 7799859984459418183;
  /**
   * Original thrift field:-
   * 1: binary binary_field
   */
  public string $binary_field;
  /**
   * Original thrift field:-
   * 2: list<map<i32, string>> list_field
   */
  public Vector<Map<int, string>> $list_field;

  public function __construct(?string $binary_field = null, ?Vector<Map<int, string>> $list_field = null)[] {
    $this->binary_field = $binary_field ?? '';
    $this->list_field = $list_field ?? Vector {};
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'binary_field'),
      Shapes::idx($shape, 'list_field'),
    );
  }

  public function getName()[]: string {
    return 'AnnotatedTypes';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.AnnotatedTypes",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.TBinary",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                            shape(
                              "name" => "module.TBinary",
                              "underlyingType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "binary_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "include.SomeListOfTypeMap",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                            shape(
                              "name" => "include.SomeListOfTypeMap",
                              "underlyingType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_list" => tmeta_ThriftListType::fromShape(
                                    shape(
                                      "valueType" => tmeta_ThriftType::fromShape(
                                        shape(
                                          "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                                            shape(
                                              "name" => "include.SomeMap",
                                              "underlyingType" => tmeta_ThriftType::fromShape(
                                                shape(
                                                  "t_map" => tmeta_ThriftMapType::fromShape(
                                                    shape(
                                                      "keyType" => tmeta_ThriftType::fromShape(
                                                        shape(
                                                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                                        )
                                                      ),
                                                      "valueType" => tmeta_ThriftType::fromShape(
                                                        shape(
                                                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                                                        )
                                                      ),
                                                    )
                                                  ),
                                                )
                                              ),
                                            )
                                          ),
                                        )
                                      ),
                                    )
                                  ),
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "list_field",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'binary_field') !== null) {
      $this->binary_field = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['binary_field']);
    }
    if (idx($parsed, 'list_field') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<Map<int, string>>>($parsed['list_field']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = Map {};
        $_json9 = $_value2;
        $_container10 = Map {};
        foreach($_json9 as $_key7 => $_value8) {
          $_value11 = '';
          $_value11 = $_value8;
          $_container10[$_key7] = $_value11;
        }
        $_elem5 = $_container10;
        $_container4 []= $_elem5;
      }
      $this->list_field = $_container4;
    }
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageRoot
 */
class ForwardUsageRoot implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'ForwardUsageStruct',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageStruct::class,
    ),
    2 => shape(
      'var' => 'ForwardUsageByRef',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageByRef::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'ForwardUsageStruct' => 1,
    'ForwardUsageByRef' => 2,
  ];

  const type TConstructorShape = shape(
    ?'ForwardUsageStruct' => ?ForwardUsageStruct,
    ?'ForwardUsageByRef' => ?ForwardUsageByRef,
  );

  const int STRUCTURAL_ID = 839155360071855827;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageStruct ForwardUsageStruct
   */
  public ?ForwardUsageStruct $ForwardUsageStruct;
  /**
   * Original thrift field:-
   * 2: struct module.ForwardUsageByRef ForwardUsageByRef
   */
  public ?ForwardUsageByRef $ForwardUsageByRef;

  public function __construct(?ForwardUsageStruct $ForwardUsageStruct = null, ?ForwardUsageByRef $ForwardUsageByRef = null)[] {
    $this->ForwardUsageStruct = $ForwardUsageStruct;
    $this->ForwardUsageByRef = $ForwardUsageByRef;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'ForwardUsageStruct'),
      Shapes::idx($shape, 'ForwardUsageByRef'),
    );
  }

  public function getName()[]: string {
    return 'ForwardUsageRoot';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ForwardUsageRoot",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.ForwardUsageStruct",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "module.ForwardUsageStruct",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "ForwardUsageStruct",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.ForwardUsageByRef",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_struct" => tmeta_ThriftStructType::fromShape(
                            shape(
                              "name" => "module.ForwardUsageByRef",
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "ForwardUsageByRef",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'ForwardUsageStruct') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, ForwardUsageStruct>($parsed['ForwardUsageStruct']));
      $_tmp1 = ForwardUsageStruct::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->ForwardUsageStruct = $_tmp1;
    }
    if (idx($parsed, 'ForwardUsageByRef') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, ForwardUsageByRef>($parsed['ForwardUsageByRef']));
      $_tmp3 = ForwardUsageByRef::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->ForwardUsageByRef = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageStruct
 */
class ForwardUsageStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => ?ForwardUsageRoot,
  );

  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  public function __construct(?ForwardUsageRoot $foo = null)[] {
    $this->foo = $foo;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName()[]: string {
    return 'ForwardUsageStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ForwardUsageStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.ForwardUsageRoot",
                    )
                  ),
                )
              ),
              "name" => "foo",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, ForwardUsageRoot>($parsed['foo']));
      $_tmp1 = ForwardUsageRoot::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * ForwardUsageByRef
 */
class ForwardUsageByRef implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'foo',
      'type' => \TType::STRUCT,
      'class' => ForwardUsageRoot::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'foo' => 1,
  ];

  const type TConstructorShape = shape(
    ?'foo' => ?ForwardUsageRoot,
  );

  const int STRUCTURAL_ID = 7148256645166217470;
  /**
   * Original thrift field:-
   * 1: struct module.ForwardUsageRoot foo
   */
  public ?ForwardUsageRoot $foo;

  public function __construct(?ForwardUsageRoot $foo = null)[] {
    $this->foo = $foo;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'foo'),
    );
  }

  public function getName()[]: string {
    return 'ForwardUsageByRef';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.ForwardUsageByRef",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "module.ForwardUsageRoot",
                    )
                  ),
                )
              ),
              "name" => "foo",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'foo') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, ForwardUsageRoot>($parsed['foo']));
      $_tmp1 = ForwardUsageRoot::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->foo = $_tmp1;
    }
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveEmpty
 */
class NoexceptMoveEmpty implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'NoexceptMoveEmpty';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.NoexceptMoveEmpty",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveSimpleStruct
 */
class NoexceptMoveSimpleStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'boolField',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'boolField' => 1,
  ];

  const type TConstructorShape = shape(
    ?'boolField' => ?int,
  );

  const int STRUCTURAL_ID = 7058232826271171943;
  /**
   * Original thrift field:-
   * 1: i64 boolField
   */
  public int $boolField;

  public function __construct(?int $boolField = null)[] {
    $this->boolField = $boolField ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'boolField'),
    );
  }

  public function getName()[]: string {
    return 'NoexceptMoveSimpleStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.NoexceptMoveSimpleStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "boolField",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'boolField') !== null) {
      $this->boolField = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['boolField']);
    }
  }

}

/**
 * Original thrift struct:-
 * NoexceptMoveComplexStruct
 */
class NoexceptMoveComplexStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'MyBoolField',
      'type' => \TType::BOOL,
    ),
    2 => shape(
      'var' => 'MyIntField',
      'type' => \TType::I64,
    ),
    3 => shape(
      'var' => 'MyStringField',
      'type' => \TType::STRING,
    ),
    4 => shape(
      'var' => 'MyStringField2',
      'type' => \TType::STRING,
    ),
    5 => shape(
      'var' => 'MyBinaryField',
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    6 => shape(
      'var' => 'MyBinaryField2',
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    7 => shape(
      'var' => 'MyBinaryField3',
      'type' => \TType::STRING,
      'is_binary' => true,
    ),
    8 => shape(
      'var' => 'MyBinaryListField4',
      'type' => \TType::LST,
      'etype' => \TType::STRING,
      'elem' => shape(
        'type' => \TType::STRING,
        'is_binary' => true,
      ),
      'format' => 'collection',
    ),
    9 => shape(
      'var' => 'MyMapEnumAndInt',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::STRING,
      'key' => shape(
        'type' => \TType::I32,
        'enum' => MyEnumA::class,
      ),
      'val' => shape(
        'type' => \TType::STRING,
      ),
      'format' => 'collection',
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'MyBoolField' => 1,
    'MyIntField' => 2,
    'MyStringField' => 3,
    'MyStringField2' => 4,
    'MyBinaryField' => 5,
    'MyBinaryField2' => 6,
    'MyBinaryField3' => 7,
    'MyBinaryListField4' => 8,
    'MyMapEnumAndInt' => 9,
  ];

  const type TConstructorShape = shape(
    ?'MyBoolField' => ?bool,
    ?'MyIntField' => ?int,
    ?'MyStringField' => ?string,
    ?'MyStringField2' => ?string,
    ?'MyBinaryField' => ?string,
    ?'MyBinaryField2' => ?string,
    ?'MyBinaryField3' => ?string,
    ?'MyBinaryListField4' => ?Vector<string>,
    ?'MyMapEnumAndInt' => ?Map<MyEnumA, string>,
  );

  const int STRUCTURAL_ID = 8958221528844030164;
  /**
   * Original thrift field:-
   * 1: bool MyBoolField
   */
  public bool $MyBoolField;
  /**
   * Original thrift field:-
   * 2: i64 MyIntField
   */
  public int $MyIntField;
  /**
   * Original thrift field:-
   * 3: string MyStringField
   */
  public string $MyStringField;
  /**
   * Original thrift field:-
   * 4: string MyStringField2
   */
  public string $MyStringField2;
  /**
   * Original thrift field:-
   * 5: binary MyBinaryField
   */
  public string $MyBinaryField;
  /**
   * Original thrift field:-
   * 6: binary MyBinaryField2
   */
  public ?string $MyBinaryField2;
  /**
   * Original thrift field:-
   * 7: binary MyBinaryField3
   */
  public string $MyBinaryField3;
  /**
   * Original thrift field:-
   * 8: list<binary> MyBinaryListField4
   */
  public Vector<string> $MyBinaryListField4;
  /**
   * Original thrift field:-
   * 9: map<enum module.MyEnumA, string> MyMapEnumAndInt
   */
  public Map<MyEnumA, string> $MyMapEnumAndInt;

  public function __construct(?bool $MyBoolField = null, ?int $MyIntField = null, ?string $MyStringField = null, ?string $MyStringField2 = null, ?string $MyBinaryField = null, ?string $MyBinaryField2 = null, ?string $MyBinaryField3 = null, ?Vector<string> $MyBinaryListField4 = null, ?Map<MyEnumA, string> $MyMapEnumAndInt = null)[] {
    $this->MyBoolField = $MyBoolField ?? false;
    $this->MyIntField = $MyIntField ?? 12;
    $this->MyStringField = $MyStringField ?? "test";
    $this->MyStringField2 = $MyStringField2 ?? '';
    $this->MyBinaryField = $MyBinaryField ?? '';
    $this->MyBinaryField2 = $MyBinaryField2;
    $this->MyBinaryField3 = $MyBinaryField3 ?? '';
    $this->MyBinaryListField4 = $MyBinaryListField4 ?? Vector {};
    $this->MyMapEnumAndInt = $MyMapEnumAndInt ?? Map {
      MyEnumA::fieldA => "fieldA",
      MyEnumA::fieldC => "fieldC",
    };
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'MyBoolField'),
      Shapes::idx($shape, 'MyIntField'),
      Shapes::idx($shape, 'MyStringField'),
      Shapes::idx($shape, 'MyStringField2'),
      Shapes::idx($shape, 'MyBinaryField'),
      Shapes::idx($shape, 'MyBinaryField2'),
      Shapes::idx($shape, 'MyBinaryField3'),
      Shapes::idx($shape, 'MyBinaryListField4'),
      Shapes::idx($shape, 'MyMapEnumAndInt'),
    );
  }

  public function getName()[]: string {
    return 'NoexceptMoveComplexStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.NoexceptMoveComplexStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "MyBoolField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "MyIntField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "MyStringField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "MyStringField2",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "MyBinaryField",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "MyBinaryField2",
              "is_optional" => true,
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "MyBinaryField3",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "MyBinaryListField4",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 9,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_enum" => tmeta_ThriftEnumType::fromShape(
                            shape(
                              "name" => "module.MyEnumA",
                            )
                          ),
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "MyMapEnumAndInt",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'MyBoolField') !== null) {
      $this->MyBoolField = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['MyBoolField']);
    }
    if (idx($parsed, 'MyIntField') !== null) {
      $this->MyIntField = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['MyIntField']);
    }
    if (idx($parsed, 'MyStringField') !== null) {
      $this->MyStringField = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyStringField']);
    }
    if (idx($parsed, 'MyStringField2') !== null) {
      $this->MyStringField2 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyStringField2']);
    }
    if (idx($parsed, 'MyBinaryField') !== null) {
      $this->MyBinaryField = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyBinaryField']);
    }
    if (idx($parsed, 'MyBinaryField2') !== null) {
      $this->MyBinaryField2 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyBinaryField2']);
    }
    if (idx($parsed, 'MyBinaryField3') !== null) {
      $this->MyBinaryField3 = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['MyBinaryField3']);
    } else {
      throw new \TProtocolException("Required field MyBinaryField3 cannot be found.");
    }
    if (idx($parsed, 'MyBinaryListField4') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<string>>($parsed['MyBinaryListField4']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = '';
        $_elem5 = $_value2;
        $_container4 []= $_elem5;
      }
      $this->MyBinaryListField4 = $_container4;
    }
    if (idx($parsed, 'MyMapEnumAndInt') !== null) {
      $_json9 = HH\FIXME\UNSAFE_CAST<mixed, Map<MyEnumA, string>>($parsed['MyMapEnumAndInt']);
      $_container10 = Map {};
      foreach($_json9 as $_key7 => $_value8) {
        $_value11 = '';
        $_value11 = $_value8;
        $_container10[$_key7] = $_value11;
      }
      $this->MyMapEnumAndInt = $_container10;
    }
  }

}

enum NoExceptMoveUnionEnum: int {
  _EMPTY_ = 0;
  string_field = 1;
  i32_field = 2;
}

/**
 * Original thrift struct:-
 * NoExceptMoveUnion
 */
class NoExceptMoveUnion implements \IThriftSyncStruct, \IThriftUnion<NoExceptMoveUnionEnum> {
  use \ThriftUnionSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'string_field',
      'union' => true,
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'i32_field',
      'union' => true,
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'string_field' => 1,
    'i32_field' => 2,
  ];

  const type TConstructorShape = shape(
    ?'string_field' => ?string,
    ?'i32_field' => ?int,
  );

  const int STRUCTURAL_ID = 5659539827624892912;
  /**
   * Original thrift field:-
   * 1: string string_field
   */
  public ?string $string_field;
  /**
   * Original thrift field:-
   * 2: i32 i32_field
   */
  public ?int $i32_field;
  protected NoExceptMoveUnionEnum $_type = NoExceptMoveUnionEnum::_EMPTY_;

  public function __construct(?string $string_field = null, ?int $i32_field = null)[] {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    if ($string_field !== null) {
      $this->string_field = $string_field;
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }
    if ($i32_field !== null) {
      $this->i32_field = $i32_field;
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'string_field'),
      Shapes::idx($shape, 'i32_field'),
    );
  }

  public function getName()[]: string {
    return 'NoExceptMoveUnion';
  }

  public function getType()[]: NoExceptMoveUnionEnum {
    return $this->_type;
  }

  public function reset()[write_props]: void {
    switch ($this->_type) {
      case NoExceptMoveUnionEnum::string_field:
        $this->string_field = null;
        break;
      case NoExceptMoveUnionEnum::i32_field:
        $this->i32_field = null;
        break;
      case NoExceptMoveUnionEnum::_EMPTY_:
        break;
    }
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
  }

  public function set_string_field(string $string_field)[write_props]: this {
    $this->reset();
    $this->_type = NoExceptMoveUnionEnum::string_field;
    $this->string_field = $string_field;
    return $this;
  }

  public function get_string_field()[]: ?string {
    return $this->string_field;
  }

  public function getx_string_field()[]: string {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::string_field,
      'get_string_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->string_field as nonnull;
  }

  public function set_i32_field(int $i32_field)[write_props]: this {
    $this->reset();
    $this->_type = NoExceptMoveUnionEnum::i32_field;
    $this->i32_field = $i32_field;
    return $this;
  }

  public function get_i32_field()[]: ?int {
    return $this->i32_field;
  }

  public function getx_i32_field()[]: int {
    invariant(
      $this->_type === NoExceptMoveUnionEnum::i32_field,
      'get_i32_field called on an instance of NoExceptMoveUnion whose current type is %s',
      (string)$this->_type,
    );
    return $this->i32_field as nonnull;
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.NoExceptMoveUnion",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "string_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "i32_field",
            )
          ),
        ],
        "is_union" => true,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $this->_type = NoExceptMoveUnionEnum::_EMPTY_;
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'string_field') !== null) {
      $this->string_field = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['string_field']);
      $this->_type = NoExceptMoveUnionEnum::string_field;
    }
    if (idx($parsed, 'i32_field') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i32_field']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32_field = (int)$_tmp0;
      }
      $this->_type = NoExceptMoveUnionEnum::i32_field;
    }
  }

}

/**
 * Original thrift struct:-
 * AllocatorAware
 */
class AllocatorAware implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'aa_list',
      'type' => \TType::LST,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    2 => shape(
      'var' => 'aa_set',
      'type' => \TType::SET,
      'etype' => \TType::I32,
      'elem' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    3 => shape(
      'var' => 'aa_map',
      'type' => \TType::MAP,
      'ktype' => \TType::I32,
      'vtype' => \TType::I32,
      'key' => shape(
        'type' => \TType::I32,
      ),
      'val' => shape(
        'type' => \TType::I32,
      ),
      'format' => 'collection',
    ),
    4 => shape(
      'var' => 'aa_string',
      'type' => \TType::STRING,
    ),
    5 => shape(
      'var' => 'not_a_container',
      'type' => \TType::I32,
    ),
    6 => shape(
      'var' => 'aa_unique',
      'type' => \TType::I32,
    ),
    7 => shape(
      'var' => 'aa_shared',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'aa_list' => 1,
    'aa_set' => 2,
    'aa_map' => 3,
    'aa_string' => 4,
    'not_a_container' => 5,
    'aa_unique' => 6,
    'aa_shared' => 7,
  ];

  const type TConstructorShape = shape(
    ?'aa_list' => ?Vector<int>,
    ?'aa_set' => ?Set<int>,
    ?'aa_map' => ?Map<int, int>,
    ?'aa_string' => ?string,
    ?'not_a_container' => ?int,
    ?'aa_unique' => ?int,
    ?'aa_shared' => ?int,
  );

  const int STRUCTURAL_ID = 6797195997786481852;
  /**
   * Original thrift field:-
   * 1: list<i32> aa_list
   */
  public Vector<int> $aa_list;
  /**
   * Original thrift field:-
   * 2: set<i32> aa_set
   */
  public Set<int> $aa_set;
  /**
   * Original thrift field:-
   * 3: map<i32, i32> aa_map
   */
  public Map<int, int> $aa_map;
  /**
   * Original thrift field:-
   * 4: string aa_string
   */
  public string $aa_string;
  /**
   * Original thrift field:-
   * 5: i32 not_a_container
   */
  public int $not_a_container;
  /**
   * Original thrift field:-
   * 6: i32 aa_unique
   */
  public int $aa_unique;
  /**
   * Original thrift field:-
   * 7: i32 aa_shared
   */
  public int $aa_shared;

  public function __construct(?Vector<int> $aa_list = null, ?Set<int> $aa_set = null, ?Map<int, int> $aa_map = null, ?string $aa_string = null, ?int $not_a_container = null, ?int $aa_unique = null, ?int $aa_shared = null)[] {
    $this->aa_list = $aa_list ?? Vector {};
    $this->aa_set = $aa_set ?? Set {};
    $this->aa_map = $aa_map ?? Map {};
    $this->aa_string = $aa_string ?? '';
    $this->not_a_container = $not_a_container ?? 0;
    $this->aa_unique = $aa_unique ?? 0;
    $this->aa_shared = $aa_shared ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'aa_list'),
      Shapes::idx($shape, 'aa_set'),
      Shapes::idx($shape, 'aa_map'),
      Shapes::idx($shape, 'aa_string'),
      Shapes::idx($shape, 'not_a_container'),
      Shapes::idx($shape, 'aa_unique'),
      Shapes::idx($shape, 'aa_shared'),
    );
  }

  public function getName()[]: string {
    return 'AllocatorAware';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.AllocatorAware",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_list" => tmeta_ThriftListType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "aa_list",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_set" => tmeta_ThriftSetType::fromShape(
                    shape(
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "aa_set",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_map" => tmeta_ThriftMapType::fromShape(
                    shape(
                      "keyType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                      "valueType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "aa_map",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "aa_string",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 5,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "not_a_container",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "aa_unique",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 7,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "aa_shared",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'aa_list') !== null) {
      $_json3 = HH\FIXME\UNSAFE_CAST<mixed, Vector<int>>($parsed['aa_list']);
      $_container4 = Vector {};
      foreach($_json3 as $_key1 => $_value2) {
        $_elem5 = 0;
        $_tmp6 = (int)$_value2;
        if ($_tmp6 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem5 = (int)$_tmp6;
        }
        $_container4 []= $_elem5;
      }
      $this->aa_list = $_container4;
    }
    if (idx($parsed, 'aa_set') !== null) {
      $_json10 = HH\FIXME\UNSAFE_CAST<mixed, Set<int>>($parsed['aa_set']);
      $_container11 = Set {};
      foreach($_json10 as $_key8 => $_value9) {
        $_elem12 = 0;
        $_tmp13 = (int)$_value9;
        if ($_tmp13 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_elem12 = (int)$_tmp13;
        }
        $_container11->add($_elem12);
      }
      $this->aa_set = $_container11;
    }
    if (idx($parsed, 'aa_map') !== null) {
      $_json17 = HH\FIXME\UNSAFE_CAST<mixed, Map<int, int>>($parsed['aa_map']);
      $_container18 = Map {};
      foreach($_json17 as $_key15 => $_value16) {
        $_value19 = 0;
        $_tmp20 = (int)$_value16;
        if ($_tmp20 > 0x7fffffff) {
          throw new \TProtocolException("number exceeds limit in field");
        } else {
          $_value19 = (int)$_tmp20;
        }
        $_container18[$_key15] = $_value19;
      }
      $this->aa_map = $_container18;
    }
    if (idx($parsed, 'aa_string') !== null) {
      $this->aa_string = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['aa_string']);
    }
    if (idx($parsed, 'not_a_container') !== null) {
      $_tmp21 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['not_a_container']);
      if ($_tmp21 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->not_a_container = (int)$_tmp21;
      }
    }
    if (idx($parsed, 'aa_unique') !== null) {
      $_tmp22 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['aa_unique']);
      if ($_tmp22 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->aa_unique = (int)$_tmp22;
      }
    }
    if (idx($parsed, 'aa_shared') !== null) {
      $_tmp23 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['aa_shared']);
      if ($_tmp23 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->aa_shared = (int)$_tmp23;
      }
    }
  }

}

/**
 * Original thrift struct:-
 * AllocatorAware2
 */
class AllocatorAware2 implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'not_a_container',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'not_a_container' => 1,
  ];

  const type TConstructorShape = shape(
    ?'not_a_container' => ?int,
  );

  const int STRUCTURAL_ID = 3476753821834683211;
  /**
   * Original thrift field:-
   * 1: i32 not_a_container
   */
  public int $not_a_container;

  public function __construct(?int $not_a_container = null)[] {
    $this->not_a_container = $not_a_container ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'not_a_container'),
    );
  }

  public function getName()[]: string {
    return 'AllocatorAware2';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.AllocatorAware2",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "not_a_container",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'not_a_container') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['not_a_container']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->not_a_container = (int)$_tmp0;
      }
    }
  }

}

/**
 * Original thrift struct:-
 * TypedefStruct
 */
class TypedefStruct implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'i32_field',
      'type' => \TType::I32,
    ),
    2 => shape(
      'var' => 'IntTypedef_field',
      'type' => \TType::I32,
    ),
    3 => shape(
      'var' => 'UintTypedef_field',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'i32_field' => 1,
    'IntTypedef_field' => 2,
    'UintTypedef_field' => 3,
  ];

  const type TConstructorShape = shape(
    ?'i32_field' => ?int,
    ?'IntTypedef_field' => ?int,
    ?'UintTypedef_field' => ?int,
  );

  const int STRUCTURAL_ID = 9104074718450007174;
  /**
   * Original thrift field:-
   * 1: i32 i32_field
   */
  public int $i32_field;
  /**
   * Original thrift field:-
   * 2: i32 IntTypedef_field
   */
  public int $IntTypedef_field;
  /**
   * Original thrift field:-
   * 3: i32 UintTypedef_field
   */
  public int $UintTypedef_field;

  public function __construct(?int $i32_field = null, ?int $IntTypedef_field = null, ?int $UintTypedef_field = null)[] {
    $this->i32_field = $i32_field ?? 0;
    $this->IntTypedef_field = $IntTypedef_field ?? 0;
    $this->UintTypedef_field = $UintTypedef_field ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'i32_field'),
      Shapes::idx($shape, 'IntTypedef_field'),
      Shapes::idx($shape, 'UintTypedef_field'),
    );
  }

  public function getName()[]: string {
    return 'TypedefStruct';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.TypedefStruct",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "i32_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.IntTypedef",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "IntTypedef_field",
            )
          ),
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                    shape(
                      "name" => "module.UintTypedef",
                      "underlyingType" => tmeta_ThriftType::fromShape(
                        shape(
                          "t_typedef" => tmeta_ThriftTypedefType::fromShape(
                            shape(
                              "name" => "module.IntTypedef",
                              "underlyingType" => tmeta_ThriftType::fromShape(
                                shape(
                                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                                )
                              ),
                            )
                          ),
                        )
                      ),
                    )
                  ),
                )
              ),
              "name" => "UintTypedef_field",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'i32_field') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['i32_field']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->i32_field = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'IntTypedef_field') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['IntTypedef_field']);
      if ($_tmp1 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->IntTypedef_field = (int)$_tmp1;
      }
    }
    if (idx($parsed, 'UintTypedef_field') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['UintTypedef_field']);
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->UintTypedef_field = (int)$_tmp2;
      }
    }
  }

}

/**
 * Original thrift struct:-
 * StructWithDoubleUnderscores
 */
class StructWithDoubleUnderscores implements \IThriftSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => '__field',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    '__field' => 1,
  ];

  const type TConstructorShape = shape(
    ?'__field' => ?int,
  );

  const int STRUCTURAL_ID = 8209484534723602012;
  /**
   * Original thrift field:-
   * 1: i32 __field
   */
  public int $__field;

  public function __construct(?int $__field = null)[] {
    $this->__field = $__field ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, '__field'),
    );
  }

  public function getName()[]: string {
    return 'StructWithDoubleUnderscores';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "module.StructWithDoubleUnderscores",
        "fields" => vec[
          tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "__field",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[],
      'fields' => dict[
      ],
    );
  }

  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, '__field') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['__field']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->__field = (int)$_tmp0;
      }
    }
  }

}

