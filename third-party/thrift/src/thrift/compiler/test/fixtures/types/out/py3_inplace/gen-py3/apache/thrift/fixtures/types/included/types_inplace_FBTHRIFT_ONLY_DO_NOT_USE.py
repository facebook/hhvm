#
# Autogenerated by Thrift for included.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib
from builtins import property as _python__property

import typing as _typing
import folly.iobuf as _fbthrift_iobuf
import thrift.py3.types
from thrift.py3.types import (
    _fbthrift__is_float32,
    _fbthrift__filter_kwargs,
)
import thrift.py3.exceptions
import thrift.python.exceptions
import thrift.python.types
import apache.thrift.fixtures.types.included.thrift_types as _fbthrift_python_types
import apache.thrift.fixtures.types.included.thrift_enums as _fbthrift_python_enums



def get_types_reflection():
    return importlib.import_module(
        "apache.thrift.fixtures.types.included.types_reflection"
    )

def _get_py_deprecated_module():
    import thrift.util.converter # needed by _to_py_deprecated() call
    return importlib.import_module("included.ttypes")

_fbthrift__module_name__ = "apache.thrift.fixtures.types.included.types"

__all__ = []

### Enums ###

### Union Enums ###

### Containers ###
class std_unordered_map__Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map__Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map__Map__i32_string._check_key_type_or_raise
            check_val = std_unordered_map__Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> std_unordered_map__Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return std_unordered_map__Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(std_unordered_map__Map__i32_string)

__all__.append("std_unordered_map__Map__i32_string")

class List__std_unordered_map__Map__i32_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__std_unordered_map__Map__i32_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__std_unordered_map__Map__i32_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, str]")
        if not isinstance(item, std_unordered_map__Map__i32_string):
            item = std_unordered_map__Map__i32_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, std_unordered_map__Map__i32_string):
            return item
        try:
            return std_unordered_map__Map__i32_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__std_unordered_map__Map__i32_string:
        _items = [
            std_unordered_map__Map__i32_string.from_python(item)
            for item in python_list
        ]
        return List__std_unordered_map__Map__i32_string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__std_unordered_map__Map__i32_string)


__all__.append("List__std_unordered_map__Map__i32_string")


### Structured Types ###

### Constants
