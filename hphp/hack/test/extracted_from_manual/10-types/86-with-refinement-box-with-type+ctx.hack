// @generated by hh_manual from manual/hack/10-types/86-with-refinement.md
// @codegen-command : buck run fbcode//hphp/hack/src/hh_manual:hh_manual extract fbcode/hphp/hack/manual/hack/

interface Box {
  abstract const type T;
  abstract const ctx C super [defaults];
  public function get()[this::C]: this::T;
}

function unwrap_as_singleton_set<Tb as arraykey>(
  Box with { type T = Tb } $int_or_string_box
): Set<Tb> {
  return Set { $int_or_string_box->get() };
}

function unwrap_pure<Tb>(
  Box with { ctx C = []; type T = Tb } $box,
)[]: Tb {
  return $box->get(); // OK (type-checker knows `get` must have the empty context list)
}

// API
function wrap_number(num $x): Box with { type T = num } {
  return new IntBox($x);
}
// implementation details (subject to change):
class IntBox implements Box {
  const type T = num;
  const ctx C = [];

  public function __construct(private this::T $v) {}
  public function get()[]: this::T { return $this->v; }
}

function boxed_sum(
  Traversable<Box with { type T as num }> $numeric_boxes
): float {
  $sum = 0.0;
  foreach ($numeric_boxes as $nb) {
    $sum += $nb->get();
  }
  return $sum;
}

interface MeasuredBox extends Box {
  abstract const type TQuantity;
  public function getQuantity(): this::TQuantity;
}

function weigh_bulk_unsafe<TBox as MeasuredBox>(TBox $box): float
where TBox::TQuantity = float {
  return $box->getQuantity();
}

function weigh_bulk(MeasuredBox with { type TQuantity = float } $box): float {
  return $box->getQuantity();
}
