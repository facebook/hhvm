<?php
// Copyright 2004-present Facebook. All Rights Reserved.
// This file is @generated by
// fbcode/hphp/facebook/tools/code_model/GenerateCode.sh

namespace HH\CodeModel {

/** A collection of factory methods for allocating nodes
  * of an object model for PHP code. The factory methods
  * abstract over the concrete classes to use for the
  * object model produced by the consumer of a factory instance.
  */
class CodeModelFactory {
  /**
   *  A file containing source code and stored in a repository.
   *
   * @param @path
   * The path in the source repository where this file can be found.
   *
   * @param @revisions
   * One or more code revisions that modified this file.
   *
   * @param @predecessor
   * A file that was renamed and possibly modified to create this file.
   *
   */
  public function makeSourceFile(
    /*string*/ $path,
    /*Vector<ISourceRevision>*/ $revisions,
    /*?ISourceFile*/ $predecessor
  ) /*: SourceFile*/ {
    return (new SourceFile())
      ->setPath($path)
      ->setRevisions($revisions)
      ->setPredecessor($predecessor);
  }

  /**
   *  A source commit to a git or mercurial repository.
   *
   * @param @path
   * The path in the source repository where this file can be found.
   *
   * @param @revision
   * The revision of the source repository that contains this file.
   *
   */
  public function makeSourceFileRevision(
    /*string*/ $path,
    /*ISourceRevision*/ $revision
  ) /*: SourceFileRevision*/ {
    return (new SourceFileRevision())
      ->setPath($path)
      ->setRevision($revision);
  }

  /**
   *  The location in a source file where a code node can be found.
   *
   * @param @source_file
   * The source file containing this location.
   *
   * @param @start_line
   * The 1-based line number where this location starts.
   *
   * @param @end_line
   * The 1-based line number where this location end.
   *
   * @param @start_column
   * The 1-based column in the start line where this location starts.
   *
   * @param @end_column
   * The 1-based column in the end line where this location end.
   *
   */
  public function makeSourceLocation(
    /*?ISourceFile*/ $source_file,
    /*int*/ $start_line,
    /*int*/ $end_line,
    /*int*/ $start_column,
    /*int*/ $end_column
  ) /*: SourceLocation*/ {
    return (new SourceLocation())
      ->setSourceFile($source_file)
      ->setStartLine($start_line)
      ->setEndLine($end_line)
      ->setStartColumn($start_column)
      ->setEndColumn($end_column);
  }

  /**
   *  A source commit to a code repository such a GIT or Mercurial.
   *
   * @param @repository
   * The URL of a source code repository such a GIT or Mercurial.
   *
   * @param @branch
   * The name of a branch in a code repository, such as "master" or "trunk"
   *
   * @param @number
   * The serial number of this revision. Unique and ascending within a branch.
   *
   * @param @hash
   * A hash over the contents of the revision.
   * It is highly likely that no two revisions will ever have the same hash.
   *
   */
  public function makeSourceRevision(
    /*string*/ $repository,
    /*string*/ $branch,
    /*int*/ $number,
    /*string*/ $hash
  ) /*: SourceRevision*/ {
    return (new SourceRevision())
      ->setRepository($repository)
      ->setBranch($branch)
      ->setNumber($number)
      ->setHash($hash);
  }

  /**
   *  attributeName [( expressions )]
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeAttribute(
    /*string*/ $attribute_name,
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: Attribute*/ {
    return (new Attribute())
      ->setAttributeName($attribute_name)
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  A namespace function or a class method.
   *
   * @param @attributes
   * Zero or more attributes, for example: << __Native >>.
   *
   * @param @type_arguments
   * Zero or more type references representing generic arguments.
   *
   * @param @parameters
   * Zero or more parameters.
   *
   * @param @captured_variables
   * Zero or more variables captured from the enclosing environment
   *
   * @param @return_type
   * A reference to the return type, if any.
   *
   * @param @block
   * A block of statements making up the function body.
   *
   * @param @containing_namespace
   * A reference to the namespace, if any, that contains this node
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   * @param @containing_type
   * A reference to the type, if any, that contains this node.
   *
   * @param @modifiers
   * Zero or more modifiers, such as public and static.
   *
   */
  public function makeFunctionData(
    /*Vector<IAttribute>*/ $attributes,
    /*Vector<ITypeData>*/ $type_arguments,
    /*Vector<IParameterData>*/ $parameters,
    /*Vector<IVariable>*/ $captured_variables,
    /*?ITypeData*/ $return_type,
    /*IBlockStatement*/ $block,
    /*?INamespaceData*/ $containing_namespace,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location,
    /*?ITypeData*/ $containing_type,
    /*Vector<IModifier>*/ $modifiers
  ) /*: FunctionData*/ {
    return (new FunctionData())
      ->setAttributes($attributes)
      ->setTypeArguments($type_arguments)
      ->setParameters($parameters)
      ->setCapturedVariables($captured_variables)
      ->setReturnType($return_type)
      ->setBlock($block)
      ->setContainingNamespace($containing_namespace)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location)
      ->setContainingType($containing_type)
      ->setModifiers($modifiers);
  }

  /**
   * A variable whose scope is confined to a function body and
   * whose life time is one call/activation of the function.
   *
   * @param @value
   * The runtime value of this variable.
   * This may be known if the variable was obtained via
   * runtime reflection.
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   * @param @name
   * The name of this node
   *
   */
  public function makeLocalVariableData(
    /*mixed*/ $value,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location,
    /*string*/ $name
  ) /*: LocalVariableData*/ {
    return (new LocalVariableData())
      ->setValue($value)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location)
      ->setName($name);
  }

  /**
   * A name that identifies some kind of modification to the
   * semantics of another code node. For example "public".
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeModifier(
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: Modifier*/ {
    return (new Modifier())
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * A namespace is a named container of nested namespaces, namespace types and
   * namespace functions
   *
   * @param @nested_namespaces
   * Zero or more namespaces that are nested in this namespace
   *
   * @param @types
   * Zero more types that belong to this namespace
   *
   * @param @functions
   * Zero more functions that belong to this namespace
   *
   * @param @containing_namespace
   * A reference to the namespace, if any, that contains this node
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeNamespaceData(
    /*Vector<INamespaceData>*/ $nested_namespaces,
    /*Vector<ITypeData>*/ $types,
    /*Vector<IFunctionData>*/ $functions,
    /*?INamespaceData*/ $containing_namespace,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: NamespaceData*/ {
    return (new NamespaceData())
      ->setNestedNamespaces($nested_namespaces)
      ->setTypes($types)
      ->setFunctions($functions)
      ->setContainingNamespace($containing_namespace)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * A parameter is a name, possibly annoted with a type, for a
   * runtime argument value supplied by the caller of a parameterized function.
   *
   * @param @attributes
   * Zero or more attributes, for example: << Data >>.
   *
   * @param @value
   * The runtime value of this variable.
   * This may be known if the variable was obtained via
   * runtime reflection.
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   * @param @name
   * The name of this node
   *
   */
  public function makeParameterData(
    /*Vector<IAttribute>*/ $attributes,
    /*mixed*/ $value,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location,
    /*string*/ $name
  ) /*: ParameterData*/ {
    return (new ParameterData())
      ->setAttributes($attributes)
      ->setValue($value)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location)
      ->setName($name);
  }

  /**
   * A property is a name, possibly annoted with a type, for
   * a runtime value that forms part of an object or array.
   *
   * @param @containing_type
   * A reference to the type, if any, that contains this node.
   *
   * @param @modifiers
   * Zero or more modifiers, such as public and static.
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   * @param @value
   * The runtime value of this variable.
   * This may be known if the variable was obtained via
   * runtime reflection.
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   */
  public function makePropertyData(
    /*?ITypeData*/ $containing_type,
    /*Vector<IModifier>*/ $modifiers,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location,
    /*mixed*/ $value,
    /*?ITypeData*/ $type
  ) /*: PropertyData*/ {
    return (new PropertyData())
      ->setContainingType($containing_type)
      ->setModifiers($modifiers)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location)
      ->setValue($value)
      ->setType($type);
  }

  /**
   * A type is the metadata for a set of values and a set of operations that
   * may be applied to the values in the set.
   *
   * @param @attributes
   * Zero or more attributes, for example: << __MockClass >>.
   *
   * @param @modifiers
   * Zero or more modifiers, such as final.
   *
   * @param @is_class
   * Indicates if this type is a class.
   *
   * @param @is_interface
   * Indicates if this type is an interface
   *
   * @param @type_arguments
   * Zero or more type references representing generic arguments.
   *
   * @param @base_types
   * Zero or one type references representing the base type.
   *
   * @param @interfaces
   * Zero or more type references representing implemented interfaces.
   *
   * @param @methods
   * Zero or more functions that are methods of this type.
   *
   * @param @properties
   * Zero or more properties that belong to this type.
   *
   * @param @containing_namespace
   * A reference to the namespace, if any, that contains this node
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   * @param @containing_type
   * A reference to the type, if any, that contains this node.
   *
   */
  public function makeTypeData(
    /*Vector<IAttribute>*/ $attributes,
    /*Vector<IModifier>*/ $modifiers,
    /*bool*/ $is_class,
    /*bool*/ $is_interface,
    /*Vector<ITypeData>*/ $type_arguments,
    /*Vector<ITypeData>*/ $base_types,
    /*Vector<ITypeData>*/ $interfaces,
    /*Vector<IFunctionData>*/ $methods,
    /*Vector<IPropertyData>*/ $properties,
    /*?INamespaceData*/ $containing_namespace,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location,
    /*?ITypeData*/ $containing_type
  ) /*: TypeData*/ {
    return (new TypeData())
      ->setAttributes($attributes)
      ->setModifiers($modifiers)
      ->setIsClass($is_class)
      ->setIsInterface($is_interface)
      ->setTypeArguments($type_arguments)
      ->setBaseTypes($base_types)
      ->setInterfaces($interfaces)
      ->setMethods($methods)
      ->setProperties($properties)
      ->setContainingNamespace($containing_namespace)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location)
      ->setContainingType($containing_type);
  }

  /**
   *  expression1 operation expression2
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeBinaryOpExpression(
    /*IExpression*/ $expression1,
    /*IExpression*/ $expression2,
    /*BinaryOperator*/ $operation,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: BinaryOpExpression*/ {
    return (new BinaryOpExpression())
      ->setExpression1($expression1)
      ->setExpression2($expression2)
      ->setOperation($operation)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  (class|self|parent|static)::constantName
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeClassConstantExpression(
    /*ITypeExpression*/ $class,
    /*string*/ $constant_name,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ClassConstantExpression*/ {
    return (new ClassConstantExpression())
      ->setClass($class)
      ->setConstantName($constant_name)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  (class|self|parent|static)::methodName(arguments)
   *  (class|self|parent|static)::{methodExpression}(arguments)
   *  ${classExpression}::methodName(arguments)
   *  ${classExpression}::{methodExpression}(arguments)
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeClassMethodCallExpression(
    /*?ITypeExpression*/ $class,
    /*?IExpression*/ $class_expression,
    /*?string*/ $method_name,
    /*?IExpression*/ $method_expression,
    /*Vector<IExpression>*/ $arguments,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ClassMethodCallExpression*/ {
    return (new ClassMethodCallExpression())
      ->setClass($class)
      ->setClassExpression($class_expression)
      ->setMethodName($method_name)
      ->setMethodExpression($method_expression)
      ->setArguments($arguments)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  (class|self|parent|static)::$propertyName
   *  (class|self|parent|static)::${propertyExpression}
   *  ${classExpression}::::$propertyName
   *  ${classExpression}::${propertyExpression}
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeClassPropertyExpression(
    /*?ITypeExpression*/ $class,
    /*?IExpression*/ $class_expression,
    /*?string*/ $property_name,
    /*?IExpression*/ $property_expression,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ClassPropertyExpression*/ {
    return (new ClassPropertyExpression())
      ->setClass($class)
      ->setClassExpression($class_expression)
      ->setPropertyName($property_name)
      ->setPropertyExpression($property_expression)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  function (params) use (vars) { statements }
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeClosureExpression(
    /*IFunctionStatement*/ $function,
    /*Vector<IExpression>*/ $captured_variables,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ClosureExpression*/ {
    return (new ClosureExpression())
      ->setFunction($function)
      ->setCapturedVariables($captured_variables)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  class {arguments}
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeCollectionInitializerExpression(
    /*ITypeExpression*/ $class,
    /*Vector<IExpression>*/ $arguments,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: CollectionInitializerExpression*/ {
    return (new CollectionInitializerExpression())
      ->setClass($class)
      ->setArguments($arguments)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *   condition ? valueIfTrue : valueIfFalse
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeConditionalExpression(
    /*IExpression*/ $condition,
    /*IExpression*/ $value_if_true,
    /*IExpression*/ $value_if_false,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ConditionalExpression*/ {
    return (new ConditionalExpression())
      ->setCondition($condition)
      ->setValueIfTrue($value_if_true)
      ->setValueIfFalse($value_if_false)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * `text $var more text ...`
   * "text $var more text ..."
   * 'text ...'
   * <<<Delimiter text $var more text ... Delimiter;
   * <<<'Delimiter' text ... Delimiter;
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeEncapsListExpression(
    /*string*/ $delimiter,
    /*Vector<IExpression>*/ $expressions,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: EncapsListExpression*/ {
    return (new EncapsListExpression())
      ->setDelimiter($delimiter)
      ->setExpressions($expressions)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  from identifier in collection
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeFromClause(
    /*string*/ $identifier,
    /*IExpression*/ $collection,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: FromClause*/ {
    return (new FromClause())
      ->setIdentifier($identifier)
      ->setCollection($collection)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  group collection by key
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeGroupClause(
    /*IExpression*/ $collection,
    /*IExpression*/ $key,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: GroupClause*/ {
    return (new GroupClause())
      ->setCollection($collection)
      ->setKey($key)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  into identifier query_clauses
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeIntoClause(
    /*string*/ $identifier,
    /*Vector<IQueryClause>*/ $clauses,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: IntoClause*/ {
    return (new IntoClause())
      ->setIdentifier($identifier)
      ->setClauses($clauses)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  join [identifier in] collection
   *    [[on left equals right] [into group]]
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeJoinClause(
    /*?string*/ $identifier,
    /*IExpression*/ $collection,
    /*?IExpression*/ $left,
    /*?IExpression*/ $right,
    /*?string*/ $group,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: JoinClause*/ {
    return (new JoinClause())
      ->setIdentifier($identifier)
      ->setCollection($collection)
      ->setLeft($left)
      ->setRight($right)
      ->setGroup($group)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  let identifier = expr
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeLetClause(
    /*string*/ $identifier,
    /*IExpression*/ $expression,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: LetClause*/ {
    return (new LetClause())
      ->setIdentifier($identifier)
      ->setExpression($expression)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  list(variables) [ = expression ]
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeListAssignmentExpression(
    /*Vector<?IExpression>*/ $variables,
    /*?IExpression*/ $expression,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ListAssignmentExpression*/ {
    return (new ListAssignmentExpression())
      ->setVariables($variables)
      ->setExpression($expression)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  new class(arguments)
   *  new ${classExpression}(arguments)
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeNewObjectExpression(
    /*?ITypeExpression*/ $class,
    /*?IExpression*/ $class_expression,
    /*Vector<IExpression>*/ $arguments,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: NewObjectExpression*/ {
    return (new NewObjectExpression())
      ->setClass($class)
      ->setClassExpression($class_expression)
      ->setArguments($arguments)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  object->methodName(arguments)
   *  object->{expression}(arguments)
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeObjectMethodCallExpression(
    /*IExpression*/ $object,
    /*?string*/ $method_name,
    /*?IExpression*/ $method_expression,
    /*Vector<IExpression>*/ $arguments,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ObjectMethodCallExpression*/ {
    return (new ObjectMethodCallExpression())
      ->setObject($object)
      ->setMethodName($method_name)
      ->setMethodExpression($method_expression)
      ->setArguments($arguments)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  object->propertyName
   *  object->{propertyExpression}
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeObjectPropertyExpression(
    /*IExpression*/ $object,
    /*?string*/ $property_name,
    /*?IExpression*/ $property_expression,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ObjectPropertyExpression*/ {
    return (new ObjectPropertyExpression())
      ->setObject($object)
      ->setPropertyName($property_name)
      ->setPropertyExpression($property_expression)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  orderby orderings
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeOrderbyClause(
    /*Vector<IOrdering>*/ $orders,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: OrderbyClause*/ {
    return (new OrderbyClause())
      ->setOrders($orders)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  expression [order]
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeOrdering(
    /*IExpression*/ $expression,
    /*Order*/ $order,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: Ordering*/ {
    return (new Ordering())
      ->setExpression($expression)
      ->setOrder($order)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  query_clauses
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeQueryExpression(
    /*Vector<IQueryClause>*/ $clauses,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: QueryExpression*/ {
    return (new QueryExpression())
      ->setClauses($clauses)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  a compile time constant of some type
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeScalarExpression(
    /*mixed*/ $value,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ScalarExpression*/ {
    return (new ScalarExpression())
      ->setValue($value)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  select expression
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeSelectClause(
    /*IExpression*/ $expression,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: SelectClause*/ {
    return (new SelectClause())
      ->setExpression($expression)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * constantName
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeSimpleConstantExpression(
    /*?string*/ $constant_name,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: SimpleConstantExpression*/ {
    return (new SimpleConstantExpression())
      ->setConstantName($constant_name)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  functionName(arguments)
   *  ${functionExpression}(arguments)
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeSimpleFunctionCallExpression(
    /*?string*/ $function_name,
    /*?IExpression*/ $function_expression,
    /*Vector<IExpression>*/ $arguments,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: SimpleFunctionCallExpression*/ {
    return (new SimpleFunctionCallExpression())
      ->setFunctionName($function_name)
      ->setFunctionExpression($function_expression)
      ->setArguments($arguments)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * $variableName
   * ${variableExpression}
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeSimpleVariableExpression(
    /*?string*/ $variable_name,
    /*?IExpression*/ $variable_expression,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: SimpleVariableExpression*/ {
    return (new SimpleVariableExpression())
      ->setVariableName($variable_name)
      ->setVariableExpression($variable_expression)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * A type expression results in a value of type Type.
   * But it's compile time type (getType()) is the runtime
   * type value (or null) rather than type Type.
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTypeExpression(
    /*bool*/ $is_nullable,
    /*bool*/ $is_soft,
    /*string*/ $name,
    /*Vector<ITypeExpression>*/ $type_arguments,
    /*?ITypeExpression*/ $return_type,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TypeExpression*/ {
    return (new TypeExpression())
      ->setIsNullable($is_nullable)
      ->setIsSoft($is_soft)
      ->setName($name)
      ->setTypeArguments($type_arguments)
      ->setReturnType($return_type)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *   name [as constraint]
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTypeParameterExpression(
    /*string*/ $name,
    /*?ITypeExpression*/ $constraint,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TypeParameterExpression*/ {
    return (new TypeParameterExpression())
      ->setName($name)
      ->setConstraint($constraint)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  operation expression
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeUnaryOpExpression(
    /*IExpression*/ $expression,
    /*UnaryOperator*/ $operation,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: UnaryOpExpression*/ {
    return (new UnaryOpExpression())
      ->setExpression($expression)
      ->setOperation($operation)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  where condition
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeWhereClause(
    /*IExpression*/ $condition,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: WhereClause*/ {
    return (new WhereClause())
      ->setCondition($condition)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  <tag attr=expression, ... > {expression} <tag/>
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeXmlExpression(
    /*string*/ $tag_name,
    /*Vector<IBinaryOpExpression>*/ $attributes,
    /*Vector<IExpression>*/ $elements,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: XmlExpression*/ {
    return (new XmlExpression())
      ->setTagName($tag_name)
      ->setAttributes($attributes)
      ->setElements($elements)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  yield [key =>] value
   *
   * @param @type
   * A reference to the type of value this node corresponds to.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeYieldExpression(
    /*?IExpression*/ $key,
    /*IExpression*/ $value,
    /*?ITypeData*/ $type,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: YieldExpression*/ {
    return (new YieldExpression())
      ->setKey($key)
      ->setValue($value)
      ->setType($type)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  { statements }
   *
   * @param @is_enclosed
   * True if the statements are enclosed in curly braces.
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeBlockStatement(
    /*Vector<IStatement>*/ $statements,
    /*bool*/ $is_enclosed,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: BlockStatement*/ {
    return (new BlockStatement())
      ->setStatements($statements)
      ->setIsEnclosed($is_enclosed)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  break depth;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeBreakStatement(
    /*int*/ $depth,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: BreakStatement*/ {
    return (new BreakStatement())
      ->setDepth($depth)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  case condition: block
   *  default: block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeCaseStatement(
    /*?IExpression*/ $condition,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: CaseStatement*/ {
    return (new CaseStatement())
      ->setCondition($condition)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  catch (class variableName) block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeCatchStatement(
    /*ITypeExpression*/ $class,
    /*string*/ $variable_name,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: CatchStatement*/ {
    return (new CatchStatement())
      ->setClass($class)
      ->setVariableName($variable_name)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  modifiers [typeAnnotation] expressions;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeClassVariableStatement(
    /*Vector<IModifier>*/ $modifiers,
    /*?ITypeExpression*/ $type_annotation,
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ClassVariableStatement*/ {
    return (new ClassVariableStatement())
      ->setModifiers($modifiers)
      ->setTypeAnnotation($type_annotation)
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  if (condition) trueBlock else falseBlock
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeConditionalStatement(
    /*IExpression*/ $condition,
    /*IBlockStatement*/ $true_block,
    /*IBlockStatement*/ $false_block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ConditionalStatement*/ {
    return (new ConditionalStatement())
      ->setCondition($condition)
      ->setTrueBlock($true_block)
      ->setFalseBlock($false_block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  const [typeAnnotation] expressions;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeConstantStatement(
    /*?ITypeExpression*/ $type_annotation,
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ConstantStatement*/ {
    return (new ConstantStatement())
      ->setTypeAnnotation($type_annotation)
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  continue depth;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeContinueStatement(
    /*int*/ $depth,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ContinueStatement*/ {
    return (new ContinueStatement())
      ->setDepth($depth)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  do block while (condition)
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeDoStatement(
    /*IBlockStatement*/ $block,
    /*IExpression*/ $condition,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: DoStatement*/ {
    return (new DoStatement())
      ->setBlock($block)
      ->setCondition($condition)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  echo expressions;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeEchoStatement(
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: EchoStatement*/ {
    return (new EchoStatement())
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  expression;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeExpressionStatement(
    /*IExpression*/ $expression,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ExpressionStatement*/ {
    return (new ExpressionStatement())
      ->setExpression($expression)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  finally block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeFinallyStatement(
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: FinallyStatement*/ {
    return (new FinallyStatement())
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  for (initializers; conditions; increments) block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeForStatement(
    /*Vector<IExpression>*/ $initializers,
    /*Vector<IExpression>*/ $conditions,
    /*Vector<IExpression>*/ $increments,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ForStatement*/ {
    return (new ForStatement())
      ->setInitializers($initializers)
      ->setConditions($conditions)
      ->setIncrements($increments)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  foreach (collection as [key =>] value) block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeForeachStatement(
    /*IExpression*/ $collection,
    /*?IExpression*/ $key,
    /*IExpression*/ $value,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ForeachStatement*/ {
    return (new ForeachStatement())
      ->setCollection($collection)
      ->setKey($key)
      ->setValue($value)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  [ << attributes >> ]
   *  [modifiers] function [&] name [<typeParameters>]
   *  (parameters) [: returnType]
   *    block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeFunctionStatement(
    /*Vector<IAttribute>*/ $attributes,
    /*Vector<IModifier>*/ $modifiers,
    /*bool*/ $returns_reference,
    /*string*/ $name,
    /*Vector<ITypeExpression>*/ $type_parameters,
    /*Vector<IParameterDeclaration>*/ $parameters,
    /*?ITypeExpression*/ $return_type,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: FunctionStatement*/ {
    return (new FunctionStatement())
      ->setAttributes($attributes)
      ->setModifiers($modifiers)
      ->setReturnsReference($returns_reference)
      ->setName($name)
      ->setTypeParameters($type_parameters)
      ->setParameters($parameters)
      ->setReturnType($return_type)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  global expressions;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeGlobalStatement(
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: GlobalStatement*/ {
    return (new GlobalStatement())
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  goto label;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeGotoStatement(
    /*string*/ $label,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: GotoStatement*/ {
    return (new GotoStatement())
      ->setLabel($label)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  label:
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeLabelStatement(
    /*string*/ $label,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: LabelStatement*/ {
    return (new LabelStatement())
      ->setLabel($label)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  [ << attributes >> ]
   *  [modifiers] [typeAnnotation] [&] name [= expression]
   *
   * @param @name
   * The name of this node
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeParameterDeclaration(
    /*Vector<IAttribute>*/ $attributes,
    /*Vector<IModifier>*/ $modifiers,
    /*?ITypeExpression*/ $type_annotation,
    /*bool*/ $is_passed_by_reference,
    /*?IExpression*/ $expression,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ParameterDeclaration*/ {
    return (new ParameterDeclaration())
      ->setAttributes($attributes)
      ->setModifiers($modifiers)
      ->setTypeAnnotation($type_annotation)
      ->setIsPassedByReference($is_passed_by_reference)
      ->setExpression($expression)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  return [expression];
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeReturnStatement(
    /*?IExpression*/ $expression,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ReturnStatement*/ {
    return (new ReturnStatement())
      ->setExpression($expression)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  static expressions;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeStaticStatement(
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: StaticStatement*/ {
    return (new StaticStatement())
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  switch (expression) { caseStatements }
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeSwitchStatement(
    /*IExpression*/ $expression,
    /*Vector<ICaseStatement>*/ $case_statements,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: SwitchStatement*/ {
    return (new SwitchStatement())
      ->setExpression($expression)
      ->setCaseStatements($case_statements)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  throw expression;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeThrowStatement(
    /*IExpression*/ $expression,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: ThrowStatement*/ {
    return (new ThrowStatement())
      ->setExpression($expression)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  [traitName::]methodName1 as modifiers methodName2;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTraitAliasStatement(
    /*?string*/ $trait_name,
    /*string*/ $method_name1,
    /*Vector<IModifier>*/ $modifiers,
    /*string*/ $method_name2,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TraitAliasStatement*/ {
    return (new TraitAliasStatement())
      ->setTraitName($trait_name)
      ->setMethodName1($method_name1)
      ->setModifiers($modifiers)
      ->setMethodName2($method_name2)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  traitName::methodName instead otherTraitNames;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTraitInsteadStatement(
    /*string*/ $trait_name,
    /*string*/ $method_name,
    /*Vector<string>*/ $other_trait_names,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TraitInsteadStatement*/ {
    return (new TraitInsteadStatement())
      ->setTraitName($trait_name)
      ->setMethodName($method_name)
      ->setOtherTraitNames($other_trait_names)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  require extends|implements name;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTraitRequiresStatement(
    /*RequireKind*/ $kind,
    /*string*/ $name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TraitRequiresStatement*/ {
    return (new TraitRequiresStatement())
      ->setKind($kind)
      ->setName($name)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  try block catchStatements [finallyStatement]
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTryStatement(
    /*IBlockStatement*/ $block,
    /*Vector<ICatchStatement>*/ $catch_statements,
    /*?IFinallyStatement*/ $finally_statement,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TryStatement*/ {
    return (new TryStatement())
      ->setBlock($block)
      ->setCatchStatements($catch_statements)
      ->setFinallyStatement($finally_statement)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * [ << attributes >> ]
   * [modifiers] class|interface|trait name [typeParameters] [extends baseClass]
   * [implements interfaces]
   *   block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTypeStatement(
    /*Vector<IAttribute>*/ $attributes,
    /*Vector<IModifier>*/ $modifiers,
    /*TypeKind*/ $kind,
    /*string*/ $name,
    /*Vector<ITypeParameterExpression>*/ $type_parameters,
    /*?ITypeExpression*/ $base_class,
    /*Vector<ITypeExpression>*/ $interfaces,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TypeStatement*/ {
    return (new TypeStatement())
      ->setAttributes($attributes)
      ->setModifiers($modifiers)
      ->setKind($kind)
      ->setName($name)
      ->setTypeParameters($type_parameters)
      ->setBaseClass($base_class)
      ->setInterfaces($interfaces)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  type name [typeParameters] [as constraint] = typeAnnotation;
   *  newtype name [typeParameters] [as constraint] = typeAnnotation;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeTypedefStatement(
    /*string*/ $name,
    /*bool*/ $is_opaque,
    /*Vector<ITypeParameterExpression>*/ $type_parameters,
    /*?ITypeExpression*/ $constraint,
    /*ITypeExpression*/ $type_annotation,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: TypedefStatement*/ {
    return (new TypedefStatement())
      ->setName($name)
      ->setIsOpaque($is_opaque)
      ->setTypeParameters($type_parameters)
      ->setConstraint($constraint)
      ->setTypeAnnotation($type_annotation)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   * unset(expressions);
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeUnsetStatement(
    /*Vector<IExpression>*/ $expressions,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: UnsetStatement*/ {
    return (new UnsetStatement())
      ->setExpressions($expressions)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  use usedNamespaces;
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeUseNamespacesStatement(
    /*Vector<IUsedNamespaceStatement>*/ $used_namespaces,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: UseNamespacesStatement*/ {
    return (new UseNamespacesStatement())
      ->setUsedNamespaces($used_namespaces)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  use typeExpressions block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeUseTraitStatement(
    /*Vector<ITypeExpression>*/ $type_expressions,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: UseTraitStatement*/ {
    return (new UseTraitStatement())
      ->setTypeExpressions($type_expressions)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  use namespace [as alias];
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeUsedNamespaceStatement(
    /*string*/ $namespace_name,
    /*string*/ $alias_name,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: UsedNamespaceStatement*/ {
    return (new UsedNamespaceStatement())
      ->setNamespaceName($namespace_name)
      ->setAliasName($alias_name)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

  /**
   *  while (condition) block
   *
   * @param @comments
   * Zero or more code comments that immediately preceded this code node
   *
   * @param @source_location
   * The source location corresponding to this code node.
   * This includes the repository path and version.
   *
   */
  public function makeWhileStatement(
    /*IExpression*/ $condition,
    /*IBlockStatement*/ $block,
    /*Vector<string>*/ $comments,
    /*?ISourceLocation*/ $source_location
  ) /*: WhileStatement*/ {
    return (new WhileStatement())
      ->setCondition($condition)
      ->setBlock($block)
      ->setComments($comments)
      ->setSourceLocation($source_location);
  }

}
}
