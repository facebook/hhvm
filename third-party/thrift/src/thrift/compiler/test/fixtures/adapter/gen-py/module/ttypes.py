#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import sys
from thrift.util.Recursive import fix_spec
from thrift.Thrift import TType, TMessageType, TPriority, TRequestContext, TProcessorEventHandler, TServerInterface, TProcessor, TException, TApplicationException, UnimplementedTypedef
from thrift.protocol.TProtocol import TProtocolException

from json import loads
import sys
if sys.version_info[0] >= 3:
  long = int

import thrift.annotation.cpp.ttypes
import thrift.annotation.python.ttypes
import thrift.annotation.thrift.ttypes
import thrift.annotation.scope.ttypes
import thrift.annotation.hack.ttypes

import my


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
fastproto = None
try:
  from thrift.protocol import fastproto
except ImportError:
  pass
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'MyAnnotation', 'Foo', 'Baz', 'Bar', 'DirectlyAdapted', 'StructWithFieldAdapter', 'TerseAdaptedFields', 'B', 'A', 'Config', 'MyStruct', 'SetWithAdapter', 'StringWithAdapter', 'ListWithElemAdapter', 'ListWithElemAdapter_withAdapter', 'MyI64', 'DoubleTypedefI64', 'MyI32', 'FooWithAdapter', 'StructWithAdapter', 'UnionWithAdapter', 'AdaptedA']

class MyAnnotation:
  """
  Attributes:
   - signature
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.signature = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyAnnotation')
    if self.signature != None:
      oprot.writeFieldBegin('signature', TType.STRING, 1)
      oprot.writeString(self.signature.encode('utf-8')) if UTF8STRINGS and not isinstance(self.signature, bytes) else oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'signature' in json_obj and json_obj['signature'] is not None:
      self.signature = json_obj['signature']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.signature is not None:
      value = pprint.pformat(self.signature, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    signature=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'signature',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyAnnotation, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyAnnotation, self)

  def _to_py_deprecated(self):
    return self

class Foo:
  """
  Attributes:
   - intField
   - optionalIntField
   - intFieldWithDefault
   - setField
   - optionalSetField
   - mapField
   - optionalMapField
   - binaryField
   - longField
   - adaptedLongField
   - doubleAdaptedField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.intField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.optionalIntField = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.intFieldWithDefault = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          self.setField = set()
          (_etype3, _size0) = iprot.readSetBegin()
          if _size0 >= 0:
            for _i4 in range(_size0):
              _elem5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem5)
          else: 
            while iprot.peekSet():
              _elem6 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.setField.add(_elem6)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.SET:
          self.optionalSetField = set()
          (_etype10, _size7) = iprot.readSetBegin()
          if _size7 >= 0:
            for _i11 in range(_size7):
              _elem12 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem12)
          else: 
            while iprot.peekSet():
              _elem13 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.optionalSetField.add(_elem13)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.mapField = {}
          (_ktype15, _vtype16, _size14 ) = iprot.readMapBegin() 
          if _size14 >= 0:
            for _i18 in range(_size14):
              _key19 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val20 = []
              (_etype24, _size21) = iprot.readListBegin()
              if _size21 >= 0:
                for _i25 in range(_size21):
                  _elem26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem26)
              else: 
                while iprot.peekList():
                  _elem27 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val20.append(_elem27)
              iprot.readListEnd()
              self.mapField[_key19] = _val20
          else: 
            while iprot.peekMap():
              _key28 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val29 = []
              (_etype33, _size30) = iprot.readListBegin()
              if _size30 >= 0:
                for _i34 in range(_size30):
                  _elem35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem35)
              else: 
                while iprot.peekList():
                  _elem36 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val29.append(_elem36)
              iprot.readListEnd()
              self.mapField[_key28] = _val29
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.optionalMapField = {}
          (_ktype38, _vtype39, _size37 ) = iprot.readMapBegin() 
          if _size37 >= 0:
            for _i41 in range(_size37):
              _key42 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val43 = []
              (_etype47, _size44) = iprot.readListBegin()
              if _size44 >= 0:
                for _i48 in range(_size44):
                  _elem49 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem49)
              else: 
                while iprot.peekList():
                  _elem50 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val43.append(_elem50)
              iprot.readListEnd()
              self.optionalMapField[_key42] = _val43
          else: 
            while iprot.peekMap():
              _key51 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val52 = []
              (_etype56, _size53) = iprot.readListBegin()
              if _size53 >= 0:
                for _i57 in range(_size53):
                  _elem58 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem58)
              else: 
                while iprot.peekList():
                  _elem59 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val52.append(_elem59)
              iprot.readListEnd()
              self.optionalMapField[_key51] = _val52
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.binaryField = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.longField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.adaptedLongField = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.doubleAdaptedField = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Foo')
    if self.intField != None:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      oprot.writeI32(self.intField)
      oprot.writeFieldEnd()
    if self.optionalIntField != None:
      oprot.writeFieldBegin('optionalIntField', TType.I32, 2)
      oprot.writeI32(self.optionalIntField)
      oprot.writeFieldEnd()
    if self.intFieldWithDefault != None:
      oprot.writeFieldBegin('intFieldWithDefault', TType.I32, 3)
      oprot.writeI32(self.intFieldWithDefault)
      oprot.writeFieldEnd()
    if self.setField != None:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      oprot.writeSetBegin(TType.STRING, len(self.setField))
      for iter60 in self.setField:
        oprot.writeString(iter60.encode('utf-8')) if UTF8STRINGS and not isinstance(iter60, bytes) else oprot.writeString(iter60)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.optionalSetField != None:
      oprot.writeFieldBegin('optionalSetField', TType.SET, 5)
      oprot.writeSetBegin(TType.STRING, len(self.optionalSetField))
      for iter61 in self.optionalSetField:
        oprot.writeString(iter61.encode('utf-8')) if UTF8STRINGS and not isinstance(iter61, bytes) else oprot.writeString(iter61)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.mapField != None:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.mapField))
      for kiter62,viter63 in self.mapField.items():
        oprot.writeString(kiter62.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter62, bytes) else oprot.writeString(kiter62)
        oprot.writeListBegin(TType.STRING, len(viter63))
        for iter64 in viter63:
          oprot.writeString(iter64.encode('utf-8')) if UTF8STRINGS and not isinstance(iter64, bytes) else oprot.writeString(iter64)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.optionalMapField != None:
      oprot.writeFieldBegin('optionalMapField', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.optionalMapField))
      for kiter65,viter66 in self.optionalMapField.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        oprot.writeListBegin(TType.STRING, len(viter66))
        for iter67 in viter66:
          oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.binaryField != None:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      oprot.writeString(self.binaryField)
      oprot.writeFieldEnd()
    if self.longField != None:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      oprot.writeI64(self.longField)
      oprot.writeFieldEnd()
    if self.adaptedLongField != None:
      oprot.writeFieldBegin('adaptedLongField', TType.I64, 10)
      oprot.writeI64(self.adaptedLongField)
      oprot.writeFieldEnd()
    if self.doubleAdaptedField != None:
      oprot.writeFieldBegin('doubleAdaptedField', TType.I64, 11)
      oprot.writeI64(self.doubleAdaptedField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'intField' in json_obj and json_obj['intField'] is not None:
      self.intField = json_obj['intField']
      if self.intField > 0x7fffffff or self.intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'optionalIntField' in json_obj and json_obj['optionalIntField'] is not None:
      self.optionalIntField = json_obj['optionalIntField']
      if self.optionalIntField > 0x7fffffff or self.optionalIntField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'intFieldWithDefault' in json_obj and json_obj['intFieldWithDefault'] is not None:
      self.intFieldWithDefault = json_obj['intFieldWithDefault']
      if self.intFieldWithDefault > 0x7fffffff or self.intFieldWithDefault < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'setField' in json_obj and json_obj['setField'] is not None:
      self.setField = set_cls()
      for _tmp_e68 in json_obj['setField']:
        self.setField.add(_tmp_e68)
    if 'optionalSetField' in json_obj and json_obj['optionalSetField'] is not None:
      self.optionalSetField = set_cls()
      for _tmp_e69 in json_obj['optionalSetField']:
        self.optionalSetField.add(_tmp_e69)
    if 'mapField' in json_obj and json_obj['mapField'] is not None:
      self.mapField = dict_cls()
      for _tmp_k70, _tmp_v71 in json_obj['mapField'].items():
        _tmp_kp72 = _tmp_k70
        _list73 = []
        for _tmp_e74 in _tmp_v71:
          _list73.append(_tmp_e74)
        self.mapField[_tmp_kp72] = _list73
    if 'optionalMapField' in json_obj and json_obj['optionalMapField'] is not None:
      self.optionalMapField = dict_cls()
      for _tmp_k75, _tmp_v76 in json_obj['optionalMapField'].items():
        _tmp_kp77 = _tmp_k75
        _list78 = []
        for _tmp_e79 in _tmp_v76:
          _list78.append(_tmp_e79)
        self.optionalMapField[_tmp_kp77] = _list78
    if 'binaryField' in json_obj and json_obj['binaryField'] is not None:
      self.binaryField = json_obj['binaryField']
    if 'longField' in json_obj and json_obj['longField'] is not None:
      self.longField = long(json_obj['longField'])
    if 'adaptedLongField' in json_obj and json_obj['adaptedLongField'] is not None:
      self.adaptedLongField = long(json_obj['adaptedLongField'])
    if 'doubleAdaptedField' in json_obj and json_obj['doubleAdaptedField'] is not None:
      self.doubleAdaptedField = long(json_obj['doubleAdaptedField'])

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.intField is not None:
      value = pprint.pformat(self.intField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intField=%s' % (value))
    if self.optionalIntField is not None:
      value = pprint.pformat(self.optionalIntField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalIntField=%s' % (value))
    if self.intFieldWithDefault is not None:
      value = pprint.pformat(self.intFieldWithDefault, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    intFieldWithDefault=%s' % (value))
    if self.setField is not None:
      value = pprint.pformat(self.setField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    setField=%s' % (value))
    if self.optionalSetField is not None:
      value = pprint.pformat(self.optionalSetField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalSetField=%s' % (value))
    if self.mapField is not None:
      value = pprint.pformat(self.mapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    mapField=%s' % (value))
    if self.optionalMapField is not None:
      value = pprint.pformat(self.optionalMapField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalMapField=%s' % (value))
    if self.binaryField is not None:
      value = pprint.pformat(self.binaryField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    binaryField=%s' % (value))
    if self.longField is not None:
      value = pprint.pformat(self.longField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    longField=%s' % (value))
    if self.adaptedLongField is not None:
      value = pprint.pformat(self.adaptedLongField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedLongField=%s' % (value))
    if self.doubleAdaptedField is not None:
      value = pprint.pformat(self.doubleAdaptedField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    doubleAdaptedField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'intField',
      'optionalIntField',
      'intFieldWithDefault',
      'setField',
      'optionalSetField',
      'mapField',
      'optionalMapField',
      'binaryField',
      'longField',
      'adaptedLongField',
      'doubleAdaptedField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Foo, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Foo, self)

  def _to_py_deprecated(self):
    return self

class Baz(object):
  """
  Attributes:
   - intField
   - setField
   - mapField
   - binaryField
   - longField
  """

  thrift_spec = None
  __init__ = None

  __EMPTY__ = 0
  INTFIELD = 1
  SETFIELD = 4
  MAPFIELD = 6
  BINARYFIELD = 8
  LONGFIELD = 9
  
  @staticmethod
  def isUnion():
    return True

  def get_intField(self):
    assert self.field == 1
    return self.value

  def get_setField(self):
    assert self.field == 4
    return self.value

  def get_mapField(self):
    assert self.field == 6
    return self.value

  def get_binaryField(self):
    assert self.field == 8
    return self.value

  def get_longField(self):
    assert self.field == 9
    return self.value

  def set_intField(self, value):
    self.field = 1
    self.value = value

  def set_setField(self, value):
    self.field = 4
    self.value = value

  def set_mapField(self, value):
    self.field = 6
    self.value = value

  def set_binaryField(self, value):
    self.field = 8
    self.value = value

  def set_longField(self, value):
    self.field = 9
    self.value = value

  def getType(self):
    return self.field

  def __repr__(self):
    value = pprint.pformat(self.value)
    member = ''
    if self.field == 1:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('intField', value)
    if self.field == 4:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('setField', value)
    if self.field == 6:
      padding = ' ' * 9
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('mapField', value)
    if self.field == 8:
      padding = ' ' * 12
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('binaryField', value)
    if self.field == 9:
      padding = ' ' * 10
      value = padding.join(value.splitlines(True))
      member = '\n    %s=%s' % ('longField', value)
    return "%s(%s)" % (self.__class__.__name__, member)

  def read(self, iprot):
    self.field = 0
    self.value = None
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break

      if fid == 1:
        if ftype == TType.I32:
          _fbthrift_intField = iprot.readI32()
          assert self.field == 0 and self.value is None
          self.set_intField(_fbthrift_intField)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.SET:
          _fbthrift_setField = set()
          (_etype83, _size80) = iprot.readSetBegin()
          if _size80 >= 0:
            for _i84 in range(_size80):
              _elem85 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem85)
          else: 
            while iprot.peekSet():
              _elem86 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _fbthrift_setField.add(_elem86)
          iprot.readSetEnd()
          assert self.field == 0 and self.value is None
          self.set_setField(_fbthrift_setField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          _fbthrift_mapField = {}
          (_ktype88, _vtype89, _size87 ) = iprot.readMapBegin() 
          if _size87 >= 0:
            for _i91 in range(_size87):
              _key92 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val93 = []
              (_etype97, _size94) = iprot.readListBegin()
              if _size94 >= 0:
                for _i98 in range(_size94):
                  _elem99 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem99)
              else: 
                while iprot.peekList():
                  _elem100 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val93.append(_elem100)
              iprot.readListEnd()
              _fbthrift_mapField[_key92] = _val93
          else: 
            while iprot.peekMap():
              _key101 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val102 = []
              (_etype106, _size103) = iprot.readListBegin()
              if _size103 >= 0:
                for _i107 in range(_size103):
                  _elem108 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem108)
              else: 
                while iprot.peekList():
                  _elem109 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
                  _val102.append(_elem109)
              iprot.readListEnd()
              _fbthrift_mapField[_key101] = _val102
          iprot.readMapEnd()
          assert self.field == 0 and self.value is None
          self.set_mapField(_fbthrift_mapField)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          _fbthrift_binaryField = iprot.readString()
          assert self.field == 0 and self.value is None
          self.set_binaryField(_fbthrift_binaryField)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          _fbthrift_longField = iprot.readI64()
          assert self.field == 0 and self.value is None
          self.set_longField(_fbthrift_longField)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, True], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeUnionBegin('Baz')
    if self.field == 1:
      oprot.writeFieldBegin('intField', TType.I32, 1)
      intField = self.value
      oprot.writeI32(intField)
      oprot.writeFieldEnd()
    if self.field == 4:
      oprot.writeFieldBegin('setField', TType.SET, 4)
      setField = self.value
      oprot.writeSetBegin(TType.STRING, len(setField))
      for iter110 in setField:
        oprot.writeString(iter110.encode('utf-8')) if UTF8STRINGS and not isinstance(iter110, bytes) else oprot.writeString(iter110)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.field == 6:
      oprot.writeFieldBegin('mapField', TType.MAP, 6)
      mapField = self.value
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(mapField))
      for kiter111,viter112 in mapField.items():
        oprot.writeString(kiter111.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter111, bytes) else oprot.writeString(kiter111)
        oprot.writeListBegin(TType.STRING, len(viter112))
        for iter113 in viter112:
          oprot.writeString(iter113.encode('utf-8')) if UTF8STRINGS and not isinstance(iter113, bytes) else oprot.writeString(iter113)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.field == 8:
      oprot.writeFieldBegin('binaryField', TType.STRING, 8)
      binaryField = self.value
      oprot.writeString(binaryField)
      oprot.writeFieldEnd()
    if self.field == 9:
      oprot.writeFieldBegin('longField', TType.I64, 9)
      longField = self.value
      oprot.writeI64(longField)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeUnionEnd()
  
  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    self.field = 0
    self.value = None
    obj = json
    if is_text:
      obj = loads(json)
    if not isinstance(obj, dict) or len(obj) > 1:
      raise TProtocolException(TProtocolException.INVALID_DATA, 'Can not parse')
    
    if 'intField' in obj:
      _fbthrift_intField = obj['intField']
      if _fbthrift_intField > 0x7fffffff or _fbthrift_intField < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
      self.set_intField(_fbthrift_intField)
    if 'setField' in obj:
      _fbthrift_setField = set_cls()
      for _tmp_e114 in obj['setField']:
        _fbthrift_setField.add(_tmp_e114)
      self.set_setField(_fbthrift_setField)
    if 'mapField' in obj:
      _fbthrift_mapField = dict_cls()
      for _tmp_k115, _tmp_v116 in obj['mapField'].items():
        _tmp_kp117 = _tmp_k115
        _list118 = []
        for _tmp_e119 in _tmp_v116:
          _list118.append(_tmp_e119)
        _fbthrift_mapField[_tmp_kp117] = _list118
      self.set_mapField(_fbthrift_mapField)
    if 'binaryField' in obj:
      _fbthrift_binaryField = obj['binaryField']
      self.set_binaryField(_fbthrift_binaryField)
    if 'longField' in obj:
      _fbthrift_longField = long(obj['longField'])
      self.set_longField(_fbthrift_longField)

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Baz, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Baz, self)

  def _to_py_deprecated(self):
    return self

class Bar:
  """
  Attributes:
   - structField
   - optionalStructField
   - structListField
   - optionalStructListField
   - unionField
   - optionalUnionField
   - adaptedStructField
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.structField = Foo()
          self.structField.read(iprot)
          self.structField = my.Adapter1.from_thrift(self.structField)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.optionalStructField = Foo()
          self.optionalStructField.read(iprot)
          self.optionalStructField = my.Adapter1.from_thrift(self.optionalStructField)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.structListField = []
          (_etype123, _size120) = iprot.readListBegin()
          if _size120 >= 0:
            for _i124 in range(_size120):
              _elem125 = Foo()
              _elem125.read(iprot)
              _elem125 = my.Adapter1.from_thrift(_elem125)
              self.structListField.append(_elem125)
          else: 
            while iprot.peekList():
              _elem126 = Foo()
              _elem126.read(iprot)
              _elem126 = my.Adapter1.from_thrift(_elem126)
              self.structListField.append(_elem126)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.optionalStructListField = []
          (_etype130, _size127) = iprot.readListBegin()
          if _size127 >= 0:
            for _i131 in range(_size127):
              _elem132 = Foo()
              _elem132.read(iprot)
              _elem132 = my.Adapter1.from_thrift(_elem132)
              self.optionalStructListField.append(_elem132)
          else: 
            while iprot.peekList():
              _elem133 = Foo()
              _elem133.read(iprot)
              _elem133 = my.Adapter1.from_thrift(_elem133)
              self.optionalStructListField.append(_elem133)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.unionField = Baz()
          self.unionField.read(iprot)
          self.unionField = my.Adapter1.from_thrift(self.unionField)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.optionalUnionField = Baz()
          self.optionalUnionField.read(iprot)
          self.optionalUnionField = my.Adapter1.from_thrift(self.optionalUnionField)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.adaptedStructField = DirectlyAdapted()
          self.adaptedStructField.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Bar')
    if self.structField != None:
      oprot.writeFieldBegin('structField', TType.STRUCT, 1)
      adpt134 = my.Adapter1.to_thrift(self.structField)
      adpt134.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalStructField != None:
      oprot.writeFieldBegin('optionalStructField', TType.STRUCT, 2)
      adpt135 = my.Adapter1.to_thrift(self.optionalStructField)
      adpt135.write(oprot)
      oprot.writeFieldEnd()
    if self.structListField != None:
      oprot.writeFieldBegin('structListField', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.structListField))
      for iter136 in self.structListField:
        adpt137 = my.Adapter1.to_thrift(iter136)
        adpt137.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.optionalStructListField != None:
      oprot.writeFieldBegin('optionalStructListField', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.optionalStructListField))
      for iter138 in self.optionalStructListField:
        adpt139 = my.Adapter1.to_thrift(iter138)
        adpt139.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.unionField != None:
      oprot.writeFieldBegin('unionField', TType.STRUCT, 5)
      adpt140 = my.Adapter1.to_thrift(self.unionField)
      adpt140.write(oprot)
      oprot.writeFieldEnd()
    if self.optionalUnionField != None:
      oprot.writeFieldBegin('optionalUnionField', TType.STRUCT, 6)
      adpt141 = my.Adapter1.to_thrift(self.optionalUnionField)
      adpt141.write(oprot)
      oprot.writeFieldEnd()
    if self.adaptedStructField != None:
      oprot.writeFieldBegin('adaptedStructField', TType.STRUCT, 7)
      self.adaptedStructField.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'structField' in json_obj and json_obj['structField'] is not None:
      self.structField = Foo()
      self.structField.readFromJson(json_obj['structField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalStructField' in json_obj and json_obj['optionalStructField'] is not None:
      self.optionalStructField = Foo()
      self.optionalStructField.readFromJson(json_obj['optionalStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'structListField' in json_obj and json_obj['structListField'] is not None:
      self.structListField = []
      for _tmp_e142 in json_obj['structListField']:
        _struct143 = Foo()
        _struct143.readFromJson(_tmp_e142, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.structListField.append(_struct143)
    if 'optionalStructListField' in json_obj and json_obj['optionalStructListField'] is not None:
      self.optionalStructListField = []
      for _tmp_e144 in json_obj['optionalStructListField']:
        _struct145 = Foo()
        _struct145.readFromJson(_tmp_e144, is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
        self.optionalStructListField.append(_struct145)
    if 'unionField' in json_obj and json_obj['unionField'] is not None:
      self.unionField = Baz()
      self.unionField.readFromJson(json_obj['unionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'optionalUnionField' in json_obj and json_obj['optionalUnionField'] is not None:
      self.optionalUnionField = Baz()
      self.optionalUnionField.readFromJson(json_obj['optionalUnionField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)
    if 'adaptedStructField' in json_obj and json_obj['adaptedStructField'] is not None:
      self.adaptedStructField = DirectlyAdapted()
      self.adaptedStructField.readFromJson(json_obj['adaptedStructField'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.structField is not None:
      value = pprint.pformat(self.structField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structField=%s' % (value))
    if self.optionalStructField is not None:
      value = pprint.pformat(self.optionalStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructField=%s' % (value))
    if self.structListField is not None:
      value = pprint.pformat(self.structListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    structListField=%s' % (value))
    if self.optionalStructListField is not None:
      value = pprint.pformat(self.optionalStructListField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalStructListField=%s' % (value))
    if self.unionField is not None:
      value = pprint.pformat(self.unionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    unionField=%s' % (value))
    if self.optionalUnionField is not None:
      value = pprint.pformat(self.optionalUnionField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    optionalUnionField=%s' % (value))
    if self.adaptedStructField is not None:
      value = pprint.pformat(self.adaptedStructField, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    adaptedStructField=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'structField',
      'optionalStructField',
      'structListField',
      'optionalStructListField',
      'unionField',
      'optionalUnionField',
      'adaptedStructField',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Bar, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Bar, self)

  def _to_py_deprecated(self):
    return self

class DirectlyAdapted:
  """
  Attributes:
   - field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('DirectlyAdapted')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.DirectlyAdapted, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.DirectlyAdapted, self)

  def _to_py_deprecated(self):
    return self

class StructWithFieldAdapter:
  """
  Attributes:
   - field
   - shared_field
   - opt_shared_field
   - opt_boxed_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.opt_shared_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.opt_boxed_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('StructWithFieldAdapter')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.shared_field != None:
      oprot.writeFieldBegin('shared_field', TType.I32, 2)
      oprot.writeI32(self.shared_field)
      oprot.writeFieldEnd()
    if self.opt_shared_field != None:
      oprot.writeFieldBegin('opt_shared_field', TType.I32, 3)
      oprot.writeI32(self.opt_shared_field)
      oprot.writeFieldEnd()
    if self.opt_boxed_field != None:
      oprot.writeFieldBegin('opt_boxed_field', TType.I32, 4)
      oprot.writeI32(self.opt_boxed_field)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'shared_field' in json_obj and json_obj['shared_field'] is not None:
      self.shared_field = json_obj['shared_field']
      if self.shared_field > 0x7fffffff or self.shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_shared_field' in json_obj and json_obj['opt_shared_field'] is not None:
      self.opt_shared_field = json_obj['opt_shared_field']
      if self.opt_shared_field > 0x7fffffff or self.opt_shared_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'opt_boxed_field' in json_obj and json_obj['opt_boxed_field'] is not None:
      self.opt_boxed_field = json_obj['opt_boxed_field']
      if self.opt_boxed_field > 0x7fffffff or self.opt_boxed_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.shared_field is not None:
      value = pprint.pformat(self.shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    shared_field=%s' % (value))
    if self.opt_shared_field is not None:
      value = pprint.pformat(self.opt_shared_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_shared_field=%s' % (value))
    if self.opt_boxed_field is not None:
      value = pprint.pformat(self.opt_boxed_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    opt_boxed_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'shared_field',
      'opt_shared_field',
      'opt_boxed_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.StructWithFieldAdapter, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.StructWithFieldAdapter, self)

  def _to_py_deprecated(self):
    return self

class TerseAdaptedFields:
  """
  Attributes:
   - int_field
   - string_field
   - set_field
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.int_field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.string_field = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.SET:
          self.set_field = set()
          (_etype149, _size146) = iprot.readSetBegin()
          if _size146 >= 0:
            for _i150 in range(_size146):
              _elem151 = iprot.readI32()
              self.set_field.add(_elem151)
          else: 
            while iprot.peekSet():
              _elem152 = iprot.readI32()
              self.set_field.add(_elem152)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('TerseAdaptedFields')
    if self.int_field != None:
      oprot.writeFieldBegin('int_field', TType.I32, 1)
      oprot.writeI32(self.int_field)
      oprot.writeFieldEnd()
    if self.string_field != None:
      oprot.writeFieldBegin('string_field', TType.STRING, 2)
      oprot.writeString(self.string_field.encode('utf-8')) if UTF8STRINGS and not isinstance(self.string_field, bytes) else oprot.writeString(self.string_field)
      oprot.writeFieldEnd()
    if self.set_field != None:
      oprot.writeFieldBegin('set_field', TType.SET, 3)
      oprot.writeSetBegin(TType.I32, len(self.set_field))
      for iter153 in self.set_field:
        oprot.writeI32(iter153)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'int_field' in json_obj and json_obj['int_field'] is not None:
      self.int_field = json_obj['int_field']
      if self.int_field > 0x7fffffff or self.int_field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'string_field' in json_obj and json_obj['string_field'] is not None:
      self.string_field = json_obj['string_field']
    if 'set_field' in json_obj and json_obj['set_field'] is not None:
      self.set_field = set_cls()
      for _tmp_e154 in json_obj['set_field']:
        if _tmp_e154 > 0x7fffffff or _tmp_e154 < -0x80000000:
          raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
        self.set_field.add(_tmp_e154)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.int_field is not None:
      value = pprint.pformat(self.int_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    int_field=%s' % (value))
    if self.string_field is not None:
      value = pprint.pformat(self.string_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    string_field=%s' % (value))
    if self.set_field is not None:
      value = pprint.pformat(self.set_field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_field=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'int_field',
      'string_field',
      'set_field',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.TerseAdaptedFields, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.TerseAdaptedFields, self)

  def _to_py_deprecated(self):
    return self

class B:
  """
  Attributes:
   - a
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.a = A()
          self.a.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('B')
    if self.a != None:
      oprot.writeFieldBegin('a', TType.STRUCT, 1)
      self.a.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'a' in json_obj and json_obj['a'] is not None:
      self.a = A()
      self.a.readFromJson(json_obj['a'], is_text=False, relax_enum_validation=relax_enum_validation, custom_set_cls=set_cls, custom_dict_cls=dict_cls)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.a is not None:
      value = pprint.pformat(self.a, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    a=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'a',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.B, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.B, self)

  def _to_py_deprecated(self):
    return self

class A:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('A')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.A, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.A, self)

  def _to_py_deprecated(self):
    return self

class Config:
  """
  Attributes:
   - path
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.path = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Config')
    if self.path != None:
      oprot.writeFieldBegin('path', TType.STRING, 1)
      oprot.writeString(self.path.encode('utf-8')) if UTF8STRINGS and not isinstance(self.path, bytes) else oprot.writeString(self.path)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'path' in json_obj and json_obj['path'] is not None:
      self.path = json_obj['path']

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.path is not None:
      value = pprint.pformat(self.path, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    path=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'path',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.Config, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.Config, self)

  def _to_py_deprecated(self):
    return self

class MyStruct:
  """
  Attributes:
   - field
   - set_string
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.field = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.set_string = set()
          (_etype158, _size155) = iprot.readSetBegin()
          if _size155 >= 0:
            for _i159 in range(_size155):
              _elem160 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem160)
          else: 
            while iprot.peekSet():
              _elem161 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.set_string.add(_elem161)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('MyStruct')
    if self.field != None:
      oprot.writeFieldBegin('field', TType.I32, 1)
      oprot.writeI32(self.field)
      oprot.writeFieldEnd()
    if self.set_string != None:
      oprot.writeFieldBegin('set_string', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.set_string))
      for iter162 in self.set_string:
        oprot.writeString(iter162.encode('utf-8')) if UTF8STRINGS and not isinstance(iter162, bytes) else oprot.writeString(iter162)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def readFromJson(self, json, is_text=True, **kwargs):
    relax_enum_validation = bool(kwargs.pop('relax_enum_validation', False))
    set_cls = kwargs.pop('custom_set_cls', set)
    dict_cls = kwargs.pop('custom_dict_cls', dict)
    if kwargs:
        extra_kwargs = ', '.join(kwargs.keys())
        raise ValueError(
            'Unexpected keyword arguments: ' + extra_kwargs
        )
    json_obj = json
    if is_text:
      json_obj = loads(json)
    if 'field' in json_obj and json_obj['field'] is not None:
      self.field = json_obj['field']
      if self.field > 0x7fffffff or self.field < -0x80000000:
        raise TProtocolException(TProtocolException.INVALID_DATA, 'number exceeds limit in field')
    if 'set_string' in json_obj and json_obj['set_string'] is not None:
      self.set_string = set_cls()
      for _tmp_e163 in json_obj['set_string']:
        self.set_string.add(_tmp_e163)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    if self.field is not None:
      value = pprint.pformat(self.field, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    field=%s' % (value))
    if self.set_string is not None:
      value = pprint.pformat(self.set_string, indent=0)
      value = padding.join(value.splitlines(True))
      L.append('    set_string=%s' % (value))
    return "%s(%s)" % (self.__class__.__name__, "\n" + ",\n".join(L) if L else '')

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  def __dir__(self):
    return (
      'field',
      'set_string',
    )

  # Override the __hash__ function for Python3 - t10434117
  __hash__ = object.__hash__

  def _to_python(self):
    import importlib
    import thrift.python.converter
    python_types = importlib.import_module("facebook.thrift.test.module.thrift_types")
    return thrift.python.converter.to_python_struct(python_types.MyStruct, self)

  def _to_py3(self):
    import importlib
    import thrift.py3.converter
    py3_types = importlib.import_module("facebook.thrift.test.module.types")
    return thrift.py3.converter.to_py3_struct(py3_types.MyStruct, self)

  def _to_py_deprecated(self):
    return self

SetWithAdapter = UnimplementedTypedef()
StringWithAdapter = UnimplementedTypedef()
ListWithElemAdapter = UnimplementedTypedef()
ListWithElemAdapter_withAdapter = ListWithElemAdapter
MyI64 = UnimplementedTypedef()
DoubleTypedefI64 = MyI64
MyI32 = UnimplementedTypedef()
FooWithAdapter = Foo
StructWithAdapter = my.Adapter2.Type
UnionWithAdapter = my.Adapter2.Type
AdaptedA = A
all_structs.append(MyAnnotation)
MyAnnotation.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'signature', True, None, 2, ), # 1
)

MyAnnotation.thrift_struct_annotations = {
}
MyAnnotation.thrift_field_annotations = {
}

def MyAnnotation__init__(self, signature=None,):
  self.signature = signature

MyAnnotation.__init__ = MyAnnotation__init__

def MyAnnotation__setstate__(self, state):
  state.setdefault('signature', None)
  self.__dict__ = state

MyAnnotation.__getstate__ = lambda self: self.__dict__.copy()
MyAnnotation.__setstate__ = MyAnnotation__setstate__

all_structs.append(Foo)
Foo.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  (2, TType.I32, 'optionalIntField', None, None, 1, ), # 2
  (3, TType.I32, 'intFieldWithDefault', None, 13, 2, ), # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  (5, TType.SET, 'optionalSetField', (TType.STRING,True), None, 1, ), # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  (7, TType.MAP, 'optionalMapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 1, ), # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
  (10, TType.I64, 'adaptedLongField', None, None, 2, ), # 10
  (11, TType.I64, 'doubleAdaptedField', None, None, 2, ), # 11
)

Foo.thrift_struct_annotations = {
  "thrift.uri": "facebook.com/thrift/compiler/test/fixtures/adapter/src/module/Foo",
}
Foo.thrift_field_annotations = {
}

def Foo__init__(self, intField=None, optionalIntField=None, intFieldWithDefault=Foo.thrift_spec[3][4], setField=None, optionalSetField=None, mapField=None, optionalMapField=None, binaryField=None, longField=None, adaptedLongField=None, doubleAdaptedField=None,):
  self.intField = intField
  self.optionalIntField = optionalIntField
  self.intFieldWithDefault = intFieldWithDefault
  self.setField = setField
  self.optionalSetField = optionalSetField
  self.mapField = mapField
  self.optionalMapField = optionalMapField
  self.binaryField = binaryField
  self.longField = longField
  self.adaptedLongField = adaptedLongField
  self.doubleAdaptedField = doubleAdaptedField

Foo.__init__ = Foo__init__

def Foo__setstate__(self, state):
  state.setdefault('intField', None)
  state.setdefault('optionalIntField', None)
  state.setdefault('intFieldWithDefault', 13)
  state.setdefault('setField', None)
  state.setdefault('optionalSetField', None)
  state.setdefault('mapField', None)
  state.setdefault('optionalMapField', None)
  state.setdefault('binaryField', None)
  state.setdefault('longField', None)
  state.setdefault('adaptedLongField', None)
  state.setdefault('doubleAdaptedField', None)
  self.__dict__ = state

Foo.__getstate__ = lambda self: self.__dict__.copy()
Foo.__setstate__ = Foo__setstate__

all_structs.append(Baz)
Baz.thrift_spec = (
  None, # 0
  (1, TType.I32, 'intField', None, None, 2, ), # 1
  None, # 2
  None, # 3
  (4, TType.SET, 'setField', (TType.STRING,True), None, 2, ), # 4
  None, # 5
  (6, TType.MAP, 'mapField', (TType.STRING,True,TType.LIST,(TType.STRING,True)), None, 2, ), # 6
  None, # 7
  (8, TType.STRING, 'binaryField', False, None, 2, ), # 8
  (9, TType.I64, 'longField', None, None, 2, ), # 9
)

Baz.thrift_struct_annotations = {
}
Baz.thrift_field_annotations = {
}

def Baz__init__(self, intField=None, setField=None, mapField=None, binaryField=None, longField=None,):
  self.field = 0
  self.value = None
  if intField is not None:
    assert self.field == 0 and self.value is None
    self.field = 1
    self.value = intField
  if setField is not None:
    assert self.field == 0 and self.value is None
    self.field = 4
    self.value = setField
  if mapField is not None:
    assert self.field == 0 and self.value is None
    self.field = 6
    self.value = mapField
  if binaryField is not None:
    assert self.field == 0 and self.value is None
    self.field = 8
    self.value = binaryField
  if longField is not None:
    assert self.field == 0 and self.value is None
    self.field = 9
    self.value = longField

Baz.__init__ = Baz__init__

all_structs.append(Bar)
Bar.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'structField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 2, ), # 1
  (2, TType.STRUCT, 'optionalStructField', [Foo, Foo.thrift_spec, False, my.Adapter1], None, 1, ), # 2
  (3, TType.LIST, 'structListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 2, ), # 3
  (4, TType.LIST, 'optionalStructListField', (TType.STRUCT,[Foo, Foo.thrift_spec, False, my.Adapter1]), None, 1, ), # 4
  (5, TType.STRUCT, 'unionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 2, ), # 5
  (6, TType.STRUCT, 'optionalUnionField', [Baz, Baz.thrift_spec, True, my.Adapter1], None, 1, ), # 6
  (7, TType.STRUCT, 'adaptedStructField', [DirectlyAdapted, DirectlyAdapted.thrift_spec, False], None, 2, ), # 7
)

Bar.thrift_struct_annotations = {
}
Bar.thrift_field_annotations = {
}

def Bar__init__(self, structField=None, optionalStructField=None, structListField=None, optionalStructListField=None, unionField=None, optionalUnionField=None, adaptedStructField=None,):
  self.structField = structField
  self.optionalStructField = optionalStructField
  self.structListField = structListField
  self.optionalStructListField = optionalStructListField
  self.unionField = unionField
  self.optionalUnionField = optionalUnionField
  self.adaptedStructField = adaptedStructField

Bar.__init__ = Bar__init__

def Bar__setstate__(self, state):
  state.setdefault('structField', None)
  state.setdefault('optionalStructField', None)
  state.setdefault('structListField', None)
  state.setdefault('optionalStructListField', None)
  state.setdefault('unionField', None)
  state.setdefault('optionalUnionField', None)
  state.setdefault('adaptedStructField', None)
  self.__dict__ = state

Bar.__getstate__ = lambda self: self.__dict__.copy()
Bar.__setstate__ = Bar__setstate__

all_structs.append(DirectlyAdapted)
DirectlyAdapted.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
)

DirectlyAdapted.thrift_struct_annotations = {
}
DirectlyAdapted.thrift_field_annotations = {
}

def DirectlyAdapted__init__(self, field=None,):
  self.field = field

DirectlyAdapted.__init__ = DirectlyAdapted__init__

def DirectlyAdapted__setstate__(self, state):
  state.setdefault('field', None)
  self.__dict__ = state

DirectlyAdapted.__getstate__ = lambda self: self.__dict__.copy()
DirectlyAdapted.__setstate__ = DirectlyAdapted__setstate__

all_structs.append(StructWithFieldAdapter)
StructWithFieldAdapter.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.I32, 'shared_field', None, None, 2, ), # 2
  (3, TType.I32, 'opt_shared_field', None, None, 1, ), # 3
  (4, TType.I32, 'opt_boxed_field', None, None, 1, ), # 4
)

StructWithFieldAdapter.thrift_struct_annotations = {
}
StructWithFieldAdapter.thrift_field_annotations = {
}

def StructWithFieldAdapter__init__(self, field=None, shared_field=None, opt_shared_field=None, opt_boxed_field=None,):
  self.field = field
  self.shared_field = shared_field
  self.opt_shared_field = opt_shared_field
  self.opt_boxed_field = opt_boxed_field

StructWithFieldAdapter.__init__ = StructWithFieldAdapter__init__

def StructWithFieldAdapter__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('shared_field', None)
  state.setdefault('opt_shared_field', None)
  state.setdefault('opt_boxed_field', None)
  self.__dict__ = state

StructWithFieldAdapter.__getstate__ = lambda self: self.__dict__.copy()
StructWithFieldAdapter.__setstate__ = StructWithFieldAdapter__setstate__

all_structs.append(TerseAdaptedFields)
TerseAdaptedFields.thrift_spec = (
  None, # 0
  (1, TType.I32, 'int_field', None, None, 3, ), # 1
  (2, TType.STRING, 'string_field', True, None, 3, ), # 2
  (3, TType.SET, 'set_field', (TType.I32,None), None, 3, ), # 3
)

TerseAdaptedFields.thrift_struct_annotations = {
}
TerseAdaptedFields.thrift_field_annotations = {
}

def TerseAdaptedFields__init__(self, int_field=None, string_field=None, set_field=None,):
  self.int_field = int_field
  self.string_field = string_field
  self.set_field = set_field

TerseAdaptedFields.__init__ = TerseAdaptedFields__init__

def TerseAdaptedFields__setstate__(self, state):
  state.setdefault('int_field', None)
  state.setdefault('string_field', None)
  state.setdefault('set_field', None)
  self.__dict__ = state

TerseAdaptedFields.__getstate__ = lambda self: self.__dict__.copy()
TerseAdaptedFields.__setstate__ = TerseAdaptedFields__setstate__

all_structs.append(B)
B.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'a', [A, A.thrift_spec, False], None, 2, ), # 1
)

B.thrift_struct_annotations = {
}
B.thrift_field_annotations = {
}

def B__init__(self, a=None,):
  self.a = a

B.__init__ = B__init__

def B__setstate__(self, state):
  state.setdefault('a', None)
  self.__dict__ = state

B.__getstate__ = lambda self: self.__dict__.copy()
B.__setstate__ = B__setstate__

all_structs.append(A)
A.thrift_spec = (
)

A.thrift_struct_annotations = {
}
A.thrift_field_annotations = {
}

all_structs.append(Config)
Config.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'path', True, None, 2, ), # 1
)

Config.thrift_struct_annotations = {
}
Config.thrift_field_annotations = {
}

def Config__init__(self, path=None,):
  self.path = path

Config.__init__ = Config__init__

def Config__setstate__(self, state):
  state.setdefault('path', None)
  self.__dict__ = state

Config.__getstate__ = lambda self: self.__dict__.copy()
Config.__setstate__ = Config__setstate__

all_structs.append(MyStruct)
MyStruct.thrift_spec = (
  None, # 0
  (1, TType.I32, 'field', None, None, 2, ), # 1
  (2, TType.SET, 'set_string', (TType.STRING,True), None, 2, ), # 2
)

MyStruct.thrift_struct_annotations = {
}
MyStruct.thrift_field_annotations = {
}

def MyStruct__init__(self, field=None, set_string=None,):
  self.field = field
  self.set_string = set_string

MyStruct.__init__ = MyStruct__init__

def MyStruct__setstate__(self, state):
  state.setdefault('field', None)
  state.setdefault('set_string', None)
  self.__dict__ = state

MyStruct.__getstate__ = lambda self: self.__dict__.copy()
MyStruct.__setstate__ = MyStruct__setstate__

fix_spec(all_structs)
del all_structs
