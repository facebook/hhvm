/**
 * Autogenerated by Thrift for /home/fbthrift/thrift/lib/thrift/RpcMetadata.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#pragma once

#include <thrift/lib/cpp2/gen/module_types_h.h>


#include "thrift/lib/cpp2/util/ManagedStringView.h"
#include "thrift/lib/thrift/RpcMetadata_extra.h"

namespace apache {
namespace thrift {
namespace tag {
struct zlibConfig;
struct zstdConfig;
struct codecConfig;
struct compressionSizeLimit;
struct compressionAlgos;
struct useStopTLS;
struct interactionId;
struct interactionName;
struct interactionId;
struct protocol;
struct name;
struct kind;
struct seqId;
struct clientTimeoutMs;
struct queueTimeoutMs;
struct priority;
struct otherMetadata;
struct crc32c;
struct loadMetric;
struct compression;
struct compressionConfig;
struct interactionId;
struct interactionCreate;
struct clientId;
struct serviceTraceMeta;
struct declaredException;
struct proxyException;
struct proxiedException;
struct appClientException;
struct appServerException;
struct name_utf8;
struct what_utf8;
struct metadata;
struct responseMetadata;
struct exceptionMetadata;
struct protocol;
struct seqId;
struct otherMetadata;
struct load;
struct crc32c;
struct compression;
struct payloadMetadata;
struct proxiedPayloadMetadata;
struct name_utf8;
struct what_utf8;
struct category;
struct code;
struct load;
struct compression;
struct otherMetadata;
struct agent;
struct hostname;
struct otherMetadata;
struct opaque;
struct interfaceKind;
struct minVersion;
struct maxVersion;
struct dscpToReflect;
struct markToReflect;
struct clientMetadata;
struct version;
struct setupResponse;
struct otherMetadata;
struct compression;
} // namespace tag
namespace detail {
#ifndef APACHE_THRIFT_ACCESSOR_zlibConfig
#define APACHE_THRIFT_ACCESSOR_zlibConfig
APACHE_THRIFT_DEFINE_ACCESSOR(zlibConfig);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_zstdConfig
#define APACHE_THRIFT_ACCESSOR_zstdConfig
APACHE_THRIFT_DEFINE_ACCESSOR(zstdConfig);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_codecConfig
#define APACHE_THRIFT_ACCESSOR_codecConfig
APACHE_THRIFT_DEFINE_ACCESSOR(codecConfig);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compressionSizeLimit
#define APACHE_THRIFT_ACCESSOR_compressionSizeLimit
APACHE_THRIFT_DEFINE_ACCESSOR(compressionSizeLimit);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compressionAlgos
#define APACHE_THRIFT_ACCESSOR_compressionAlgos
APACHE_THRIFT_DEFINE_ACCESSOR(compressionAlgos);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_useStopTLS
#define APACHE_THRIFT_ACCESSOR_useStopTLS
APACHE_THRIFT_DEFINE_ACCESSOR(useStopTLS);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interactionId
#define APACHE_THRIFT_ACCESSOR_interactionId
APACHE_THRIFT_DEFINE_ACCESSOR(interactionId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interactionName
#define APACHE_THRIFT_ACCESSOR_interactionName
APACHE_THRIFT_DEFINE_ACCESSOR(interactionName);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interactionId
#define APACHE_THRIFT_ACCESSOR_interactionId
APACHE_THRIFT_DEFINE_ACCESSOR(interactionId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_protocol
#define APACHE_THRIFT_ACCESSOR_protocol
APACHE_THRIFT_DEFINE_ACCESSOR(protocol);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name
#define APACHE_THRIFT_ACCESSOR_name
APACHE_THRIFT_DEFINE_ACCESSOR(name);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_kind
#define APACHE_THRIFT_ACCESSOR_kind
APACHE_THRIFT_DEFINE_ACCESSOR(kind);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_seqId
#define APACHE_THRIFT_ACCESSOR_seqId
APACHE_THRIFT_DEFINE_ACCESSOR(seqId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_clientTimeoutMs
#define APACHE_THRIFT_ACCESSOR_clientTimeoutMs
APACHE_THRIFT_DEFINE_ACCESSOR(clientTimeoutMs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_queueTimeoutMs
#define APACHE_THRIFT_ACCESSOR_queueTimeoutMs
APACHE_THRIFT_DEFINE_ACCESSOR(queueTimeoutMs);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_priority
#define APACHE_THRIFT_ACCESSOR_priority
APACHE_THRIFT_DEFINE_ACCESSOR(priority);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_otherMetadata
#define APACHE_THRIFT_ACCESSOR_otherMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(otherMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_crc32c
#define APACHE_THRIFT_ACCESSOR_crc32c
APACHE_THRIFT_DEFINE_ACCESSOR(crc32c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_loadMetric
#define APACHE_THRIFT_ACCESSOR_loadMetric
APACHE_THRIFT_DEFINE_ACCESSOR(loadMetric);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compression
#define APACHE_THRIFT_ACCESSOR_compression
APACHE_THRIFT_DEFINE_ACCESSOR(compression);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compressionConfig
#define APACHE_THRIFT_ACCESSOR_compressionConfig
APACHE_THRIFT_DEFINE_ACCESSOR(compressionConfig);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interactionId
#define APACHE_THRIFT_ACCESSOR_interactionId
APACHE_THRIFT_DEFINE_ACCESSOR(interactionId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interactionCreate
#define APACHE_THRIFT_ACCESSOR_interactionCreate
APACHE_THRIFT_DEFINE_ACCESSOR(interactionCreate);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_clientId
#define APACHE_THRIFT_ACCESSOR_clientId
APACHE_THRIFT_DEFINE_ACCESSOR(clientId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_serviceTraceMeta
#define APACHE_THRIFT_ACCESSOR_serviceTraceMeta
APACHE_THRIFT_DEFINE_ACCESSOR(serviceTraceMeta);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_declaredException
#define APACHE_THRIFT_ACCESSOR_declaredException
APACHE_THRIFT_DEFINE_ACCESSOR(declaredException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_proxyException
#define APACHE_THRIFT_ACCESSOR_proxyException
APACHE_THRIFT_DEFINE_ACCESSOR(proxyException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_proxiedException
#define APACHE_THRIFT_ACCESSOR_proxiedException
APACHE_THRIFT_DEFINE_ACCESSOR(proxiedException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_appClientException
#define APACHE_THRIFT_ACCESSOR_appClientException
APACHE_THRIFT_DEFINE_ACCESSOR(appClientException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_appServerException
#define APACHE_THRIFT_ACCESSOR_appServerException
APACHE_THRIFT_DEFINE_ACCESSOR(appServerException);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_utf8
#define APACHE_THRIFT_ACCESSOR_name_utf8
APACHE_THRIFT_DEFINE_ACCESSOR(name_utf8);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_what_utf8
#define APACHE_THRIFT_ACCESSOR_what_utf8
APACHE_THRIFT_DEFINE_ACCESSOR(what_utf8);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_metadata
#define APACHE_THRIFT_ACCESSOR_metadata
APACHE_THRIFT_DEFINE_ACCESSOR(metadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_responseMetadata
#define APACHE_THRIFT_ACCESSOR_responseMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(responseMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_exceptionMetadata
#define APACHE_THRIFT_ACCESSOR_exceptionMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(exceptionMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_protocol
#define APACHE_THRIFT_ACCESSOR_protocol
APACHE_THRIFT_DEFINE_ACCESSOR(protocol);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_seqId
#define APACHE_THRIFT_ACCESSOR_seqId
APACHE_THRIFT_DEFINE_ACCESSOR(seqId);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_otherMetadata
#define APACHE_THRIFT_ACCESSOR_otherMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(otherMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_load
#define APACHE_THRIFT_ACCESSOR_load
APACHE_THRIFT_DEFINE_ACCESSOR(load);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_crc32c
#define APACHE_THRIFT_ACCESSOR_crc32c
APACHE_THRIFT_DEFINE_ACCESSOR(crc32c);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compression
#define APACHE_THRIFT_ACCESSOR_compression
APACHE_THRIFT_DEFINE_ACCESSOR(compression);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_payloadMetadata
#define APACHE_THRIFT_ACCESSOR_payloadMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(payloadMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_proxiedPayloadMetadata
#define APACHE_THRIFT_ACCESSOR_proxiedPayloadMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(proxiedPayloadMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_name_utf8
#define APACHE_THRIFT_ACCESSOR_name_utf8
APACHE_THRIFT_DEFINE_ACCESSOR(name_utf8);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_what_utf8
#define APACHE_THRIFT_ACCESSOR_what_utf8
APACHE_THRIFT_DEFINE_ACCESSOR(what_utf8);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_category
#define APACHE_THRIFT_ACCESSOR_category
APACHE_THRIFT_DEFINE_ACCESSOR(category);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_code
#define APACHE_THRIFT_ACCESSOR_code
APACHE_THRIFT_DEFINE_ACCESSOR(code);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_load
#define APACHE_THRIFT_ACCESSOR_load
APACHE_THRIFT_DEFINE_ACCESSOR(load);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compression
#define APACHE_THRIFT_ACCESSOR_compression
APACHE_THRIFT_DEFINE_ACCESSOR(compression);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_otherMetadata
#define APACHE_THRIFT_ACCESSOR_otherMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(otherMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_agent
#define APACHE_THRIFT_ACCESSOR_agent
APACHE_THRIFT_DEFINE_ACCESSOR(agent);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_hostname
#define APACHE_THRIFT_ACCESSOR_hostname
APACHE_THRIFT_DEFINE_ACCESSOR(hostname);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_otherMetadata
#define APACHE_THRIFT_ACCESSOR_otherMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(otherMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_opaque
#define APACHE_THRIFT_ACCESSOR_opaque
APACHE_THRIFT_DEFINE_ACCESSOR(opaque);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_interfaceKind
#define APACHE_THRIFT_ACCESSOR_interfaceKind
APACHE_THRIFT_DEFINE_ACCESSOR(interfaceKind);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_minVersion
#define APACHE_THRIFT_ACCESSOR_minVersion
APACHE_THRIFT_DEFINE_ACCESSOR(minVersion);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_maxVersion
#define APACHE_THRIFT_ACCESSOR_maxVersion
APACHE_THRIFT_DEFINE_ACCESSOR(maxVersion);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_dscpToReflect
#define APACHE_THRIFT_ACCESSOR_dscpToReflect
APACHE_THRIFT_DEFINE_ACCESSOR(dscpToReflect);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_markToReflect
#define APACHE_THRIFT_ACCESSOR_markToReflect
APACHE_THRIFT_DEFINE_ACCESSOR(markToReflect);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_clientMetadata
#define APACHE_THRIFT_ACCESSOR_clientMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(clientMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_version
#define APACHE_THRIFT_ACCESSOR_version
APACHE_THRIFT_DEFINE_ACCESSOR(version);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_setupResponse
#define APACHE_THRIFT_ACCESSOR_setupResponse
APACHE_THRIFT_DEFINE_ACCESSOR(setupResponse);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_otherMetadata
#define APACHE_THRIFT_ACCESSOR_otherMetadata
APACHE_THRIFT_DEFINE_ACCESSOR(otherMetadata);
#endif
#ifndef APACHE_THRIFT_ACCESSOR_compression
#define APACHE_THRIFT_ACCESSOR_compression
APACHE_THRIFT_DEFINE_ACCESSOR(compression);
#endif
} // namespace detail
} // namespace thrift
} // namespace apache

// BEGIN declare_enums
namespace apache { namespace thrift {

enum class ProtocolId {
  BINARY = 0,
  COMPACT = 2,
};




enum class RpcKind {
  SINGLE_REQUEST_SINGLE_RESPONSE = 0,
  SINGLE_REQUEST_NO_RESPONSE = 1,
  STREAMING_REQUEST_SINGLE_RESPONSE = 2,
  STREAMING_REQUEST_NO_RESPONSE = 3,
  SINGLE_REQUEST_STREAMING_RESPONSE = 4,
  STREAMING_REQUEST_STREAMING_RESPONSE = 5,
  SINK = 6,
};




enum class RpcPriority {
  HIGH_IMPORTANT = 0,
  HIGH = 1,
  IMPORTANT = 2,
  NORMAL = 3,
  BEST_EFFORT = 4,
  N_PRIORITIES = 5,
};




enum class CompressionAlgorithm {
  NONE = 0,
  ZLIB = 1,
  ZSTD = 2,
};




enum class ResponseRpcErrorCategory {
  INTERNAL_ERROR = 0,
  INVALID_REQUEST = 1,
  LOADSHEDDING = 2,
  SHUTDOWN = 3,
};




enum class ResponseRpcErrorCode {
  UNKNOWN = 0,
  OVERLOAD = 1,
  TASK_EXPIRED = 2,
  QUEUE_OVERLOADED = 3,
  SHUTDOWN = 4,
  INJECTED_FAILURE = 5,
  REQUEST_PARSING_FAILURE = 6,
  QUEUE_TIMEOUT = 7,
  RESPONSE_TOO_BIG = 8,
  WRONG_RPC_KIND = 9,
  UNKNOWN_METHOD = 10,
  CHECKSUM_MISMATCH = 11,
  INTERRUPTION = 12,
  APP_OVERLOAD = 13,
  UNKNOWN_INTERACTION_ID = 14,
  INTERACTION_CONSTRUCTOR_ERROR = 15,
};




enum class InterfaceKind {
  USER = 0,
  DEBUGGING = 1,
  MONITORING = 2,
  PROFILING = 3,
};




}} // apache::thrift

namespace std {
template<> struct hash<::apache::thrift::ProtocolId> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::ProtocolId> {};
template<> struct hash<::apache::thrift::RpcKind> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::RpcKind> {};
template<> struct hash<::apache::thrift::RpcPriority> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::RpcPriority> {};
template<> struct hash<::apache::thrift::CompressionAlgorithm> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::CompressionAlgorithm> {};
template<> struct hash<::apache::thrift::ResponseRpcErrorCategory> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::ResponseRpcErrorCategory> {};
template<> struct hash<::apache::thrift::ResponseRpcErrorCode> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::ResponseRpcErrorCode> {};
template<> struct hash<::apache::thrift::InterfaceKind> :
  ::apache::thrift::detail::enum_hash<::apache::thrift::InterfaceKind> {};
} // std

namespace apache { namespace thrift {


template <> struct TEnumDataStorage<::apache::thrift::ProtocolId>;

template <> struct TEnumTraits<::apache::thrift::ProtocolId> {
  using type = ::apache::thrift::ProtocolId;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::BINARY; }
  static constexpr type max() { return type::COMPACT; }
};


template <> struct TEnumDataStorage<::apache::thrift::RpcKind>;

template <> struct TEnumTraits<::apache::thrift::RpcKind> {
  using type = ::apache::thrift::RpcKind;

  static constexpr std::size_t const size = 7;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::SINGLE_REQUEST_SINGLE_RESPONSE; }
  static constexpr type max() { return type::SINK; }
};


template <> struct TEnumDataStorage<::apache::thrift::RpcPriority>;

template <> struct TEnumTraits<::apache::thrift::RpcPriority> {
  using type = ::apache::thrift::RpcPriority;

  static constexpr std::size_t const size = 6;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::HIGH_IMPORTANT; }
  static constexpr type max() { return type::N_PRIORITIES; }
};


template <> struct TEnumDataStorage<::apache::thrift::CompressionAlgorithm>;

template <> struct TEnumTraits<::apache::thrift::CompressionAlgorithm> {
  using type = ::apache::thrift::CompressionAlgorithm;

  static constexpr std::size_t const size = 3;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::NONE; }
  static constexpr type max() { return type::ZSTD; }
};


template <> struct TEnumDataStorage<::apache::thrift::ResponseRpcErrorCategory>;

template <> struct TEnumTraits<::apache::thrift::ResponseRpcErrorCategory> {
  using type = ::apache::thrift::ResponseRpcErrorCategory;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::INTERNAL_ERROR; }
  static constexpr type max() { return type::SHUTDOWN; }
};


template <> struct TEnumDataStorage<::apache::thrift::ResponseRpcErrorCode>;

template <> struct TEnumTraits<::apache::thrift::ResponseRpcErrorCode> {
  using type = ::apache::thrift::ResponseRpcErrorCode;

  static constexpr std::size_t const size = 16;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::UNKNOWN; }
  static constexpr type max() { return type::INTERACTION_CONSTRUCTOR_ERROR; }
};


template <> struct TEnumDataStorage<::apache::thrift::InterfaceKind>;

template <> struct TEnumTraits<::apache::thrift::InterfaceKind> {
  using type = ::apache::thrift::InterfaceKind;

  static constexpr std::size_t const size = 4;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

  static constexpr type min() { return type::USER; }
  static constexpr type max() { return type::PROFILING; }
};


}} // apache::thrift

namespace apache { namespace thrift {

using _ProtocolId_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ProtocolId>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ProtocolId_EnumMapFactory::ValuesToNamesMapType _ProtocolId_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ProtocolId_EnumMapFactory::NamesToValuesMapType _ProtocolId_NAMES_TO_VALUES;

using _RpcKind_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<RpcKind>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _RpcKind_EnumMapFactory::ValuesToNamesMapType _RpcKind_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _RpcKind_EnumMapFactory::NamesToValuesMapType _RpcKind_NAMES_TO_VALUES;

using _RpcPriority_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<RpcPriority>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _RpcPriority_EnumMapFactory::ValuesToNamesMapType _RpcPriority_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _RpcPriority_EnumMapFactory::NamesToValuesMapType _RpcPriority_NAMES_TO_VALUES;

using _CompressionAlgorithm_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<CompressionAlgorithm>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _CompressionAlgorithm_EnumMapFactory::ValuesToNamesMapType _CompressionAlgorithm_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _CompressionAlgorithm_EnumMapFactory::NamesToValuesMapType _CompressionAlgorithm_NAMES_TO_VALUES;

using _ResponseRpcErrorCategory_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ResponseRpcErrorCategory>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ResponseRpcErrorCategory_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCategory_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ResponseRpcErrorCategory_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCategory_NAMES_TO_VALUES;

using _ResponseRpcErrorCode_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<ResponseRpcErrorCode>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _ResponseRpcErrorCode_EnumMapFactory::ValuesToNamesMapType _ResponseRpcErrorCode_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _ResponseRpcErrorCode_EnumMapFactory::NamesToValuesMapType _ResponseRpcErrorCode_NAMES_TO_VALUES;

using _InterfaceKind_EnumMapFactory = apache::thrift::detail::TEnumMapFactory<InterfaceKind>;
[[deprecated("use apache::thrift::util::enumNameSafe, apache::thrift::util::enumName, or apache::thrift::TEnumTraits")]]
extern const _InterfaceKind_EnumMapFactory::ValuesToNamesMapType _InterfaceKind_VALUES_TO_NAMES;
[[deprecated("use apache::thrift::TEnumTraits")]]
extern const _InterfaceKind_EnumMapFactory::NamesToValuesMapType _InterfaceKind_NAMES_TO_VALUES;

}} // apache::thrift

// END declare_enums
// BEGIN forward_declare
namespace apache { namespace thrift {
class ZlibCompressionCodecConfig;
class ZstdCompressionCodecConfig;
class CodecConfig;
class CompressionConfig;
class NegotiationParameters;
class InteractionCreate;
class InteractionTerminate;
class RequestRpcMetadata;
class PayloadResponseMetadata;
class PayloadDeclaredExceptionMetadata;
class PayloadProxyExceptionMetadata;
class PayloadProxiedExceptionMetadata;
class PayloadAppClientExceptionMetadata;
class PayloadAppServerExceptionMetadata;
class PayloadExceptionMetadata;
class PayloadExceptionMetadataBase;
class PayloadMetadata;
class ProxiedPayloadMetadata;
class ResponseRpcMetadata;
class ResponseRpcError;
class StreamPayloadMetadata;
class ClientMetadata;
class RequestSetupMetadata;
class SetupResponse;
class ServerPushMetadata;
class HeadersPayloadContent;
class HeadersPayloadMetadata;
}} // apache::thrift
// END forward_declare
// BEGIN typedefs
namespace apache { namespace thrift {
typedef ManagedStringViewWithConversions ManagedStringViewField;

}} // apache::thrift
// END typedefs
// BEGIN hash_and_equal_to
// END hash_and_equal_to
THRIFT_IGNORE_ISSET_USE_WARNING_BEGIN
namespace apache { namespace thrift {
class ZlibCompressionCodecConfig final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ZlibCompressionCodecConfig;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ZlibCompressionCodecConfig() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ZlibCompressionCodecConfig(apache::thrift::FragileConstructor);

  ZlibCompressionCodecConfig(ZlibCompressionCodecConfig&&) = default;

  ZlibCompressionCodecConfig(const ZlibCompressionCodecConfig&) = default;


  ZlibCompressionCodecConfig& operator=(ZlibCompressionCodecConfig&&) = default;

  ZlibCompressionCodecConfig& operator=(const ZlibCompressionCodecConfig&) = default;
  void __clear();
  bool operator==(const ZlibCompressionCodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ZlibCompressionCodecConfig& __x, const ZlibCompressionCodecConfig& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ZlibCompressionCodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator>(const ZlibCompressionCodecConfig& __x, const ZlibCompressionCodecConfig& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ZlibCompressionCodecConfig& __x, const ZlibCompressionCodecConfig& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ZlibCompressionCodecConfig& __x, const ZlibCompressionCodecConfig& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ZlibCompressionCodecConfig >;
  friend void swap(ZlibCompressionCodecConfig& a, ZlibCompressionCodecConfig& b);
};

template <class Protocol_>
uint32_t ZlibCompressionCodecConfig::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ZstdCompressionCodecConfig final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ZstdCompressionCodecConfig;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ZstdCompressionCodecConfig() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ZstdCompressionCodecConfig(apache::thrift::FragileConstructor);

  ZstdCompressionCodecConfig(ZstdCompressionCodecConfig&&) = default;

  ZstdCompressionCodecConfig(const ZstdCompressionCodecConfig&) = default;


  ZstdCompressionCodecConfig& operator=(ZstdCompressionCodecConfig&&) = default;

  ZstdCompressionCodecConfig& operator=(const ZstdCompressionCodecConfig&) = default;
  void __clear();
  bool operator==(const ZstdCompressionCodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ZstdCompressionCodecConfig& __x, const ZstdCompressionCodecConfig& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ZstdCompressionCodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator>(const ZstdCompressionCodecConfig& __x, const ZstdCompressionCodecConfig& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ZstdCompressionCodecConfig& __x, const ZstdCompressionCodecConfig& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ZstdCompressionCodecConfig& __x, const ZstdCompressionCodecConfig& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ZstdCompressionCodecConfig >;
  friend void swap(ZstdCompressionCodecConfig& a, ZstdCompressionCodecConfig& b);
};

template <class Protocol_>
uint32_t ZstdCompressionCodecConfig::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class CodecConfig final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CodecConfig;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    zlibConfig = 1,
    zstdConfig = 2,
  } ;

  CodecConfig()
      : type_(Type::__EMPTY__) {}

  CodecConfig(CodecConfig&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::zlibConfig:
      {
        set_zlibConfig(std::move(rhs.value_.zlibConfig));
        break;
      }
      case Type::zstdConfig:
      {
        set_zstdConfig(std::move(rhs.value_.zstdConfig));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  CodecConfig(const CodecConfig& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::zlibConfig:
      {
        set_zlibConfig(rhs.value_.zlibConfig);
        break;
      }
      case Type::zstdConfig:
      {
        set_zstdConfig(rhs.value_.zstdConfig);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  CodecConfig& operator=(CodecConfig&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::zlibConfig:
      {
        set_zlibConfig(std::move(rhs.value_.zlibConfig));
        break;
      }
      case Type::zstdConfig:
      {
        set_zstdConfig(std::move(rhs.value_.zstdConfig));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  CodecConfig& operator=(const CodecConfig& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::zlibConfig:
      {
        set_zlibConfig(rhs.value_.zlibConfig);
        break;
      }
      case Type::zstdConfig:
      {
        set_zstdConfig(rhs.value_.zstdConfig);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~CodecConfig() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::ZlibCompressionCodecConfig zlibConfig;
    ::apache::thrift::ZstdCompressionCodecConfig zstdConfig;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const CodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CodecConfig& __x, const CodecConfig& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CodecConfig& rhs) const;
#ifndef SWIG
  friend bool operator>(const CodecConfig& __x, const CodecConfig& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CodecConfig& __x, const CodecConfig& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CodecConfig& __x, const CodecConfig& __y) {
    return !(__x < __y);
  }
#endif

  ::apache::thrift::ZlibCompressionCodecConfig& set_zlibConfig(::apache::thrift::ZlibCompressionCodecConfig const &t) {
    __clear();
    type_ = Type::zlibConfig;
    ::new (std::addressof(value_.zlibConfig)) ::apache::thrift::ZlibCompressionCodecConfig(t);
    return value_.zlibConfig;
  }

  ::apache::thrift::ZlibCompressionCodecConfig& set_zlibConfig(::apache::thrift::ZlibCompressionCodecConfig&& t) {
    __clear();
    type_ = Type::zlibConfig;
    ::new (std::addressof(value_.zlibConfig)) ::apache::thrift::ZlibCompressionCodecConfig(std::move(t));
    return value_.zlibConfig;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::ZlibCompressionCodecConfig, T...>> ::apache::thrift::ZlibCompressionCodecConfig& set_zlibConfig(T&&... t) {
    __clear();
    type_ = Type::zlibConfig;
    ::new (std::addressof(value_.zlibConfig)) ::apache::thrift::ZlibCompressionCodecConfig(std::forward<T>(t)...);
    return value_.zlibConfig;
  }

  ::apache::thrift::ZstdCompressionCodecConfig& set_zstdConfig(::apache::thrift::ZstdCompressionCodecConfig const &t) {
    __clear();
    type_ = Type::zstdConfig;
    ::new (std::addressof(value_.zstdConfig)) ::apache::thrift::ZstdCompressionCodecConfig(t);
    return value_.zstdConfig;
  }

  ::apache::thrift::ZstdCompressionCodecConfig& set_zstdConfig(::apache::thrift::ZstdCompressionCodecConfig&& t) {
    __clear();
    type_ = Type::zstdConfig;
    ::new (std::addressof(value_.zstdConfig)) ::apache::thrift::ZstdCompressionCodecConfig(std::move(t));
    return value_.zstdConfig;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::ZstdCompressionCodecConfig, T...>> ::apache::thrift::ZstdCompressionCodecConfig& set_zstdConfig(T&&... t) {
    __clear();
    type_ = Type::zstdConfig;
    ::new (std::addressof(value_.zstdConfig)) ::apache::thrift::ZstdCompressionCodecConfig(std::forward<T>(t)...);
    return value_.zstdConfig;
  }

  ::apache::thrift::ZlibCompressionCodecConfig const & get_zlibConfig() const {
    assert(type_ == Type::zlibConfig);
    return value_.zlibConfig;
  }

  ::apache::thrift::ZstdCompressionCodecConfig const & get_zstdConfig() const {
    assert(type_ == Type::zstdConfig);
    return value_.zstdConfig;
  }

  ::apache::thrift::ZlibCompressionCodecConfig & mutable_zlibConfig() {
    assert(type_ == Type::zlibConfig);
    return value_.zlibConfig;
  }

  ::apache::thrift::ZstdCompressionCodecConfig & mutable_zstdConfig() {
    assert(type_ == Type::zstdConfig);
    return value_.zstdConfig;
  }

  ::apache::thrift::ZlibCompressionCodecConfig move_zlibConfig() {
    assert(type_ == Type::zlibConfig);
    return std::move(value_.zlibConfig);
  }

  ::apache::thrift::ZstdCompressionCodecConfig move_zstdConfig() {
    assert(type_ == Type::zstdConfig);
    return std::move(value_.zstdConfig);
  }

  template <typename..., typename T = ::apache::thrift::ZlibCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> zlibConfig_ref() const& {
    return {value_.zlibConfig, type_, zlibConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZlibCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> zlibConfig_ref() const&& {
    return {std::move(value_.zlibConfig), type_, zlibConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZlibCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> zlibConfig_ref() & {
    return {value_.zlibConfig, type_, zlibConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZlibCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> zlibConfig_ref() && {
    return {std::move(value_.zlibConfig), type_, zlibConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::ZstdCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> zstdConfig_ref() const& {
    return {value_.zstdConfig, type_, zstdConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZstdCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> zstdConfig_ref() const&& {
    return {std::move(value_.zstdConfig), type_, zstdConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZstdCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> zstdConfig_ref() & {
    return {value_.zstdConfig, type_, zstdConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::ZstdCompressionCodecConfig>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> zstdConfig_ref() && {
    return {std::move(value_.zstdConfig), type_, zstdConfig, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CodecConfig >;
  friend void swap(CodecConfig& a, CodecConfig& b);
};

template <class Protocol_>
uint32_t CodecConfig::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class CompressionConfig final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = CompressionConfig;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  CompressionConfig() :
      compressionSizeLimit(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  CompressionConfig(apache::thrift::FragileConstructor, ::apache::thrift::CodecConfig codecConfig__arg, ::std::int64_t compressionSizeLimit__arg);

  CompressionConfig(CompressionConfig&&) = default;

  CompressionConfig(const CompressionConfig&) = default;


  CompressionConfig& operator=(CompressionConfig&&) = default;

  CompressionConfig& operator=(const CompressionConfig&) = default;
  void __clear();
 private:
  ::apache::thrift::CodecConfig codecConfig;
 private:
  ::std::int64_t compressionSizeLimit;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool codecConfig;
    bool compressionSizeLimit;
  } __isset = {};
  bool operator==(const CompressionConfig& rhs) const;
#ifndef SWIG
  friend bool operator!=(const CompressionConfig& __x, const CompressionConfig& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const CompressionConfig& rhs) const;
#ifndef SWIG
  friend bool operator>(const CompressionConfig& __x, const CompressionConfig& __y) {
    return __y < __x;
  }
  friend bool operator<=(const CompressionConfig& __x, const CompressionConfig& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const CompressionConfig& __x, const CompressionConfig& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::CodecConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> codecConfig_ref() const& {
    return {this->codecConfig, __isset.codecConfig};
  }

  template <typename..., typename T = ::apache::thrift::CodecConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> codecConfig_ref() const&& {
    return {std::move(this->codecConfig), __isset.codecConfig};
  }

  template <typename..., typename T = ::apache::thrift::CodecConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> codecConfig_ref() & {
    return {this->codecConfig, __isset.codecConfig};
  }

  template <typename..., typename T = ::apache::thrift::CodecConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> codecConfig_ref() && {
    return {std::move(this->codecConfig), __isset.codecConfig};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compressionSizeLimit_ref() const& {
    return {this->compressionSizeLimit, __isset.compressionSizeLimit};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compressionSizeLimit_ref() const&& {
    return {std::move(this->compressionSizeLimit), __isset.compressionSizeLimit};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compressionSizeLimit_ref() & {
    return {this->compressionSizeLimit, __isset.compressionSizeLimit};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compressionSizeLimit_ref() && {
    return {std::move(this->compressionSizeLimit), __isset.compressionSizeLimit};
  }
  const ::apache::thrift::CodecConfig* get_codecConfig() const&;
  ::apache::thrift::CodecConfig* get_codecConfig() &;
  ::apache::thrift::CodecConfig* get_codecConfig() && = delete;

  template <typename T_CompressionConfig_codecConfig_struct_setter = ::apache::thrift::CodecConfig>
  ::apache::thrift::CodecConfig& set_codecConfig(T_CompressionConfig_codecConfig_struct_setter&& codecConfig_) {
    codecConfig = std::forward<T_CompressionConfig_codecConfig_struct_setter>(codecConfig_);
    __isset.codecConfig = true;
    return codecConfig;
  }

  const ::std::int64_t* get_compressionSizeLimit() const& {
    return compressionSizeLimit_ref() ? std::addressof(compressionSizeLimit) : nullptr;
  }

  ::std::int64_t* get_compressionSizeLimit() & {
    return compressionSizeLimit_ref() ? std::addressof(compressionSizeLimit) : nullptr;
  }
  ::std::int64_t* get_compressionSizeLimit() && = delete;

  ::std::int64_t& set_compressionSizeLimit(::std::int64_t compressionSizeLimit_) {
    compressionSizeLimit = compressionSizeLimit_;
    __isset.compressionSizeLimit = true;
    return compressionSizeLimit;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< CompressionConfig >;
  friend void swap(CompressionConfig& a, CompressionConfig& b);
};

template <class Protocol_>
uint32_t CompressionConfig::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class NegotiationParameters final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = NegotiationParameters;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  NegotiationParameters() :
      compressionAlgos(0),
      useStopTLS(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  NegotiationParameters(apache::thrift::FragileConstructor, std::uint64_t compressionAlgos__arg, bool useStopTLS__arg);

  NegotiationParameters(NegotiationParameters&&) = default;

  NegotiationParameters(const NegotiationParameters&) = default;


  NegotiationParameters& operator=(NegotiationParameters&&) = default;

  NegotiationParameters& operator=(const NegotiationParameters&) = default;
  void __clear();
 private:
  std::uint64_t compressionAlgos;
 private:
  bool useStopTLS;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool compressionAlgos;
    bool useStopTLS;
  } __isset = {};
  bool operator==(const NegotiationParameters& rhs) const;
#ifndef SWIG
  friend bool operator!=(const NegotiationParameters& __x, const NegotiationParameters& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const NegotiationParameters& rhs) const;
#ifndef SWIG
  friend bool operator>(const NegotiationParameters& __x, const NegotiationParameters& __y) {
    return __y < __x;
  }
  friend bool operator<=(const NegotiationParameters& __x, const NegotiationParameters& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const NegotiationParameters& __x, const NegotiationParameters& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = std::uint64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compressionAlgos_ref() const& {
    return {this->compressionAlgos, __isset.compressionAlgos};
  }

  template <typename..., typename T = std::uint64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compressionAlgos_ref() const&& {
    return {std::move(this->compressionAlgos), __isset.compressionAlgos};
  }

  template <typename..., typename T = std::uint64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compressionAlgos_ref() & {
    return {this->compressionAlgos, __isset.compressionAlgos};
  }

  template <typename..., typename T = std::uint64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compressionAlgos_ref() && {
    return {std::move(this->compressionAlgos), __isset.compressionAlgos};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> useStopTLS_ref() const& {
    return {this->useStopTLS, __isset.useStopTLS};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> useStopTLS_ref() const&& {
    return {std::move(this->useStopTLS), __isset.useStopTLS};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> useStopTLS_ref() & {
    return {this->useStopTLS, __isset.useStopTLS};
  }

  template <typename..., typename T = bool>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> useStopTLS_ref() && {
    return {std::move(this->useStopTLS), __isset.useStopTLS};
  }

  const std::uint64_t* get_compressionAlgos() const& {
    return compressionAlgos_ref() ? std::addressof(compressionAlgos) : nullptr;
  }

  std::uint64_t* get_compressionAlgos() & {
    return compressionAlgos_ref() ? std::addressof(compressionAlgos) : nullptr;
  }
  std::uint64_t* get_compressionAlgos() && = delete;

  std::uint64_t& set_compressionAlgos(std::uint64_t compressionAlgos_) {
    compressionAlgos = compressionAlgos_;
    __isset.compressionAlgos = true;
    return compressionAlgos;
  }

  const bool* get_useStopTLS() const& {
    return useStopTLS_ref() ? std::addressof(useStopTLS) : nullptr;
  }

  bool* get_useStopTLS() & {
    return useStopTLS_ref() ? std::addressof(useStopTLS) : nullptr;
  }
  bool* get_useStopTLS() && = delete;

  bool& set_useStopTLS(bool useStopTLS_) {
    useStopTLS = useStopTLS_;
    __isset.useStopTLS = true;
    return useStopTLS;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< NegotiationParameters >;
  friend void swap(NegotiationParameters& a, NegotiationParameters& b);
};

template <class Protocol_>
uint32_t NegotiationParameters::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class InteractionCreate final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = InteractionCreate;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  InteractionCreate() :
      interactionId(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  InteractionCreate(apache::thrift::FragileConstructor, ::std::int64_t interactionId__arg, ::apache::thrift::ManagedStringViewField interactionName__arg);

  InteractionCreate(InteractionCreate&&) = default;

  InteractionCreate(const InteractionCreate&) = default;


  InteractionCreate& operator=(InteractionCreate&&) = default;

  InteractionCreate& operator=(const InteractionCreate&) = default;
  void __clear();
 private:
  ::std::int64_t interactionId;
 private:
  ::apache::thrift::ManagedStringViewField interactionName;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool interactionId;
    bool interactionName;
  } __isset = {};
  bool operator==(const InteractionCreate& rhs) const;
#ifndef SWIG
  friend bool operator!=(const InteractionCreate& __x, const InteractionCreate& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const InteractionCreate& rhs) const;
#ifndef SWIG
  friend bool operator>(const InteractionCreate& __x, const InteractionCreate& __y) {
    return __y < __x;
  }
  friend bool operator<=(const InteractionCreate& __x, const InteractionCreate& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const InteractionCreate& __x, const InteractionCreate& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> interactionId_ref() const& {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> interactionId_ref() const&& {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> interactionId_ref() & {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> interactionId_ref() && {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> interactionName_ref() const& {
    return {this->interactionName, __isset.interactionName};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> interactionName_ref() const&& {
    return {std::move(this->interactionName), __isset.interactionName};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> interactionName_ref() & {
    return {this->interactionName, __isset.interactionName};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> interactionName_ref() && {
    return {std::move(this->interactionName), __isset.interactionName};
  }

  ::std::int64_t get_interactionId() const {
    return interactionId;
  }

  ::std::int64_t& set_interactionId(::std::int64_t interactionId_) {
    interactionId = interactionId_;
    __isset.interactionId = true;
    return interactionId;
  }

  const ::apache::thrift::ManagedStringViewField& get_interactionName() const& {
    return interactionName;
  }

  ::apache::thrift::ManagedStringViewField get_interactionName() && {
    return std::move(interactionName);
  }

  template <typename T_InteractionCreate_interactionName_struct_setter = ::apache::thrift::ManagedStringViewField>
  ::apache::thrift::ManagedStringViewField& set_interactionName(T_InteractionCreate_interactionName_struct_setter&& interactionName_) {
    interactionName = std::forward<T_InteractionCreate_interactionName_struct_setter>(interactionName_);
    __isset.interactionName = true;
    return interactionName;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< InteractionCreate >;
  friend void swap(InteractionCreate& a, InteractionCreate& b);
};

template <class Protocol_>
uint32_t InteractionCreate::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class InteractionTerminate final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = InteractionTerminate;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  InteractionTerminate() :
      interactionId(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  InteractionTerminate(apache::thrift::FragileConstructor, ::std::int64_t interactionId__arg);

  InteractionTerminate(InteractionTerminate&&) = default;

  InteractionTerminate(const InteractionTerminate&) = default;


  InteractionTerminate& operator=(InteractionTerminate&&) = default;

  InteractionTerminate& operator=(const InteractionTerminate&) = default;
  void __clear();
 private:
  ::std::int64_t interactionId;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool interactionId;
  } __isset = {};
  bool operator==(const InteractionTerminate& rhs) const;
#ifndef SWIG
  friend bool operator!=(const InteractionTerminate& __x, const InteractionTerminate& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const InteractionTerminate& rhs) const;
#ifndef SWIG
  friend bool operator>(const InteractionTerminate& __x, const InteractionTerminate& __y) {
    return __y < __x;
  }
  friend bool operator<=(const InteractionTerminate& __x, const InteractionTerminate& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const InteractionTerminate& __x, const InteractionTerminate& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&> interactionId_ref() const& {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<const T&&> interactionId_ref() const&& {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&> interactionId_ref() & {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::field_ref<T&&> interactionId_ref() && {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  ::std::int64_t get_interactionId() const {
    return interactionId;
  }

  ::std::int64_t& set_interactionId(::std::int64_t interactionId_) {
    interactionId = interactionId_;
    __isset.interactionId = true;
    return interactionId;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< InteractionTerminate >;
  friend void swap(InteractionTerminate& a, InteractionTerminate& b);
};

template <class Protocol_>
uint32_t InteractionTerminate::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class RequestRpcMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RequestRpcMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  RequestRpcMetadata();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RequestRpcMetadata(apache::thrift::FragileConstructor, ::apache::thrift::ProtocolId protocol__arg, ::apache::thrift::ManagedStringViewField name__arg, ::apache::thrift::RpcKind kind__arg, ::std::int32_t seqId__arg, ::std::int32_t clientTimeoutMs__arg, ::std::int32_t queueTimeoutMs__arg, ::apache::thrift::RpcPriority priority__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, std::uint32_t crc32c__arg, ::std::string loadMetric__arg, ::apache::thrift::CompressionAlgorithm compression__arg, ::apache::thrift::CompressionConfig compressionConfig__arg, ::std::int64_t interactionId__arg, ::apache::thrift::InteractionCreate interactionCreate__arg, ::std::string clientId__arg, ::std::string serviceTraceMeta__arg);

  RequestRpcMetadata(RequestRpcMetadata&&) = default;

  RequestRpcMetadata(const RequestRpcMetadata&) = default;


  RequestRpcMetadata& operator=(RequestRpcMetadata&&) = default;

  RequestRpcMetadata& operator=(const RequestRpcMetadata&) = default;
  void __clear();

  ~RequestRpcMetadata();

 private:
  ::apache::thrift::ProtocolId protocol;
 private:
  ::apache::thrift::ManagedStringViewField name;
 private:
  ::apache::thrift::RpcKind kind;
 private:
  ::std::int32_t seqId;
 private:
  ::std::int32_t clientTimeoutMs;
 private:
  ::std::int32_t queueTimeoutMs;
 private:
  ::apache::thrift::RpcPriority priority;
 private:
  ::std::map<::std::string, ::std::string> otherMetadata;
 private:
  std::uint32_t crc32c;
 private:
  ::std::string loadMetric;
 private:
  ::apache::thrift::CompressionAlgorithm compression;
 private:
  ::apache::thrift::CompressionConfig compressionConfig;
 private:
  ::std::int64_t interactionId;
 private:
  ::apache::thrift::InteractionCreate interactionCreate;
 private:
  ::std::string clientId;
 private:
  ::std::string serviceTraceMeta;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool protocol;
    bool name;
    bool kind;
    bool seqId;
    bool clientTimeoutMs;
    bool queueTimeoutMs;
    bool priority;
    bool otherMetadata;
    bool crc32c;
    bool loadMetric;
    bool compression;
    bool compressionConfig;
    bool interactionId;
    bool interactionCreate;
    bool clientId;
    bool serviceTraceMeta;
  } __isset = {};
  bool operator==(const RequestRpcMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RequestRpcMetadata& __x, const RequestRpcMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RequestRpcMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const RequestRpcMetadata& __x, const RequestRpcMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RequestRpcMetadata& __x, const RequestRpcMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RequestRpcMetadata& __x, const RequestRpcMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> protocol_ref() const& {
    return {this->protocol, __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> protocol_ref() const&& {
    return {std::move(this->protocol), __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> protocol_ref() & {
    return {this->protocol, __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> protocol_ref() && {
    return {std::move(this->protocol), __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> name_ref() const& {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> name_ref() const&& {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> name_ref() & {
    return {this->name, __isset.name};
  }

  template <typename..., typename T = ::apache::thrift::ManagedStringViewField>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> name_ref() && {
    return {std::move(this->name), __isset.name};
  }

  template <typename..., typename T = ::apache::thrift::RpcKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> kind_ref() const& {
    return {this->kind, __isset.kind};
  }

  template <typename..., typename T = ::apache::thrift::RpcKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> kind_ref() const&& {
    return {std::move(this->kind), __isset.kind};
  }

  template <typename..., typename T = ::apache::thrift::RpcKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> kind_ref() & {
    return {this->kind, __isset.kind};
  }

  template <typename..., typename T = ::apache::thrift::RpcKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> kind_ref() && {
    return {std::move(this->kind), __isset.kind};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> seqId_ref() const& {
    return {this->seqId, __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> seqId_ref() const&& {
    return {std::move(this->seqId), __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> seqId_ref() & {
    return {this->seqId, __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> seqId_ref() && {
    return {std::move(this->seqId), __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> clientTimeoutMs_ref() const& {
    return {this->clientTimeoutMs, __isset.clientTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> clientTimeoutMs_ref() const&& {
    return {std::move(this->clientTimeoutMs), __isset.clientTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> clientTimeoutMs_ref() & {
    return {this->clientTimeoutMs, __isset.clientTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> clientTimeoutMs_ref() && {
    return {std::move(this->clientTimeoutMs), __isset.clientTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> queueTimeoutMs_ref() const& {
    return {this->queueTimeoutMs, __isset.queueTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> queueTimeoutMs_ref() const&& {
    return {std::move(this->queueTimeoutMs), __isset.queueTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> queueTimeoutMs_ref() & {
    return {this->queueTimeoutMs, __isset.queueTimeoutMs};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> queueTimeoutMs_ref() && {
    return {std::move(this->queueTimeoutMs), __isset.queueTimeoutMs};
  }

  template <typename..., typename T = ::apache::thrift::RpcPriority>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> priority_ref() const& {
    return {this->priority, __isset.priority};
  }

  template <typename..., typename T = ::apache::thrift::RpcPriority>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> priority_ref() const&& {
    return {std::move(this->priority), __isset.priority};
  }

  template <typename..., typename T = ::apache::thrift::RpcPriority>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> priority_ref() & {
    return {this->priority, __isset.priority};
  }

  template <typename..., typename T = ::apache::thrift::RpcPriority>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> priority_ref() && {
    return {std::move(this->priority), __isset.priority};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> otherMetadata_ref() const& {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> otherMetadata_ref() const&& {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> otherMetadata_ref() & {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> otherMetadata_ref() && {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> crc32c_ref() const& {
    return {this->crc32c, __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> crc32c_ref() const&& {
    return {std::move(this->crc32c), __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> crc32c_ref() & {
    return {this->crc32c, __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> crc32c_ref() && {
    return {std::move(this->crc32c), __isset.crc32c};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> loadMetric_ref() const& {
    return {this->loadMetric, __isset.loadMetric};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> loadMetric_ref() const&& {
    return {std::move(this->loadMetric), __isset.loadMetric};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> loadMetric_ref() & {
    return {this->loadMetric, __isset.loadMetric};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> loadMetric_ref() && {
    return {std::move(this->loadMetric), __isset.loadMetric};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compression_ref() const& {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compression_ref() const&& {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compression_ref() & {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compression_ref() && {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compressionConfig_ref() const& {
    return {this->compressionConfig, __isset.compressionConfig};
  }

  template <typename..., typename T = ::apache::thrift::CompressionConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compressionConfig_ref() const&& {
    return {std::move(this->compressionConfig), __isset.compressionConfig};
  }

  template <typename..., typename T = ::apache::thrift::CompressionConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compressionConfig_ref() & {
    return {this->compressionConfig, __isset.compressionConfig};
  }

  template <typename..., typename T = ::apache::thrift::CompressionConfig>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compressionConfig_ref() && {
    return {std::move(this->compressionConfig), __isset.compressionConfig};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> interactionId_ref() const& {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> interactionId_ref() const&& {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> interactionId_ref() & {
    return {this->interactionId, __isset.interactionId};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> interactionId_ref() && {
    return {std::move(this->interactionId), __isset.interactionId};
  }

  template <typename..., typename T = ::apache::thrift::InteractionCreate>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> interactionCreate_ref() const& {
    return {this->interactionCreate, __isset.interactionCreate};
  }

  template <typename..., typename T = ::apache::thrift::InteractionCreate>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> interactionCreate_ref() const&& {
    return {std::move(this->interactionCreate), __isset.interactionCreate};
  }

  template <typename..., typename T = ::apache::thrift::InteractionCreate>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> interactionCreate_ref() & {
    return {this->interactionCreate, __isset.interactionCreate};
  }

  template <typename..., typename T = ::apache::thrift::InteractionCreate>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> interactionCreate_ref() && {
    return {std::move(this->interactionCreate), __isset.interactionCreate};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> clientId_ref() const& {
    return {this->clientId, __isset.clientId};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> clientId_ref() const&& {
    return {std::move(this->clientId), __isset.clientId};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> clientId_ref() & {
    return {this->clientId, __isset.clientId};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> clientId_ref() && {
    return {std::move(this->clientId), __isset.clientId};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> serviceTraceMeta_ref() const& {
    return {this->serviceTraceMeta, __isset.serviceTraceMeta};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> serviceTraceMeta_ref() const&& {
    return {std::move(this->serviceTraceMeta), __isset.serviceTraceMeta};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> serviceTraceMeta_ref() & {
    return {this->serviceTraceMeta, __isset.serviceTraceMeta};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> serviceTraceMeta_ref() && {
    return {std::move(this->serviceTraceMeta), __isset.serviceTraceMeta};
  }

  const ::apache::thrift::ProtocolId* get_protocol() const& {
    return protocol_ref() ? std::addressof(protocol) : nullptr;
  }

  ::apache::thrift::ProtocolId* get_protocol() & {
    return protocol_ref() ? std::addressof(protocol) : nullptr;
  }
  ::apache::thrift::ProtocolId* get_protocol() && = delete;

  ::apache::thrift::ProtocolId& set_protocol(::apache::thrift::ProtocolId protocol_) {
    protocol = protocol_;
    __isset.protocol = true;
    return protocol;
  }

  const ::apache::thrift::ManagedStringViewField* get_name() const& {
    return name_ref() ? std::addressof(name) : nullptr;
  }

  ::apache::thrift::ManagedStringViewField* get_name() & {
    return name_ref() ? std::addressof(name) : nullptr;
  }
  ::apache::thrift::ManagedStringViewField* get_name() && = delete;

  template <typename T_RequestRpcMetadata_name_struct_setter = ::apache::thrift::ManagedStringViewField>
  ::apache::thrift::ManagedStringViewField& set_name(T_RequestRpcMetadata_name_struct_setter&& name_) {
    name = std::forward<T_RequestRpcMetadata_name_struct_setter>(name_);
    __isset.name = true;
    return name;
  }

  const ::apache::thrift::RpcKind* get_kind() const& {
    return kind_ref() ? std::addressof(kind) : nullptr;
  }

  ::apache::thrift::RpcKind* get_kind() & {
    return kind_ref() ? std::addressof(kind) : nullptr;
  }
  ::apache::thrift::RpcKind* get_kind() && = delete;

  ::apache::thrift::RpcKind& set_kind(::apache::thrift::RpcKind kind_) {
    kind = kind_;
    __isset.kind = true;
    return kind;
  }

  const ::std::int32_t* get_seqId() const& {
    return seqId_ref() ? std::addressof(seqId) : nullptr;
  }

  ::std::int32_t* get_seqId() & {
    return seqId_ref() ? std::addressof(seqId) : nullptr;
  }
  ::std::int32_t* get_seqId() && = delete;

  ::std::int32_t& set_seqId(::std::int32_t seqId_) {
    seqId = seqId_;
    __isset.seqId = true;
    return seqId;
  }

  const ::std::int32_t* get_clientTimeoutMs() const& {
    return clientTimeoutMs_ref() ? std::addressof(clientTimeoutMs) : nullptr;
  }

  ::std::int32_t* get_clientTimeoutMs() & {
    return clientTimeoutMs_ref() ? std::addressof(clientTimeoutMs) : nullptr;
  }
  ::std::int32_t* get_clientTimeoutMs() && = delete;

  ::std::int32_t& set_clientTimeoutMs(::std::int32_t clientTimeoutMs_) {
    clientTimeoutMs = clientTimeoutMs_;
    __isset.clientTimeoutMs = true;
    return clientTimeoutMs;
  }

  const ::std::int32_t* get_queueTimeoutMs() const& {
    return queueTimeoutMs_ref() ? std::addressof(queueTimeoutMs) : nullptr;
  }

  ::std::int32_t* get_queueTimeoutMs() & {
    return queueTimeoutMs_ref() ? std::addressof(queueTimeoutMs) : nullptr;
  }
  ::std::int32_t* get_queueTimeoutMs() && = delete;

  ::std::int32_t& set_queueTimeoutMs(::std::int32_t queueTimeoutMs_) {
    queueTimeoutMs = queueTimeoutMs_;
    __isset.queueTimeoutMs = true;
    return queueTimeoutMs;
  }

  const ::apache::thrift::RpcPriority* get_priority() const& {
    return priority_ref() ? std::addressof(priority) : nullptr;
  }

  ::apache::thrift::RpcPriority* get_priority() & {
    return priority_ref() ? std::addressof(priority) : nullptr;
  }
  ::apache::thrift::RpcPriority* get_priority() && = delete;

  ::apache::thrift::RpcPriority& set_priority(::apache::thrift::RpcPriority priority_) {
    priority = priority_;
    __isset.priority = true;
    return priority;
  }
  const ::std::map<::std::string, ::std::string>* get_otherMetadata() const&;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() &;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() && = delete;

  template <typename T_RequestRpcMetadata_otherMetadata_struct_setter = ::std::map<::std::string, ::std::string>>
  ::std::map<::std::string, ::std::string>& set_otherMetadata(T_RequestRpcMetadata_otherMetadata_struct_setter&& otherMetadata_) {
    otherMetadata = std::forward<T_RequestRpcMetadata_otherMetadata_struct_setter>(otherMetadata_);
    __isset.otherMetadata = true;
    return otherMetadata;
  }

  const std::uint32_t* get_crc32c() const& {
    return crc32c_ref() ? std::addressof(crc32c) : nullptr;
  }

  std::uint32_t* get_crc32c() & {
    return crc32c_ref() ? std::addressof(crc32c) : nullptr;
  }
  std::uint32_t* get_crc32c() && = delete;

  std::uint32_t& set_crc32c(std::uint32_t crc32c_) {
    crc32c = crc32c_;
    __isset.crc32c = true;
    return crc32c;
  }

  const ::std::string* get_loadMetric() const& {
    return loadMetric_ref() ? std::addressof(loadMetric) : nullptr;
  }

  ::std::string* get_loadMetric() & {
    return loadMetric_ref() ? std::addressof(loadMetric) : nullptr;
  }
  ::std::string* get_loadMetric() && = delete;

  template <typename T_RequestRpcMetadata_loadMetric_struct_setter = ::std::string>
  ::std::string& set_loadMetric(T_RequestRpcMetadata_loadMetric_struct_setter&& loadMetric_) {
    loadMetric = std::forward<T_RequestRpcMetadata_loadMetric_struct_setter>(loadMetric_);
    __isset.loadMetric = true;
    return loadMetric;
  }

  const ::apache::thrift::CompressionAlgorithm* get_compression() const& {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }

  ::apache::thrift::CompressionAlgorithm* get_compression() & {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }
  ::apache::thrift::CompressionAlgorithm* get_compression() && = delete;

  ::apache::thrift::CompressionAlgorithm& set_compression(::apache::thrift::CompressionAlgorithm compression_) {
    compression = compression_;
    __isset.compression = true;
    return compression;
  }
  const ::apache::thrift::CompressionConfig* get_compressionConfig() const&;
  ::apache::thrift::CompressionConfig* get_compressionConfig() &;
  ::apache::thrift::CompressionConfig* get_compressionConfig() && = delete;

  template <typename T_RequestRpcMetadata_compressionConfig_struct_setter = ::apache::thrift::CompressionConfig>
  ::apache::thrift::CompressionConfig& set_compressionConfig(T_RequestRpcMetadata_compressionConfig_struct_setter&& compressionConfig_) {
    compressionConfig = std::forward<T_RequestRpcMetadata_compressionConfig_struct_setter>(compressionConfig_);
    __isset.compressionConfig = true;
    return compressionConfig;
  }

  const ::std::int64_t* get_interactionId() const& {
    return interactionId_ref() ? std::addressof(interactionId) : nullptr;
  }

  ::std::int64_t* get_interactionId() & {
    return interactionId_ref() ? std::addressof(interactionId) : nullptr;
  }
  ::std::int64_t* get_interactionId() && = delete;

  ::std::int64_t& set_interactionId(::std::int64_t interactionId_) {
    interactionId = interactionId_;
    __isset.interactionId = true;
    return interactionId;
  }
  const ::apache::thrift::InteractionCreate* get_interactionCreate() const&;
  ::apache::thrift::InteractionCreate* get_interactionCreate() &;
  ::apache::thrift::InteractionCreate* get_interactionCreate() && = delete;

  template <typename T_RequestRpcMetadata_interactionCreate_struct_setter = ::apache::thrift::InteractionCreate>
  ::apache::thrift::InteractionCreate& set_interactionCreate(T_RequestRpcMetadata_interactionCreate_struct_setter&& interactionCreate_) {
    interactionCreate = std::forward<T_RequestRpcMetadata_interactionCreate_struct_setter>(interactionCreate_);
    __isset.interactionCreate = true;
    return interactionCreate;
  }

  const ::std::string* get_clientId() const& {
    return clientId_ref() ? std::addressof(clientId) : nullptr;
  }

  ::std::string* get_clientId() & {
    return clientId_ref() ? std::addressof(clientId) : nullptr;
  }
  ::std::string* get_clientId() && = delete;

  template <typename T_RequestRpcMetadata_clientId_struct_setter = ::std::string>
  ::std::string& set_clientId(T_RequestRpcMetadata_clientId_struct_setter&& clientId_) {
    clientId = std::forward<T_RequestRpcMetadata_clientId_struct_setter>(clientId_);
    __isset.clientId = true;
    return clientId;
  }

  const ::std::string* get_serviceTraceMeta() const& {
    return serviceTraceMeta_ref() ? std::addressof(serviceTraceMeta) : nullptr;
  }

  ::std::string* get_serviceTraceMeta() & {
    return serviceTraceMeta_ref() ? std::addressof(serviceTraceMeta) : nullptr;
  }
  ::std::string* get_serviceTraceMeta() && = delete;

  template <typename T_RequestRpcMetadata_serviceTraceMeta_struct_setter = ::std::string>
  ::std::string& set_serviceTraceMeta(T_RequestRpcMetadata_serviceTraceMeta_struct_setter&& serviceTraceMeta_) {
    serviceTraceMeta = std::forward<T_RequestRpcMetadata_serviceTraceMeta_struct_setter>(serviceTraceMeta_);
    __isset.serviceTraceMeta = true;
    return serviceTraceMeta;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RequestRpcMetadata >;
  friend void swap(RequestRpcMetadata& a, RequestRpcMetadata& b);
};

template <class Protocol_>
uint32_t RequestRpcMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadResponseMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadResponseMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadResponseMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadResponseMetadata(apache::thrift::FragileConstructor);

  PayloadResponseMetadata(PayloadResponseMetadata&&) = default;

  PayloadResponseMetadata(const PayloadResponseMetadata&) = default;


  PayloadResponseMetadata& operator=(PayloadResponseMetadata&&) = default;

  PayloadResponseMetadata& operator=(const PayloadResponseMetadata&) = default;
  void __clear();
  bool operator==(const PayloadResponseMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadResponseMetadata& __x, const PayloadResponseMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadResponseMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadResponseMetadata& __x, const PayloadResponseMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadResponseMetadata& __x, const PayloadResponseMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadResponseMetadata& __x, const PayloadResponseMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadResponseMetadata >;
  friend void swap(PayloadResponseMetadata& a, PayloadResponseMetadata& b);
};

template <class Protocol_>
uint32_t PayloadResponseMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadDeclaredExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadDeclaredExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadDeclaredExceptionMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadDeclaredExceptionMetadata(apache::thrift::FragileConstructor);

  PayloadDeclaredExceptionMetadata(PayloadDeclaredExceptionMetadata&&) = default;

  PayloadDeclaredExceptionMetadata(const PayloadDeclaredExceptionMetadata&) = default;


  PayloadDeclaredExceptionMetadata& operator=(PayloadDeclaredExceptionMetadata&&) = default;

  PayloadDeclaredExceptionMetadata& operator=(const PayloadDeclaredExceptionMetadata&) = default;
  void __clear();
  bool operator==(const PayloadDeclaredExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadDeclaredExceptionMetadata& __x, const PayloadDeclaredExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadDeclaredExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadDeclaredExceptionMetadata& __x, const PayloadDeclaredExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadDeclaredExceptionMetadata& __x, const PayloadDeclaredExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadDeclaredExceptionMetadata& __x, const PayloadDeclaredExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadDeclaredExceptionMetadata >;
  friend void swap(PayloadDeclaredExceptionMetadata& a, PayloadDeclaredExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadDeclaredExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadProxyExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadProxyExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadProxyExceptionMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadProxyExceptionMetadata(apache::thrift::FragileConstructor);

  PayloadProxyExceptionMetadata(PayloadProxyExceptionMetadata&&) = default;

  PayloadProxyExceptionMetadata(const PayloadProxyExceptionMetadata&) = default;


  PayloadProxyExceptionMetadata& operator=(PayloadProxyExceptionMetadata&&) = default;

  PayloadProxyExceptionMetadata& operator=(const PayloadProxyExceptionMetadata&) = default;
  void __clear();
  bool operator==(const PayloadProxyExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadProxyExceptionMetadata& __x, const PayloadProxyExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadProxyExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadProxyExceptionMetadata& __x, const PayloadProxyExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadProxyExceptionMetadata& __x, const PayloadProxyExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadProxyExceptionMetadata& __x, const PayloadProxyExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadProxyExceptionMetadata >;
  friend void swap(PayloadProxyExceptionMetadata& a, PayloadProxyExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadProxyExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadProxiedExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadProxiedExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadProxiedExceptionMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadProxiedExceptionMetadata(apache::thrift::FragileConstructor);

  PayloadProxiedExceptionMetadata(PayloadProxiedExceptionMetadata&&) = default;

  PayloadProxiedExceptionMetadata(const PayloadProxiedExceptionMetadata&) = default;


  PayloadProxiedExceptionMetadata& operator=(PayloadProxiedExceptionMetadata&&) = default;

  PayloadProxiedExceptionMetadata& operator=(const PayloadProxiedExceptionMetadata&) = default;
  void __clear();
  bool operator==(const PayloadProxiedExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadProxiedExceptionMetadata& __x, const PayloadProxiedExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadProxiedExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadProxiedExceptionMetadata& __x, const PayloadProxiedExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadProxiedExceptionMetadata& __x, const PayloadProxiedExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadProxiedExceptionMetadata& __x, const PayloadProxiedExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadProxiedExceptionMetadata >;
  friend void swap(PayloadProxiedExceptionMetadata& a, PayloadProxiedExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadProxiedExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadAppClientExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadAppClientExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadAppClientExceptionMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadAppClientExceptionMetadata(apache::thrift::FragileConstructor);

  PayloadAppClientExceptionMetadata(PayloadAppClientExceptionMetadata&&) = default;

  PayloadAppClientExceptionMetadata(const PayloadAppClientExceptionMetadata&) = default;


  PayloadAppClientExceptionMetadata& operator=(PayloadAppClientExceptionMetadata&&) = default;

  PayloadAppClientExceptionMetadata& operator=(const PayloadAppClientExceptionMetadata&) = default;
  void __clear();
  bool operator==(const PayloadAppClientExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadAppClientExceptionMetadata& __x, const PayloadAppClientExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadAppClientExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadAppClientExceptionMetadata& __x, const PayloadAppClientExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadAppClientExceptionMetadata& __x, const PayloadAppClientExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadAppClientExceptionMetadata& __x, const PayloadAppClientExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadAppClientExceptionMetadata >;
  friend void swap(PayloadAppClientExceptionMetadata& a, PayloadAppClientExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadAppClientExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadAppServerExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadAppServerExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadAppServerExceptionMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadAppServerExceptionMetadata(apache::thrift::FragileConstructor);

  PayloadAppServerExceptionMetadata(PayloadAppServerExceptionMetadata&&) = default;

  PayloadAppServerExceptionMetadata(const PayloadAppServerExceptionMetadata&) = default;


  PayloadAppServerExceptionMetadata& operator=(PayloadAppServerExceptionMetadata&&) = default;

  PayloadAppServerExceptionMetadata& operator=(const PayloadAppServerExceptionMetadata&) = default;
  void __clear();
  bool operator==(const PayloadAppServerExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadAppServerExceptionMetadata& __x, const PayloadAppServerExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadAppServerExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadAppServerExceptionMetadata& __x, const PayloadAppServerExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadAppServerExceptionMetadata& __x, const PayloadAppServerExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadAppServerExceptionMetadata& __x, const PayloadAppServerExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadAppServerExceptionMetadata >;
  friend void swap(PayloadAppServerExceptionMetadata& a, PayloadAppServerExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadAppServerExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadExceptionMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadExceptionMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    declaredException = 1,
    proxyException = 2,
    proxiedException = 3,
    appClientException = 4,
    appServerException = 5,
  } ;

  PayloadExceptionMetadata()
      : type_(Type::__EMPTY__) {}

  PayloadExceptionMetadata(PayloadExceptionMetadata&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::declaredException:
      {
        set_declaredException(std::move(rhs.value_.declaredException));
        break;
      }
      case Type::proxyException:
      {
        set_proxyException(std::move(rhs.value_.proxyException));
        break;
      }
      case Type::proxiedException:
      {
        set_proxiedException(std::move(rhs.value_.proxiedException));
        break;
      }
      case Type::appClientException:
      {
        set_appClientException(std::move(rhs.value_.appClientException));
        break;
      }
      case Type::appServerException:
      {
        set_appServerException(std::move(rhs.value_.appServerException));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  PayloadExceptionMetadata(const PayloadExceptionMetadata& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::declaredException:
      {
        set_declaredException(rhs.value_.declaredException);
        break;
      }
      case Type::proxyException:
      {
        set_proxyException(rhs.value_.proxyException);
        break;
      }
      case Type::proxiedException:
      {
        set_proxiedException(rhs.value_.proxiedException);
        break;
      }
      case Type::appClientException:
      {
        set_appClientException(rhs.value_.appClientException);
        break;
      }
      case Type::appServerException:
      {
        set_appServerException(rhs.value_.appServerException);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  PayloadExceptionMetadata& operator=(PayloadExceptionMetadata&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::declaredException:
      {
        set_declaredException(std::move(rhs.value_.declaredException));
        break;
      }
      case Type::proxyException:
      {
        set_proxyException(std::move(rhs.value_.proxyException));
        break;
      }
      case Type::proxiedException:
      {
        set_proxiedException(std::move(rhs.value_.proxiedException));
        break;
      }
      case Type::appClientException:
      {
        set_appClientException(std::move(rhs.value_.appClientException));
        break;
      }
      case Type::appServerException:
      {
        set_appServerException(std::move(rhs.value_.appServerException));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  PayloadExceptionMetadata& operator=(const PayloadExceptionMetadata& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::declaredException:
      {
        set_declaredException(rhs.value_.declaredException);
        break;
      }
      case Type::proxyException:
      {
        set_proxyException(rhs.value_.proxyException);
        break;
      }
      case Type::proxiedException:
      {
        set_proxiedException(rhs.value_.proxiedException);
        break;
      }
      case Type::appClientException:
      {
        set_appClientException(rhs.value_.appClientException);
        break;
      }
      case Type::appServerException:
      {
        set_appServerException(rhs.value_.appServerException);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~PayloadExceptionMetadata() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::PayloadDeclaredExceptionMetadata declaredException;
    ::apache::thrift::PayloadProxyExceptionMetadata proxyException;
    ::apache::thrift::PayloadProxiedExceptionMetadata proxiedException;
    ::apache::thrift::PayloadAppClientExceptionMetadata appClientException;
    ::apache::thrift::PayloadAppServerExceptionMetadata appServerException;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const PayloadExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadExceptionMetadata& __x, const PayloadExceptionMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadExceptionMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadExceptionMetadata& __x, const PayloadExceptionMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadExceptionMetadata& __x, const PayloadExceptionMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadExceptionMetadata& __x, const PayloadExceptionMetadata& __y) {
    return !(__x < __y);
  }
#endif

  ::apache::thrift::PayloadDeclaredExceptionMetadata& set_declaredException(::apache::thrift::PayloadDeclaredExceptionMetadata const &t) {
    __clear();
    type_ = Type::declaredException;
    ::new (std::addressof(value_.declaredException)) ::apache::thrift::PayloadDeclaredExceptionMetadata(t);
    return value_.declaredException;
  }

  ::apache::thrift::PayloadDeclaredExceptionMetadata& set_declaredException(::apache::thrift::PayloadDeclaredExceptionMetadata&& t) {
    __clear();
    type_ = Type::declaredException;
    ::new (std::addressof(value_.declaredException)) ::apache::thrift::PayloadDeclaredExceptionMetadata(std::move(t));
    return value_.declaredException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadDeclaredExceptionMetadata, T...>> ::apache::thrift::PayloadDeclaredExceptionMetadata& set_declaredException(T&&... t) {
    __clear();
    type_ = Type::declaredException;
    ::new (std::addressof(value_.declaredException)) ::apache::thrift::PayloadDeclaredExceptionMetadata(std::forward<T>(t)...);
    return value_.declaredException;
  }

  ::apache::thrift::PayloadProxyExceptionMetadata& set_proxyException(::apache::thrift::PayloadProxyExceptionMetadata const &t) {
    __clear();
    type_ = Type::proxyException;
    ::new (std::addressof(value_.proxyException)) ::apache::thrift::PayloadProxyExceptionMetadata(t);
    return value_.proxyException;
  }

  ::apache::thrift::PayloadProxyExceptionMetadata& set_proxyException(::apache::thrift::PayloadProxyExceptionMetadata&& t) {
    __clear();
    type_ = Type::proxyException;
    ::new (std::addressof(value_.proxyException)) ::apache::thrift::PayloadProxyExceptionMetadata(std::move(t));
    return value_.proxyException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadProxyExceptionMetadata, T...>> ::apache::thrift::PayloadProxyExceptionMetadata& set_proxyException(T&&... t) {
    __clear();
    type_ = Type::proxyException;
    ::new (std::addressof(value_.proxyException)) ::apache::thrift::PayloadProxyExceptionMetadata(std::forward<T>(t)...);
    return value_.proxyException;
  }

  ::apache::thrift::PayloadProxiedExceptionMetadata& set_proxiedException(::apache::thrift::PayloadProxiedExceptionMetadata const &t) {
    __clear();
    type_ = Type::proxiedException;
    ::new (std::addressof(value_.proxiedException)) ::apache::thrift::PayloadProxiedExceptionMetadata(t);
    return value_.proxiedException;
  }

  ::apache::thrift::PayloadProxiedExceptionMetadata& set_proxiedException(::apache::thrift::PayloadProxiedExceptionMetadata&& t) {
    __clear();
    type_ = Type::proxiedException;
    ::new (std::addressof(value_.proxiedException)) ::apache::thrift::PayloadProxiedExceptionMetadata(std::move(t));
    return value_.proxiedException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadProxiedExceptionMetadata, T...>> ::apache::thrift::PayloadProxiedExceptionMetadata& set_proxiedException(T&&... t) {
    __clear();
    type_ = Type::proxiedException;
    ::new (std::addressof(value_.proxiedException)) ::apache::thrift::PayloadProxiedExceptionMetadata(std::forward<T>(t)...);
    return value_.proxiedException;
  }

  ::apache::thrift::PayloadAppClientExceptionMetadata& set_appClientException(::apache::thrift::PayloadAppClientExceptionMetadata const &t) {
    __clear();
    type_ = Type::appClientException;
    ::new (std::addressof(value_.appClientException)) ::apache::thrift::PayloadAppClientExceptionMetadata(t);
    return value_.appClientException;
  }

  ::apache::thrift::PayloadAppClientExceptionMetadata& set_appClientException(::apache::thrift::PayloadAppClientExceptionMetadata&& t) {
    __clear();
    type_ = Type::appClientException;
    ::new (std::addressof(value_.appClientException)) ::apache::thrift::PayloadAppClientExceptionMetadata(std::move(t));
    return value_.appClientException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadAppClientExceptionMetadata, T...>> ::apache::thrift::PayloadAppClientExceptionMetadata& set_appClientException(T&&... t) {
    __clear();
    type_ = Type::appClientException;
    ::new (std::addressof(value_.appClientException)) ::apache::thrift::PayloadAppClientExceptionMetadata(std::forward<T>(t)...);
    return value_.appClientException;
  }

  ::apache::thrift::PayloadAppServerExceptionMetadata& set_appServerException(::apache::thrift::PayloadAppServerExceptionMetadata const &t) {
    __clear();
    type_ = Type::appServerException;
    ::new (std::addressof(value_.appServerException)) ::apache::thrift::PayloadAppServerExceptionMetadata(t);
    return value_.appServerException;
  }

  ::apache::thrift::PayloadAppServerExceptionMetadata& set_appServerException(::apache::thrift::PayloadAppServerExceptionMetadata&& t) {
    __clear();
    type_ = Type::appServerException;
    ::new (std::addressof(value_.appServerException)) ::apache::thrift::PayloadAppServerExceptionMetadata(std::move(t));
    return value_.appServerException;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadAppServerExceptionMetadata, T...>> ::apache::thrift::PayloadAppServerExceptionMetadata& set_appServerException(T&&... t) {
    __clear();
    type_ = Type::appServerException;
    ::new (std::addressof(value_.appServerException)) ::apache::thrift::PayloadAppServerExceptionMetadata(std::forward<T>(t)...);
    return value_.appServerException;
  }

  ::apache::thrift::PayloadDeclaredExceptionMetadata const & get_declaredException() const {
    assert(type_ == Type::declaredException);
    return value_.declaredException;
  }

  ::apache::thrift::PayloadProxyExceptionMetadata const & get_proxyException() const {
    assert(type_ == Type::proxyException);
    return value_.proxyException;
  }

  ::apache::thrift::PayloadProxiedExceptionMetadata const & get_proxiedException() const {
    assert(type_ == Type::proxiedException);
    return value_.proxiedException;
  }

  ::apache::thrift::PayloadAppClientExceptionMetadata const & get_appClientException() const {
    assert(type_ == Type::appClientException);
    return value_.appClientException;
  }

  ::apache::thrift::PayloadAppServerExceptionMetadata const & get_appServerException() const {
    assert(type_ == Type::appServerException);
    return value_.appServerException;
  }

  ::apache::thrift::PayloadDeclaredExceptionMetadata & mutable_declaredException() {
    assert(type_ == Type::declaredException);
    return value_.declaredException;
  }

  ::apache::thrift::PayloadProxyExceptionMetadata & mutable_proxyException() {
    assert(type_ == Type::proxyException);
    return value_.proxyException;
  }

  ::apache::thrift::PayloadProxiedExceptionMetadata & mutable_proxiedException() {
    assert(type_ == Type::proxiedException);
    return value_.proxiedException;
  }

  ::apache::thrift::PayloadAppClientExceptionMetadata & mutable_appClientException() {
    assert(type_ == Type::appClientException);
    return value_.appClientException;
  }

  ::apache::thrift::PayloadAppServerExceptionMetadata & mutable_appServerException() {
    assert(type_ == Type::appServerException);
    return value_.appServerException;
  }

  ::apache::thrift::PayloadDeclaredExceptionMetadata move_declaredException() {
    assert(type_ == Type::declaredException);
    return std::move(value_.declaredException);
  }

  ::apache::thrift::PayloadProxyExceptionMetadata move_proxyException() {
    assert(type_ == Type::proxyException);
    return std::move(value_.proxyException);
  }

  ::apache::thrift::PayloadProxiedExceptionMetadata move_proxiedException() {
    assert(type_ == Type::proxiedException);
    return std::move(value_.proxiedException);
  }

  ::apache::thrift::PayloadAppClientExceptionMetadata move_appClientException() {
    assert(type_ == Type::appClientException);
    return std::move(value_.appClientException);
  }

  ::apache::thrift::PayloadAppServerExceptionMetadata move_appServerException() {
    assert(type_ == Type::appServerException);
    return std::move(value_.appServerException);
  }

  template <typename..., typename T = ::apache::thrift::PayloadDeclaredExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> declaredException_ref() const& {
    return {value_.declaredException, type_, declaredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadDeclaredExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> declaredException_ref() const&& {
    return {std::move(value_.declaredException), type_, declaredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadDeclaredExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> declaredException_ref() & {
    return {value_.declaredException, type_, declaredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadDeclaredExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> declaredException_ref() && {
    return {std::move(value_.declaredException), type_, declaredException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::PayloadProxyExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> proxyException_ref() const& {
    return {value_.proxyException, type_, proxyException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxyExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> proxyException_ref() const&& {
    return {std::move(value_.proxyException), type_, proxyException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxyExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> proxyException_ref() & {
    return {value_.proxyException, type_, proxyException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxyExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> proxyException_ref() && {
    return {std::move(value_.proxyException), type_, proxyException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::PayloadProxiedExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> proxiedException_ref() const& {
    return {value_.proxiedException, type_, proxiedException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxiedExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> proxiedException_ref() const&& {
    return {std::move(value_.proxiedException), type_, proxiedException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxiedExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> proxiedException_ref() & {
    return {value_.proxiedException, type_, proxiedException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadProxiedExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> proxiedException_ref() && {
    return {std::move(value_.proxiedException), type_, proxiedException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::PayloadAppClientExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> appClientException_ref() const& {
    return {value_.appClientException, type_, appClientException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppClientExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> appClientException_ref() const&& {
    return {std::move(value_.appClientException), type_, appClientException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppClientExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> appClientException_ref() & {
    return {value_.appClientException, type_, appClientException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppClientExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> appClientException_ref() && {
    return {std::move(value_.appClientException), type_, appClientException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::PayloadAppServerExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> appServerException_ref() const& {
    return {value_.appServerException, type_, appServerException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppServerExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> appServerException_ref() const&& {
    return {std::move(value_.appServerException), type_, appServerException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppServerExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> appServerException_ref() & {
    return {value_.appServerException, type_, appServerException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadAppServerExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> appServerException_ref() && {
    return {std::move(value_.appServerException), type_, appServerException, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadExceptionMetadata >;
  friend void swap(PayloadExceptionMetadata& a, PayloadExceptionMetadata& b);
};

template <class Protocol_>
uint32_t PayloadExceptionMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadExceptionMetadataBase final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadExceptionMetadataBase;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  PayloadExceptionMetadataBase() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  PayloadExceptionMetadataBase(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg, ::apache::thrift::PayloadExceptionMetadata metadata__arg);

  PayloadExceptionMetadataBase(PayloadExceptionMetadataBase&&) = default;

  PayloadExceptionMetadataBase(const PayloadExceptionMetadataBase&) = default;


  PayloadExceptionMetadataBase& operator=(PayloadExceptionMetadataBase&&) = default;

  PayloadExceptionMetadataBase& operator=(const PayloadExceptionMetadataBase&) = default;
  void __clear();
 private:
  ::std::string name_utf8;
 private:
  ::std::string what_utf8;
 private:
  ::apache::thrift::PayloadExceptionMetadata metadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name_utf8;
    bool what_utf8;
    bool metadata;
  } __isset = {};
  bool operator==(const PayloadExceptionMetadataBase& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadExceptionMetadataBase& __x, const PayloadExceptionMetadataBase& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadExceptionMetadataBase& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadExceptionMetadataBase& __x, const PayloadExceptionMetadataBase& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadExceptionMetadataBase& __x, const PayloadExceptionMetadataBase& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadExceptionMetadataBase& __x, const PayloadExceptionMetadataBase& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> name_utf8_ref() const& {
    return {this->name_utf8, __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> name_utf8_ref() const&& {
    return {std::move(this->name_utf8), __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> name_utf8_ref() & {
    return {this->name_utf8, __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> name_utf8_ref() && {
    return {std::move(this->name_utf8), __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> what_utf8_ref() const& {
    return {this->what_utf8, __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> what_utf8_ref() const&& {
    return {std::move(this->what_utf8), __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> what_utf8_ref() & {
    return {this->what_utf8, __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> what_utf8_ref() && {
    return {std::move(this->what_utf8), __isset.what_utf8};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> metadata_ref() const& {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> metadata_ref() const&& {
    return {std::move(this->metadata), __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> metadata_ref() & {
    return {this->metadata, __isset.metadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> metadata_ref() && {
    return {std::move(this->metadata), __isset.metadata};
  }

  const ::std::string* get_name_utf8() const& {
    return name_utf8_ref() ? std::addressof(name_utf8) : nullptr;
  }

  ::std::string* get_name_utf8() & {
    return name_utf8_ref() ? std::addressof(name_utf8) : nullptr;
  }
  ::std::string* get_name_utf8() && = delete;

  template <typename T_PayloadExceptionMetadataBase_name_utf8_struct_setter = ::std::string>
  ::std::string& set_name_utf8(T_PayloadExceptionMetadataBase_name_utf8_struct_setter&& name_utf8_) {
    name_utf8 = std::forward<T_PayloadExceptionMetadataBase_name_utf8_struct_setter>(name_utf8_);
    __isset.name_utf8 = true;
    return name_utf8;
  }

  const ::std::string* get_what_utf8() const& {
    return what_utf8_ref() ? std::addressof(what_utf8) : nullptr;
  }

  ::std::string* get_what_utf8() & {
    return what_utf8_ref() ? std::addressof(what_utf8) : nullptr;
  }
  ::std::string* get_what_utf8() && = delete;

  template <typename T_PayloadExceptionMetadataBase_what_utf8_struct_setter = ::std::string>
  ::std::string& set_what_utf8(T_PayloadExceptionMetadataBase_what_utf8_struct_setter&& what_utf8_) {
    what_utf8 = std::forward<T_PayloadExceptionMetadataBase_what_utf8_struct_setter>(what_utf8_);
    __isset.what_utf8 = true;
    return what_utf8;
  }
  const ::apache::thrift::PayloadExceptionMetadata* get_metadata() const&;
  ::apache::thrift::PayloadExceptionMetadata* get_metadata() &;
  ::apache::thrift::PayloadExceptionMetadata* get_metadata() && = delete;

  template <typename T_PayloadExceptionMetadataBase_metadata_struct_setter = ::apache::thrift::PayloadExceptionMetadata>
  ::apache::thrift::PayloadExceptionMetadata& set_metadata(T_PayloadExceptionMetadataBase_metadata_struct_setter&& metadata_) {
    metadata = std::forward<T_PayloadExceptionMetadataBase_metadata_struct_setter>(metadata_);
    __isset.metadata = true;
    return metadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadExceptionMetadataBase >;
  friend void swap(PayloadExceptionMetadataBase& a, PayloadExceptionMetadataBase& b);
};

template <class Protocol_>
uint32_t PayloadExceptionMetadataBase::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class PayloadMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = PayloadMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    responseMetadata = 1,
    exceptionMetadata = 2,
  } ;

  PayloadMetadata()
      : type_(Type::__EMPTY__) {}

  PayloadMetadata(PayloadMetadata&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::responseMetadata:
      {
        set_responseMetadata(std::move(rhs.value_.responseMetadata));
        break;
      }
      case Type::exceptionMetadata:
      {
        set_exceptionMetadata(std::move(rhs.value_.exceptionMetadata));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  PayloadMetadata(const PayloadMetadata& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::responseMetadata:
      {
        set_responseMetadata(rhs.value_.responseMetadata);
        break;
      }
      case Type::exceptionMetadata:
      {
        set_exceptionMetadata(rhs.value_.exceptionMetadata);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  PayloadMetadata& operator=(PayloadMetadata&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::responseMetadata:
      {
        set_responseMetadata(std::move(rhs.value_.responseMetadata));
        break;
      }
      case Type::exceptionMetadata:
      {
        set_exceptionMetadata(std::move(rhs.value_.exceptionMetadata));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  PayloadMetadata& operator=(const PayloadMetadata& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::responseMetadata:
      {
        set_responseMetadata(rhs.value_.responseMetadata);
        break;
      }
      case Type::exceptionMetadata:
      {
        set_exceptionMetadata(rhs.value_.exceptionMetadata);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~PayloadMetadata() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::PayloadResponseMetadata responseMetadata;
    ::apache::thrift::PayloadExceptionMetadataBase exceptionMetadata;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const PayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const PayloadMetadata& __x, const PayloadMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const PayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const PayloadMetadata& __x, const PayloadMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const PayloadMetadata& __x, const PayloadMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const PayloadMetadata& __x, const PayloadMetadata& __y) {
    return !(__x < __y);
  }
#endif

  ::apache::thrift::PayloadResponseMetadata& set_responseMetadata(::apache::thrift::PayloadResponseMetadata const &t) {
    __clear();
    type_ = Type::responseMetadata;
    ::new (std::addressof(value_.responseMetadata)) ::apache::thrift::PayloadResponseMetadata(t);
    return value_.responseMetadata;
  }

  ::apache::thrift::PayloadResponseMetadata& set_responseMetadata(::apache::thrift::PayloadResponseMetadata&& t) {
    __clear();
    type_ = Type::responseMetadata;
    ::new (std::addressof(value_.responseMetadata)) ::apache::thrift::PayloadResponseMetadata(std::move(t));
    return value_.responseMetadata;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadResponseMetadata, T...>> ::apache::thrift::PayloadResponseMetadata& set_responseMetadata(T&&... t) {
    __clear();
    type_ = Type::responseMetadata;
    ::new (std::addressof(value_.responseMetadata)) ::apache::thrift::PayloadResponseMetadata(std::forward<T>(t)...);
    return value_.responseMetadata;
  }

  ::apache::thrift::PayloadExceptionMetadataBase& set_exceptionMetadata(::apache::thrift::PayloadExceptionMetadataBase const &t) {
    __clear();
    type_ = Type::exceptionMetadata;
    ::new (std::addressof(value_.exceptionMetadata)) ::apache::thrift::PayloadExceptionMetadataBase(t);
    return value_.exceptionMetadata;
  }

  ::apache::thrift::PayloadExceptionMetadataBase& set_exceptionMetadata(::apache::thrift::PayloadExceptionMetadataBase&& t) {
    __clear();
    type_ = Type::exceptionMetadata;
    ::new (std::addressof(value_.exceptionMetadata)) ::apache::thrift::PayloadExceptionMetadataBase(std::move(t));
    return value_.exceptionMetadata;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::PayloadExceptionMetadataBase, T...>> ::apache::thrift::PayloadExceptionMetadataBase& set_exceptionMetadata(T&&... t) {
    __clear();
    type_ = Type::exceptionMetadata;
    ::new (std::addressof(value_.exceptionMetadata)) ::apache::thrift::PayloadExceptionMetadataBase(std::forward<T>(t)...);
    return value_.exceptionMetadata;
  }

  ::apache::thrift::PayloadResponseMetadata const & get_responseMetadata() const {
    assert(type_ == Type::responseMetadata);
    return value_.responseMetadata;
  }

  ::apache::thrift::PayloadExceptionMetadataBase const & get_exceptionMetadata() const {
    assert(type_ == Type::exceptionMetadata);
    return value_.exceptionMetadata;
  }

  ::apache::thrift::PayloadResponseMetadata & mutable_responseMetadata() {
    assert(type_ == Type::responseMetadata);
    return value_.responseMetadata;
  }

  ::apache::thrift::PayloadExceptionMetadataBase & mutable_exceptionMetadata() {
    assert(type_ == Type::exceptionMetadata);
    return value_.exceptionMetadata;
  }

  ::apache::thrift::PayloadResponseMetadata move_responseMetadata() {
    assert(type_ == Type::responseMetadata);
    return std::move(value_.responseMetadata);
  }

  ::apache::thrift::PayloadExceptionMetadataBase move_exceptionMetadata() {
    assert(type_ == Type::exceptionMetadata);
    return std::move(value_.exceptionMetadata);
  }

  template <typename..., typename T = ::apache::thrift::PayloadResponseMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> responseMetadata_ref() const& {
    return {value_.responseMetadata, type_, responseMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadResponseMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> responseMetadata_ref() const&& {
    return {std::move(value_.responseMetadata), type_, responseMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadResponseMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> responseMetadata_ref() & {
    return {value_.responseMetadata, type_, responseMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadResponseMetadata>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> responseMetadata_ref() && {
    return {std::move(value_.responseMetadata), type_, responseMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadataBase>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> exceptionMetadata_ref() const& {
    return {value_.exceptionMetadata, type_, exceptionMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadataBase>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> exceptionMetadata_ref() const&& {
    return {std::move(value_.exceptionMetadata), type_, exceptionMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadataBase>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> exceptionMetadata_ref() & {
    return {value_.exceptionMetadata, type_, exceptionMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::PayloadExceptionMetadataBase>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> exceptionMetadata_ref() && {
    return {std::move(value_.exceptionMetadata), type_, exceptionMetadata, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< PayloadMetadata >;
  friend void swap(PayloadMetadata& a, PayloadMetadata& b);
};

template <class Protocol_>
uint32_t PayloadMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ProxiedPayloadMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ProxiedPayloadMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ProxiedPayloadMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ProxiedPayloadMetadata(apache::thrift::FragileConstructor);

  ProxiedPayloadMetadata(ProxiedPayloadMetadata&&) = default;

  ProxiedPayloadMetadata(const ProxiedPayloadMetadata&) = default;


  ProxiedPayloadMetadata& operator=(ProxiedPayloadMetadata&&) = default;

  ProxiedPayloadMetadata& operator=(const ProxiedPayloadMetadata&) = default;
  void __clear();
  bool operator==(const ProxiedPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ProxiedPayloadMetadata& __x, const ProxiedPayloadMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ProxiedPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const ProxiedPayloadMetadata& __x, const ProxiedPayloadMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ProxiedPayloadMetadata& __x, const ProxiedPayloadMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ProxiedPayloadMetadata& __x, const ProxiedPayloadMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ProxiedPayloadMetadata >;
  friend void swap(ProxiedPayloadMetadata& a, ProxiedPayloadMetadata& b);
};

template <class Protocol_>
uint32_t ProxiedPayloadMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ResponseRpcMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ResponseRpcMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ResponseRpcMetadata();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ResponseRpcMetadata(apache::thrift::FragileConstructor, ::apache::thrift::ProtocolId protocol__arg, ::std::int32_t seqId__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg, ::std::int64_t load__arg, std::uint32_t crc32c__arg, ::apache::thrift::CompressionAlgorithm compression__arg, ::apache::thrift::PayloadMetadata payloadMetadata__arg, ::apache::thrift::ProxiedPayloadMetadata proxiedPayloadMetadata__arg);

  ResponseRpcMetadata(ResponseRpcMetadata&&) = default;

  ResponseRpcMetadata(const ResponseRpcMetadata&) = default;


  ResponseRpcMetadata& operator=(ResponseRpcMetadata&&) = default;

  ResponseRpcMetadata& operator=(const ResponseRpcMetadata&) = default;
  void __clear();

  ~ResponseRpcMetadata();

 private:
  ::apache::thrift::ProtocolId protocol;
 private:
  ::std::int32_t seqId;
 private:
  ::std::map<::std::string, ::std::string> otherMetadata;
 private:
  ::std::int64_t load;
 private:
  std::uint32_t crc32c;
 private:
  ::apache::thrift::CompressionAlgorithm compression;
 private:
  ::apache::thrift::PayloadMetadata payloadMetadata;
 private:
  ::apache::thrift::ProxiedPayloadMetadata proxiedPayloadMetadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool protocol;
    bool seqId;
    bool otherMetadata;
    bool load;
    bool crc32c;
    bool compression;
    bool payloadMetadata;
    bool proxiedPayloadMetadata;
  } __isset = {};
  bool operator==(const ResponseRpcMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ResponseRpcMetadata& __x, const ResponseRpcMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ResponseRpcMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const ResponseRpcMetadata& __x, const ResponseRpcMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ResponseRpcMetadata& __x, const ResponseRpcMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ResponseRpcMetadata& __x, const ResponseRpcMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> protocol_ref() const& {
    return {this->protocol, __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> protocol_ref() const&& {
    return {std::move(this->protocol), __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> protocol_ref() & {
    return {this->protocol, __isset.protocol};
  }

  template <typename..., typename T = ::apache::thrift::ProtocolId>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> protocol_ref() && {
    return {std::move(this->protocol), __isset.protocol};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> seqId_ref() const& {
    return {this->seqId, __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> seqId_ref() const&& {
    return {std::move(this->seqId), __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> seqId_ref() & {
    return {this->seqId, __isset.seqId};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> seqId_ref() && {
    return {std::move(this->seqId), __isset.seqId};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> otherMetadata_ref() const& {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> otherMetadata_ref() const&& {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> otherMetadata_ref() & {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> otherMetadata_ref() && {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> load_ref() const& {
    return {this->load, __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> load_ref() const&& {
    return {std::move(this->load), __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> load_ref() & {
    return {this->load, __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> load_ref() && {
    return {std::move(this->load), __isset.load};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> crc32c_ref() const& {
    return {this->crc32c, __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> crc32c_ref() const&& {
    return {std::move(this->crc32c), __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> crc32c_ref() & {
    return {this->crc32c, __isset.crc32c};
  }

  template <typename..., typename T = std::uint32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> crc32c_ref() && {
    return {std::move(this->crc32c), __isset.crc32c};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compression_ref() const& {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compression_ref() const&& {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compression_ref() & {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compression_ref() && {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::PayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> payloadMetadata_ref() const& {
    return {this->payloadMetadata, __isset.payloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> payloadMetadata_ref() const&& {
    return {std::move(this->payloadMetadata), __isset.payloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> payloadMetadata_ref() & {
    return {this->payloadMetadata, __isset.payloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::PayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> payloadMetadata_ref() && {
    return {std::move(this->payloadMetadata), __isset.payloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ProxiedPayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> proxiedPayloadMetadata_ref() const& {
    return {this->proxiedPayloadMetadata, __isset.proxiedPayloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ProxiedPayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> proxiedPayloadMetadata_ref() const&& {
    return {std::move(this->proxiedPayloadMetadata), __isset.proxiedPayloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ProxiedPayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> proxiedPayloadMetadata_ref() & {
    return {this->proxiedPayloadMetadata, __isset.proxiedPayloadMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ProxiedPayloadMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> proxiedPayloadMetadata_ref() && {
    return {std::move(this->proxiedPayloadMetadata), __isset.proxiedPayloadMetadata};
  }

  const ::apache::thrift::ProtocolId* get_protocol() const& {
    return protocol_ref() ? std::addressof(protocol) : nullptr;
  }

  ::apache::thrift::ProtocolId* get_protocol() & {
    return protocol_ref() ? std::addressof(protocol) : nullptr;
  }
  ::apache::thrift::ProtocolId* get_protocol() && = delete;

  ::apache::thrift::ProtocolId& set_protocol(::apache::thrift::ProtocolId protocol_) {
    protocol = protocol_;
    __isset.protocol = true;
    return protocol;
  }

  const ::std::int32_t* get_seqId() const& {
    return seqId_ref() ? std::addressof(seqId) : nullptr;
  }

  ::std::int32_t* get_seqId() & {
    return seqId_ref() ? std::addressof(seqId) : nullptr;
  }
  ::std::int32_t* get_seqId() && = delete;

  ::std::int32_t& set_seqId(::std::int32_t seqId_) {
    seqId = seqId_;
    __isset.seqId = true;
    return seqId;
  }
  const ::std::map<::std::string, ::std::string>* get_otherMetadata() const&;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() &;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() && = delete;

  template <typename T_ResponseRpcMetadata_otherMetadata_struct_setter = ::std::map<::std::string, ::std::string>>
  ::std::map<::std::string, ::std::string>& set_otherMetadata(T_ResponseRpcMetadata_otherMetadata_struct_setter&& otherMetadata_) {
    otherMetadata = std::forward<T_ResponseRpcMetadata_otherMetadata_struct_setter>(otherMetadata_);
    __isset.otherMetadata = true;
    return otherMetadata;
  }

  const ::std::int64_t* get_load() const& {
    return load_ref() ? std::addressof(load) : nullptr;
  }

  ::std::int64_t* get_load() & {
    return load_ref() ? std::addressof(load) : nullptr;
  }
  ::std::int64_t* get_load() && = delete;

  ::std::int64_t& set_load(::std::int64_t load_) {
    load = load_;
    __isset.load = true;
    return load;
  }

  const std::uint32_t* get_crc32c() const& {
    return crc32c_ref() ? std::addressof(crc32c) : nullptr;
  }

  std::uint32_t* get_crc32c() & {
    return crc32c_ref() ? std::addressof(crc32c) : nullptr;
  }
  std::uint32_t* get_crc32c() && = delete;

  std::uint32_t& set_crc32c(std::uint32_t crc32c_) {
    crc32c = crc32c_;
    __isset.crc32c = true;
    return crc32c;
  }

  const ::apache::thrift::CompressionAlgorithm* get_compression() const& {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }

  ::apache::thrift::CompressionAlgorithm* get_compression() & {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }
  ::apache::thrift::CompressionAlgorithm* get_compression() && = delete;

  ::apache::thrift::CompressionAlgorithm& set_compression(::apache::thrift::CompressionAlgorithm compression_) {
    compression = compression_;
    __isset.compression = true;
    return compression;
  }
  const ::apache::thrift::PayloadMetadata* get_payloadMetadata() const&;
  ::apache::thrift::PayloadMetadata* get_payloadMetadata() &;
  ::apache::thrift::PayloadMetadata* get_payloadMetadata() && = delete;

  template <typename T_ResponseRpcMetadata_payloadMetadata_struct_setter = ::apache::thrift::PayloadMetadata>
  ::apache::thrift::PayloadMetadata& set_payloadMetadata(T_ResponseRpcMetadata_payloadMetadata_struct_setter&& payloadMetadata_) {
    payloadMetadata = std::forward<T_ResponseRpcMetadata_payloadMetadata_struct_setter>(payloadMetadata_);
    __isset.payloadMetadata = true;
    return payloadMetadata;
  }
  const ::apache::thrift::ProxiedPayloadMetadata* get_proxiedPayloadMetadata() const&;
  ::apache::thrift::ProxiedPayloadMetadata* get_proxiedPayloadMetadata() &;
  ::apache::thrift::ProxiedPayloadMetadata* get_proxiedPayloadMetadata() && = delete;

  template <typename T_ResponseRpcMetadata_proxiedPayloadMetadata_struct_setter = ::apache::thrift::ProxiedPayloadMetadata>
  ::apache::thrift::ProxiedPayloadMetadata& set_proxiedPayloadMetadata(T_ResponseRpcMetadata_proxiedPayloadMetadata_struct_setter&& proxiedPayloadMetadata_) {
    proxiedPayloadMetadata = std::forward<T_ResponseRpcMetadata_proxiedPayloadMetadata_struct_setter>(proxiedPayloadMetadata_);
    __isset.proxiedPayloadMetadata = true;
    return proxiedPayloadMetadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ResponseRpcMetadata >;
  friend void swap(ResponseRpcMetadata& a, ResponseRpcMetadata& b);
};

template <class Protocol_>
uint32_t ResponseRpcMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ResponseRpcError final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ResponseRpcError;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ResponseRpcError();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ResponseRpcError(apache::thrift::FragileConstructor, ::std::string name_utf8__arg, ::std::string what_utf8__arg, ::apache::thrift::ResponseRpcErrorCategory category__arg, ::apache::thrift::ResponseRpcErrorCode code__arg, ::std::int64_t load__arg);

  ResponseRpcError(ResponseRpcError&&) = default;

  ResponseRpcError(const ResponseRpcError&) = default;


  ResponseRpcError& operator=(ResponseRpcError&&) = default;

  ResponseRpcError& operator=(const ResponseRpcError&) = default;
  void __clear();

  ~ResponseRpcError();

 private:
  ::std::string name_utf8;
 private:
  ::std::string what_utf8;
 private:
  ::apache::thrift::ResponseRpcErrorCategory category;
 private:
  ::apache::thrift::ResponseRpcErrorCode code;
 private:
  ::std::int64_t load;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool name_utf8;
    bool what_utf8;
    bool category;
    bool code;
    bool load;
  } __isset = {};
  bool operator==(const ResponseRpcError& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ResponseRpcError& __x, const ResponseRpcError& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ResponseRpcError& rhs) const;
#ifndef SWIG
  friend bool operator>(const ResponseRpcError& __x, const ResponseRpcError& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ResponseRpcError& __x, const ResponseRpcError& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ResponseRpcError& __x, const ResponseRpcError& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> name_utf8_ref() const& {
    return {this->name_utf8, __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> name_utf8_ref() const&& {
    return {std::move(this->name_utf8), __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> name_utf8_ref() & {
    return {this->name_utf8, __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> name_utf8_ref() && {
    return {std::move(this->name_utf8), __isset.name_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> what_utf8_ref() const& {
    return {this->what_utf8, __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> what_utf8_ref() const&& {
    return {std::move(this->what_utf8), __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> what_utf8_ref() & {
    return {this->what_utf8, __isset.what_utf8};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> what_utf8_ref() && {
    return {std::move(this->what_utf8), __isset.what_utf8};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCategory>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> category_ref() const& {
    return {this->category, __isset.category};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCategory>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> category_ref() const&& {
    return {std::move(this->category), __isset.category};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCategory>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> category_ref() & {
    return {this->category, __isset.category};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCategory>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> category_ref() && {
    return {std::move(this->category), __isset.category};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCode>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> code_ref() const& {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCode>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> code_ref() const&& {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCode>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> code_ref() & {
    return {this->code, __isset.code};
  }

  template <typename..., typename T = ::apache::thrift::ResponseRpcErrorCode>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> code_ref() && {
    return {std::move(this->code), __isset.code};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> load_ref() const& {
    return {this->load, __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> load_ref() const&& {
    return {std::move(this->load), __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> load_ref() & {
    return {this->load, __isset.load};
  }

  template <typename..., typename T = ::std::int64_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> load_ref() && {
    return {std::move(this->load), __isset.load};
  }

  const ::std::string* get_name_utf8() const& {
    return name_utf8_ref() ? std::addressof(name_utf8) : nullptr;
  }

  ::std::string* get_name_utf8() & {
    return name_utf8_ref() ? std::addressof(name_utf8) : nullptr;
  }
  ::std::string* get_name_utf8() && = delete;

  template <typename T_ResponseRpcError_name_utf8_struct_setter = ::std::string>
  ::std::string& set_name_utf8(T_ResponseRpcError_name_utf8_struct_setter&& name_utf8_) {
    name_utf8 = std::forward<T_ResponseRpcError_name_utf8_struct_setter>(name_utf8_);
    __isset.name_utf8 = true;
    return name_utf8;
  }

  const ::std::string* get_what_utf8() const& {
    return what_utf8_ref() ? std::addressof(what_utf8) : nullptr;
  }

  ::std::string* get_what_utf8() & {
    return what_utf8_ref() ? std::addressof(what_utf8) : nullptr;
  }
  ::std::string* get_what_utf8() && = delete;

  template <typename T_ResponseRpcError_what_utf8_struct_setter = ::std::string>
  ::std::string& set_what_utf8(T_ResponseRpcError_what_utf8_struct_setter&& what_utf8_) {
    what_utf8 = std::forward<T_ResponseRpcError_what_utf8_struct_setter>(what_utf8_);
    __isset.what_utf8 = true;
    return what_utf8;
  }

  const ::apache::thrift::ResponseRpcErrorCategory* get_category() const& {
    return category_ref() ? std::addressof(category) : nullptr;
  }

  ::apache::thrift::ResponseRpcErrorCategory* get_category() & {
    return category_ref() ? std::addressof(category) : nullptr;
  }
  ::apache::thrift::ResponseRpcErrorCategory* get_category() && = delete;

  ::apache::thrift::ResponseRpcErrorCategory& set_category(::apache::thrift::ResponseRpcErrorCategory category_) {
    category = category_;
    __isset.category = true;
    return category;
  }

  const ::apache::thrift::ResponseRpcErrorCode* get_code() const& {
    return code_ref() ? std::addressof(code) : nullptr;
  }

  ::apache::thrift::ResponseRpcErrorCode* get_code() & {
    return code_ref() ? std::addressof(code) : nullptr;
  }
  ::apache::thrift::ResponseRpcErrorCode* get_code() && = delete;

  ::apache::thrift::ResponseRpcErrorCode& set_code(::apache::thrift::ResponseRpcErrorCode code_) {
    code = code_;
    __isset.code = true;
    return code;
  }

  const ::std::int64_t* get_load() const& {
    return load_ref() ? std::addressof(load) : nullptr;
  }

  ::std::int64_t* get_load() & {
    return load_ref() ? std::addressof(load) : nullptr;
  }
  ::std::int64_t* get_load() && = delete;

  ::std::int64_t& set_load(::std::int64_t load_) {
    load = load_;
    __isset.load = true;
    return load;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ResponseRpcError >;
  friend void swap(ResponseRpcError& a, ResponseRpcError& b);
};

template <class Protocol_>
uint32_t ResponseRpcError::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class StreamPayloadMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = StreamPayloadMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  StreamPayloadMetadata() :
      compression( ::apache::thrift::CompressionAlgorithm::NONE) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  StreamPayloadMetadata(apache::thrift::FragileConstructor, ::apache::thrift::CompressionAlgorithm compression__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg);

  StreamPayloadMetadata(StreamPayloadMetadata&&) = default;

  StreamPayloadMetadata(const StreamPayloadMetadata&) = default;


  StreamPayloadMetadata& operator=(StreamPayloadMetadata&&) = default;

  StreamPayloadMetadata& operator=(const StreamPayloadMetadata&) = default;
  void __clear();
 private:
  ::apache::thrift::CompressionAlgorithm compression;
 private:
  ::std::map<::std::string, ::std::string> otherMetadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool compression;
    bool otherMetadata;
  } __isset = {};
  bool operator==(const StreamPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const StreamPayloadMetadata& __x, const StreamPayloadMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const StreamPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const StreamPayloadMetadata& __x, const StreamPayloadMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const StreamPayloadMetadata& __x, const StreamPayloadMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const StreamPayloadMetadata& __x, const StreamPayloadMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compression_ref() const& {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compression_ref() const&& {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compression_ref() & {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compression_ref() && {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> otherMetadata_ref() const& {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> otherMetadata_ref() const&& {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> otherMetadata_ref() & {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> otherMetadata_ref() && {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  const ::apache::thrift::CompressionAlgorithm* get_compression() const& {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }

  ::apache::thrift::CompressionAlgorithm* get_compression() & {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }
  ::apache::thrift::CompressionAlgorithm* get_compression() && = delete;

  ::apache::thrift::CompressionAlgorithm& set_compression(::apache::thrift::CompressionAlgorithm compression_) {
    compression = compression_;
    __isset.compression = true;
    return compression;
  }
  const ::std::map<::std::string, ::std::string>* get_otherMetadata() const&;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() &;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() && = delete;

  template <typename T_StreamPayloadMetadata_otherMetadata_struct_setter = ::std::map<::std::string, ::std::string>>
  ::std::map<::std::string, ::std::string>& set_otherMetadata(T_StreamPayloadMetadata_otherMetadata_struct_setter&& otherMetadata_) {
    otherMetadata = std::forward<T_StreamPayloadMetadata_otherMetadata_struct_setter>(otherMetadata_);
    __isset.otherMetadata = true;
    return otherMetadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< StreamPayloadMetadata >;
  friend void swap(StreamPayloadMetadata& a, StreamPayloadMetadata& b);
};

template <class Protocol_>
uint32_t StreamPayloadMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ClientMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ClientMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  ClientMetadata() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  ClientMetadata(apache::thrift::FragileConstructor, ::std::string agent__arg, ::std::string hostname__arg, ::std::map<::std::string, ::std::string> otherMetadata__arg);

  ClientMetadata(ClientMetadata&&) = default;

  ClientMetadata(const ClientMetadata&) = default;


  ClientMetadata& operator=(ClientMetadata&&) = default;

  ClientMetadata& operator=(const ClientMetadata&) = default;
  void __clear();
 private:
  ::std::string agent;
 private:
  ::std::string hostname;
 private:
  ::std::map<::std::string, ::std::string> otherMetadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool agent;
    bool hostname;
    bool otherMetadata;
  } __isset = {};
  bool operator==(const ClientMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ClientMetadata& __x, const ClientMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ClientMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const ClientMetadata& __x, const ClientMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ClientMetadata& __x, const ClientMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ClientMetadata& __x, const ClientMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> agent_ref() const& {
    return {this->agent, __isset.agent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> agent_ref() const&& {
    return {std::move(this->agent), __isset.agent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> agent_ref() & {
    return {this->agent, __isset.agent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> agent_ref() && {
    return {std::move(this->agent), __isset.agent};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> hostname_ref() const& {
    return {this->hostname, __isset.hostname};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> hostname_ref() const&& {
    return {std::move(this->hostname), __isset.hostname};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> hostname_ref() & {
    return {this->hostname, __isset.hostname};
  }

  template <typename..., typename T = ::std::string>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> hostname_ref() && {
    return {std::move(this->hostname), __isset.hostname};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> otherMetadata_ref() const& {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> otherMetadata_ref() const&& {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> otherMetadata_ref() & {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> otherMetadata_ref() && {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  const ::std::string* get_agent() const& {
    return agent_ref() ? std::addressof(agent) : nullptr;
  }

  ::std::string* get_agent() & {
    return agent_ref() ? std::addressof(agent) : nullptr;
  }
  ::std::string* get_agent() && = delete;

  template <typename T_ClientMetadata_agent_struct_setter = ::std::string>
  ::std::string& set_agent(T_ClientMetadata_agent_struct_setter&& agent_) {
    agent = std::forward<T_ClientMetadata_agent_struct_setter>(agent_);
    __isset.agent = true;
    return agent;
  }

  const ::std::string* get_hostname() const& {
    return hostname_ref() ? std::addressof(hostname) : nullptr;
  }

  ::std::string* get_hostname() & {
    return hostname_ref() ? std::addressof(hostname) : nullptr;
  }
  ::std::string* get_hostname() && = delete;

  template <typename T_ClientMetadata_hostname_struct_setter = ::std::string>
  ::std::string& set_hostname(T_ClientMetadata_hostname_struct_setter&& hostname_) {
    hostname = std::forward<T_ClientMetadata_hostname_struct_setter>(hostname_);
    __isset.hostname = true;
    return hostname;
  }
  const ::std::map<::std::string, ::std::string>* get_otherMetadata() const&;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() &;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() && = delete;

  template <typename T_ClientMetadata_otherMetadata_struct_setter = ::std::map<::std::string, ::std::string>>
  ::std::map<::std::string, ::std::string>& set_otherMetadata(T_ClientMetadata_otherMetadata_struct_setter&& otherMetadata_) {
    otherMetadata = std::forward<T_ClientMetadata_otherMetadata_struct_setter>(otherMetadata_);
    __isset.otherMetadata = true;
    return otherMetadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ClientMetadata >;
  friend void swap(ClientMetadata& a, ClientMetadata& b);
};

template <class Protocol_>
uint32_t ClientMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class RequestSetupMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = RequestSetupMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  RequestSetupMetadata();

  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  RequestSetupMetadata(apache::thrift::FragileConstructor, apache::thrift::MetadataOpaqueMap<::std::string, ::std::string> opaque__arg, ::apache::thrift::InterfaceKind interfaceKind__arg, ::std::int32_t minVersion__arg, ::std::int32_t maxVersion__arg, ::std::int32_t dscpToReflect__arg, ::std::int32_t markToReflect__arg, ::apache::thrift::ClientMetadata clientMetadata__arg);

  RequestSetupMetadata(RequestSetupMetadata&&) = default;

  RequestSetupMetadata(const RequestSetupMetadata&) = default;


  RequestSetupMetadata& operator=(RequestSetupMetadata&&) = default;

  RequestSetupMetadata& operator=(const RequestSetupMetadata&) = default;
  void __clear();

  ~RequestSetupMetadata();

 private:
  apache::thrift::MetadataOpaqueMap<::std::string, ::std::string> opaque;
 private:
  ::apache::thrift::InterfaceKind interfaceKind;
 private:
  ::std::int32_t minVersion;
 private:
  ::std::int32_t maxVersion;
 private:
  ::std::int32_t dscpToReflect;
 private:
  ::std::int32_t markToReflect;
 private:
  ::apache::thrift::ClientMetadata clientMetadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool opaque;
    bool interfaceKind;
    bool minVersion;
    bool maxVersion;
    bool dscpToReflect;
    bool markToReflect;
    bool clientMetadata;
  } __isset = {};
  bool operator==(const RequestSetupMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const RequestSetupMetadata& __x, const RequestSetupMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const RequestSetupMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const RequestSetupMetadata& __x, const RequestSetupMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const RequestSetupMetadata& __x, const RequestSetupMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const RequestSetupMetadata& __x, const RequestSetupMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> opaque_ref() const& {
    return {this->opaque, __isset.opaque};
  }

  template <typename..., typename T = apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> opaque_ref() const&& {
    return {std::move(this->opaque), __isset.opaque};
  }

  template <typename..., typename T = apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> opaque_ref() & {
    return {this->opaque, __isset.opaque};
  }

  template <typename..., typename T = apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> opaque_ref() && {
    return {std::move(this->opaque), __isset.opaque};
  }

  template <typename..., typename T = ::apache::thrift::InterfaceKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> interfaceKind_ref() const& {
    return {this->interfaceKind, __isset.interfaceKind};
  }

  template <typename..., typename T = ::apache::thrift::InterfaceKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> interfaceKind_ref() const&& {
    return {std::move(this->interfaceKind), __isset.interfaceKind};
  }

  template <typename..., typename T = ::apache::thrift::InterfaceKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> interfaceKind_ref() & {
    return {this->interfaceKind, __isset.interfaceKind};
  }

  template <typename..., typename T = ::apache::thrift::InterfaceKind>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> interfaceKind_ref() && {
    return {std::move(this->interfaceKind), __isset.interfaceKind};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> minVersion_ref() const& {
    return {this->minVersion, __isset.minVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> minVersion_ref() const&& {
    return {std::move(this->minVersion), __isset.minVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> minVersion_ref() & {
    return {this->minVersion, __isset.minVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> minVersion_ref() && {
    return {std::move(this->minVersion), __isset.minVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> maxVersion_ref() const& {
    return {this->maxVersion, __isset.maxVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> maxVersion_ref() const&& {
    return {std::move(this->maxVersion), __isset.maxVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> maxVersion_ref() & {
    return {this->maxVersion, __isset.maxVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> maxVersion_ref() && {
    return {std::move(this->maxVersion), __isset.maxVersion};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> dscpToReflect_ref() const& {
    return {this->dscpToReflect, __isset.dscpToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> dscpToReflect_ref() const&& {
    return {std::move(this->dscpToReflect), __isset.dscpToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> dscpToReflect_ref() & {
    return {this->dscpToReflect, __isset.dscpToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> dscpToReflect_ref() && {
    return {std::move(this->dscpToReflect), __isset.dscpToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> markToReflect_ref() const& {
    return {this->markToReflect, __isset.markToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> markToReflect_ref() const&& {
    return {std::move(this->markToReflect), __isset.markToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> markToReflect_ref() & {
    return {this->markToReflect, __isset.markToReflect};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> markToReflect_ref() && {
    return {std::move(this->markToReflect), __isset.markToReflect};
  }

  template <typename..., typename T = ::apache::thrift::ClientMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> clientMetadata_ref() const& {
    return {this->clientMetadata, __isset.clientMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ClientMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> clientMetadata_ref() const&& {
    return {std::move(this->clientMetadata), __isset.clientMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ClientMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> clientMetadata_ref() & {
    return {this->clientMetadata, __isset.clientMetadata};
  }

  template <typename..., typename T = ::apache::thrift::ClientMetadata>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> clientMetadata_ref() && {
    return {std::move(this->clientMetadata), __isset.clientMetadata};
  }
  const apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* get_opaque() const&;
  apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* get_opaque() &;
  apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>* get_opaque() && = delete;

  template <typename T_RequestSetupMetadata_opaque_struct_setter = apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>>
  apache::thrift::MetadataOpaqueMap<::std::string, ::std::string>& set_opaque(T_RequestSetupMetadata_opaque_struct_setter&& opaque_) {
    opaque = std::forward<T_RequestSetupMetadata_opaque_struct_setter>(opaque_);
    __isset.opaque = true;
    return opaque;
  }

  const ::apache::thrift::InterfaceKind* get_interfaceKind() const& {
    return interfaceKind_ref() ? std::addressof(interfaceKind) : nullptr;
  }

  ::apache::thrift::InterfaceKind* get_interfaceKind() & {
    return interfaceKind_ref() ? std::addressof(interfaceKind) : nullptr;
  }
  ::apache::thrift::InterfaceKind* get_interfaceKind() && = delete;

  ::apache::thrift::InterfaceKind& set_interfaceKind(::apache::thrift::InterfaceKind interfaceKind_) {
    interfaceKind = interfaceKind_;
    __isset.interfaceKind = true;
    return interfaceKind;
  }

  const ::std::int32_t* get_minVersion() const& {
    return minVersion_ref() ? std::addressof(minVersion) : nullptr;
  }

  ::std::int32_t* get_minVersion() & {
    return minVersion_ref() ? std::addressof(minVersion) : nullptr;
  }
  ::std::int32_t* get_minVersion() && = delete;

  ::std::int32_t& set_minVersion(::std::int32_t minVersion_) {
    minVersion = minVersion_;
    __isset.minVersion = true;
    return minVersion;
  }

  const ::std::int32_t* get_maxVersion() const& {
    return maxVersion_ref() ? std::addressof(maxVersion) : nullptr;
  }

  ::std::int32_t* get_maxVersion() & {
    return maxVersion_ref() ? std::addressof(maxVersion) : nullptr;
  }
  ::std::int32_t* get_maxVersion() && = delete;

  ::std::int32_t& set_maxVersion(::std::int32_t maxVersion_) {
    maxVersion = maxVersion_;
    __isset.maxVersion = true;
    return maxVersion;
  }

  const ::std::int32_t* get_dscpToReflect() const& {
    return dscpToReflect_ref() ? std::addressof(dscpToReflect) : nullptr;
  }

  ::std::int32_t* get_dscpToReflect() & {
    return dscpToReflect_ref() ? std::addressof(dscpToReflect) : nullptr;
  }
  ::std::int32_t* get_dscpToReflect() && = delete;

  ::std::int32_t& set_dscpToReflect(::std::int32_t dscpToReflect_) {
    dscpToReflect = dscpToReflect_;
    __isset.dscpToReflect = true;
    return dscpToReflect;
  }

  const ::std::int32_t* get_markToReflect() const& {
    return markToReflect_ref() ? std::addressof(markToReflect) : nullptr;
  }

  ::std::int32_t* get_markToReflect() & {
    return markToReflect_ref() ? std::addressof(markToReflect) : nullptr;
  }
  ::std::int32_t* get_markToReflect() && = delete;

  ::std::int32_t& set_markToReflect(::std::int32_t markToReflect_) {
    markToReflect = markToReflect_;
    __isset.markToReflect = true;
    return markToReflect;
  }
  const ::apache::thrift::ClientMetadata* get_clientMetadata() const&;
  ::apache::thrift::ClientMetadata* get_clientMetadata() &;
  ::apache::thrift::ClientMetadata* get_clientMetadata() && = delete;

  template <typename T_RequestSetupMetadata_clientMetadata_struct_setter = ::apache::thrift::ClientMetadata>
  ::apache::thrift::ClientMetadata& set_clientMetadata(T_RequestSetupMetadata_clientMetadata_struct_setter&& clientMetadata_) {
    clientMetadata = std::forward<T_RequestSetupMetadata_clientMetadata_struct_setter>(clientMetadata_);
    __isset.clientMetadata = true;
    return clientMetadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< RequestSetupMetadata >;
  friend void swap(RequestSetupMetadata& a, RequestSetupMetadata& b);
};

template <class Protocol_>
uint32_t RequestSetupMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class SetupResponse final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = SetupResponse;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  SetupResponse() :
      version(0) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  SetupResponse(apache::thrift::FragileConstructor, ::std::int32_t version__arg);

  SetupResponse(SetupResponse&&) = default;

  SetupResponse(const SetupResponse&) = default;


  SetupResponse& operator=(SetupResponse&&) = default;

  SetupResponse& operator=(const SetupResponse&) = default;
  void __clear();
 private:
  ::std::int32_t version;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool version;
  } __isset = {};
  bool operator==(const SetupResponse& rhs) const;
#ifndef SWIG
  friend bool operator!=(const SetupResponse& __x, const SetupResponse& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const SetupResponse& rhs) const;
#ifndef SWIG
  friend bool operator>(const SetupResponse& __x, const SetupResponse& __y) {
    return __y < __x;
  }
  friend bool operator<=(const SetupResponse& __x, const SetupResponse& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const SetupResponse& __x, const SetupResponse& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> version_ref() const& {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> version_ref() const&& {
    return {std::move(this->version), __isset.version};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> version_ref() & {
    return {this->version, __isset.version};
  }

  template <typename..., typename T = ::std::int32_t>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> version_ref() && {
    return {std::move(this->version), __isset.version};
  }

  const ::std::int32_t* get_version() const& {
    return version_ref() ? std::addressof(version) : nullptr;
  }

  ::std::int32_t* get_version() & {
    return version_ref() ? std::addressof(version) : nullptr;
  }
  ::std::int32_t* get_version() && = delete;

  ::std::int32_t& set_version(::std::int32_t version_) {
    version = version_;
    __isset.version = true;
    return version;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< SetupResponse >;
  friend void swap(SetupResponse& a, SetupResponse& b);
};

template <class Protocol_>
uint32_t SetupResponse::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class ServerPushMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = ServerPushMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    true;


 public:
  enum Type : int {
    __EMPTY__ = 0,
    setupResponse = 1,
  } ;

  ServerPushMetadata()
      : type_(Type::__EMPTY__) {}

  ServerPushMetadata(ServerPushMetadata&& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::setupResponse:
      {
        set_setupResponse(std::move(rhs.value_.setupResponse));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
  }

  ServerPushMetadata(const ServerPushMetadata& rhs)
      : type_(Type::__EMPTY__) {
    if (this == &rhs) { return; }
    if (rhs.type_ == Type::__EMPTY__) { return; }
    switch (rhs.type_) {
      case Type::setupResponse:
      {
        set_setupResponse(rhs.value_.setupResponse);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
  }

  ServerPushMetadata& operator=(ServerPushMetadata&& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::setupResponse:
      {
        set_setupResponse(std::move(rhs.value_.setupResponse));
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    rhs.__clear();
    return *this;
  }

  ServerPushMetadata& operator=(const ServerPushMetadata& rhs) {
    if (this == &rhs) { return *this; }
    __clear();
    if (rhs.type_ == Type::__EMPTY__) { return *this; }
    switch (rhs.type_) {
      case Type::setupResponse:
      {
        set_setupResponse(rhs.value_.setupResponse);
        break;
      }
      default:
      {
        assert(false);
        break;
      }
    }
    return *this;
  }
  void __clear();

  ~ServerPushMetadata() {
    __clear();
  }
  union storage_type {
    ::apache::thrift::SetupResponse setupResponse;

    storage_type() {}
    ~storage_type() {}
  } ;
  bool operator==(const ServerPushMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const ServerPushMetadata& __x, const ServerPushMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const ServerPushMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const ServerPushMetadata& __x, const ServerPushMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const ServerPushMetadata& __x, const ServerPushMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const ServerPushMetadata& __x, const ServerPushMetadata& __y) {
    return !(__x < __y);
  }
#endif

  ::apache::thrift::SetupResponse& set_setupResponse(::apache::thrift::SetupResponse const &t) {
    __clear();
    type_ = Type::setupResponse;
    ::new (std::addressof(value_.setupResponse)) ::apache::thrift::SetupResponse(t);
    return value_.setupResponse;
  }

  ::apache::thrift::SetupResponse& set_setupResponse(::apache::thrift::SetupResponse&& t) {
    __clear();
    type_ = Type::setupResponse;
    ::new (std::addressof(value_.setupResponse)) ::apache::thrift::SetupResponse(std::move(t));
    return value_.setupResponse;
  }

  template<typename... T, typename = ::apache::thrift::safe_overload_t<::apache::thrift::SetupResponse, T...>> ::apache::thrift::SetupResponse& set_setupResponse(T&&... t) {
    __clear();
    type_ = Type::setupResponse;
    ::new (std::addressof(value_.setupResponse)) ::apache::thrift::SetupResponse(std::forward<T>(t)...);
    return value_.setupResponse;
  }

  ::apache::thrift::SetupResponse const & get_setupResponse() const {
    assert(type_ == Type::setupResponse);
    return value_.setupResponse;
  }

  ::apache::thrift::SetupResponse & mutable_setupResponse() {
    assert(type_ == Type::setupResponse);
    return value_.setupResponse;
  }

  ::apache::thrift::SetupResponse move_setupResponse() {
    assert(type_ == Type::setupResponse);
    return std::move(value_.setupResponse);
  }

  template <typename..., typename T = ::apache::thrift::SetupResponse>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&> setupResponse_ref() const& {
    return {value_.setupResponse, type_, setupResponse, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::SetupResponse>
  FOLLY_ERASE ::apache::thrift::union_field_ref<const T&&> setupResponse_ref() const&& {
    return {std::move(value_.setupResponse), type_, setupResponse, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::SetupResponse>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&> setupResponse_ref() & {
    return {value_.setupResponse, type_, setupResponse, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }

  template <typename..., typename T = ::apache::thrift::SetupResponse>
  FOLLY_ERASE ::apache::thrift::union_field_ref<T&&> setupResponse_ref() && {
    return {std::move(value_.setupResponse), type_, setupResponse, this, ::apache::thrift::detail::union_field_ref_owner_vtable_for<decltype(*this)>};
  }
  Type getType() const { return static_cast<Type>(type_); }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;
 protected:
  template <class T>
  void destruct(T &val) {
    (&val)->~T();
  }

  storage_type value_;
  std::underlying_type_t<Type> type_;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< ServerPushMetadata >;
  friend void swap(ServerPushMetadata& a, ServerPushMetadata& b);
};

template <class Protocol_>
uint32_t ServerPushMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class HeadersPayloadContent final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HeadersPayloadContent;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  HeadersPayloadContent() {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HeadersPayloadContent(apache::thrift::FragileConstructor, ::std::map<::std::string, ::std::string> otherMetadata__arg);

  HeadersPayloadContent(HeadersPayloadContent&&) = default;

  HeadersPayloadContent(const HeadersPayloadContent&) = default;


  HeadersPayloadContent& operator=(HeadersPayloadContent&&) = default;

  HeadersPayloadContent& operator=(const HeadersPayloadContent&) = default;
  void __clear();
 private:
  ::std::map<::std::string, ::std::string> otherMetadata;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool otherMetadata;
  } __isset = {};
  bool operator==(const HeadersPayloadContent& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HeadersPayloadContent& __x, const HeadersPayloadContent& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HeadersPayloadContent& rhs) const;
#ifndef SWIG
  friend bool operator>(const HeadersPayloadContent& __x, const HeadersPayloadContent& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HeadersPayloadContent& __x, const HeadersPayloadContent& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HeadersPayloadContent& __x, const HeadersPayloadContent& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> otherMetadata_ref() const& {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> otherMetadata_ref() const&& {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> otherMetadata_ref() & {
    return {this->otherMetadata, __isset.otherMetadata};
  }

  template <typename..., typename T = ::std::map<::std::string, ::std::string>>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> otherMetadata_ref() && {
    return {std::move(this->otherMetadata), __isset.otherMetadata};
  }
  const ::std::map<::std::string, ::std::string>* get_otherMetadata() const&;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() &;
  ::std::map<::std::string, ::std::string>* get_otherMetadata() && = delete;

  template <typename T_HeadersPayloadContent_otherMetadata_struct_setter = ::std::map<::std::string, ::std::string>>
  ::std::map<::std::string, ::std::string>& set_otherMetadata(T_HeadersPayloadContent_otherMetadata_struct_setter&& otherMetadata_) {
    otherMetadata = std::forward<T_HeadersPayloadContent_otherMetadata_struct_setter>(otherMetadata_);
    __isset.otherMetadata = true;
    return otherMetadata;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HeadersPayloadContent >;
  friend void swap(HeadersPayloadContent& a, HeadersPayloadContent& b);
};

template <class Protocol_>
uint32_t HeadersPayloadContent::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
namespace apache { namespace thrift {
class HeadersPayloadMetadata final  {
 private:
  friend struct ::apache::thrift::detail::st::struct_private_access;

  //  used by a static_assert in the corresponding source
  static constexpr bool __fbthrift_cpp2_gen_json = true;
  static constexpr bool __fbthrift_cpp2_gen_nimble = false;
  static constexpr bool __fbthrift_cpp2_gen_has_thrift_uri = false;

 public:
  using __fbthrift_cpp2_type = HeadersPayloadMetadata;
  static constexpr bool __fbthrift_cpp2_is_union =
    false;


 public:

  HeadersPayloadMetadata() :
      compression( ::apache::thrift::CompressionAlgorithm::NONE) {}
  // FragileConstructor for use in initialization lists only.
  [[deprecated("This constructor is deprecated")]]
  HeadersPayloadMetadata(apache::thrift::FragileConstructor, ::apache::thrift::CompressionAlgorithm compression__arg);

  HeadersPayloadMetadata(HeadersPayloadMetadata&&) = default;

  HeadersPayloadMetadata(const HeadersPayloadMetadata&) = default;


  HeadersPayloadMetadata& operator=(HeadersPayloadMetadata&&) = default;

  HeadersPayloadMetadata& operator=(const HeadersPayloadMetadata&) = default;
  void __clear();
 private:
  ::apache::thrift::CompressionAlgorithm compression;

 public:
  [[deprecated("__isset field is deprecated in Thrift struct. Use _ref() accessors instead.")]]
  struct __isset {
    bool compression;
  } __isset = {};
  bool operator==(const HeadersPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator!=(const HeadersPayloadMetadata& __x, const HeadersPayloadMetadata& __y) {
    return !(__x == __y);
  }
#endif
  bool operator<(const HeadersPayloadMetadata& rhs) const;
#ifndef SWIG
  friend bool operator>(const HeadersPayloadMetadata& __x, const HeadersPayloadMetadata& __y) {
    return __y < __x;
  }
  friend bool operator<=(const HeadersPayloadMetadata& __x, const HeadersPayloadMetadata& __y) {
    return !(__y < __x);
  }
  friend bool operator>=(const HeadersPayloadMetadata& __x, const HeadersPayloadMetadata& __y) {
    return !(__x < __y);
  }
#endif

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&> compression_ref() const& {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<const T&&> compression_ref() const&& {
    return {std::move(this->compression), __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&> compression_ref() & {
    return {this->compression, __isset.compression};
  }

  template <typename..., typename T = ::apache::thrift::CompressionAlgorithm>
  FOLLY_ERASE ::apache::thrift::optional_field_ref<T&&> compression_ref() && {
    return {std::move(this->compression), __isset.compression};
  }

  const ::apache::thrift::CompressionAlgorithm* get_compression() const& {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }

  ::apache::thrift::CompressionAlgorithm* get_compression() & {
    return compression_ref() ? std::addressof(compression) : nullptr;
  }
  ::apache::thrift::CompressionAlgorithm* get_compression() && = delete;

  ::apache::thrift::CompressionAlgorithm& set_compression(::apache::thrift::CompressionAlgorithm compression_) {
    compression = compression_;
    __isset.compression = true;
    return compression;
  }

  template <class Protocol_>
  uint32_t read(Protocol_* iprot);
  template <class Protocol_>
  uint32_t serializedSize(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t serializedSizeZC(Protocol_ const* prot_) const;
  template <class Protocol_>
  uint32_t write(Protocol_* prot_) const;

 private:
  template <class Protocol_>
  void readNoXfer(Protocol_* iprot);

  friend class ::apache::thrift::Cpp2Ops< HeadersPayloadMetadata >;
  friend void swap(HeadersPayloadMetadata& a, HeadersPayloadMetadata& b);
};

template <class Protocol_>
uint32_t HeadersPayloadMetadata::read(Protocol_* iprot) {
  auto _xferStart = iprot->getCursorPosition();
  readNoXfer(iprot);
  return iprot->getCursorPosition() - _xferStart;
}

}} // apache::thrift
THRIFT_IGNORE_ISSET_USE_WARNING_END

namespace apache { namespace thrift {

template <> struct TEnumDataStorage<::apache::thrift::CodecConfig::Type>;

template <> struct TEnumTraits<::apache::thrift::CodecConfig::Type> {
  using type = ::apache::thrift::CodecConfig::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::apache::thrift::PayloadExceptionMetadata::Type>;

template <> struct TEnumTraits<::apache::thrift::PayloadExceptionMetadata::Type> {
  using type = ::apache::thrift::PayloadExceptionMetadata::Type;

  static constexpr std::size_t const size = 5;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::apache::thrift::PayloadMetadata::Type>;

template <> struct TEnumTraits<::apache::thrift::PayloadMetadata::Type> {
  using type = ::apache::thrift::PayloadMetadata::Type;

  static constexpr std::size_t const size = 2;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};

template <> struct TEnumDataStorage<::apache::thrift::ServerPushMetadata::Type>;

template <> struct TEnumTraits<::apache::thrift::ServerPushMetadata::Type> {
  using type = ::apache::thrift::ServerPushMetadata::Type;

  static constexpr std::size_t const size = 1;
  static folly::Range<type const*> const values;
  static folly::Range<folly::StringPiece const*> const names;

  static char const* findName(type value);
  static bool findValue(char const* name, type* out);

};
}} // apache::thrift
