#
# Autogenerated by Thrift for thrift/compiler/test/fixtures/types/src/module.thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import annotations

from collections.abc import Mapping, Sequence, Set
import enum
import importlib

import thrift.py3.types
import apache.thrift.fixtures.types.module.thrift_enums as _fbthrift_python_enums


import apache.thrift.fixtures.types.included.types_inplace_FBTHRIFT_ONLY_DO_NOT_USE as _apache_thrift_fixtures_types_included_types

def get_types_reflection():
    return importlib.import_module(
        "apache.thrift.fixtures.types.module.types_reflection"
    )

_fbthrift__module_name__ = "apache.thrift.fixtures.types.module.types"

__all__ = []

### Enums ###

class has_bitwise_ops(thrift.py3.types.CompiledEnum, int):
    none = 0
    zero = 1
    one = 2
    two = 4
    three = 8

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_has_bitwise_ops()

    @staticmethod
    def __get_thrift_name__():
        return "module.has_bitwise_ops"

    def _to_python(self):
        return _fbthrift_python_enums.has_bitwise_ops(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("has_bitwise_ops")


class is_unscoped(thrift.py3.types.CompiledEnum, int):
    hello = 0
    world = 1

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_is_unscoped()

    @staticmethod
    def __get_thrift_name__():
        return "module.is_unscoped"

    def _to_python(self):
        return _fbthrift_python_enums.is_unscoped(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("is_unscoped")


class MyForwardRefEnum(thrift.py3.types.CompiledEnum, int):
    ZERO = 0
    NONZERO = 12

    __module__ = _fbthrift__module_name__
    __slots__ = ()

    @staticmethod
    def __get_metadata__():
        return _fbthrift_python_enums.gen_metadata_enum_MyForwardRefEnum()

    @staticmethod
    def __get_thrift_name__():
        return "module.MyForwardRefEnum"

    def _to_python(self):
        return _fbthrift_python_enums.MyForwardRefEnum(self._fbthrift_value_)

    def _to_py3(self):
        return self

    def _to_py_deprecated(self):
        return self._fbthrift_value_


    def __int__(self):
        return self._fbthrift_value_

    def __index__(self):
        return self._fbthrift_value_
__all__.append("MyForwardRefEnum")


### Union Enums ###

### Containers ###
class std_unordered_map__Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map__Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map__Map__i32_string._check_key_type_or_raise
            check_val = std_unordered_map__Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> std_unordered_map__Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return std_unordered_map__Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(std_unordered_map__Map__i32_string)

__all__.append("std_unordered_map__Map__i32_string")

class List__i64(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i64):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i64._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i64)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i64()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i64:
        _items = list(python_list)
        return List__i64(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i64)


__all__.append("List__i64")

class Map__binary_i64(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__binary_i64):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__binary_i64._check_key_type_or_raise
            check_val = Map__binary_i64._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__binary_i64)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, bytes)
        ):
            raise TypeError(f"{key!r} is not of type bytes")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, bytes):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__binary_i64()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__binary_i64:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__binary_i64(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__binary_i64)

__all__.append("Map__binary_i64")

class List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__i32:
        _items = list(python_list)
        return List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__i32)


__all__.append("List__i32")

class std_list__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_list__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_list__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_list__List__i32:
        _items = list(python_list)
        return std_list__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_list__List__i32)


__all__.append("std_list__List__i32")

class std_deque__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_deque__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_deque__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_deque__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_deque__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_deque__List__i32:
        _items = list(python_list)
        return std_deque__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_deque__List__i32)


__all__.append("std_deque__List__i32")

class folly_fbvector__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_fbvector__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_fbvector__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_fbvector__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_fbvector__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_fbvector__List__i32:
        _items = list(python_list)
        return folly_fbvector__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_fbvector__List__i32)


__all__.append("folly_fbvector__List__i32")

class folly_small_vector__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_small_vector__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_small_vector__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_small_vector__List__i32:
        _items = list(python_list)
        return folly_small_vector__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_small_vector__List__i32)


__all__.append("folly_small_vector__List__i32")

class folly_sorted_vector_set__Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_sorted_vector_set__Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = folly_sorted_vector_set__Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, folly_sorted_vector_set__Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_sorted_vector_set__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> folly_sorted_vector_set__Set__i32:
        _items = frozenset(python_set)
        return folly_sorted_vector_set__Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(folly_sorted_vector_set__Set__i32)


__all__.append("folly_sorted_vector_set__Set__i32")

class Map__i32_string(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_string):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_string._check_key_type_or_raise
            check_val = Map__i32_string._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_string)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, str)
        ):
            raise TypeError(f"{item!r} is not of type str")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_string()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_string:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_string(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_string)

__all__.append("Map__i32_string")

class std_list_int32_t__List__i32(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, std_list_int32_t__List__i32):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = std_list_int32_t__List__i32._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, std_list_int32_t__List__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_list_int32_t__List__i32()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> std_list_int32_t__List__i32:
        _items = list(python_list)
        return std_list_int32_t__List__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(std_list_int32_t__List__i32)


__all__.append("std_list_int32_t__List__i32")

class Map__string_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__string_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__string_i32._check_key_type_or_raise
            check_val = Map__string_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__string_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, str)
        ):
            raise TypeError(f"{key!r} is not of type str")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, str):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__string_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__string_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__string_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__string_i32)

__all__.append("Map__string_i32")

class List__std_unordered_map__Map__i32_string(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__std_unordered_map__Map__i32_string):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__std_unordered_map__Map__i32_string._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__std_unordered_map__Map__i32_string)

    @staticmethod
    def _check_item_type_or_raise(item):
        if item is None:
            raise TypeError("None is not of the type _typing.Mapping[int, str]")
        if not isinstance(item, std_unordered_map__Map__i32_string):
            item = std_unordered_map__Map__i32_string(item)
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, std_unordered_map__Map__i32_string):
            return item
        try:
            return std_unordered_map__Map__i32_string(item)
        except:
            pass

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__std_unordered_map__Map__i32_string()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__std_unordered_map__Map__i32_string:
        _items = [
            std_unordered_map__Map__i32_string.from_python(item)
            for item in python_list
        ]
        return List__std_unordered_map__Map__i32_string(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__std_unordered_map__Map__i32_string)


__all__.append("List__std_unordered_map__Map__i32_string")

class Map__i32_IncompleteMapDep(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_IncompleteMapDep):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_IncompleteMapDep._check_key_type_or_raise
            check_val = Map__i32_IncompleteMapDep._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_IncompleteMapDep)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, IncompleteMapDep)
        ):
            raise TypeError(f"{item!r} is not of type IncompleteMapDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_IncompleteMapDep()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_IncompleteMapDep:
        _keys = python_map.keys()
        _values = (
            IncompleteMapDep.from_python(item)
            for item in python_map.values()
        )
        return Map__i32_IncompleteMapDep(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_IncompleteMapDep)

__all__.append("Map__i32_IncompleteMapDep")

class std_unordered_map__Map__i32_CompleteMapDep(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = False

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, std_unordered_map__Map__i32_CompleteMapDep):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = std_unordered_map__Map__i32_CompleteMapDep._check_key_type_or_raise
            check_val = std_unordered_map__Map__i32_CompleteMapDep._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, std_unordered_map__Map__i32_CompleteMapDep)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, CompleteMapDep)
        ):
            raise TypeError(f"{item!r} is not of type CompleteMapDep")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__std_unordered_map__Map__i32_CompleteMapDep()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> std_unordered_map__Map__i32_CompleteMapDep:
        _keys = python_map.keys()
        _values = (
            CompleteMapDep.from_python(item)
            for item in python_map.values()
        )
        return std_unordered_map__Map__i32_CompleteMapDep(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(std_unordered_map__Map__i32_CompleteMapDep)

__all__.append("std_unordered_map__Map__i32_CompleteMapDep")

class _std_list__List__IncompleteListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, _std_list__List__IncompleteListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = _std_list__List__IncompleteListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, _std_list__List__IncompleteListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, IncompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type IncompleteListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, IncompleteListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection___std_list__List__IncompleteListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> _std_list__List__IncompleteListDep:
        _items = [
            IncompleteListDep.from_python(item)
            for item in python_list
        ]
        return _std_list__List__IncompleteListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(_std_list__List__IncompleteListDep)


__all__.append("_std_list__List__IncompleteListDep")

class folly_small_vector__List__CompleteListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, folly_small_vector__List__CompleteListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = folly_small_vector__List__CompleteListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, folly_small_vector__List__CompleteListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, CompleteListDep)
        ):
            raise TypeError(f"{item!r} is not of type CompleteListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, CompleteListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__folly_small_vector__List__CompleteListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> folly_small_vector__List__CompleteListDep:
        _items = [
            CompleteListDep.from_python(item)
            for item in python_list
        ]
        return folly_small_vector__List__CompleteListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(folly_small_vector__List__CompleteListDep)


__all__.append("folly_small_vector__List__CompleteListDep")

class List__AdaptedListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__AdaptedListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__AdaptedListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__AdaptedListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, AdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type AdaptedListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, AdaptedListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__AdaptedListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__AdaptedListDep:
        _items = [
            AdaptedListDep.from_python(item)
            for item in python_list
        ]
        return List__AdaptedListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__AdaptedListDep)


__all__.append("List__AdaptedListDep")

class List__DependentAdaptedListDep(thrift.py3.types.List):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_list_private_ctor:
            _py_obj = items
        elif isinstance(items, List__DependentAdaptedListDep):
            _py_obj = list(items)
        elif items is None:
            _py_obj = []
        else:
            check_method = List__DependentAdaptedListDep._check_item_type_or_raise
            _py_obj = [check_method(item) for item in items]

        super().__init__(_py_obj, List__DependentAdaptedListDep)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, DependentAdaptedListDep)
        ):
            raise TypeError(f"{item!r} is not of type DependentAdaptedListDep")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, DependentAdaptedListDep):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__List__DependentAdaptedListDep()

    @staticmethod
    def from_python(python_list: thrift.python.types.List) -> List__DependentAdaptedListDep:
        _items = [
            DependentAdaptedListDep.from_python(item)
            for item in python_list
        ]
        return List__DependentAdaptedListDep(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_list_private_ctor,
        )


Sequence.register(List__DependentAdaptedListDep)


__all__.append("List__DependentAdaptedListDep")

class Set__i32(thrift.py3.types.Set):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_set_private_ctor:
            _py_obj = items
        elif isinstance(items, Set__i32):
            _py_obj = frozenset(items)
        elif items is None:
            _py_obj = frozenset()
        else:
            check_method = Set__i32._check_item_type_or_raise
            _py_obj = frozenset(check_method(item) for item in items)

        super().__init__(_py_obj, Set__i32)

    @staticmethod
    def _check_item_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def _check_item_type_or_none(item):
        if item is None:
            return None
        if isinstance(item, int):
            return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Set__i32()

    @staticmethod
    def from_python(python_set: thrift.python.types.Set) -> Set__i32:
        _items = frozenset(python_set)
        return Set__i32(
            items=_items,
            private_ctor_token=thrift.py3.types._fbthrift_set_private_ctor,
        )


Set.register(Set__i32)


__all__.append("Set__i32")

class Map__i32_i32(thrift.py3.types.Map):
    __module__ = _fbthrift__module_name__
    __slots__ = ()

    _FBTHRIFT_USE_SORTED_REPR = True

    def __init__(self, items=None, private_ctor_token=None) -> None:
        if private_ctor_token is thrift.py3.types._fbthrift_map_private_ctor:
            _py_obj = items
        elif isinstance(items, Map__i32_i32):
            _py_obj = dict(items)
        elif items is None:
            _py_obj = dict()
        else:
            check_key = Map__i32_i32._check_key_type_or_raise
            check_val = Map__i32_i32._check_val_type_or_raise
            _py_obj = {check_key(k) : check_val(v) for k, v in items.items()}

        super().__init__(_py_obj, Map__i32_i32)

    @staticmethod
    def _check_key_type_or_raise(key):
        if not (
            isinstance(key, int)
        ):
            raise TypeError(f"{key!r} is not of type int")
        return key

    @staticmethod
    def _check_key_type_or_none(key):
        if key is None:
            return None
        if isinstance(key, int):
            return key

    @staticmethod
    def _check_val_type_or_raise(item):
        if not (
            isinstance(item, int)
        ):
            raise TypeError(f"{item!r} is not of type int")
        return item

    @staticmethod
    def __get_reflection__():
        return get_types_reflection().get_reflection__Map__i32_i32()

    @staticmethod
    def from_python(python_map: thrift.python.types.Map) -> Map__i32_i32:
        _keys = python_map.keys()
        _values = python_map.values()
        return Map__i32_i32(
            items=dict(zip(_keys, _values)),
            private_ctor_token=thrift.py3.types._fbthrift_map_private_ctor,
        )


Mapping.register(Map__i32_i32)

__all__.append("Map__i32_i32")


### Structured Types ###
class empty_struct:
    __module__ = _fbthrift__module_name__


__all__.append("empty_struct")

class decorated_struct:
    __module__ = _fbthrift__module_name__


__all__.append("decorated_struct")

class ContainerStruct:
    __module__ = _fbthrift__module_name__


__all__.append("ContainerStruct")

class CppTypeStruct:
    __module__ = _fbthrift__module_name__


__all__.append("CppTypeStruct")

class VirtualStruct:
    __module__ = _fbthrift__module_name__


__all__.append("VirtualStruct")

class MyStructWithForwardRefEnum:
    __module__ = _fbthrift__module_name__


__all__.append("MyStructWithForwardRefEnum")

class TrivialNumeric:
    __module__ = _fbthrift__module_name__


__all__.append("TrivialNumeric")

class TrivialNestedWithDefault:
    __module__ = _fbthrift__module_name__


__all__.append("TrivialNestedWithDefault")

class ComplexString:
    __module__ = _fbthrift__module_name__


__all__.append("ComplexString")

class ComplexNestedWithDefault:
    __module__ = _fbthrift__module_name__


__all__.append("ComplexNestedWithDefault")

class MinPadding:
    __module__ = _fbthrift__module_name__


__all__.append("MinPadding")

class MinPaddingWithCustomType:
    __module__ = _fbthrift__module_name__


__all__.append("MinPaddingWithCustomType")

class MyStruct:
    __module__ = _fbthrift__module_name__


__all__.append("MyStruct")

class MyDataItem:
    __module__ = _fbthrift__module_name__


__all__.append("MyDataItem")

class Renaming:
    __module__ = _fbthrift__module_name__


__all__.append("Renaming")

class AnnotatedTypes:
    __module__ = _fbthrift__module_name__


__all__.append("AnnotatedTypes")

class ForwardUsageRoot:
    __module__ = _fbthrift__module_name__


__all__.append("ForwardUsageRoot")

class ForwardUsageStruct:
    __module__ = _fbthrift__module_name__


__all__.append("ForwardUsageStruct")

class ForwardUsageByRef:
    __module__ = _fbthrift__module_name__


__all__.append("ForwardUsageByRef")

class IncompleteMap:
    __module__ = _fbthrift__module_name__


__all__.append("IncompleteMap")

class IncompleteMapDep:
    __module__ = _fbthrift__module_name__


__all__.append("IncompleteMapDep")

class CompleteMap:
    __module__ = _fbthrift__module_name__


__all__.append("CompleteMap")

class CompleteMapDep:
    __module__ = _fbthrift__module_name__


__all__.append("CompleteMapDep")

class IncompleteList:
    __module__ = _fbthrift__module_name__


__all__.append("IncompleteList")

class IncompleteListDep:
    __module__ = _fbthrift__module_name__


__all__.append("IncompleteListDep")

class CompleteList:
    __module__ = _fbthrift__module_name__


__all__.append("CompleteList")

class CompleteListDep:
    __module__ = _fbthrift__module_name__


__all__.append("CompleteListDep")

class AdaptedList:
    __module__ = _fbthrift__module_name__


__all__.append("AdaptedList")

class DependentAdaptedList:
    __module__ = _fbthrift__module_name__


__all__.append("DependentAdaptedList")

class AllocatorAware:
    __module__ = _fbthrift__module_name__


__all__.append("AllocatorAware")

class AllocatorAware2:
    __module__ = _fbthrift__module_name__


__all__.append("AllocatorAware2")

class TypedefStruct:
    __module__ = _fbthrift__module_name__


__all__.append("TypedefStruct")

class StructWithDoubleUnderscores:
    __module__ = _fbthrift__module_name__


__all__.append("StructWithDoubleUnderscores")


### Constants
