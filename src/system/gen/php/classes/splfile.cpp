/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <php/classes/iterator.h>
#include <php/classes/splfile.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////

/* preface starts */
/* preface finishes */
/* SRC: classes/splfile.php line 383 */
const int64 q_splfileobject_DROP_NEW_LINE = 1LL;
const int64 q_splfileobject_READ_AHEAD = 2LL;
const int64 q_splfileobject_SKIP_EMPTY = 6LL;
const int64 q_splfileobject_READ_CSV = 8LL;
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileobject
Variant c_splfileobject::os_getInit(const char *s, int64 hash) {
  return c_splfileinfo::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileobject
Variant c_splfileobject::os_get(const char *s, int64 hash) {
  return c_splfileinfo::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileobject
Variant &c_splfileobject::os_lval(const char *s, int64 hash) {
  return c_splfileinfo::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject
void c_splfileobject::o_getArray(Array &props) const {
  c_splfileinfo::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject
void c_splfileobject::o_setArray(CArrRef props) {
  c_splfileinfo::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_splfileobject
Variant c_splfileobject::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileobject
Variant c_splfileobject::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_splfileinfo::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject
Variant c_splfileobject::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_splfileobject
bool c_splfileobject::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileobject
bool c_splfileobject::o_existsPublic(CStrRef s, int64 hash) const {
  return c_splfileinfo::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject
bool c_splfileobject::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_splfileobject
Variant c_splfileobject::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileobject
Variant c_splfileobject::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_splfileinfo::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject
Variant c_splfileobject::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_splfileobject
Variant& c_splfileobject::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileobject
Variant& c_splfileobject::o_lvalPublic(CStrRef s, int64 hash) {
  return c_splfileinfo::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject
Variant& c_splfileobject::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileobject
Variant c_splfileobject::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_RETURN(0x54B2A676B563E232LL, q_splfileobject_SKIP_EMPTY, "SKIP_EMPTY");
      break;
    case 3:
      HASH_RETURN(0x23519E830A6DEC13LL, q_splfileobject_READ_CSV, "READ_CSV");
      break;
    case 4:
      HASH_RETURN(0x05ABC27224BDAC64LL, q_splfileobject_DROP_NEW_LINE, "DROP_NEW_LINE");
      break;
    case 6:
      HASH_RETURN(0x6ABD9DCA7D94431ELL, q_splfileobject_READ_AHEAD, "READ_AHEAD");
      break;
    default:
      break;
  }
  return c_splfileinfo::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileobject
IMPLEMENT_CLASS(splfileobject)
c_splfileobject *c_splfileobject::create(Variant v_filename, Variant v_open_mode //  = NAMSTR(s_sys_ss122506fb, "r")
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  CountableHelper h(this);
  init();
  t___construct(v_filename, v_open_mode, v_use_include_path, v_context);
  return this;
}
ObjectData *c_splfileobject::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_splfileobject::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_splfileobject::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
ObjectData *c_splfileobject::cloneImpl() {
  c_splfileobject *obj = NEW(c_splfileobject)();
  cloneSet(obj);
  return obj;
}
void c_splfileobject::cloneSet(c_splfileobject *clone) {
  c_splfileinfo::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
Variant c_splfileobject::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fscanf(arg0));
        }
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fseek(arg0, arg1));
        }
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fgetss(arg0));
        }
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fgetcsv());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fgetcsv(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fgetcsv(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fgetcsv(arg0, arg1, arg2));
        }
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setcsvcontrol());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_setcsvcontrol(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setcsvcontrol(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcsvcontrol(arg0, arg1, arg2));
        }
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setflags(arg0));
        }
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setmaxlinelen(arg0));
        }
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_ftruncate(arg0));
        }
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_seek(arg0));
        }
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_flock(arg0, ref(arg1)));
        }
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fwrite(arg0, arg1));
        }
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD_LITSTR(0x09637D7CA2E33F00LL, NAMSTR(s_sys_ss5d1cc100, "fgetc")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x44CE4DB1CE7E9F86LL, NAMSTR(s_sys_ss3181607a, "flock")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        const_cast<Array&>(params).escalate(true);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValueRef(pos)));
          return (t_flock(arg0, ref(arg1)));
        }
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2FC3A6941D522E0ALL, NAMSTR(s_sys_ss1d522e0a, "setFlags")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setflags(arg0));
        }
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x732EC1BDA8EC520FLL, NAMSTR(s_sys_ss5713adf1, "getChildren")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x40044334DA397C15LL, NAMSTR(s_sys_ss25c683eb, "hasChildren")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2B7CAC006AF27F9ALL, NAMSTR(s_sys_ss6af27f9a, "fflush")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x5B33B55D4B7E339BLL, NAMSTR(s_sys_ss4b7e339b, "fpassthru")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3E4E7C561D3A541ELL, NAMSTR(s_sys_ss1d3a541e, "fgetss")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fgetss(arg0));
        }
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x044B276686B77923LL, NAMSTR(s_sys_ss794886dd, "fscanf")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_fscanf(arg0));
        }
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x1C1216F2B7C16CADLL, NAMSTR(s_sys_ss483e9353, "ftell")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4CEC6AA30E43D437LL, NAMSTR(s_sys_ss0e43d437, "setMaxLineLen")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_setmaxlinelen(arg0));
        }
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      HASH_GUARD_LITSTR(0x0890F9052322E838LL, NAMSTR(s_sys_ss2322e838, "fstat")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x5ACCF9166CD9D043LL, NAMSTR(s_sys_ss6cd9d043, "ftruncate")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_ftruncate(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x794FAFD4412AEFC3LL, NAMSTR(s_sys_ss412aefc3, "eof")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 73:
      HASH_GUARD_LITSTR(0x4282E0231F600049LL, NAMSTR(s_sys_ss1f600049, "fseek")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fseek(arg0, arg1));
        }
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7E978C38D741664ELL, NAMSTR(s_sys_ss28be99b2, "fgetcsv")) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_fgetcsv());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_fgetcsv(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_fgetcsv(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fgetcsv(arg0, arg1, arg2));
        }
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD_LITSTR(0x3A335010F905ACD0LL, NAMSTR(s_sys_ss06fa5330, "setCsvControl")) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setcsvcontrol());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_setcsvcontrol(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_setcsvcontrol(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_setcsvcontrol(arg0, arg1, arg2));
        }
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x25F68E7910FE9CDALL, NAMSTR(s_sys_ss10fe9cda, "getMaxLineLen")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          if (count <= 1) return (t___construct(arg0), null);
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t___construct(arg0, arg1), null);
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 3) return (t___construct(arg0, arg1, arg2), null);
          CVarRef arg3((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t___construct(arg0, arg1, arg2, arg3), null);
        }
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x27E7DBA875AD17E1LL, NAMSTR(s_sys_ss75ad17e1, "getFlags")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x6FE9F691E4A6D962LL, NAMSTR(s_sys_ss1b59269e, "getCsvControl")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x05D72365192CE465LL, NAMSTR(s_sys_ss192ce465, "fwrite")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_fwrite(arg0, arg1));
        }
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      HASH_GUARD_LITSTR(0x7EF5445C77054C67LL, NAMSTR(s_sys_ss77054c67, "seek")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t_seek(arg0));
        }
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7AE1BE187F18FDF3LL, NAMSTR(s_sys_ss7f18fdf3, "fgets")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
Variant c_splfileobject::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        return (t_fscanf(a0));
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        return (t_fseek(a0, a1));
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        return (t_fgetss(a0));
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        if (count <= 0) return (t_fgetcsv());
        if (count == 1) return (t_fgetcsv(a0));
        if (count == 2) return (t_fgetcsv(a0, a1));
        return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        if (count <= 0) return (t_setcsvcontrol());
        if (count == 1) return (t_setcsvcontrol(a0));
        if (count == 2) return (t_setcsvcontrol(a0, a1));
        return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        return (t_setflags(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        return (t_setmaxlinelen(a0));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        return (t_ftruncate(a0));
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        return (t_seek(a0));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        return (t_flock(a0, ref(a1)));
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        return (t_fwrite(a0, a1));
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD_LITSTR(0x09637D7CA2E33F00LL, NAMSTR(s_sys_ss5d1cc100, "fgetc")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x44CE4DB1CE7E9F86LL, NAMSTR(s_sys_ss3181607a, "flock")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        return (t_flock(a0, ref(a1)));
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2FC3A6941D522E0ALL, NAMSTR(s_sys_ss1d522e0a, "setFlags")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        return (t_setflags(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x732EC1BDA8EC520FLL, NAMSTR(s_sys_ss5713adf1, "getChildren")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x40044334DA397C15LL, NAMSTR(s_sys_ss25c683eb, "hasChildren")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2B7CAC006AF27F9ALL, NAMSTR(s_sys_ss6af27f9a, "fflush")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x5B33B55D4B7E339BLL, NAMSTR(s_sys_ss4b7e339b, "fpassthru")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3E4E7C561D3A541ELL, NAMSTR(s_sys_ss1d3a541e, "fgetss")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        return (t_fgetss(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x044B276686B77923LL, NAMSTR(s_sys_ss794886dd, "fscanf")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        return (t_fscanf(a0));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x1C1216F2B7C16CADLL, NAMSTR(s_sys_ss483e9353, "ftell")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4CEC6AA30E43D437LL, NAMSTR(s_sys_ss0e43d437, "setMaxLineLen")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        return (t_setmaxlinelen(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        return (t_next());
      }
      HASH_GUARD_LITSTR(0x0890F9052322E838LL, NAMSTR(s_sys_ss2322e838, "fstat")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x5ACCF9166CD9D043LL, NAMSTR(s_sys_ss6cd9d043, "ftruncate")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        return (t_ftruncate(a0));
      }
      HASH_GUARD_LITSTR(0x794FAFD4412AEFC3LL, NAMSTR(s_sys_ss412aefc3, "eof")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 73:
      HASH_GUARD_LITSTR(0x4282E0231F600049LL, NAMSTR(s_sys_ss1f600049, "fseek")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        return (t_fseek(a0, a1));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7E978C38D741664ELL, NAMSTR(s_sys_ss28be99b2, "fgetcsv")) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        if (count <= 0) return (t_fgetcsv());
        if (count == 1) return (t_fgetcsv(a0));
        if (count == 2) return (t_fgetcsv(a0, a1));
        return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD_LITSTR(0x3A335010F905ACD0LL, NAMSTR(s_sys_ss06fa5330, "setCsvControl")) {
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        if (count <= 0) return (t_setcsvcontrol());
        if (count == 1) return (t_setcsvcontrol(a0));
        if (count == 2) return (t_setcsvcontrol(a0, a1));
        return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x25F68E7910FE9CDALL, NAMSTR(s_sys_ss10fe9cda, "getMaxLineLen")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        if (count <= 1) return (t___construct(a0), null);
        if (count == 2) return (t___construct(a0, a1), null);
        if (count == 3) return (t___construct(a0, a1, a2), null);
        return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x27E7DBA875AD17E1LL, NAMSTR(s_sys_ss75ad17e1, "getFlags")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x6FE9F691E4A6D962LL, NAMSTR(s_sys_ss1b59269e, "getCsvControl")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x05D72365192CE465LL, NAMSTR(s_sys_ss192ce465, "fwrite")) {
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        return (t_fwrite(a0, a1));
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      HASH_GUARD_LITSTR(0x7EF5445C77054C67LL, NAMSTR(s_sys_ss77054c67, "seek")) {
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        return (t_seek(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7AE1BE187F18FDF3LL, NAMSTR(s_sys_ss7f18fdf3, "fgets")) {
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileobject
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileobject
Variant c_splfileobject::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileobject
Variant c_splfileobject::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 0x15e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fscanf(a0));
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 0x1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      break;
    case 0x15f:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fseek(a0, a1));
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      break;
    case 0x2:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 0x160:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetss(a0));
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 0x161:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fgetcsv());
        else if (count == 1) return (t_fgetcsv(a0));
        else if (count == 2) return (t_fgetcsv(a0, a1));
        else return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 0x3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 0x162:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setcsvcontrol());
        else if (count == 1) return (t_setcsvcontrol(a0));
        else if (count == 2) return (t_setcsvcontrol(a0, a1));
        else return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 0x163:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcsvcontrol());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      break;
    case 0x11:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setflags(a0));
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 0x164:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setmaxlinelen(a0));
      }
      break;
    case 0x165:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmaxlinelen());
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      break;
    case 0x166:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftruncate(a0));
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 0x168:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fflush());
      }
      break;
    case 0x167:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_eof());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0x169:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetc());
      }
      break;
    case 0x16a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fpassthru());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 0xf9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildren());
      }
      break;
    case 0x16b:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgets());
      }
      break;
    case 0x15:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_seek(a0));
      }
      break;
    case 0x16c:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_flock(a0, ref(a1)));
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 0x16:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getflags());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 0xfa:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getchildren());
      }
      break;
    case 0x7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 0x16e:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fwrite(a0, a1));
      }
      break;
    case 0x16d:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftell());
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 0x16f:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fstat());
      }
      break;
    case 0x9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 0:
      HASH_GUARD_LITSTR(0x09637D7CA2E33F00LL, NAMSTR(s_sys_ss5d1cc100, "fgetc")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgetc", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetc());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x44CE4DB1CE7E9F86LL, NAMSTR(s_sys_ss3181607a, "flock")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::flock", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_flock(a0, ref(a1)));
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x2FC3A6941D522E0ALL, NAMSTR(s_sys_ss1d522e0a, "setFlags")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setFlags", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setflags(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x732EC1BDA8EC520FLL, NAMSTR(s_sys_ss5713adf1, "getChildren")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getchildren());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x40044334DA397C15LL, NAMSTR(s_sys_ss25c683eb, "hasChildren")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::hasChildren", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_haschildren());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2B7CAC006AF27F9ALL, NAMSTR(s_sys_ss6af27f9a, "fflush")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fflush", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fflush());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x5B33B55D4B7E339BLL, NAMSTR(s_sys_ss4b7e339b, "fpassthru")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fpassthru", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fpassthru());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x3E4E7C561D3A541ELL, NAMSTR(s_sys_ss1d3a541e, "fgetss")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fgetss", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgetss(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x044B276686B77923LL, NAMSTR(s_sys_ss794886dd, "fscanf")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::fscanf", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fscanf(a0));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x1C1216F2B7C16CADLL, NAMSTR(s_sys_ss483e9353, "ftell")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::ftell", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftell());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4CEC6AA30E43D437LL, NAMSTR(s_sys_ss0e43d437, "setMaxLineLen")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::setMaxLineLen", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_setmaxlinelen(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss447efd48, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::next", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_next());
      }
      HASH_GUARD_LITSTR(0x0890F9052322E838LL, NAMSTR(s_sys_ss2322e838, "fstat")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fstat", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fstat());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 67:
      HASH_GUARD_LITSTR(0x5ACCF9166CD9D043LL, NAMSTR(s_sys_ss6cd9d043, "ftruncate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::ftruncate", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_ftruncate(a0));
      }
      HASH_GUARD_LITSTR(0x794FAFD4412AEFC3LL, NAMSTR(s_sys_ss412aefc3, "eof")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::eof", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_eof());
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss54808c44, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::valid", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_valid());
      }
      break;
    case 69:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 73:
      HASH_GUARD_LITSTR(0x4282E0231F600049LL, NAMSTR(s_sys_ss1f600049, "fseek")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fseek", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fseek(a0, a1));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 78:
      HASH_GUARD_LITSTR(0x7E978C38D741664ELL, NAMSTR(s_sys_ss28be99b2, "fgetcsv")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::fgetcsv", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_fgetcsv());
        else if (count == 1) return (t_fgetcsv(a0));
        else if (count == 2) return (t_fgetcsv(a0, a1));
        else return (t_fgetcsv(a0, a1, a2));
      }
      break;
    case 79:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 80:
      HASH_GUARD_LITSTR(0x3A335010F905ACD0LL, NAMSTR(s_sys_ss06fa5330, "setCsvControl")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileObject::setCsvControl", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setcsvcontrol());
        else if (count == 1) return (t_setcsvcontrol(a0));
        else if (count == 2) return (t_setcsvcontrol(a0, a1));
        else return (t_setcsvcontrol(a0, a1, a2));
      }
      break;
    case 81:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss7db173af, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::key", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_key());
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x25F68E7910FE9CDALL, NAMSTR(s_sys_ss10fe9cda, "getMaxLineLen")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getMaxLineLen", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmaxlinelen());
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss7b94de24, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::current", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_current());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("SplFileObject::__construct", count, 1, 4, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 97:
      HASH_GUARD_LITSTR(0x27E7DBA875AD17E1LL, NAMSTR(s_sys_ss75ad17e1, "getFlags")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getFlags", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getflags());
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x6FE9F691E4A6D962LL, NAMSTR(s_sys_ss1b59269e, "getCsvControl")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::getCsvControl", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getcsvcontrol());
      }
      break;
    case 99:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x05D72365192CE465LL, NAMSTR(s_sys_ss192ce465, "fwrite")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("SplFileObject::fwrite", count, 2, 2, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fwrite(a0, a1));
      }
      break;
    case 103:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      HASH_GUARD_LITSTR(0x7EF5445C77054C67LL, NAMSTR(s_sys_ss77054c67, "seek")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileObject::seek", count, 1, 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_seek(a0));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss21d85096, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::rewind", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_rewind());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7AE1BE187F18FDF3LL, NAMSTR(s_sys_ss7f18fdf3, "fgets")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileObject::fgets", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_fgets());
      }
      break;
    case 116:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 125:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    default:
      break;
  }
#endif
  return c_splfileinfo::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_splfileobject::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_splfileinfo::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_splfileobject = {
  c_splfileobject::os_getInit,
  c_splfileobject::os_get,
  c_splfileobject::os_lval,
  c_splfileobject::os_invoke,
  c_splfileobject::os_constant,
};
void c_splfileobject::init() {
  c_splfileinfo::init();
}
/* SRC: classes/splfile.php line 391 */
void c_splfileobject::t___construct(Variant v_filename, Variant v_open_mode //  = NAMSTR(s_sys_ss122506fb, "r")
, Variant v_use_include_path //  = false
, Variant v_context //  = null
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::__construct);
  bool oldInCtor = gasInCtor(true);
  Variant v_file_name;

  x_hphp_splfileobject___construct(GET_THIS(), toString(v_file_name), toString(v_open_mode), toBoolean(v_use_include_path), v_context);
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/splfile.php line 409 */
Variant c_splfileobject::t_current() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::current);
  return x_hphp_splfileobject_current(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 421 */
bool c_splfileobject::t_eof() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::eof);
  return x_hphp_splfileobject_eof(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 433 */
bool c_splfileobject::t_fflush() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fflush);
  return x_hphp_splfileobject_fflush(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 451 */
String c_splfileobject::t_fgetc() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetc);
  return x_hphp_splfileobject_fgetc(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 481 */
Variant c_splfileobject::t_fgetcsv(CVarRef v_delimiter //  = NAMSTR(s_sys_ss2d8b6f3b, ",")
, CVarRef v_enclosure //  = NAMSTR(s_sys_ss228ee909, "\"")
, CVarRef v_escape //  = NAMSTR(s_sys_ss2a618761, "\\")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetcsv);
  return x_hphp_splfileobject_fgetcsv(GET_THIS(), toString(v_delimiter), toString(v_enclosure), toString(v_escape));
} /* function */
/* SRC: classes/splfile.php line 496 */
String c_splfileobject::t_fgets() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgets);
  return x_hphp_splfileobject_fgets(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 516 */
String c_splfileobject::t_fgetss(CVarRef v_allowable_tags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fgetss);
  return x_hphp_splfileobject_fgetss(GET_THIS(), toString(v_allowable_tags));
} /* function */
/* SRC: classes/splfile.php line 536 */
bool c_splfileobject::t_flock(CVarRef v_operation, Variant v_wouldblock) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::flock);
  return x_hphp_splfileobject_flock(GET_THIS(), ref(v_wouldblock));
} /* function */
/* SRC: classes/splfile.php line 554 */
int64 c_splfileobject::t_fpassthru() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fpassthru);
  return x_hphp_splfileobject_fpassthru(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 578 */
Variant c_splfileobject::t_fscanf(CVarRef v_format) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fscanf);
  return invoke("hphp_splfileobject_fscanf", Array(ArrayInit(1, true).setRef(0, toInt64(GET_THIS())).create()), 0x6DB71D850799D76ELL);
} /* function */
/* SRC: classes/splfile.php line 604 */
int64 c_splfileobject::t_fseek(CVarRef v_offset, CVarRef v_whence) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fseek);
  return x_hphp_splfileobject_fseek(GET_THIS(), toInt64(v_offset), toInt64(v_whence));
} /* function */
/* SRC: classes/splfile.php line 618 */
Variant c_splfileobject::t_fstat() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fstat);
  return x_hphp_splfileobject_fstat(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 632 */
int64 c_splfileobject::t_ftell() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftell);
  return x_hphp_splfileobject_ftell(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 652 */
bool c_splfileobject::t_ftruncate(CVarRef v_size) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::ftruncate);
  return x_hphp_splfileobject_ftruncate(GET_THIS(), toInt64(v_size));
} /* function */
/* SRC: classes/splfile.php line 670 */
int64 c_splfileobject::t_fwrite(CVarRef v_str, CVarRef v_length) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::fwrite);
  return x_hphp_splfileobject_fwrite(GET_THIS(), toString(v_str), toInt64(v_length));
} /* function */
/* SRC: classes/splfile.php line 682 */
Variant c_splfileobject::t_getchildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getChildren);
  return null;
} /* function */
/* SRC: classes/splfile.php line 696 */
Variant c_splfileobject::t_getcsvcontrol() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getCsvControl);
  return x_hphp_splfileobject_getcvscontrol(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 708 */
int64 c_splfileobject::t_getflags() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getFlags);
  return x_hphp_splfileobject_getflags(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 722 */
int64 c_splfileobject::t_getmaxlinelen() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::getMaxLineLen);
  return x_hphp_splfileobject_getmaxlinelen(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 735 */
bool c_splfileobject::t_haschildren() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::hasChildren);
  return false;
} /* function */
/* SRC: classes/splfile.php line 751 */
int64 c_splfileobject::t_key() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::key);
  return x_hphp_splfileobject_key(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 763 */
Variant c_splfileobject::t_next() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::next);
  return (x_hphp_splfileobject_next(GET_THIS()), null);
} /* function */
/* SRC: classes/splfile.php line 775 */
Variant c_splfileobject::t_rewind() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::rewind);
  return (x_hphp_splfileobject_rewind(GET_THIS()), null);
} /* function */
/* SRC: classes/splfile.php line 789 */
Variant c_splfileobject::t_seek(CVarRef v_line_pos) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::seek);
  return (x_hphp_splfileobject_seek(GET_THIS(), toInt64(v_line_pos)), null);
} /* function */
/* SRC: classes/splfile.php line 806 */
Variant c_splfileobject::t_setcsvcontrol(CVarRef v_delimiter //  = NAMSTR(s_sys_ss2d8b6f3b, ",")
, CVarRef v_enclosure //  = NAMSTR(s_sys_ss228ee909, "\"")
, CVarRef v_escape //  = NAMSTR(s_sys_ss2a618761, "\\")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setCsvControl);
  return (x_hphp_splfileobject_setcsvcontrol(GET_THIS(), toString(v_delimiter), toString(v_enclosure), toString(v_escape)), null);
} /* function */
/* SRC: classes/splfile.php line 823 */
Variant c_splfileobject::t_setflags(CVarRef v_flags) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setFlags);
  return (x_hphp_splfileobject_setflags(GET_THIS(), toInt64(v_flags)), null);
} /* function */
/* SRC: classes/splfile.php line 838 */
Variant c_splfileobject::t_setmaxlinelen(CVarRef v_max_len) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::setMaxLineLen);
  return (x_hphp_splfileobject_setmaxlinelen(GET_THIS(), toInt64(v_max_len)), null);
} /* function */
/* SRC: classes/splfile.php line 850 */
bool c_splfileobject::t_valid() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileObject, SplFileObject::valid);
  return x_hphp_splfileobject_valid(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 11 */
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileinfo
Variant c_splfileinfo::os_getInit(const char *s, int64 hash) {
  return c_ObjectData::os_getInit(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileinfo
Variant c_splfileinfo::os_get(const char *s, int64 hash) {
  return c_ObjectData::os_get(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileinfo
Variant &c_splfileinfo::os_lval(const char *s, int64 hash) {
  return c_ObjectData::os_lval(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo
void c_splfileinfo::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo
void c_splfileinfo::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_splfileinfo
Variant c_splfileinfo::o_get(CStrRef prop, int64 phash, bool error, const char *context, int64 hash) {
  return o_getPublic(prop, phash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileinfo
Variant c_splfileinfo::o_getPublic(CStrRef s, int64 hash, bool error) {
  return c_ObjectData::o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo
Variant c_splfileinfo::o_getPrivate(CStrRef s, int64 hash, bool error) {
  return o_getPublic(s, hash, error);
}
#endif // OMIT_JUMP_TABLE_CLASS_get_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_splfileinfo
bool c_splfileinfo::o_exists(CStrRef prop, int64 phash, const char *context, int64 hash) const {
  return o_existsPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileinfo
bool c_splfileinfo::o_existsPublic(CStrRef s, int64 hash) const {
  return c_ObjectData::o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo
bool c_splfileinfo::o_existsPrivate(CStrRef s, int64 hash) const {
  return o_existsPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_exists_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_splfileinfo
Variant c_splfileinfo::o_set(CStrRef prop, int64 phash, CVarRef v, bool forInit, const char *context, int64 hash) {
  return o_setPublic(prop, phash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileinfo
Variant c_splfileinfo::o_setPublic(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return c_ObjectData::o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo
Variant c_splfileinfo::o_setPrivate(CStrRef s, int64 hash, CVarRef v, bool forInit) {
  return o_setPublic(s, hash, v, forInit);
}
#endif // OMIT_JUMP_TABLE_CLASS_set_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_splfileinfo
Variant& c_splfileinfo::o_lval(CStrRef prop, int64 phash, const char *context, int64 hash) {
  return o_lvalPublic(prop, phash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileinfo
Variant& c_splfileinfo::o_lvalPublic(CStrRef s, int64 hash) {
  return c_ObjectData::o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PUBLIC_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo
Variant& c_splfileinfo::o_lvalPrivate(CStrRef s, int64 hash) {
  return o_lvalPublic(s, hash);
}
#endif // OMIT_JUMP_TABLE_CLASS_lval_PRIVATE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileinfo
Variant c_splfileinfo::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_splfileinfo
IMPLEMENT_CLASS(splfileinfo)
c_splfileinfo *c_splfileinfo::create(Variant v_file_name) {
  CountableHelper h(this);
  init();
  t___construct(v_file_name);
  return this;
}
ObjectData *c_splfileinfo::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_splfileinfo::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_splfileinfo::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 1);
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  (t___construct(a0), null);
}
ObjectData *c_splfileinfo::cloneImpl() {
  c_splfileinfo *obj = NEW(c_splfileinfo)();
  cloneSet(obj);
  return obj;
}
void c_splfileinfo::cloneSet(c_splfileinfo *clone) {
  ObjectData::cloneSet(clone);
}
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke(MethodIndex methodIndex, const char *s, CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setinfoclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setinfoclass(arg0));
        }
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getbasename());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getbasename(arg0));
        }
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          CVarRef arg0((ad->getValue(pos)));
          return (t___construct(arg0), null);
        }
      }
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_setfileclass());
          CVarRef arg0((ad->getValue(pos)));
          return (t_setfileclass(arg0));
        }
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getpathinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getpathinfo(arg0));
        }
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_openfile());
          CVarRef arg0((ad->getValue(pos)));
          if (count == 1) return (t_openfile(arg0));
          CVarRef arg1((pos = ad->iter_advance(pos),ad->getValue(pos)));
          if (count == 2) return (t_openfile(arg0, arg1));
          CVarRef arg2((pos = ad->iter_advance(pos),ad->getValue(pos)));
          return (t_openfile(arg0, arg1, arg2));
        }
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        {
          ArrayData *ad(params.get());
          ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
          if (count <= 0) return (t_getfileinfo());
          CVarRef arg0((ad->getValue(pos)));
          return (t_getfileinfo(arg0));
        }
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke(methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke_few_args(MethodIndex methodIndex, const char *s, int64 hash, int count, CVarRef a0, CVarRef a1, CVarRef a2, CVarRef a3, CVarRef a4, CVarRef a5) {
#ifdef FMCGEN
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        if (count <= 0) return (t_setinfoclass());
        return (t_setinfoclass(a0));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        if (count <= 0) return (t_getbasename());
        return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        if (count <= 0) return (t_setfileclass());
        return (t_setfileclass(a0));
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        if (count <= 0) return (t_getpathinfo());
        return (t_getpathinfo(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        if (count <= 0) return (t_openfile());
        if (count == 1) return (t_openfile(a0));
        if (count == 2) return (t_openfile(a0, a1));
        return (t_openfile(a0, a1, a2));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        if (count <= 0) return (t_getfileinfo());
        return (t_getfileinfo(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_few_args(methodIndex, s, hash, count, a0, a1, a2, a3, a4, a5);
}
#endif // OMIT_JUMP_TABLE_CLASS_INVOKE_splfileinfo
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileinfo
Variant c_splfileinfo::os_invoke(const char *c, MethodIndex methodIndex, const char *s,  CArrRef params, int64 hash, bool fatal) {
  int count __attribute__((__unused__)) = params.size();
#ifdef FMCGEN
#else
#endif
  return c_ObjectData::os_invoke(c, methodIndex, s, params, hash, fatal);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_INVOKE_splfileinfo
Variant c_splfileinfo::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
  switch (methodIndex.m_callIndex) {
    case 0xad:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 0xae:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 0xaf:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 0xb0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 0xb1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      break;
    case 0xb2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 0xb3:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 0x1a:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 0xb4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 0xb5:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 0xb6:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      break;
    case 0x6:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      break;
    case 0xb7:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 0xb8:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 0xb9:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      break;
    case 0xba:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 0xbb:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 0xbc:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 0xbe:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 0xbd:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 0xbf:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 0xc0:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 0xc1:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 0xc2:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    case 0xc4:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 0xc3:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 0xc5:
      if (methodIndex.m_overloadIndex == 0x1) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 0xc7:
      if (methodIndex.m_overloadIndex == 0x1) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    default:
      break;
  }
#else
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 5:
      HASH_GUARD_LITSTR(0x5676046725D241C5LL, NAMSTR(s_sys_ss25d241c5, "setInfoClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setInfoClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setinfoclass());
        else return (t_setinfoclass(a0));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x6B2EAD4A44934786LL, NAMSTR(s_sys_ss44934786, "getRealPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getRealPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getrealpath());
      }
      HASH_GUARD_LITSTR(0x1D3B08AA0AF50F06LL, NAMSTR(s_sys_ss0af50f06, "getType")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getType", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_gettype());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x1ADA46FCC8EFEC08LL, NAMSTR(s_sys_ss371013f8, "isDir")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isDir", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isdir());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x01A800A73CD2604ALL, NAMSTR(s_sys_ss3cd2604a, "getInode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getInode", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getinode());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x1930CE336D39474DLL, NAMSTR(s_sys_ss6d39474d, "getFilename")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getFilename", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getfilename());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x32ABF385AD4BE48ELL, NAMSTR(s_sys_ss52b41b72, "getOwner")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getOwner", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getowner());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x569FC7D8E9401C4FLL, NAMSTR(s_sys_ss16bfe3b1, "isReadable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isReadable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isreadable());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6b4cb5ed, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::__toString", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___tostring());
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x1D5801BB72C51C58LL, NAMSTR(s_sys_ss72c51c58, "isLink")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isLink", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_islink());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x572E108C6731E29CLL, NAMSTR(s_sys_ss6731e29c, "getBasename")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getBasename", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getbasename());
        else return (t_getbasename(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4C43532D60465F1DLL, NAMSTR(s_sys_ss60465f1d, "isFile")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isFile", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isfile());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss229c615f, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("SplFileInfo::__construct", count, 1, 1, 2);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x4BC19906B553C59FLL, NAMSTR(s_sys_ss4aac3a61, "getATime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getATime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getatime());
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x638F2A56B8463A63LL, NAMSTR(s_sys_ss47b9c59d, "isWritable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isWritable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_iswritable());
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x5948407CA9CC4DA5LL, NAMSTR(s_sys_ss5633b25b, "setFileClass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::setFileClass", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_setfileclass());
        else return (t_setfileclass(a0));
      }
      break;
    case 39:
      HASH_GUARD_LITSTR(0x00DCC39EDB16AFE7LL, NAMSTR(s_sys_ss24e95019, "getPathInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getPathInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getpathinfo());
        else return (t_getpathinfo(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x0F9EDEC32565D86ALL, NAMSTR(s_sys_ss2565d86a, "getGroup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getGroup", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getgroup());
      }
      HASH_GUARD_LITSTR(0x6615B5496D03A6EALL, NAMSTR(s_sys_ss6d03a6ea, "getSize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getSize", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getsize());
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0D6276BAB75513ABLL, NAMSTR(s_sys_ss48aaec55, "getLinkTarget")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getLinkTarget", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getlinktarget());
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5640A4755D0078AFLL, NAMSTR(s_sys_ss5d0078af, "getCTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getCTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getctime());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x265BDC54C992EE74LL, NAMSTR(s_sys_ss366d118c, "getMTime")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getMTime", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getmtime());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x337DEC2D48BDFE35LL, NAMSTR(s_sys_ss48bdfe35, "openFile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("SplFileInfo::openFile", 3, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_openfile());
        else if (count == 1) return (t_openfile(a0));
        else if (count == 2) return (t_openfile(a0, a1));
        else return (t_openfile(a0, a1, a2));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x25070641C3D924F8LL, NAMSTR(s_sys_ss3c26db08, "getPathname")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPathname", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpathname());
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x3786834B2A0CCB7ALL, NAMSTR(s_sys_ss2a0ccb7a, "isExecutable")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::isExecutable", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_isexecutable());
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x4351578037A06E7DLL, NAMSTR(s_sys_ss37a06e7d, "getPerms")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPerms", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getperms());
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x04C642C6C162243FLL, NAMSTR(s_sys_ss3e9ddbc1, "getPath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("SplFileInfo::getPath", 0, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        return (t_getpath());
      }
      HASH_GUARD_LITSTR(0x7D50FA42F9D4923FLL, NAMSTR(s_sys_ss062b6dc1, "getFileInfo")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("SplFileInfo::getFileInfo", 1, 1);
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        if (count <= 0) return (t_getfileinfo());
        else return (t_getfileinfo(a0));
      }
      break;
    default:
      break;
  }
#endif
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_splfileinfo::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
#ifdef FMCGEN
  MethodIndex methodIndex = methodIndexExists(s);
#else
#endif
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
struct ObjectStaticCallbacks cw_splfileinfo = {
  c_splfileinfo::os_getInit,
  c_splfileinfo::os_get,
  c_splfileinfo::os_lval,
  c_splfileinfo::os_invoke,
  c_splfileinfo::os_constant,
};
void c_splfileinfo::init() {
}
/* SRC: classes/splfile.php line 13 */
void c_splfileinfo::t___construct(Variant v_file_name) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__construct);
  bool oldInCtor = gasInCtor(true);
  x_hphp_splfileinfo___construct(GET_THIS(), toString(v_file_name));
  gasInCtor(oldInCtor);
} /* function */
/* SRC: classes/splfile.php line 26 */
String c_splfileinfo::t_getpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPath);
  return x_hphp_splfileinfo_getpath(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 38 */
String c_splfileinfo::t_getfilename() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFilename);
  return x_hphp_splfileinfo_getfilename(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 52 */
Object c_splfileinfo::t_getfileinfo(CVarRef v_class_name //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getFileInfo);
  return x_hphp_splfileinfo_getfileinfo(GET_THIS(), toString(v_class_name));
} /* function */
/* SRC: classes/splfile.php line 67 */
String c_splfileinfo::t_getbasename(CVarRef v_suffix //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getBasename);
  return x_hphp_splfileinfo_getbasename(GET_THIS(), toString(v_suffix));
} /* function */
/* SRC: classes/splfile.php line 79 */
String c_splfileinfo::t_getpathname() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathname);
  return x_hphp_splfileinfo_getpathname(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 94 */
Object c_splfileinfo::t_getpathinfo(CVarRef v_class_name //  = NAMSTR(s_sys_ss00000000, "")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPathInfo);
  return x_hphp_splfileinfo_getpathinfo(GET_THIS(), toString(v_class_name));
} /* function */
/* SRC: classes/splfile.php line 106 */
int64 c_splfileinfo::t_getperms() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getPerms);
  return x_hphp_splfileinfo_getperms(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 118 */
int64 c_splfileinfo::t_getinode() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getInode);
  return x_hphp_splfileinfo_getinode(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 130 */
int64 c_splfileinfo::t_getsize() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getSize);
  return x_hphp_splfileinfo_getsize(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 142 */
int64 c_splfileinfo::t_getowner() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getOwner);
  return x_hphp_splfileinfo_getowner(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 154 */
int64 c_splfileinfo::t_getgroup() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getGroup);
  return x_hphp_splfileinfo_getgroup(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 166 */
int64 c_splfileinfo::t_getatime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getATime);
  return x_hphp_splfileinfo_getatime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 180 */
int64 c_splfileinfo::t_getmtime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getMTime);
  return x_hphp_splfileinfo_getmtime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 193 */
int64 c_splfileinfo::t_getctime() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getCTime);
  return x_hphp_splfileinfo_getctime(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 206 */
String c_splfileinfo::t_gettype() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getType);
  return x_hphp_splfileinfo_gettype(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 218 */
bool c_splfileinfo::t_iswritable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isWritable);
  return x_hphp_splfileinfo_iswritable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 230 */
bool c_splfileinfo::t_isreadable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isReadable);
  return x_hphp_splfileinfo_isreadable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 242 */
bool c_splfileinfo::t_isexecutable() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isExecutable);
  return x_hphp_splfileinfo_isexecutable(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 256 */
bool c_splfileinfo::t_isfile() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isFile);
  return x_hphp_splfileinfo_isfile(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 268 */
bool c_splfileinfo::t_isdir() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isDir);
  return x_hphp_splfileinfo_isdir(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 281 */
bool c_splfileinfo::t_islink() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::isLink);
  return x_hphp_splfileinfo_islink(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 296 */
String c_splfileinfo::t_getlinktarget() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getLinkTarget);
  return x_hphp_splfileinfo_getlinktarget(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 309 */
Variant c_splfileinfo::t_getrealpath() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::getRealPath);
  return x_hphp_splfileinfo_getrealpath(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 313 */
String c_splfileinfo::t___tostring() {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::__toString);
  return x_hphp_splfileinfo___tostring(GET_THIS());
} /* function */
/* SRC: classes/splfile.php line 337 */
Object c_splfileinfo::t_openfile(CVarRef v_mode //  = NAMSTR(s_sys_ss122506fb, "r")
, CVarRef v_use_include_path //  = false
, CVarRef v_context //  = null_variant
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::openFile);
  return x_hphp_splfileinfo_openfile(GET_THIS(), toString(v_mode), toBoolean(v_use_include_path), v_context);
} /* function */
/* SRC: classes/splfile.php line 355 */
Variant c_splfileinfo::t_setfileclass(CVarRef v_class_name //  = NAMSTR(s_sys_ss5da6122e, "SplFileObject")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setFileClass);
  return (x_hphp_splfileinfo_setfileclass(GET_THIS(), toString(v_class_name)), null);
} /* function */
/* SRC: classes/splfile.php line 371 */
Variant c_splfileinfo::t_setinfoclass(CVarRef v_class_name //  = NAMSTR(s_sys_ss016dc059, "SplFileInfo")
) {
  INSTANCE_METHOD_INJECTION_BUILTIN(SplFileInfo, SplFileInfo::setInfoClass);
  return (x_hphp_splfileinfo_setinfoclass(GET_THIS(), toString(v_class_name)), null);
} /* function */
Object co_splfileobject(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_splfileobject)())->dynCreate(params, init));
}
Object co_splfileinfo(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_splfileinfo)())->dynCreate(params, init));
}
Variant pm_php$classes$splfile_php(bool incOnce /* = false */, LVariableTable* variables /* = NULL */, Globals *globals /* = get_globals() */) {
  PSEUDOMAIN_INJECTION_BUILTIN(run_init::classes/splfile.php, pm_php$classes$splfile_php);
  LVariableTable *gVariables __attribute__((__unused__)) = (LVariableTable *)g;
  return true;
} /* function */

///////////////////////////////////////////////////////////////////////////////
}
