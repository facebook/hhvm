# Copyright (c) Meta Platforms, Inc. and affiliates.
# This file was generated by `thrift/test/testset/generator.py`
# @generated

include "thrift/annotation/cpp.thrift"
include "thrift/annotation/hack.thrift"
include "thrift/annotation/java.thrift"
include "thrift/annotation/python.thrift"
include "thrift/annotation/thrift.thrift"

cpp_include "thrift/test/AdapterTest.h"

@thrift.Experimental
package "facebook.com/thrift/test/testset"

namespace cpp2 apache.thrift.test.testset
namespace py3 thrift.test
namespace php apache_thrift
namespace py thrift.test.testset
namespace py.asyncio thrift_asyncio.test.testset
namespace java.swift org.apache.thrift.test
namespace go thrift.test.testset

struct struct_empty {
}
struct struct_list_bool {
  1: list<bool> field_1;
}
struct struct_list_byte {
  1: list<byte> field_1;
}
struct struct_list_i16 {
  1: list<i16> field_1;
}
struct struct_list_i32 {
  1: list<i32> field_1;
}
struct struct_list_i64 {
  1: list<i64> field_1;
}
struct struct_list_float {
  1: list<float> field_1;
}
struct struct_list_double {
  1: list<double> field_1;
}
struct struct_list_binary {
  1: list<binary> field_1;
}
struct struct_list_string {
  1: list<string> field_1;
}
struct struct_list_struct_empty {
  1: list<struct_empty> field_1;
}
struct struct_list_list_bool {
  1: list<list<bool>> field_1;
}
struct struct_list_list_byte {
  1: list<list<byte>> field_1;
}
struct struct_list_list_i16 {
  1: list<list<i16>> field_1;
}
struct struct_list_list_i32 {
  1: list<list<i32>> field_1;
}
struct struct_list_list_i64 {
  1: list<list<i64>> field_1;
}
struct struct_list_list_float {
  1: list<list<float>> field_1;
}
struct struct_list_list_double {
  1: list<list<double>> field_1;
}
struct struct_list_list_binary {
  1: list<list<binary>> field_1;
}
struct struct_list_list_string {
  1: list<list<string>> field_1;
}
struct struct_list_list_struct_empty {
  1: list<list<struct_empty>> field_1;
}
struct struct_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_set_byte {
  1: set<byte> field_1;
}
struct struct_set_i16 {
  1: set<i16> field_1;
}
struct struct_set_i32 {
  1: set<i32> field_1;
}
struct struct_set_i64 {
  1: set<i64> field_1;
}
struct struct_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_set_binary {
  1: set<binary> field_1;
}
struct struct_set_string {
  1: set<string> field_1;
}
struct struct_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_map_string_bool {
  1: map<string, bool> field_1;
}
struct struct_map_string_byte {
  1: map<string, byte> field_1;
}
struct struct_map_string_i16 {
  1: map<string, i16> field_1;
}
struct struct_map_string_i32 {
  1: map<string, i32> field_1;
}
struct struct_map_string_i64 {
  1: map<string, i64> field_1;
}
struct struct_map_string_float {
  1: map<string, float> field_1;
}
struct struct_map_string_double {
  1: map<string, double> field_1;
}
struct struct_map_string_binary {
  1: map<string, binary> field_1;
}
struct struct_map_string_string {
  1: map<string, string> field_1;
}
struct struct_map_string_struct_empty {
  1: map<string, struct_empty> field_1;
}
struct struct_map_i64_bool {
  1: map<i64, bool> field_1;
}
struct struct_map_i64_byte {
  1: map<i64, byte> field_1;
}
struct struct_map_i64_i16 {
  1: map<i64, i16> field_1;
}
struct struct_map_i64_i32 {
  1: map<i64, i32> field_1;
}
struct struct_map_i64_i64 {
  1: map<i64, i64> field_1;
}
struct struct_map_i64_float {
  1: map<i64, float> field_1;
}
struct struct_map_i64_double {
  1: map<i64, double> field_1;
}
struct struct_map_i64_binary {
  1: map<i64, binary> field_1;
}
struct struct_map_i64_string {
  1: map<i64, string> field_1;
}
struct struct_map_i64_struct_empty {
  1: map<i64, struct_empty> field_1;
}
struct struct_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_map_string_set_byte {
  1: map<string, set<byte>> field_1;
}
struct struct_map_string_set_i16 {
  1: map<string, set<i16>> field_1;
}
struct struct_map_string_set_i32 {
  1: map<string, set<i32>> field_1;
}
struct struct_map_string_set_i64 {
  1: map<string, set<i64>> field_1;
}
struct struct_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_map_string_set_binary {
  1: map<string, set<binary>> field_1;
}
struct struct_map_string_set_string {
  1: map<string, set<string>> field_1;
}
struct struct_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_map_i64_set_byte {
  1: map<i64, set<byte>> field_1;
}
struct struct_map_i64_set_i16 {
  1: map<i64, set<i16>> field_1;
}
struct struct_map_i64_set_i32 {
  1: map<i64, set<i32>> field_1;
}
struct struct_map_i64_set_i64 {
  1: map<i64, set<i64>> field_1;
}
struct struct_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_map_i64_set_binary {
  1: map<i64, set<binary>> field_1;
}
struct struct_map_i64_set_string {
  1: map<i64, set<string>> field_1;
}
struct struct_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
struct struct_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
struct struct_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
struct struct_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
struct struct_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
struct struct_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
struct struct_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
struct struct_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
struct struct_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
struct struct_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
struct struct_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
struct struct_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
struct struct_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
struct struct_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
struct struct_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
struct struct_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
struct struct_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
struct struct_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
struct struct_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
struct struct_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
struct struct_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
struct struct_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
struct struct_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
struct struct_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
struct struct_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
struct struct_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
struct struct_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
struct struct_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
struct struct_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
struct struct_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
struct struct_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
struct struct_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
struct struct_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
struct struct_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
struct struct_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
struct struct_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
struct struct_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
struct struct_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
struct struct_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
struct struct_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
struct struct_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
struct struct_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
struct struct_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
struct struct_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
struct struct_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
struct struct_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
struct struct_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
struct struct_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
struct struct_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
struct struct_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
struct struct_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
struct struct_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
struct struct_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
struct struct_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
struct struct_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
struct struct_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
struct struct_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
struct struct_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
struct struct_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
struct struct_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
struct struct_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
struct struct_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
struct struct_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
struct struct_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
struct struct_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
struct struct_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
struct struct_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
struct struct_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
struct struct_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
struct struct_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
struct struct_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
struct struct_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
struct struct_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
struct struct_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
struct struct_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
struct struct_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
struct struct_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
struct struct_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
struct struct_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
struct struct_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
struct struct_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
struct struct_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
struct struct_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
struct struct_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
struct struct_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
struct struct_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
struct struct_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
struct struct_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
struct struct_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
struct struct_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
struct struct_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
struct struct_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
struct struct_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
struct struct_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
struct struct_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
struct struct_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
struct struct_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
struct struct_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
struct struct_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
struct struct_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
struct struct_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
struct struct_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
struct struct_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
struct struct_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
struct struct_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
struct struct_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
struct struct_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
struct struct_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
struct struct_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
struct struct_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
struct struct_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
struct struct_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
struct struct_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
struct struct_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
struct struct_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
struct struct_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
struct struct_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_bool {
  1: bool field_1;
}
struct struct_byte {
  1: byte field_1;
}
struct struct_i16 {
  1: i16 field_1;
}
struct struct_i32 {
  1: i32 field_1;
}
struct struct_i64 {
  1: i64 field_1;
}
struct struct_float {
  1: float field_1;
}
struct struct_double {
  1: double field_1;
}
struct struct_binary {
  1: binary field_1;
}
struct struct_string {
  1: string field_1;
}
struct struct_bool_custom_default {
  1: bool field_1 = true;
}
struct struct_byte_custom_default {
  1: byte field_1 = 1;
}
struct struct_i16_custom_default {
  1: i16 field_1 = 2;
}
struct struct_i32_custom_default {
  1: i32 field_1 = 3;
}
struct struct_i64_custom_default {
  1: i64 field_1 = 4;
}
struct struct_float_custom_default {
  1: float field_1 = 5;
}
struct struct_double_custom_default {
  1: double field_1 = 6;
}
struct struct_binary_custom_default {
  1: binary field_1 = "7";
}
struct struct_string_custom_default {
  1: string field_1 = "8";
}
struct struct_bool_alternative_custom_default {
  1: bool field_1 = true;
}
struct struct_byte_alternative_custom_default {
  1: byte field_1 = 10;
}
struct struct_i16_alternative_custom_default {
  1: i16 field_1 = 20;
}
struct struct_i32_alternative_custom_default {
  1: i32 field_1 = 30;
}
struct struct_i64_alternative_custom_default {
  1: i64 field_1 = 40;
}
struct struct_float_alternative_custom_default {
  1: float field_1 = 50;
}
struct struct_double_alternative_custom_default {
  1: double field_1 = 60;
}
struct struct_binary_alternative_custom_default {
  1: binary field_1 = "70";
}
struct struct_string_alternative_custom_default {
  1: string field_1 = "80";
}
struct struct_optional_list_bool {
  1: optional list<bool> field_1;
}
struct struct_optional_list_byte {
  1: optional list<byte> field_1;
}
struct struct_optional_list_i16 {
  1: optional list<i16> field_1;
}
struct struct_optional_list_i32 {
  1: optional list<i32> field_1;
}
struct struct_optional_list_i64 {
  1: optional list<i64> field_1;
}
struct struct_optional_list_float {
  1: optional list<float> field_1;
}
struct struct_optional_list_double {
  1: optional list<double> field_1;
}
struct struct_optional_list_binary {
  1: optional list<binary> field_1;
}
struct struct_optional_list_string {
  1: optional list<string> field_1;
}
struct struct_optional_list_struct_empty {
  1: optional list<struct_empty> field_1;
}
struct struct_optional_list_list_bool {
  1: optional list<list<bool>> field_1;
}
struct struct_optional_list_list_byte {
  1: optional list<list<byte>> field_1;
}
struct struct_optional_list_list_i16 {
  1: optional list<list<i16>> field_1;
}
struct struct_optional_list_list_i32 {
  1: optional list<list<i32>> field_1;
}
struct struct_optional_list_list_i64 {
  1: optional list<list<i64>> field_1;
}
struct struct_optional_list_list_float {
  1: optional list<list<float>> field_1;
}
struct struct_optional_list_list_double {
  1: optional list<list<double>> field_1;
}
struct struct_optional_list_list_binary {
  1: optional list<list<binary>> field_1;
}
struct struct_optional_list_list_string {
  1: optional list<list<string>> field_1;
}
struct struct_optional_list_list_struct_empty {
  1: optional list<list<struct_empty>> field_1;
}
struct struct_optional_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
struct struct_optional_set_byte {
  1: optional set<byte> field_1;
}
struct struct_optional_set_i16 {
  1: optional set<i16> field_1;
}
struct struct_optional_set_i32 {
  1: optional set<i32> field_1;
}
struct struct_optional_set_i64 {
  1: optional set<i64> field_1;
}
struct struct_optional_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
struct struct_optional_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
struct struct_optional_set_binary {
  1: optional set<binary> field_1;
}
struct struct_optional_set_string {
  1: optional set<string> field_1;
}
struct struct_optional_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
struct struct_optional_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
struct struct_optional_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
struct struct_optional_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
struct struct_optional_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
struct struct_optional_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
struct struct_optional_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
struct struct_optional_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
struct struct_optional_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
struct struct_optional_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
struct struct_optional_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
struct struct_optional_map_string_bool {
  1: optional map<string, bool> field_1;
}
struct struct_optional_map_string_byte {
  1: optional map<string, byte> field_1;
}
struct struct_optional_map_string_i16 {
  1: optional map<string, i16> field_1;
}
struct struct_optional_map_string_i32 {
  1: optional map<string, i32> field_1;
}
struct struct_optional_map_string_i64 {
  1: optional map<string, i64> field_1;
}
struct struct_optional_map_string_float {
  1: optional map<string, float> field_1;
}
struct struct_optional_map_string_double {
  1: optional map<string, double> field_1;
}
struct struct_optional_map_string_binary {
  1: optional map<string, binary> field_1;
}
struct struct_optional_map_string_string {
  1: optional map<string, string> field_1;
}
struct struct_optional_map_string_struct_empty {
  1: optional map<string, struct_empty> field_1;
}
struct struct_optional_map_i64_bool {
  1: optional map<i64, bool> field_1;
}
struct struct_optional_map_i64_byte {
  1: optional map<i64, byte> field_1;
}
struct struct_optional_map_i64_i16 {
  1: optional map<i64, i16> field_1;
}
struct struct_optional_map_i64_i32 {
  1: optional map<i64, i32> field_1;
}
struct struct_optional_map_i64_i64 {
  1: optional map<i64, i64> field_1;
}
struct struct_optional_map_i64_float {
  1: optional map<i64, float> field_1;
}
struct struct_optional_map_i64_double {
  1: optional map<i64, double> field_1;
}
struct struct_optional_map_i64_binary {
  1: optional map<i64, binary> field_1;
}
struct struct_optional_map_i64_string {
  1: optional map<i64, string> field_1;
}
struct struct_optional_map_i64_struct_empty {
  1: optional map<i64, struct_empty> field_1;
}
struct struct_optional_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
struct struct_optional_map_string_set_byte {
  1: optional map<string, set<byte>> field_1;
}
struct struct_optional_map_string_set_i16 {
  1: optional map<string, set<i16>> field_1;
}
struct struct_optional_map_string_set_i32 {
  1: optional map<string, set<i32>> field_1;
}
struct struct_optional_map_string_set_i64 {
  1: optional map<string, set<i64>> field_1;
}
struct struct_optional_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
struct struct_optional_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
struct struct_optional_map_string_set_binary {
  1: optional map<string, set<binary>> field_1;
}
struct struct_optional_map_string_set_string {
  1: optional map<string, set<string>> field_1;
}
struct struct_optional_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
struct struct_optional_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
struct struct_optional_map_i64_set_byte {
  1: optional map<i64, set<byte>> field_1;
}
struct struct_optional_map_i64_set_i16 {
  1: optional map<i64, set<i16>> field_1;
}
struct struct_optional_map_i64_set_i32 {
  1: optional map<i64, set<i32>> field_1;
}
struct struct_optional_map_i64_set_i64 {
  1: optional map<i64, set<i64>> field_1;
}
struct struct_optional_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
struct struct_optional_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
struct struct_optional_map_i64_set_binary {
  1: optional map<i64, set<binary>> field_1;
}
struct struct_optional_map_i64_set_string {
  1: optional map<i64, set<string>> field_1;
}
struct struct_optional_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
struct struct_optional_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
struct struct_optional_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
struct struct_optional_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
struct struct_optional_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
struct struct_optional_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
struct struct_optional_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
struct struct_optional_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
struct struct_optional_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
struct struct_optional_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
struct struct_optional_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
struct struct_optional_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
struct struct_optional_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
struct struct_optional_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
struct struct_optional_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
struct struct_optional_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
struct struct_optional_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
struct struct_optional_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
struct struct_optional_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
struct struct_optional_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
struct struct_optional_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
struct struct_optional_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
struct struct_optional_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
struct struct_optional_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
struct struct_optional_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
struct struct_optional_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
struct struct_optional_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
struct struct_optional_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
struct struct_optional_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
struct struct_optional_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
struct struct_optional_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
struct struct_optional_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
struct struct_optional_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
struct struct_optional_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
struct struct_optional_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
struct struct_optional_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
struct struct_optional_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
struct struct_optional_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
struct struct_optional_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
struct struct_optional_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
struct struct_optional_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
struct struct_optional_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
struct struct_optional_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
struct struct_optional_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
struct struct_optional_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
struct struct_optional_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
struct struct_optional_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
struct struct_optional_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
struct struct_optional_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
struct struct_optional_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
struct struct_optional_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
struct struct_optional_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
struct struct_optional_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
struct struct_optional_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
struct struct_optional_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
struct struct_optional_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
struct struct_optional_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
struct struct_optional_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
struct struct_optional_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
struct struct_optional_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
struct struct_optional_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
struct struct_optional_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
struct struct_optional_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
struct struct_optional_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
struct struct_optional_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
struct struct_optional_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
struct struct_optional_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
struct struct_optional_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
struct struct_optional_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
struct struct_optional_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
struct struct_optional_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
struct struct_optional_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
struct struct_optional_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
struct struct_optional_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
struct struct_optional_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
struct struct_optional_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
struct struct_optional_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
struct struct_optional_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
struct struct_optional_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
struct struct_optional_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
struct struct_optional_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
struct struct_optional_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
struct struct_optional_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
struct struct_optional_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
struct struct_optional_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
struct struct_optional_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
struct struct_optional_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
struct struct_optional_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
struct struct_optional_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
struct struct_optional_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
struct struct_optional_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
struct struct_optional_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
struct struct_optional_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
struct struct_optional_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
struct struct_optional_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
struct struct_optional_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
struct struct_optional_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
struct struct_optional_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
struct struct_optional_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
struct struct_optional_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
struct struct_optional_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
struct struct_optional_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
struct struct_optional_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
struct struct_optional_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
struct struct_optional_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
struct struct_optional_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
struct struct_optional_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
struct struct_optional_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
struct struct_optional_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
struct struct_optional_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
struct struct_optional_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
struct struct_optional_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
struct struct_optional_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
struct struct_optional_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
struct struct_optional_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
struct struct_optional_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
struct struct_optional_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
struct struct_optional_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
struct struct_optional_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
struct struct_optional_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
struct struct_optional_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
struct struct_optional_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
struct struct_optional_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
struct struct_optional_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
struct struct_optional_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
struct struct_optional_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
struct struct_optional_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
struct struct_optional_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
struct struct_optional_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
struct struct_optional_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
struct struct_optional_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
struct struct_optional_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
struct struct_optional_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
struct struct_optional_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
struct struct_optional_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
struct struct_optional_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
struct struct_optional_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
struct struct_optional_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
struct struct_optional_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
struct struct_optional_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
struct struct_optional_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
struct struct_optional_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
struct struct_optional_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
struct struct_optional_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
struct struct_optional_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
struct struct_optional_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
struct struct_optional_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
struct struct_optional_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
struct struct_optional_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
struct struct_optional_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
struct struct_optional_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
struct struct_optional_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
struct struct_optional_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
struct struct_optional_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
struct struct_optional_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
struct struct_optional_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
struct struct_optional_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
struct struct_optional_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
struct struct_optional_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
struct struct_optional_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
struct struct_optional_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
struct struct_optional_bool {
  1: optional bool field_1;
}
struct struct_optional_byte {
  1: optional byte field_1;
}
struct struct_optional_i16 {
  1: optional i16 field_1;
}
struct struct_optional_i32 {
  1: optional i32 field_1;
}
struct struct_optional_i64 {
  1: optional i64 field_1;
}
struct struct_optional_float {
  1: optional float field_1;
}
struct struct_optional_double {
  1: optional double field_1;
}
struct struct_optional_binary {
  1: optional binary field_1;
}
struct struct_optional_string {
  1: optional string field_1;
}
struct struct_optional_bool_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
struct struct_optional_byte_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 1;
}
struct struct_optional_i16_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 2;
}
struct struct_optional_i32_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 3;
}
struct struct_optional_i64_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 4;
}
struct struct_optional_float_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 5;
}
struct struct_optional_double_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 6;
}
struct struct_optional_binary_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "7";
}
struct struct_optional_string_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "8";
}
struct struct_optional_bool_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
struct struct_optional_byte_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 10;
}
struct struct_optional_i16_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 20;
}
struct struct_optional_i32_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 30;
}
struct struct_optional_i64_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 40;
}
struct struct_optional_float_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 50;
}
struct struct_optional_double_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 60;
}
struct struct_optional_binary_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "70";
}
struct struct_optional_string_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "80";
}
struct struct_required_list_bool {
  1: required list<bool> field_1;
}
struct struct_required_list_byte {
  1: required list<byte> field_1;
}
struct struct_required_list_i16 {
  1: required list<i16> field_1;
}
struct struct_required_list_i32 {
  1: required list<i32> field_1;
}
struct struct_required_list_i64 {
  1: required list<i64> field_1;
}
struct struct_required_list_float {
  1: required list<float> field_1;
}
struct struct_required_list_double {
  1: required list<double> field_1;
}
struct struct_required_list_binary {
  1: required list<binary> field_1;
}
struct struct_required_list_string {
  1: required list<string> field_1;
}
struct struct_required_list_struct_empty {
  1: required list<struct_empty> field_1;
}
struct struct_required_list_list_bool {
  1: required list<list<bool>> field_1;
}
struct struct_required_list_list_byte {
  1: required list<list<byte>> field_1;
}
struct struct_required_list_list_i16 {
  1: required list<list<i16>> field_1;
}
struct struct_required_list_list_i32 {
  1: required list<list<i32>> field_1;
}
struct struct_required_list_list_i64 {
  1: required list<list<i64>> field_1;
}
struct struct_required_list_list_float {
  1: required list<list<float>> field_1;
}
struct struct_required_list_list_double {
  1: required list<list<double>> field_1;
}
struct struct_required_list_list_binary {
  1: required list<list<binary>> field_1;
}
struct struct_required_list_list_string {
  1: required list<list<string>> field_1;
}
struct struct_required_list_list_struct_empty {
  1: required list<list<struct_empty>> field_1;
}
struct struct_required_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
struct struct_required_set_byte {
  1: required set<byte> field_1;
}
struct struct_required_set_i16 {
  1: required set<i16> field_1;
}
struct struct_required_set_i32 {
  1: required set<i32> field_1;
}
struct struct_required_set_i64 {
  1: required set<i64> field_1;
}
struct struct_required_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
struct struct_required_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
struct struct_required_set_binary {
  1: required set<binary> field_1;
}
struct struct_required_set_string {
  1: required set<string> field_1;
}
struct struct_required_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
struct struct_required_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
struct struct_required_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
struct struct_required_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
struct struct_required_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
struct struct_required_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
struct struct_required_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
struct struct_required_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
struct struct_required_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
struct struct_required_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
struct struct_required_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
struct struct_required_map_string_bool {
  1: required map<string, bool> field_1;
}
struct struct_required_map_string_byte {
  1: required map<string, byte> field_1;
}
struct struct_required_map_string_i16 {
  1: required map<string, i16> field_1;
}
struct struct_required_map_string_i32 {
  1: required map<string, i32> field_1;
}
struct struct_required_map_string_i64 {
  1: required map<string, i64> field_1;
}
struct struct_required_map_string_float {
  1: required map<string, float> field_1;
}
struct struct_required_map_string_double {
  1: required map<string, double> field_1;
}
struct struct_required_map_string_binary {
  1: required map<string, binary> field_1;
}
struct struct_required_map_string_string {
  1: required map<string, string> field_1;
}
struct struct_required_map_string_struct_empty {
  1: required map<string, struct_empty> field_1;
}
struct struct_required_map_i64_bool {
  1: required map<i64, bool> field_1;
}
struct struct_required_map_i64_byte {
  1: required map<i64, byte> field_1;
}
struct struct_required_map_i64_i16 {
  1: required map<i64, i16> field_1;
}
struct struct_required_map_i64_i32 {
  1: required map<i64, i32> field_1;
}
struct struct_required_map_i64_i64 {
  1: required map<i64, i64> field_1;
}
struct struct_required_map_i64_float {
  1: required map<i64, float> field_1;
}
struct struct_required_map_i64_double {
  1: required map<i64, double> field_1;
}
struct struct_required_map_i64_binary {
  1: required map<i64, binary> field_1;
}
struct struct_required_map_i64_string {
  1: required map<i64, string> field_1;
}
struct struct_required_map_i64_struct_empty {
  1: required map<i64, struct_empty> field_1;
}
struct struct_required_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
struct struct_required_map_string_set_byte {
  1: required map<string, set<byte>> field_1;
}
struct struct_required_map_string_set_i16 {
  1: required map<string, set<i16>> field_1;
}
struct struct_required_map_string_set_i32 {
  1: required map<string, set<i32>> field_1;
}
struct struct_required_map_string_set_i64 {
  1: required map<string, set<i64>> field_1;
}
struct struct_required_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
struct struct_required_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
struct struct_required_map_string_set_binary {
  1: required map<string, set<binary>> field_1;
}
struct struct_required_map_string_set_string {
  1: required map<string, set<string>> field_1;
}
struct struct_required_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
struct struct_required_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
struct struct_required_map_i64_set_byte {
  1: required map<i64, set<byte>> field_1;
}
struct struct_required_map_i64_set_i16 {
  1: required map<i64, set<i16>> field_1;
}
struct struct_required_map_i64_set_i32 {
  1: required map<i64, set<i32>> field_1;
}
struct struct_required_map_i64_set_i64 {
  1: required map<i64, set<i64>> field_1;
}
struct struct_required_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
struct struct_required_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
struct struct_required_map_i64_set_binary {
  1: required map<i64, set<binary>> field_1;
}
struct struct_required_map_i64_set_string {
  1: required map<i64, set<string>> field_1;
}
struct struct_required_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
struct struct_required_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
struct struct_required_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
struct struct_required_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
struct struct_required_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
struct struct_required_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
struct struct_required_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
struct struct_required_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
struct struct_required_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
struct struct_required_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
struct struct_required_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
struct struct_required_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
struct struct_required_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
struct struct_required_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
struct struct_required_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
struct struct_required_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
struct struct_required_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
struct struct_required_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
struct struct_required_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
struct struct_required_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
struct struct_required_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
struct struct_required_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
struct struct_required_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
struct struct_required_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
struct struct_required_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
struct struct_required_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
struct struct_required_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
struct struct_required_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
struct struct_required_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
struct struct_required_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
struct struct_required_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
struct struct_required_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
struct struct_required_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
struct struct_required_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
struct struct_required_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
struct struct_required_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
struct struct_required_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
struct struct_required_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
struct struct_required_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
struct struct_required_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
struct struct_required_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
struct struct_required_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
struct struct_required_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
struct struct_required_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
struct struct_required_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
struct struct_required_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
struct struct_required_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
struct struct_required_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
struct struct_required_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
struct struct_required_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
struct struct_required_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
struct struct_required_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
struct struct_required_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
struct struct_required_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
struct struct_required_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
struct struct_required_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
struct struct_required_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
struct struct_required_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
struct struct_required_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
struct struct_required_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
struct struct_required_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
struct struct_required_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
struct struct_required_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
struct struct_required_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
struct struct_required_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
struct struct_required_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
struct struct_required_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
struct struct_required_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
struct struct_required_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
struct struct_required_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
struct struct_required_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
struct struct_required_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
struct struct_required_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
struct struct_required_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
struct struct_required_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
struct struct_required_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
struct struct_required_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
struct struct_required_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
struct struct_required_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
struct struct_required_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
struct struct_required_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
struct struct_required_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
struct struct_required_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
struct struct_required_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
struct struct_required_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
struct struct_required_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
struct struct_required_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
struct struct_required_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
struct struct_required_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
struct struct_required_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
struct struct_required_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
struct struct_required_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
struct struct_required_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
struct struct_required_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
struct struct_required_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
struct struct_required_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
struct struct_required_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
struct struct_required_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
struct struct_required_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
struct struct_required_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
struct struct_required_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
struct struct_required_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
struct struct_required_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
struct struct_required_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
struct struct_required_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
struct struct_required_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
struct struct_required_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
struct struct_required_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
struct struct_required_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
struct struct_required_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
struct struct_required_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
struct struct_required_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
struct struct_required_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
struct struct_required_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
struct struct_required_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
struct struct_required_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
struct struct_required_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
struct struct_required_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
struct struct_required_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
struct struct_required_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
struct struct_required_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
struct struct_required_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
struct struct_required_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
struct struct_required_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
struct struct_required_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
struct struct_required_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
struct struct_required_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
struct struct_required_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
struct struct_required_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
struct struct_required_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
struct struct_required_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
struct struct_required_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
struct struct_required_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
struct struct_required_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
struct struct_required_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
struct struct_required_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
struct struct_required_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
struct struct_required_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
struct struct_required_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
struct struct_required_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
struct struct_required_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
struct struct_required_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
struct struct_required_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
struct struct_required_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
struct struct_required_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
struct struct_required_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
struct struct_required_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
struct struct_required_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
struct struct_required_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
struct struct_required_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
struct struct_required_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
struct struct_required_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
struct struct_required_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
struct struct_required_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
struct struct_required_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
struct struct_required_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
struct struct_required_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
struct struct_required_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
struct struct_required_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
struct struct_required_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
struct struct_required_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
struct struct_required_bool {
  1: required bool field_1;
}
struct struct_required_byte {
  1: required byte field_1;
}
struct struct_required_i16 {
  1: required i16 field_1;
}
struct struct_required_i32 {
  1: required i32 field_1;
}
struct struct_required_i64 {
  1: required i64 field_1;
}
struct struct_required_float {
  1: required float field_1;
}
struct struct_required_double {
  1: required double field_1;
}
struct struct_required_binary {
  1: required binary field_1;
}
struct struct_required_string {
  1: required string field_1;
}
struct struct_required_bool_custom_default {
  1: required bool field_1 = true;
}
struct struct_required_byte_custom_default {
  1: required byte field_1 = 1;
}
struct struct_required_i16_custom_default {
  1: required i16 field_1 = 2;
}
struct struct_required_i32_custom_default {
  1: required i32 field_1 = 3;
}
struct struct_required_i64_custom_default {
  1: required i64 field_1 = 4;
}
struct struct_required_float_custom_default {
  1: required float field_1 = 5;
}
struct struct_required_double_custom_default {
  1: required double field_1 = 6;
}
struct struct_required_binary_custom_default {
  1: required binary field_1 = "7";
}
struct struct_required_string_custom_default {
  1: required string field_1 = "8";
}
struct struct_required_bool_alternative_custom_default {
  1: required bool field_1 = true;
}
struct struct_required_byte_alternative_custom_default {
  1: required byte field_1 = 10;
}
struct struct_required_i16_alternative_custom_default {
  1: required i16 field_1 = 20;
}
struct struct_required_i32_alternative_custom_default {
  1: required i32 field_1 = 30;
}
struct struct_required_i64_alternative_custom_default {
  1: required i64 field_1 = 40;
}
struct struct_required_float_alternative_custom_default {
  1: required float field_1 = 50;
}
struct struct_required_double_alternative_custom_default {
  1: required double field_1 = 60;
}
struct struct_required_binary_alternative_custom_default {
  1: required binary field_1 = "70";
}
struct struct_required_string_alternative_custom_default {
  1: required string field_1 = "80";
}
struct struct_terse_list_bool {
  @thrift.TerseWrite
  1: list<bool> field_1;
}
struct struct_terse_list_byte {
  @thrift.TerseWrite
  1: list<byte> field_1;
}
struct struct_terse_list_i16 {
  @thrift.TerseWrite
  1: list<i16> field_1;
}
struct struct_terse_list_i32 {
  @thrift.TerseWrite
  1: list<i32> field_1;
}
struct struct_terse_list_i64 {
  @thrift.TerseWrite
  1: list<i64> field_1;
}
struct struct_terse_list_float {
  @thrift.TerseWrite
  1: list<float> field_1;
}
struct struct_terse_list_double {
  @thrift.TerseWrite
  1: list<double> field_1;
}
struct struct_terse_list_binary {
  @thrift.TerseWrite
  1: list<binary> field_1;
}
struct struct_terse_list_string {
  @thrift.TerseWrite
  1: list<string> field_1;
}
struct struct_terse_list_struct_empty {
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
struct struct_terse_list_list_bool {
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
struct struct_terse_list_list_byte {
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
struct struct_terse_list_list_i16 {
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
struct struct_terse_list_list_i32 {
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
struct struct_terse_list_list_i64 {
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
struct struct_terse_list_list_float {
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
struct struct_terse_list_list_double {
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
struct struct_terse_list_list_binary {
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
struct struct_terse_list_list_string {
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
struct struct_terse_list_list_struct_empty {
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
struct struct_terse_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
struct struct_terse_set_byte {
  @thrift.TerseWrite
  1: set<byte> field_1;
}
struct struct_terse_set_i16 {
  @thrift.TerseWrite
  1: set<i16> field_1;
}
struct struct_terse_set_i32 {
  @thrift.TerseWrite
  1: set<i32> field_1;
}
struct struct_terse_set_i64 {
  @thrift.TerseWrite
  1: set<i64> field_1;
}
struct struct_terse_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
struct struct_terse_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
struct struct_terse_set_binary {
  @thrift.TerseWrite
  1: set<binary> field_1;
}
struct struct_terse_set_string {
  @thrift.TerseWrite
  1: set<string> field_1;
}
struct struct_terse_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
struct struct_terse_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
struct struct_terse_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
struct struct_terse_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
struct struct_terse_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
struct struct_terse_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
struct struct_terse_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
struct struct_terse_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
struct struct_terse_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
struct struct_terse_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
struct struct_terse_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
struct struct_terse_map_string_bool {
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
struct struct_terse_map_string_byte {
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
struct struct_terse_map_string_i16 {
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
struct struct_terse_map_string_i32 {
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
struct struct_terse_map_string_i64 {
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
struct struct_terse_map_string_float {
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
struct struct_terse_map_string_double {
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
struct struct_terse_map_string_binary {
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
struct struct_terse_map_string_string {
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
struct struct_terse_map_string_struct_empty {
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
struct struct_terse_map_i64_bool {
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
struct struct_terse_map_i64_byte {
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
struct struct_terse_map_i64_i16 {
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
struct struct_terse_map_i64_i32 {
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
struct struct_terse_map_i64_i64 {
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
struct struct_terse_map_i64_float {
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
struct struct_terse_map_i64_double {
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
struct struct_terse_map_i64_binary {
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
struct struct_terse_map_i64_string {
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
struct struct_terse_map_i64_struct_empty {
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
struct struct_terse_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
struct struct_terse_map_string_set_byte {
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
struct struct_terse_map_string_set_i16 {
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
struct struct_terse_map_string_set_i32 {
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
struct struct_terse_map_string_set_i64 {
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
struct struct_terse_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
struct struct_terse_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
struct struct_terse_map_string_set_binary {
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
struct struct_terse_map_string_set_string {
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
struct struct_terse_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
struct struct_terse_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
struct struct_terse_map_i64_set_byte {
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
struct struct_terse_map_i64_set_i16 {
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
struct struct_terse_map_i64_set_i32 {
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
struct struct_terse_map_i64_set_i64 {
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
struct struct_terse_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
struct struct_terse_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
struct struct_terse_map_i64_set_binary {
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
struct struct_terse_map_i64_set_string {
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
struct struct_terse_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_terse_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
struct struct_terse_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
struct struct_terse_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
struct struct_terse_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
struct struct_terse_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
struct struct_terse_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
struct struct_terse_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
struct struct_terse_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
struct struct_terse_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
struct struct_terse_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
struct struct_terse_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
struct struct_terse_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
struct struct_terse_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
struct struct_terse_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
struct struct_terse_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
struct struct_terse_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
struct struct_terse_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
struct struct_terse_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
struct struct_terse_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
struct struct_terse_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
struct struct_terse_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
struct struct_terse_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
struct struct_terse_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
struct struct_terse_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
struct struct_terse_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
struct struct_terse_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
struct struct_terse_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
struct struct_terse_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
struct struct_terse_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
struct struct_terse_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
struct struct_terse_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
struct struct_terse_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
struct struct_terse_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
struct struct_terse_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
struct struct_terse_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
struct struct_terse_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
struct struct_terse_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
struct struct_terse_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
struct struct_terse_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
struct struct_terse_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
struct struct_terse_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
struct struct_terse_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
struct struct_terse_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
struct struct_terse_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
struct struct_terse_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
struct struct_terse_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
struct struct_terse_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
struct struct_terse_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
struct struct_terse_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
struct struct_terse_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
struct struct_terse_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
struct struct_terse_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
struct struct_terse_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
struct struct_terse_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
struct struct_terse_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
struct struct_terse_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
struct struct_terse_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
struct struct_terse_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
struct struct_terse_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
struct struct_terse_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
struct struct_terse_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
struct struct_terse_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
struct struct_terse_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
struct struct_terse_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
struct struct_terse_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
struct struct_terse_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
struct struct_terse_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
struct struct_terse_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
struct struct_terse_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
struct struct_terse_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
struct struct_terse_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
struct struct_terse_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
struct struct_terse_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
struct struct_terse_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
struct struct_terse_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
struct struct_terse_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
struct struct_terse_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
struct struct_terse_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
struct struct_terse_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
struct struct_terse_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_terse_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
struct struct_terse_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
struct struct_terse_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
struct struct_terse_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
struct struct_terse_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
struct struct_terse_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
struct struct_terse_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
struct struct_terse_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
struct struct_terse_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
struct struct_terse_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
struct struct_terse_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
struct struct_terse_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
struct struct_terse_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
struct struct_terse_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
struct struct_terse_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
struct struct_terse_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
struct struct_terse_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
struct struct_terse_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
struct struct_terse_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
struct struct_terse_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
struct struct_terse_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
struct struct_terse_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
struct struct_terse_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
struct struct_terse_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
struct struct_terse_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
struct struct_terse_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
struct struct_terse_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
struct struct_terse_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
struct struct_terse_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
struct struct_terse_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
struct struct_terse_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
struct struct_terse_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
struct struct_terse_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
struct struct_terse_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
struct struct_terse_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
struct struct_terse_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
struct struct_terse_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
struct struct_terse_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
struct struct_terse_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
struct struct_terse_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
struct struct_terse_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
struct struct_terse_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
struct struct_terse_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
struct struct_terse_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
struct struct_terse_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
struct struct_terse_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
struct struct_terse_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
struct struct_terse_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
struct struct_terse_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
struct struct_terse_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
struct struct_terse_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
struct struct_terse_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
struct struct_terse_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
struct struct_terse_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
struct struct_terse_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
struct struct_terse_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
struct struct_terse_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
struct struct_terse_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
struct struct_terse_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
struct struct_terse_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
struct struct_terse_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
struct struct_terse_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
struct struct_terse_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
struct struct_terse_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
struct struct_terse_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
struct struct_terse_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
struct struct_terse_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
struct struct_terse_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
struct struct_terse_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
struct struct_terse_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
struct struct_terse_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
struct struct_terse_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
struct struct_terse_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
struct struct_terse_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
struct struct_terse_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
struct struct_terse_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
struct struct_terse_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
struct struct_terse_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
struct struct_terse_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
struct struct_terse_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_terse_bool {
  @thrift.TerseWrite
  1: bool field_1;
}
struct struct_terse_byte {
  @thrift.TerseWrite
  1: byte field_1;
}
struct struct_terse_i16 {
  @thrift.TerseWrite
  1: i16 field_1;
}
struct struct_terse_i32 {
  @thrift.TerseWrite
  1: i32 field_1;
}
struct struct_terse_i64 {
  @thrift.TerseWrite
  1: i64 field_1;
}
struct struct_terse_float {
  @thrift.TerseWrite
  1: float field_1;
}
struct struct_terse_double {
  @thrift.TerseWrite
  1: double field_1;
}
struct struct_terse_binary {
  @thrift.TerseWrite
  1: binary field_1;
}
struct struct_terse_string {
  @thrift.TerseWrite
  1: string field_1;
}
struct struct_optional_list_bool_box {
  @thrift.Box
  1: optional list<bool> field_1;
}
struct struct_optional_list_byte_box {
  @thrift.Box
  1: optional list<byte> field_1;
}
struct struct_optional_list_i16_box {
  @thrift.Box
  1: optional list<i16> field_1;
}
struct struct_optional_list_i32_box {
  @thrift.Box
  1: optional list<i32> field_1;
}
struct struct_optional_list_i64_box {
  @thrift.Box
  1: optional list<i64> field_1;
}
struct struct_optional_list_float_box {
  @thrift.Box
  1: optional list<float> field_1;
}
struct struct_optional_list_double_box {
  @thrift.Box
  1: optional list<double> field_1;
}
struct struct_optional_list_binary_box {
  @thrift.Box
  1: optional list<binary> field_1;
}
struct struct_optional_list_string_box {
  @thrift.Box
  1: optional list<string> field_1;
}
struct struct_optional_list_struct_empty_box {
  @thrift.Box
  1: optional list<struct_empty> field_1;
}
struct struct_optional_list_list_bool_box {
  @thrift.Box
  1: optional list<list<bool>> field_1;
}
struct struct_optional_list_list_byte_box {
  @thrift.Box
  1: optional list<list<byte>> field_1;
}
struct struct_optional_list_list_i16_box {
  @thrift.Box
  1: optional list<list<i16>> field_1;
}
struct struct_optional_list_list_i32_box {
  @thrift.Box
  1: optional list<list<i32>> field_1;
}
struct struct_optional_list_list_i64_box {
  @thrift.Box
  1: optional list<list<i64>> field_1;
}
struct struct_optional_list_list_float_box {
  @thrift.Box
  1: optional list<list<float>> field_1;
}
struct struct_optional_list_list_double_box {
  @thrift.Box
  1: optional list<list<double>> field_1;
}
struct struct_optional_list_list_binary_box {
  @thrift.Box
  1: optional list<list<binary>> field_1;
}
struct struct_optional_list_list_string_box {
  @thrift.Box
  1: optional list<list<string>> field_1;
}
struct struct_optional_list_list_struct_empty_box {
  @thrift.Box
  1: optional list<list<struct_empty>> field_1;
}
struct struct_optional_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
struct struct_optional_set_byte_box {
  @thrift.Box
  1: optional set<byte> field_1;
}
struct struct_optional_set_i16_box {
  @thrift.Box
  1: optional set<i16> field_1;
}
struct struct_optional_set_i32_box {
  @thrift.Box
  1: optional set<i32> field_1;
}
struct struct_optional_set_i64_box {
  @thrift.Box
  1: optional set<i64> field_1;
}
struct struct_optional_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
struct struct_optional_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
struct struct_optional_set_binary_box {
  @thrift.Box
  1: optional set<binary> field_1;
}
struct struct_optional_set_string_box {
  @thrift.Box
  1: optional set<string> field_1;
}
struct struct_optional_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
struct struct_optional_set_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
struct struct_optional_set_set_byte_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
struct struct_optional_set_set_i16_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
struct struct_optional_set_set_i32_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
struct struct_optional_set_set_i64_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
struct struct_optional_set_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
struct struct_optional_set_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
struct struct_optional_set_set_binary_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
struct struct_optional_set_set_string_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
struct struct_optional_set_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
struct struct_optional_map_string_bool_box {
  @thrift.Box
  1: optional map<string, bool> field_1;
}
struct struct_optional_map_string_byte_box {
  @thrift.Box
  1: optional map<string, byte> field_1;
}
struct struct_optional_map_string_i16_box {
  @thrift.Box
  1: optional map<string, i16> field_1;
}
struct struct_optional_map_string_i32_box {
  @thrift.Box
  1: optional map<string, i32> field_1;
}
struct struct_optional_map_string_i64_box {
  @thrift.Box
  1: optional map<string, i64> field_1;
}
struct struct_optional_map_string_float_box {
  @thrift.Box
  1: optional map<string, float> field_1;
}
struct struct_optional_map_string_double_box {
  @thrift.Box
  1: optional map<string, double> field_1;
}
struct struct_optional_map_string_binary_box {
  @thrift.Box
  1: optional map<string, binary> field_1;
}
struct struct_optional_map_string_string_box {
  @thrift.Box
  1: optional map<string, string> field_1;
}
struct struct_optional_map_string_struct_empty_box {
  @thrift.Box
  1: optional map<string, struct_empty> field_1;
}
struct struct_optional_map_i64_bool_box {
  @thrift.Box
  1: optional map<i64, bool> field_1;
}
struct struct_optional_map_i64_byte_box {
  @thrift.Box
  1: optional map<i64, byte> field_1;
}
struct struct_optional_map_i64_i16_box {
  @thrift.Box
  1: optional map<i64, i16> field_1;
}
struct struct_optional_map_i64_i32_box {
  @thrift.Box
  1: optional map<i64, i32> field_1;
}
struct struct_optional_map_i64_i64_box {
  @thrift.Box
  1: optional map<i64, i64> field_1;
}
struct struct_optional_map_i64_float_box {
  @thrift.Box
  1: optional map<i64, float> field_1;
}
struct struct_optional_map_i64_double_box {
  @thrift.Box
  1: optional map<i64, double> field_1;
}
struct struct_optional_map_i64_binary_box {
  @thrift.Box
  1: optional map<i64, binary> field_1;
}
struct struct_optional_map_i64_string_box {
  @thrift.Box
  1: optional map<i64, string> field_1;
}
struct struct_optional_map_i64_struct_empty_box {
  @thrift.Box
  1: optional map<i64, struct_empty> field_1;
}
struct struct_optional_map_string_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
struct struct_optional_map_string_set_byte_box {
  @thrift.Box
  1: optional map<string, set<byte>> field_1;
}
struct struct_optional_map_string_set_i16_box {
  @thrift.Box
  1: optional map<string, set<i16>> field_1;
}
struct struct_optional_map_string_set_i32_box {
  @thrift.Box
  1: optional map<string, set<i32>> field_1;
}
struct struct_optional_map_string_set_i64_box {
  @thrift.Box
  1: optional map<string, set<i64>> field_1;
}
struct struct_optional_map_string_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
struct struct_optional_map_string_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
struct struct_optional_map_string_set_binary_box {
  @thrift.Box
  1: optional map<string, set<binary>> field_1;
}
struct struct_optional_map_string_set_string_box {
  @thrift.Box
  1: optional map<string, set<string>> field_1;
}
struct struct_optional_map_string_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
struct struct_optional_map_i64_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
struct struct_optional_map_i64_set_byte_box {
  @thrift.Box
  1: optional map<i64, set<byte>> field_1;
}
struct struct_optional_map_i64_set_i16_box {
  @thrift.Box
  1: optional map<i64, set<i16>> field_1;
}
struct struct_optional_map_i64_set_i32_box {
  @thrift.Box
  1: optional map<i64, set<i32>> field_1;
}
struct struct_optional_map_i64_set_i64_box {
  @thrift.Box
  1: optional map<i64, set<i64>> field_1;
}
struct struct_optional_map_i64_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
struct struct_optional_map_i64_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
struct struct_optional_map_i64_set_binary_box {
  @thrift.Box
  1: optional map<i64, set<binary>> field_1;
}
struct struct_optional_map_i64_set_string_box {
  @thrift.Box
  1: optional map<i64, set<string>> field_1;
}
struct struct_optional_map_i64_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
struct struct_adapted_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_bool'}
  1: bool field_1;
}
struct struct_adapted_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_byte'}
  1: byte field_1;
}
struct struct_adapted_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i16'}
  1: i16 field_1;
}
struct struct_adapted_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i32'}
  1: i32 field_1;
}
struct struct_adapted_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i64'}
  1: i64 field_1;
}
struct struct_adapted_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_float'}
  1: float field_1;
}
struct struct_adapted_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_double'}
  1: double field_1;
}
struct struct_adapted_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_binary'}
  1: binary field_1;
}
struct struct_adapted_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_string'}
  1: string field_1;
}
struct struct_adapted_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_bool'}
  1: list<bool> field_1;
}
struct struct_adapted_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_byte'}
  1: list<byte> field_1;
}
struct struct_adapted_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i16'}
  1: list<i16> field_1;
}
struct struct_adapted_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i32'}
  1: list<i32> field_1;
}
struct struct_adapted_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i64'}
  1: list<i64> field_1;
}
struct struct_adapted_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_float'}
  1: list<float> field_1;
}
struct struct_adapted_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_double'}
  1: list<double> field_1;
}
struct struct_adapted_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_binary'}
  1: list<binary> field_1;
}
struct struct_adapted_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_string'}
  1: list<string> field_1;
}
struct struct_adapted_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_struct_empty'}
  1: list<struct_empty> field_1;
}
struct struct_adapted_list_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_bool'}
  1: list<list<bool>> field_1;
}
struct struct_adapted_list_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_byte'}
  1: list<list<byte>> field_1;
}
struct struct_adapted_list_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i16'}
  1: list<list<i16>> field_1;
}
struct struct_adapted_list_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i32'}
  1: list<list<i32>> field_1;
}
struct struct_adapted_list_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i64'}
  1: list<list<i64>> field_1;
}
struct struct_adapted_list_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_float'}
  1: list<list<float>> field_1;
}
struct struct_adapted_list_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_double'}
  1: list<list<double>> field_1;
}
struct struct_adapted_list_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_binary'}
  1: list<list<binary>> field_1;
}
struct struct_adapted_list_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_string'}
  1: list<list<string>> field_1;
}
struct struct_adapted_list_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_struct_empty'}
  1: list<list<struct_empty>> field_1;
}
struct struct_adapted_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_adapted_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_byte'}
  1: set<byte> field_1;
}
struct struct_adapted_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i16'}
  1: set<i16> field_1;
}
struct struct_adapted_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i32'}
  1: set<i32> field_1;
}
struct struct_adapted_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i64'}
  1: set<i64> field_1;
}
struct struct_adapted_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_adapted_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_adapted_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_binary'}
  1: set<binary> field_1;
}
struct struct_adapted_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_string'}
  1: set<string> field_1;
}
struct struct_adapted_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_adapted_set_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_adapted_set_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_byte'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_adapted_set_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i16'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_adapted_set_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i32'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_adapted_set_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i64'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_adapted_set_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_adapted_set_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_adapted_set_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_binary'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_adapted_set_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_string'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_adapted_set_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_adapted_map_string_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_bool'}
  1: map<string, bool> field_1;
}
struct struct_adapted_map_string_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_byte'}
  1: map<string, byte> field_1;
}
struct struct_adapted_map_string_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i16'}
  1: map<string, i16> field_1;
}
struct struct_adapted_map_string_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i32'}
  1: map<string, i32> field_1;
}
struct struct_adapted_map_string_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i64'}
  1: map<string, i64> field_1;
}
struct struct_adapted_map_string_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_float'}
  1: map<string, float> field_1;
}
struct struct_adapted_map_string_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_double'}
  1: map<string, double> field_1;
}
struct struct_adapted_map_string_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_binary'}
  1: map<string, binary> field_1;
}
struct struct_adapted_map_string_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_string'}
  1: map<string, string> field_1;
}
struct struct_adapted_map_string_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_struct_empty'}
  1: map<string, struct_empty> field_1;
}
struct struct_adapted_map_i64_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_bool'}
  1: map<i64, bool> field_1;
}
struct struct_adapted_map_i64_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_byte'}
  1: map<i64, byte> field_1;
}
struct struct_adapted_map_i64_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i16'}
  1: map<i64, i16> field_1;
}
struct struct_adapted_map_i64_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i32'}
  1: map<i64, i32> field_1;
}
struct struct_adapted_map_i64_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i64'}
  1: map<i64, i64> field_1;
}
struct struct_adapted_map_i64_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_float'}
  1: map<i64, float> field_1;
}
struct struct_adapted_map_i64_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_double'}
  1: map<i64, double> field_1;
}
struct struct_adapted_map_i64_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_binary'}
  1: map<i64, binary> field_1;
}
struct struct_adapted_map_i64_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_string'}
  1: map<i64, string> field_1;
}
struct struct_adapted_map_i64_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_struct_empty'}
  1: map<i64, struct_empty> field_1;
}
struct struct_adapted_map_string_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_adapted_map_string_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_byte'}
  1: map<string, set<byte>> field_1;
}
struct struct_adapted_map_string_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i16'}
  1: map<string, set<i16>> field_1;
}
struct struct_adapted_map_string_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i32'}
  1: map<string, set<i32>> field_1;
}
struct struct_adapted_map_string_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i64'}
  1: map<string, set<i64>> field_1;
}
struct struct_adapted_map_string_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_adapted_map_string_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_adapted_map_string_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_binary'}
  1: map<string, set<binary>> field_1;
}
struct struct_adapted_map_string_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_string'}
  1: map<string, set<string>> field_1;
}
struct struct_adapted_map_string_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_adapted_map_i64_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_adapted_map_i64_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_byte'}
  1: map<i64, set<byte>> field_1;
}
struct struct_adapted_map_i64_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i16'}
  1: map<i64, set<i16>> field_1;
}
struct struct_adapted_map_i64_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i32'}
  1: map<i64, set<i32>> field_1;
}
struct struct_adapted_map_i64_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i64'}
  1: map<i64, set<i64>> field_1;
}
struct struct_adapted_map_i64_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_adapted_map_i64_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_adapted_map_i64_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_binary'}
  1: map<i64, set<binary>> field_1;
}
struct struct_adapted_map_i64_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_string'}
  1: map<i64, set<string>> field_1;
}
struct struct_adapted_map_i64_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_field_adapted_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: bool field_1;
}
struct struct_field_adapted_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: byte field_1;
}
struct struct_field_adapted_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i16 field_1;
}
struct struct_field_adapted_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i32 field_1;
}
struct struct_field_adapted_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i64 field_1;
}
struct struct_field_adapted_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: float field_1;
}
struct struct_field_adapted_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: double field_1;
}
struct struct_field_adapted_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: binary field_1;
}
struct struct_field_adapted_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: string field_1;
}
struct struct_field_adapted_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<bool> field_1;
}
struct struct_field_adapted_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<byte> field_1;
}
struct struct_field_adapted_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i16> field_1;
}
struct struct_field_adapted_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i32> field_1;
}
struct struct_field_adapted_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i64> field_1;
}
struct struct_field_adapted_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<float> field_1;
}
struct struct_field_adapted_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<double> field_1;
}
struct struct_field_adapted_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<binary> field_1;
}
struct struct_field_adapted_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<string> field_1;
}
struct struct_field_adapted_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<struct_empty> field_1;
}
struct struct_field_adapted_list_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<bool>> field_1;
}
struct struct_field_adapted_list_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<byte>> field_1;
}
struct struct_field_adapted_list_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i16>> field_1;
}
struct struct_field_adapted_list_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i32>> field_1;
}
struct struct_field_adapted_list_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i64>> field_1;
}
struct struct_field_adapted_list_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<float>> field_1;
}
struct struct_field_adapted_list_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<double>> field_1;
}
struct struct_field_adapted_list_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<binary>> field_1;
}
struct struct_field_adapted_list_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<string>> field_1;
}
struct struct_field_adapted_list_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<struct_empty>> field_1;
}
struct struct_field_adapted_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_field_adapted_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<byte> field_1;
}
struct struct_field_adapted_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i16> field_1;
}
struct struct_field_adapted_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i32> field_1;
}
struct struct_field_adapted_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i64> field_1;
}
struct struct_field_adapted_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_field_adapted_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_field_adapted_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<binary> field_1;
}
struct struct_field_adapted_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<string> field_1;
}
struct struct_field_adapted_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_field_adapted_set_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_field_adapted_set_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_field_adapted_set_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_field_adapted_set_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_field_adapted_set_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_field_adapted_set_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_field_adapted_set_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_field_adapted_set_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_field_adapted_set_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_field_adapted_set_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_field_adapted_map_string_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, bool> field_1;
}
struct struct_field_adapted_map_string_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, byte> field_1;
}
struct struct_field_adapted_map_string_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i16> field_1;
}
struct struct_field_adapted_map_string_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i32> field_1;
}
struct struct_field_adapted_map_string_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i64> field_1;
}
struct struct_field_adapted_map_string_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, float> field_1;
}
struct struct_field_adapted_map_string_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, double> field_1;
}
struct struct_field_adapted_map_string_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, binary> field_1;
}
struct struct_field_adapted_map_string_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, string> field_1;
}
struct struct_field_adapted_map_string_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, struct_empty> field_1;
}
struct struct_field_adapted_map_i64_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, bool> field_1;
}
struct struct_field_adapted_map_i64_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, byte> field_1;
}
struct struct_field_adapted_map_i64_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i16> field_1;
}
struct struct_field_adapted_map_i64_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i32> field_1;
}
struct struct_field_adapted_map_i64_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i64> field_1;
}
struct struct_field_adapted_map_i64_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, float> field_1;
}
struct struct_field_adapted_map_i64_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, double> field_1;
}
struct struct_field_adapted_map_i64_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, binary> field_1;
}
struct struct_field_adapted_map_i64_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, string> field_1;
}
struct struct_field_adapted_map_i64_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, struct_empty> field_1;
}
struct struct_field_adapted_map_string_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_field_adapted_map_string_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<byte>> field_1;
}
struct struct_field_adapted_map_string_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i16>> field_1;
}
struct struct_field_adapted_map_string_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i32>> field_1;
}
struct struct_field_adapted_map_string_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i64>> field_1;
}
struct struct_field_adapted_map_string_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_field_adapted_map_string_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_field_adapted_map_string_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<binary>> field_1;
}
struct struct_field_adapted_map_string_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<string>> field_1;
}
struct struct_field_adapted_map_string_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_field_adapted_map_i64_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_field_adapted_map_i64_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<byte>> field_1;
}
struct struct_field_adapted_map_i64_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i16>> field_1;
}
struct struct_field_adapted_map_i64_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i32>> field_1;
}
struct struct_field_adapted_map_i64_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i64>> field_1;
}
struct struct_field_adapted_map_i64_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_field_adapted_map_i64_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_field_adapted_map_i64_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<binary>> field_1;
}
struct struct_field_adapted_map_i64_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<string>> field_1;
}
struct struct_field_adapted_map_i64_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_list_bool_lazy {
  @cpp.Lazy
  1: list<bool> field_1;
}
struct struct_list_byte_lazy {
  @cpp.Lazy
  1: list<byte> field_1;
}
struct struct_list_i16_lazy {
  @cpp.Lazy
  1: list<i16> field_1;
}
struct struct_list_i32_lazy {
  @cpp.Lazy
  1: list<i32> field_1;
}
struct struct_list_i64_lazy {
  @cpp.Lazy
  1: list<i64> field_1;
}
struct struct_list_float_lazy {
  @cpp.Lazy
  1: list<float> field_1;
}
struct struct_list_double_lazy {
  @cpp.Lazy
  1: list<double> field_1;
}
struct struct_list_binary_lazy {
  @cpp.Lazy
  1: list<binary> field_1;
}
struct struct_list_string_lazy {
  @cpp.Lazy
  1: list<string> field_1;
}
struct struct_list_struct_empty_lazy {
  @cpp.Lazy
  1: list<struct_empty> field_1;
}
struct struct_list_list_bool_lazy {
  @cpp.Lazy
  1: list<list<bool>> field_1;
}
struct struct_list_list_byte_lazy {
  @cpp.Lazy
  1: list<list<byte>> field_1;
}
struct struct_list_list_i16_lazy {
  @cpp.Lazy
  1: list<list<i16>> field_1;
}
struct struct_list_list_i32_lazy {
  @cpp.Lazy
  1: list<list<i32>> field_1;
}
struct struct_list_list_i64_lazy {
  @cpp.Lazy
  1: list<list<i64>> field_1;
}
struct struct_list_list_float_lazy {
  @cpp.Lazy
  1: list<list<float>> field_1;
}
struct struct_list_list_double_lazy {
  @cpp.Lazy
  1: list<list<double>> field_1;
}
struct struct_list_list_binary_lazy {
  @cpp.Lazy
  1: list<list<binary>> field_1;
}
struct struct_list_list_string_lazy {
  @cpp.Lazy
  1: list<list<string>> field_1;
}
struct struct_list_list_struct_empty_lazy {
  @cpp.Lazy
  1: list<list<struct_empty>> field_1;
}
struct struct_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
struct struct_set_byte_lazy {
  @cpp.Lazy
  1: set<byte> field_1;
}
struct struct_set_i16_lazy {
  @cpp.Lazy
  1: set<i16> field_1;
}
struct struct_set_i32_lazy {
  @cpp.Lazy
  1: set<i32> field_1;
}
struct struct_set_i64_lazy {
  @cpp.Lazy
  1: set<i64> field_1;
}
struct struct_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
struct struct_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
struct struct_set_binary_lazy {
  @cpp.Lazy
  1: set<binary> field_1;
}
struct struct_set_string_lazy {
  @cpp.Lazy
  1: set<string> field_1;
}
struct struct_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
struct struct_set_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
struct struct_set_set_byte_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
struct struct_set_set_i16_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
struct struct_set_set_i32_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
struct struct_set_set_i64_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
struct struct_set_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
struct struct_set_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
struct struct_set_set_binary_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
struct struct_set_set_string_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
struct struct_set_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
struct struct_map_string_bool_lazy {
  @cpp.Lazy
  1: map<string, bool> field_1;
}
struct struct_map_string_byte_lazy {
  @cpp.Lazy
  1: map<string, byte> field_1;
}
struct struct_map_string_i16_lazy {
  @cpp.Lazy
  1: map<string, i16> field_1;
}
struct struct_map_string_i32_lazy {
  @cpp.Lazy
  1: map<string, i32> field_1;
}
struct struct_map_string_i64_lazy {
  @cpp.Lazy
  1: map<string, i64> field_1;
}
struct struct_map_string_float_lazy {
  @cpp.Lazy
  1: map<string, float> field_1;
}
struct struct_map_string_double_lazy {
  @cpp.Lazy
  1: map<string, double> field_1;
}
struct struct_map_string_binary_lazy {
  @cpp.Lazy
  1: map<string, binary> field_1;
}
struct struct_map_string_string_lazy {
  @cpp.Lazy
  1: map<string, string> field_1;
}
struct struct_map_string_struct_empty_lazy {
  @cpp.Lazy
  1: map<string, struct_empty> field_1;
}
struct struct_map_i64_bool_lazy {
  @cpp.Lazy
  1: map<i64, bool> field_1;
}
struct struct_map_i64_byte_lazy {
  @cpp.Lazy
  1: map<i64, byte> field_1;
}
struct struct_map_i64_i16_lazy {
  @cpp.Lazy
  1: map<i64, i16> field_1;
}
struct struct_map_i64_i32_lazy {
  @cpp.Lazy
  1: map<i64, i32> field_1;
}
struct struct_map_i64_i64_lazy {
  @cpp.Lazy
  1: map<i64, i64> field_1;
}
struct struct_map_i64_float_lazy {
  @cpp.Lazy
  1: map<i64, float> field_1;
}
struct struct_map_i64_double_lazy {
  @cpp.Lazy
  1: map<i64, double> field_1;
}
struct struct_map_i64_binary_lazy {
  @cpp.Lazy
  1: map<i64, binary> field_1;
}
struct struct_map_i64_string_lazy {
  @cpp.Lazy
  1: map<i64, string> field_1;
}
struct struct_map_i64_struct_empty_lazy {
  @cpp.Lazy
  1: map<i64, struct_empty> field_1;
}
struct struct_map_string_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
struct struct_map_string_set_byte_lazy {
  @cpp.Lazy
  1: map<string, set<byte>> field_1;
}
struct struct_map_string_set_i16_lazy {
  @cpp.Lazy
  1: map<string, set<i16>> field_1;
}
struct struct_map_string_set_i32_lazy {
  @cpp.Lazy
  1: map<string, set<i32>> field_1;
}
struct struct_map_string_set_i64_lazy {
  @cpp.Lazy
  1: map<string, set<i64>> field_1;
}
struct struct_map_string_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
struct struct_map_string_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
struct struct_map_string_set_binary_lazy {
  @cpp.Lazy
  1: map<string, set<binary>> field_1;
}
struct struct_map_string_set_string_lazy {
  @cpp.Lazy
  1: map<string, set<string>> field_1;
}
struct struct_map_string_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
struct struct_map_i64_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
struct struct_map_i64_set_byte_lazy {
  @cpp.Lazy
  1: map<i64, set<byte>> field_1;
}
struct struct_map_i64_set_i16_lazy {
  @cpp.Lazy
  1: map<i64, set<i16>> field_1;
}
struct struct_map_i64_set_i32_lazy {
  @cpp.Lazy
  1: map<i64, set<i32>> field_1;
}
struct struct_map_i64_set_i64_lazy {
  @cpp.Lazy
  1: map<i64, set<i64>> field_1;
}
struct struct_map_i64_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
struct struct_map_i64_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
struct struct_map_i64_set_binary_lazy {
  @cpp.Lazy
  1: map<i64, set<binary>> field_1;
}
struct struct_map_i64_set_string_lazy {
  @cpp.Lazy
  1: map<i64, set<string>> field_1;
}
struct struct_map_i64_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
struct struct_string_lazy {
  @cpp.Lazy
  1: string field_1;
}
@cpp.UseOpEncode
struct struct_empty_op_encoded {
}
@cpp.UseOpEncode
struct struct_list_bool_op_encoded {
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_list_byte_op_encoded {
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_list_i16_op_encoded {
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_list_i32_op_encoded {
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_list_i64_op_encoded {
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_list_float_op_encoded {
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_list_double_op_encoded {
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_list_binary_op_encoded {
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_list_string_op_encoded {
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_list_struct_empty_op_encoded {
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_bool_op_encoded {
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_byte_op_encoded {
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i16_op_encoded {
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i32_op_encoded {
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i64_op_encoded {
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_float_op_encoded {
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_double_op_encoded {
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_binary_op_encoded {
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_string_op_encoded {
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_struct_empty_op_encoded {
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_set_byte_op_encoded {
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_set_i16_op_encoded {
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_set_i32_op_encoded {
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_set_i64_op_encoded {
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_set_binary_op_encoded {
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_set_string_op_encoded {
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_bool_op_encoded {
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_byte_op_encoded {
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i16_op_encoded {
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i32_op_encoded {
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i64_op_encoded {
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_float_op_encoded {
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_double_op_encoded {
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_binary_op_encoded {
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_string_op_encoded {
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_struct_empty_op_encoded {
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_bool_op_encoded {
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_byte_op_encoded {
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i16_op_encoded {
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i32_op_encoded {
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i64_op_encoded {
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_float_op_encoded {
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_double_op_encoded {
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_binary_op_encoded {
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_string_op_encoded {
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_struct_empty_op_encoded {
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_byte_op_encoded {
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i16_op_encoded {
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i32_op_encoded {
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i64_op_encoded {
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_binary_op_encoded {
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_string_op_encoded {
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_byte_op_encoded {
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i16_op_encoded {
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i32_op_encoded {
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i64_op_encoded {
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_binary_op_encoded {
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_string_op_encoded {
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_bool_op_encoded {
  1: bool field_1;
}
@cpp.UseOpEncode
struct struct_byte_op_encoded {
  1: byte field_1;
}
@cpp.UseOpEncode
struct struct_i16_op_encoded {
  1: i16 field_1;
}
@cpp.UseOpEncode
struct struct_i32_op_encoded {
  1: i32 field_1;
}
@cpp.UseOpEncode
struct struct_i64_op_encoded {
  1: i64 field_1;
}
@cpp.UseOpEncode
struct struct_float_op_encoded {
  1: float field_1;
}
@cpp.UseOpEncode
struct struct_double_op_encoded {
  1: double field_1;
}
@cpp.UseOpEncode
struct struct_binary_op_encoded {
  1: binary field_1;
}
@cpp.UseOpEncode
struct struct_string_op_encoded {
  1: string field_1;
}
@cpp.UseOpEncode
struct struct_bool_custom_default_op_encoded {
  1: bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_byte_custom_default_op_encoded {
  1: byte field_1 = 1;
}
@cpp.UseOpEncode
struct struct_i16_custom_default_op_encoded {
  1: i16 field_1 = 2;
}
@cpp.UseOpEncode
struct struct_i32_custom_default_op_encoded {
  1: i32 field_1 = 3;
}
@cpp.UseOpEncode
struct struct_i64_custom_default_op_encoded {
  1: i64 field_1 = 4;
}
@cpp.UseOpEncode
struct struct_float_custom_default_op_encoded {
  1: float field_1 = 5;
}
@cpp.UseOpEncode
struct struct_double_custom_default_op_encoded {
  1: double field_1 = 6;
}
@cpp.UseOpEncode
struct struct_binary_custom_default_op_encoded {
  1: binary field_1 = "7";
}
@cpp.UseOpEncode
struct struct_string_custom_default_op_encoded {
  1: string field_1 = "8";
}
@cpp.UseOpEncode
struct struct_bool_alternative_custom_default_op_encoded {
  1: bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_byte_alternative_custom_default_op_encoded {
  1: byte field_1 = 10;
}
@cpp.UseOpEncode
struct struct_i16_alternative_custom_default_op_encoded {
  1: i16 field_1 = 20;
}
@cpp.UseOpEncode
struct struct_i32_alternative_custom_default_op_encoded {
  1: i32 field_1 = 30;
}
@cpp.UseOpEncode
struct struct_i64_alternative_custom_default_op_encoded {
  1: i64 field_1 = 40;
}
@cpp.UseOpEncode
struct struct_float_alternative_custom_default_op_encoded {
  1: float field_1 = 50;
}
@cpp.UseOpEncode
struct struct_double_alternative_custom_default_op_encoded {
  1: double field_1 = 60;
}
@cpp.UseOpEncode
struct struct_binary_alternative_custom_default_op_encoded {
  1: binary field_1 = "70";
}
@cpp.UseOpEncode
struct struct_string_alternative_custom_default_op_encoded {
  1: string field_1 = "80";
}
@cpp.UseOpEncode
struct struct_optional_list_bool_op_encoded {
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_byte_op_encoded {
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i16_op_encoded {
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i32_op_encoded {
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i64_op_encoded {
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_float_op_encoded {
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_double_op_encoded {
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_binary_op_encoded {
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_string_op_encoded {
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_struct_empty_op_encoded {
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_bool_op_encoded {
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_byte_op_encoded {
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i16_op_encoded {
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i32_op_encoded {
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i64_op_encoded {
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_float_op_encoded {
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_double_op_encoded {
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_binary_op_encoded {
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_string_op_encoded {
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_struct_empty_op_encoded {
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_byte_op_encoded {
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i16_op_encoded {
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i32_op_encoded {
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i64_op_encoded {
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_binary_op_encoded {
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_string_op_encoded {
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_bool_op_encoded {
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_byte_op_encoded {
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i16_op_encoded {
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i32_op_encoded {
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i64_op_encoded {
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_float_op_encoded {
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_double_op_encoded {
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_binary_op_encoded {
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_string_op_encoded {
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_struct_empty_op_encoded {
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_bool_op_encoded {
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_byte_op_encoded {
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i16_op_encoded {
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i32_op_encoded {
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i64_op_encoded {
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_float_op_encoded {
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_double_op_encoded {
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_binary_op_encoded {
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_string_op_encoded {
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_struct_empty_op_encoded {
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_byte_op_encoded {
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i16_op_encoded {
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i32_op_encoded {
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i64_op_encoded {
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_binary_op_encoded {
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_string_op_encoded {
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_byte_op_encoded {
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i16_op_encoded {
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i32_op_encoded {
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i64_op_encoded {
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_binary_op_encoded {
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_string_op_encoded {
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_bool_op_encoded {
  1: optional bool field_1;
}
@cpp.UseOpEncode
struct struct_optional_byte_op_encoded {
  1: optional byte field_1;
}
@cpp.UseOpEncode
struct struct_optional_i16_op_encoded {
  1: optional i16 field_1;
}
@cpp.UseOpEncode
struct struct_optional_i32_op_encoded {
  1: optional i32 field_1;
}
@cpp.UseOpEncode
struct struct_optional_i64_op_encoded {
  1: optional i64 field_1;
}
@cpp.UseOpEncode
struct struct_optional_float_op_encoded {
  1: optional float field_1;
}
@cpp.UseOpEncode
struct struct_optional_double_op_encoded {
  1: optional double field_1;
}
@cpp.UseOpEncode
struct struct_optional_binary_op_encoded {
  1: optional binary field_1;
}
@cpp.UseOpEncode
struct struct_optional_string_op_encoded {
  1: optional string field_1;
}
@cpp.UseOpEncode
struct struct_optional_bool_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_optional_byte_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 1;
}
@cpp.UseOpEncode
struct struct_optional_i16_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 2;
}
@cpp.UseOpEncode
struct struct_optional_i32_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 3;
}
@cpp.UseOpEncode
struct struct_optional_i64_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 4;
}
@cpp.UseOpEncode
struct struct_optional_float_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 5;
}
@cpp.UseOpEncode
struct struct_optional_double_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 6;
}
@cpp.UseOpEncode
struct struct_optional_binary_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "7";
}
@cpp.UseOpEncode
struct struct_optional_string_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "8";
}
@cpp.UseOpEncode
struct struct_optional_bool_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_optional_byte_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 10;
}
@cpp.UseOpEncode
struct struct_optional_i16_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 20;
}
@cpp.UseOpEncode
struct struct_optional_i32_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 30;
}
@cpp.UseOpEncode
struct struct_optional_i64_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 40;
}
@cpp.UseOpEncode
struct struct_optional_float_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 50;
}
@cpp.UseOpEncode
struct struct_optional_double_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 60;
}
@cpp.UseOpEncode
struct struct_optional_binary_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "70";
}
@cpp.UseOpEncode
struct struct_optional_string_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "80";
}
@cpp.UseOpEncode
struct struct_required_list_bool_op_encoded {
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_byte_op_encoded {
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i16_op_encoded {
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i32_op_encoded {
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i64_op_encoded {
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_float_op_encoded {
  1: required list<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_double_op_encoded {
  1: required list<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_binary_op_encoded {
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_string_op_encoded {
  1: required list<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_struct_empty_op_encoded {
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_bool_op_encoded {
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_byte_op_encoded {
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i16_op_encoded {
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i32_op_encoded {
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i64_op_encoded {
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_float_op_encoded {
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_double_op_encoded {
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_binary_op_encoded {
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_string_op_encoded {
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_struct_empty_op_encoded {
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_byte_op_encoded {
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i16_op_encoded {
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i32_op_encoded {
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i64_op_encoded {
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_binary_op_encoded {
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_string_op_encoded {
  1: required set<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_bool_op_encoded {
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_byte_op_encoded {
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i16_op_encoded {
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i32_op_encoded {
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i64_op_encoded {
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_float_op_encoded {
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_double_op_encoded {
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_binary_op_encoded {
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_string_op_encoded {
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_struct_empty_op_encoded {
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_bool_op_encoded {
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_byte_op_encoded {
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i16_op_encoded {
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i32_op_encoded {
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i64_op_encoded {
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_float_op_encoded {
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_double_op_encoded {
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_binary_op_encoded {
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_string_op_encoded {
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_struct_empty_op_encoded {
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_byte_op_encoded {
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i16_op_encoded {
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i32_op_encoded {
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i64_op_encoded {
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_binary_op_encoded {
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_string_op_encoded {
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_byte_op_encoded {
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i16_op_encoded {
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i32_op_encoded {
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i64_op_encoded {
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_binary_op_encoded {
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_string_op_encoded {
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_required_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_required_bool_op_encoded {
  1: required bool field_1;
}
@cpp.UseOpEncode
struct struct_required_byte_op_encoded {
  1: required byte field_1;
}
@cpp.UseOpEncode
struct struct_required_i16_op_encoded {
  1: required i16 field_1;
}
@cpp.UseOpEncode
struct struct_required_i32_op_encoded {
  1: required i32 field_1;
}
@cpp.UseOpEncode
struct struct_required_i64_op_encoded {
  1: required i64 field_1;
}
@cpp.UseOpEncode
struct struct_required_float_op_encoded {
  1: required float field_1;
}
@cpp.UseOpEncode
struct struct_required_double_op_encoded {
  1: required double field_1;
}
@cpp.UseOpEncode
struct struct_required_binary_op_encoded {
  1: required binary field_1;
}
@cpp.UseOpEncode
struct struct_required_string_op_encoded {
  1: required string field_1;
}
@cpp.UseOpEncode
struct struct_required_bool_custom_default_op_encoded {
  1: required bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_required_byte_custom_default_op_encoded {
  1: required byte field_1 = 1;
}
@cpp.UseOpEncode
struct struct_required_i16_custom_default_op_encoded {
  1: required i16 field_1 = 2;
}
@cpp.UseOpEncode
struct struct_required_i32_custom_default_op_encoded {
  1: required i32 field_1 = 3;
}
@cpp.UseOpEncode
struct struct_required_i64_custom_default_op_encoded {
  1: required i64 field_1 = 4;
}
@cpp.UseOpEncode
struct struct_required_float_custom_default_op_encoded {
  1: required float field_1 = 5;
}
@cpp.UseOpEncode
struct struct_required_double_custom_default_op_encoded {
  1: required double field_1 = 6;
}
@cpp.UseOpEncode
struct struct_required_binary_custom_default_op_encoded {
  1: required binary field_1 = "7";
}
@cpp.UseOpEncode
struct struct_required_string_custom_default_op_encoded {
  1: required string field_1 = "8";
}
@cpp.UseOpEncode
struct struct_required_bool_alternative_custom_default_op_encoded {
  1: required bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_required_byte_alternative_custom_default_op_encoded {
  1: required byte field_1 = 10;
}
@cpp.UseOpEncode
struct struct_required_i16_alternative_custom_default_op_encoded {
  1: required i16 field_1 = 20;
}
@cpp.UseOpEncode
struct struct_required_i32_alternative_custom_default_op_encoded {
  1: required i32 field_1 = 30;
}
@cpp.UseOpEncode
struct struct_required_i64_alternative_custom_default_op_encoded {
  1: required i64 field_1 = 40;
}
@cpp.UseOpEncode
struct struct_required_float_alternative_custom_default_op_encoded {
  1: required float field_1 = 50;
}
@cpp.UseOpEncode
struct struct_required_double_alternative_custom_default_op_encoded {
  1: required double field_1 = 60;
}
@cpp.UseOpEncode
struct struct_required_binary_alternative_custom_default_op_encoded {
  1: required binary field_1 = "70";
}
@cpp.UseOpEncode
struct struct_required_string_alternative_custom_default_op_encoded {
  1: required string field_1 = "80";
}
@cpp.UseOpEncode
struct struct_terse_list_bool_op_encoded {
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_byte_op_encoded {
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i16_op_encoded {
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i32_op_encoded {
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i64_op_encoded {
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_float_op_encoded {
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_double_op_encoded {
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_binary_op_encoded {
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_string_op_encoded {
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_bool_op_encoded {
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_byte_op_encoded {
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i16_op_encoded {
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i32_op_encoded {
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i64_op_encoded {
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_float_op_encoded {
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_double_op_encoded {
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_binary_op_encoded {
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_string_op_encoded {
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_byte_op_encoded {
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i16_op_encoded {
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i32_op_encoded {
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i64_op_encoded {
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_binary_op_encoded {
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_string_op_encoded {
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_bool_op_encoded {
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_byte_op_encoded {
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i16_op_encoded {
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i32_op_encoded {
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i64_op_encoded {
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_float_op_encoded {
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_double_op_encoded {
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_binary_op_encoded {
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_string_op_encoded {
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_bool_op_encoded {
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_byte_op_encoded {
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i16_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i32_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i64_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_float_op_encoded {
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_double_op_encoded {
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_binary_op_encoded {
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_string_op_encoded {
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_byte_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i16_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i32_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i64_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_binary_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_string_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_byte_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i16_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i32_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i64_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_binary_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_string_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_terse_bool_op_encoded {
  @thrift.TerseWrite
  1: bool field_1;
}
@cpp.UseOpEncode
struct struct_terse_byte_op_encoded {
  @thrift.TerseWrite
  1: byte field_1;
}
@cpp.UseOpEncode
struct struct_terse_i16_op_encoded {
  @thrift.TerseWrite
  1: i16 field_1;
}
@cpp.UseOpEncode
struct struct_terse_i32_op_encoded {
  @thrift.TerseWrite
  1: i32 field_1;
}
@cpp.UseOpEncode
struct struct_terse_i64_op_encoded {
  @thrift.TerseWrite
  1: i64 field_1;
}
@cpp.UseOpEncode
struct struct_terse_float_op_encoded {
  @thrift.TerseWrite
  1: float field_1;
}
@cpp.UseOpEncode
struct struct_terse_double_op_encoded {
  @thrift.TerseWrite
  1: double field_1;
}
@cpp.UseOpEncode
struct struct_terse_binary_op_encoded {
  @thrift.TerseWrite
  1: binary field_1;
}
@cpp.UseOpEncode
struct struct_terse_string_op_encoded {
  @thrift.TerseWrite
  1: string field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_bool_box_op_encoded {
  @thrift.Box
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_byte_box_op_encoded {
  @thrift.Box
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i16_box_op_encoded {
  @thrift.Box
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i32_box_op_encoded {
  @thrift.Box
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_i64_box_op_encoded {
  @thrift.Box
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_float_box_op_encoded {
  @thrift.Box
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_double_box_op_encoded {
  @thrift.Box
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_binary_box_op_encoded {
  @thrift.Box
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_string_box_op_encoded {
  @thrift.Box
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_bool_box_op_encoded {
  @thrift.Box
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_byte_box_op_encoded {
  @thrift.Box
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i16_box_op_encoded {
  @thrift.Box
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i32_box_op_encoded {
  @thrift.Box
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_i64_box_op_encoded {
  @thrift.Box
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_float_box_op_encoded {
  @thrift.Box
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_double_box_op_encoded {
  @thrift.Box
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_binary_box_op_encoded {
  @thrift.Box
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_string_box_op_encoded {
  @thrift.Box
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_list_list_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_byte_box_op_encoded {
  @thrift.Box
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i16_box_op_encoded {
  @thrift.Box
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i32_box_op_encoded {
  @thrift.Box
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_i64_box_op_encoded {
  @thrift.Box
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_binary_box_op_encoded {
  @thrift.Box
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_string_box_op_encoded {
  @thrift.Box
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_byte_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i16_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i32_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_i64_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_binary_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_string_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_set_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_bool_box_op_encoded {
  @thrift.Box
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_byte_box_op_encoded {
  @thrift.Box
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i16_box_op_encoded {
  @thrift.Box
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i32_box_op_encoded {
  @thrift.Box
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_i64_box_op_encoded {
  @thrift.Box
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_float_box_op_encoded {
  @thrift.Box
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_double_box_op_encoded {
  @thrift.Box
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_binary_box_op_encoded {
  @thrift.Box
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_string_box_op_encoded {
  @thrift.Box
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_bool_box_op_encoded {
  @thrift.Box
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_byte_box_op_encoded {
  @thrift.Box
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i16_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i32_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_i64_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_float_box_op_encoded {
  @thrift.Box
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_double_box_op_encoded {
  @thrift.Box
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_binary_box_op_encoded {
  @thrift.Box
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_string_box_op_encoded {
  @thrift.Box
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_byte_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i16_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i32_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_i64_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_binary_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_string_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_string_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_byte_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i16_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i32_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_i64_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_binary_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_string_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_optional_map_i64_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_bool'}
  1: bool field_1;
}
@cpp.UseOpEncode
struct struct_adapted_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_byte'}
  1: byte field_1;
}
@cpp.UseOpEncode
struct struct_adapted_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i16'}
  1: i16 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i32'}
  1: i32 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i64'}
  1: i64 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_float'}
  1: float field_1;
}
@cpp.UseOpEncode
struct struct_adapted_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_double'}
  1: double field_1;
}
@cpp.UseOpEncode
struct struct_adapted_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_binary'}
  1: binary field_1;
}
@cpp.UseOpEncode
struct struct_adapted_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_string'}
  1: string field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_bool'}
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_byte'}
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i16'}
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i32'}
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i64'}
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_float'}
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_double'}
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_binary'}
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_string'}
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_struct_empty'}
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_bool'}
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_byte'}
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i16'}
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i32'}
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i64'}
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_float'}
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_double'}
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_binary'}
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_string'}
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_struct_empty'}
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_byte'}
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i16'}
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i32'}
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i64'}
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_binary'}
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_string'}
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_byte'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i16'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i32'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i64'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_binary'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_string'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_bool'}
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_byte'}
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i16'}
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i32'}
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i64'}
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_float'}
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_double'}
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_binary'}
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_string'}
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_struct_empty'}
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_bool'}
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_byte'}
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i16'}
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i32'}
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i64'}
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_float'}
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_double'}
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_binary'}
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_string'}
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_struct_empty'}
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_byte'}
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i16'}
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i32'}
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i64'}
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_binary'}
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_string'}
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_string_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_byte'}
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i16'}
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i32'}
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i64'}
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_binary'}
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_string'}
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_i64_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: bool field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: byte field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i16 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i32 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i64 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: float field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: double field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: binary field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: string field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_string_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_i64_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_list_bool_lazy_op_encoded {
  @cpp.Lazy
  1: list<bool> field_1;
}
@cpp.UseOpEncode
struct struct_list_byte_lazy_op_encoded {
  @cpp.Lazy
  1: list<byte> field_1;
}
@cpp.UseOpEncode
struct struct_list_i16_lazy_op_encoded {
  @cpp.Lazy
  1: list<i16> field_1;
}
@cpp.UseOpEncode
struct struct_list_i32_lazy_op_encoded {
  @cpp.Lazy
  1: list<i32> field_1;
}
@cpp.UseOpEncode
struct struct_list_i64_lazy_op_encoded {
  @cpp.Lazy
  1: list<i64> field_1;
}
@cpp.UseOpEncode
struct struct_list_float_lazy_op_encoded {
  @cpp.Lazy
  1: list<float> field_1;
}
@cpp.UseOpEncode
struct struct_list_double_lazy_op_encoded {
  @cpp.Lazy
  1: list<double> field_1;
}
@cpp.UseOpEncode
struct struct_list_binary_lazy_op_encoded {
  @cpp.Lazy
  1: list<binary> field_1;
}
@cpp.UseOpEncode
struct struct_list_string_lazy_op_encoded {
  @cpp.Lazy
  1: list<string> field_1;
}
@cpp.UseOpEncode
struct struct_list_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_bool_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_byte_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i16_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i32_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_i64_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_float_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_double_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_binary_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_string_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
struct struct_list_list_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
struct struct_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: set<byte> field_1;
}
@cpp.UseOpEncode
struct struct_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: set<i16> field_1;
}
@cpp.UseOpEncode
struct struct_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: set<i32> field_1;
}
@cpp.UseOpEncode
struct struct_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: set<i64> field_1;
}
@cpp.UseOpEncode
struct struct_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
struct struct_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
struct struct_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: set<binary> field_1;
}
@cpp.UseOpEncode
struct struct_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: set<string> field_1;
}
@cpp.UseOpEncode
struct struct_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_byte_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i16_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i32_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_i64_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_binary_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_string_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_set_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_bool_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_float_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_double_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_bool_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_float_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_double_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_string_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
struct struct_map_i64_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
struct struct_string_lazy_op_encoded {
  @cpp.Lazy
  1: string field_1;
}
exception exception_empty {
}
exception exception_list_bool {
  1: list<bool> field_1;
}
exception exception_list_byte {
  1: list<byte> field_1;
}
exception exception_list_i16 {
  1: list<i16> field_1;
}
exception exception_list_i32 {
  1: list<i32> field_1;
}
exception exception_list_i64 {
  1: list<i64> field_1;
}
exception exception_list_float {
  1: list<float> field_1;
}
exception exception_list_double {
  1: list<double> field_1;
}
exception exception_list_binary {
  1: list<binary> field_1;
}
exception exception_list_string {
  1: list<string> field_1;
}
exception exception_list_struct_empty {
  1: list<struct_empty> field_1;
}
exception exception_list_list_bool {
  1: list<list<bool>> field_1;
}
exception exception_list_list_byte {
  1: list<list<byte>> field_1;
}
exception exception_list_list_i16 {
  1: list<list<i16>> field_1;
}
exception exception_list_list_i32 {
  1: list<list<i32>> field_1;
}
exception exception_list_list_i64 {
  1: list<list<i64>> field_1;
}
exception exception_list_list_float {
  1: list<list<float>> field_1;
}
exception exception_list_list_double {
  1: list<list<double>> field_1;
}
exception exception_list_list_binary {
  1: list<list<binary>> field_1;
}
exception exception_list_list_string {
  1: list<list<string>> field_1;
}
exception exception_list_list_struct_empty {
  1: list<list<struct_empty>> field_1;
}
exception exception_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_set_byte {
  1: set<byte> field_1;
}
exception exception_set_i16 {
  1: set<i16> field_1;
}
exception exception_set_i32 {
  1: set<i32> field_1;
}
exception exception_set_i64 {
  1: set<i64> field_1;
}
exception exception_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_set_binary {
  1: set<binary> field_1;
}
exception exception_set_string {
  1: set<string> field_1;
}
exception exception_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_map_string_bool {
  1: map<string, bool> field_1;
}
exception exception_map_string_byte {
  1: map<string, byte> field_1;
}
exception exception_map_string_i16 {
  1: map<string, i16> field_1;
}
exception exception_map_string_i32 {
  1: map<string, i32> field_1;
}
exception exception_map_string_i64 {
  1: map<string, i64> field_1;
}
exception exception_map_string_float {
  1: map<string, float> field_1;
}
exception exception_map_string_double {
  1: map<string, double> field_1;
}
exception exception_map_string_binary {
  1: map<string, binary> field_1;
}
exception exception_map_string_string {
  1: map<string, string> field_1;
}
exception exception_map_string_struct_empty {
  1: map<string, struct_empty> field_1;
}
exception exception_map_i64_bool {
  1: map<i64, bool> field_1;
}
exception exception_map_i64_byte {
  1: map<i64, byte> field_1;
}
exception exception_map_i64_i16 {
  1: map<i64, i16> field_1;
}
exception exception_map_i64_i32 {
  1: map<i64, i32> field_1;
}
exception exception_map_i64_i64 {
  1: map<i64, i64> field_1;
}
exception exception_map_i64_float {
  1: map<i64, float> field_1;
}
exception exception_map_i64_double {
  1: map<i64, double> field_1;
}
exception exception_map_i64_binary {
  1: map<i64, binary> field_1;
}
exception exception_map_i64_string {
  1: map<i64, string> field_1;
}
exception exception_map_i64_struct_empty {
  1: map<i64, struct_empty> field_1;
}
exception exception_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_map_string_set_byte {
  1: map<string, set<byte>> field_1;
}
exception exception_map_string_set_i16 {
  1: map<string, set<i16>> field_1;
}
exception exception_map_string_set_i32 {
  1: map<string, set<i32>> field_1;
}
exception exception_map_string_set_i64 {
  1: map<string, set<i64>> field_1;
}
exception exception_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_map_string_set_binary {
  1: map<string, set<binary>> field_1;
}
exception exception_map_string_set_string {
  1: map<string, set<string>> field_1;
}
exception exception_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_map_i64_set_byte {
  1: map<i64, set<byte>> field_1;
}
exception exception_map_i64_set_i16 {
  1: map<i64, set<i16>> field_1;
}
exception exception_map_i64_set_i32 {
  1: map<i64, set<i32>> field_1;
}
exception exception_map_i64_set_i64 {
  1: map<i64, set<i64>> field_1;
}
exception exception_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_map_i64_set_binary {
  1: map<i64, set<binary>> field_1;
}
exception exception_map_i64_set_string {
  1: map<i64, set<string>> field_1;
}
exception exception_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
exception exception_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
exception exception_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
exception exception_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
exception exception_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
exception exception_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
exception exception_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
exception exception_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
exception exception_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
exception exception_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
exception exception_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
exception exception_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
exception exception_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
exception exception_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
exception exception_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
exception exception_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
exception exception_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
exception exception_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
exception exception_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
exception exception_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
exception exception_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
exception exception_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
exception exception_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
exception exception_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
exception exception_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
exception exception_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
exception exception_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
exception exception_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
exception exception_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
exception exception_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
exception exception_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
exception exception_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
exception exception_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
exception exception_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
exception exception_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
exception exception_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
exception exception_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
exception exception_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
exception exception_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
exception exception_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
exception exception_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
exception exception_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
exception exception_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
exception exception_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
exception exception_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
exception exception_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
exception exception_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
exception exception_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
exception exception_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
exception exception_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
exception exception_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
exception exception_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
exception exception_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
exception exception_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
exception exception_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
exception exception_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
exception exception_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
exception exception_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
exception exception_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
exception exception_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
exception exception_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
exception exception_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
exception exception_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
exception exception_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
exception exception_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
exception exception_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
exception exception_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
exception exception_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
exception exception_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
exception exception_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
exception exception_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
exception exception_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
exception exception_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
exception exception_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
exception exception_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
exception exception_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
exception exception_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
exception exception_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
exception exception_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
exception exception_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
exception exception_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
exception exception_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
exception exception_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
exception exception_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
exception exception_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
exception exception_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
exception exception_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
exception exception_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
exception exception_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
exception exception_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
exception exception_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
exception exception_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
exception exception_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
exception exception_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
exception exception_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
exception exception_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
exception exception_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
exception exception_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
exception exception_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
exception exception_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
exception exception_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
exception exception_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
exception exception_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
exception exception_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
exception exception_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
exception exception_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
exception exception_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
exception exception_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
exception exception_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
exception exception_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
exception exception_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
exception exception_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
exception exception_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
exception exception_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
exception exception_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
exception exception_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
exception exception_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_bool {
  1: bool field_1;
}
exception exception_byte {
  1: byte field_1;
}
exception exception_i16 {
  1: i16 field_1;
}
exception exception_i32 {
  1: i32 field_1;
}
exception exception_i64 {
  1: i64 field_1;
}
exception exception_float {
  1: float field_1;
}
exception exception_double {
  1: double field_1;
}
exception exception_binary {
  1: binary field_1;
}
exception exception_string {
  1: string field_1;
}
exception exception_bool_custom_default {
  1: bool field_1 = true;
}
exception exception_byte_custom_default {
  1: byte field_1 = 1;
}
exception exception_i16_custom_default {
  1: i16 field_1 = 2;
}
exception exception_i32_custom_default {
  1: i32 field_1 = 3;
}
exception exception_i64_custom_default {
  1: i64 field_1 = 4;
}
exception exception_float_custom_default {
  1: float field_1 = 5;
}
exception exception_double_custom_default {
  1: double field_1 = 6;
}
exception exception_binary_custom_default {
  1: binary field_1 = "7";
}
exception exception_string_custom_default {
  1: string field_1 = "8";
}
exception exception_bool_alternative_custom_default {
  1: bool field_1 = true;
}
exception exception_byte_alternative_custom_default {
  1: byte field_1 = 10;
}
exception exception_i16_alternative_custom_default {
  1: i16 field_1 = 20;
}
exception exception_i32_alternative_custom_default {
  1: i32 field_1 = 30;
}
exception exception_i64_alternative_custom_default {
  1: i64 field_1 = 40;
}
exception exception_float_alternative_custom_default {
  1: float field_1 = 50;
}
exception exception_double_alternative_custom_default {
  1: double field_1 = 60;
}
exception exception_binary_alternative_custom_default {
  1: binary field_1 = "70";
}
exception exception_string_alternative_custom_default {
  1: string field_1 = "80";
}
exception exception_optional_list_bool {
  1: optional list<bool> field_1;
}
exception exception_optional_list_byte {
  1: optional list<byte> field_1;
}
exception exception_optional_list_i16 {
  1: optional list<i16> field_1;
}
exception exception_optional_list_i32 {
  1: optional list<i32> field_1;
}
exception exception_optional_list_i64 {
  1: optional list<i64> field_1;
}
exception exception_optional_list_float {
  1: optional list<float> field_1;
}
exception exception_optional_list_double {
  1: optional list<double> field_1;
}
exception exception_optional_list_binary {
  1: optional list<binary> field_1;
}
exception exception_optional_list_string {
  1: optional list<string> field_1;
}
exception exception_optional_list_struct_empty {
  1: optional list<struct_empty> field_1;
}
exception exception_optional_list_list_bool {
  1: optional list<list<bool>> field_1;
}
exception exception_optional_list_list_byte {
  1: optional list<list<byte>> field_1;
}
exception exception_optional_list_list_i16 {
  1: optional list<list<i16>> field_1;
}
exception exception_optional_list_list_i32 {
  1: optional list<list<i32>> field_1;
}
exception exception_optional_list_list_i64 {
  1: optional list<list<i64>> field_1;
}
exception exception_optional_list_list_float {
  1: optional list<list<float>> field_1;
}
exception exception_optional_list_list_double {
  1: optional list<list<double>> field_1;
}
exception exception_optional_list_list_binary {
  1: optional list<list<binary>> field_1;
}
exception exception_optional_list_list_string {
  1: optional list<list<string>> field_1;
}
exception exception_optional_list_list_struct_empty {
  1: optional list<list<struct_empty>> field_1;
}
exception exception_optional_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
exception exception_optional_set_byte {
  1: optional set<byte> field_1;
}
exception exception_optional_set_i16 {
  1: optional set<i16> field_1;
}
exception exception_optional_set_i32 {
  1: optional set<i32> field_1;
}
exception exception_optional_set_i64 {
  1: optional set<i64> field_1;
}
exception exception_optional_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
exception exception_optional_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
exception exception_optional_set_binary {
  1: optional set<binary> field_1;
}
exception exception_optional_set_string {
  1: optional set<string> field_1;
}
exception exception_optional_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
exception exception_optional_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
exception exception_optional_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
exception exception_optional_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
exception exception_optional_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
exception exception_optional_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
exception exception_optional_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
exception exception_optional_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
exception exception_optional_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
exception exception_optional_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
exception exception_optional_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
exception exception_optional_map_string_bool {
  1: optional map<string, bool> field_1;
}
exception exception_optional_map_string_byte {
  1: optional map<string, byte> field_1;
}
exception exception_optional_map_string_i16 {
  1: optional map<string, i16> field_1;
}
exception exception_optional_map_string_i32 {
  1: optional map<string, i32> field_1;
}
exception exception_optional_map_string_i64 {
  1: optional map<string, i64> field_1;
}
exception exception_optional_map_string_float {
  1: optional map<string, float> field_1;
}
exception exception_optional_map_string_double {
  1: optional map<string, double> field_1;
}
exception exception_optional_map_string_binary {
  1: optional map<string, binary> field_1;
}
exception exception_optional_map_string_string {
  1: optional map<string, string> field_1;
}
exception exception_optional_map_string_struct_empty {
  1: optional map<string, struct_empty> field_1;
}
exception exception_optional_map_i64_bool {
  1: optional map<i64, bool> field_1;
}
exception exception_optional_map_i64_byte {
  1: optional map<i64, byte> field_1;
}
exception exception_optional_map_i64_i16 {
  1: optional map<i64, i16> field_1;
}
exception exception_optional_map_i64_i32 {
  1: optional map<i64, i32> field_1;
}
exception exception_optional_map_i64_i64 {
  1: optional map<i64, i64> field_1;
}
exception exception_optional_map_i64_float {
  1: optional map<i64, float> field_1;
}
exception exception_optional_map_i64_double {
  1: optional map<i64, double> field_1;
}
exception exception_optional_map_i64_binary {
  1: optional map<i64, binary> field_1;
}
exception exception_optional_map_i64_string {
  1: optional map<i64, string> field_1;
}
exception exception_optional_map_i64_struct_empty {
  1: optional map<i64, struct_empty> field_1;
}
exception exception_optional_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
exception exception_optional_map_string_set_byte {
  1: optional map<string, set<byte>> field_1;
}
exception exception_optional_map_string_set_i16 {
  1: optional map<string, set<i16>> field_1;
}
exception exception_optional_map_string_set_i32 {
  1: optional map<string, set<i32>> field_1;
}
exception exception_optional_map_string_set_i64 {
  1: optional map<string, set<i64>> field_1;
}
exception exception_optional_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
exception exception_optional_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
exception exception_optional_map_string_set_binary {
  1: optional map<string, set<binary>> field_1;
}
exception exception_optional_map_string_set_string {
  1: optional map<string, set<string>> field_1;
}
exception exception_optional_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
exception exception_optional_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
exception exception_optional_map_i64_set_byte {
  1: optional map<i64, set<byte>> field_1;
}
exception exception_optional_map_i64_set_i16 {
  1: optional map<i64, set<i16>> field_1;
}
exception exception_optional_map_i64_set_i32 {
  1: optional map<i64, set<i32>> field_1;
}
exception exception_optional_map_i64_set_i64 {
  1: optional map<i64, set<i64>> field_1;
}
exception exception_optional_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
exception exception_optional_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
exception exception_optional_map_i64_set_binary {
  1: optional map<i64, set<binary>> field_1;
}
exception exception_optional_map_i64_set_string {
  1: optional map<i64, set<string>> field_1;
}
exception exception_optional_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
exception exception_optional_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
exception exception_optional_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
exception exception_optional_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
exception exception_optional_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
exception exception_optional_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
exception exception_optional_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
exception exception_optional_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
exception exception_optional_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
exception exception_optional_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
exception exception_optional_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
exception exception_optional_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
exception exception_optional_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
exception exception_optional_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
exception exception_optional_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
exception exception_optional_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
exception exception_optional_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
exception exception_optional_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
exception exception_optional_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
exception exception_optional_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
exception exception_optional_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
exception exception_optional_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
exception exception_optional_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
exception exception_optional_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
exception exception_optional_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
exception exception_optional_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
exception exception_optional_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
exception exception_optional_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
exception exception_optional_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
exception exception_optional_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
exception exception_optional_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
exception exception_optional_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
exception exception_optional_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
exception exception_optional_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
exception exception_optional_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
exception exception_optional_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
exception exception_optional_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
exception exception_optional_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
exception exception_optional_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
exception exception_optional_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
exception exception_optional_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
exception exception_optional_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
exception exception_optional_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
exception exception_optional_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
exception exception_optional_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
exception exception_optional_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
exception exception_optional_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
exception exception_optional_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
exception exception_optional_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
exception exception_optional_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
exception exception_optional_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
exception exception_optional_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
exception exception_optional_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
exception exception_optional_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
exception exception_optional_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
exception exception_optional_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
exception exception_optional_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
exception exception_optional_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
exception exception_optional_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
exception exception_optional_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
exception exception_optional_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
exception exception_optional_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
exception exception_optional_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
exception exception_optional_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
exception exception_optional_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
exception exception_optional_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
exception exception_optional_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
exception exception_optional_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
exception exception_optional_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
exception exception_optional_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
exception exception_optional_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
exception exception_optional_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
exception exception_optional_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
exception exception_optional_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
exception exception_optional_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
exception exception_optional_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
exception exception_optional_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
exception exception_optional_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
exception exception_optional_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
exception exception_optional_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
exception exception_optional_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
exception exception_optional_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
exception exception_optional_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
exception exception_optional_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
exception exception_optional_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
exception exception_optional_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
exception exception_optional_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
exception exception_optional_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
exception exception_optional_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
exception exception_optional_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
exception exception_optional_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
exception exception_optional_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
exception exception_optional_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
exception exception_optional_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
exception exception_optional_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
exception exception_optional_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
exception exception_optional_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
exception exception_optional_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
exception exception_optional_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
exception exception_optional_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
exception exception_optional_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
exception exception_optional_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
exception exception_optional_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
exception exception_optional_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
exception exception_optional_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
exception exception_optional_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
exception exception_optional_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
exception exception_optional_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
exception exception_optional_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
exception exception_optional_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
exception exception_optional_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
exception exception_optional_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
exception exception_optional_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
exception exception_optional_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
exception exception_optional_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
exception exception_optional_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
exception exception_optional_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
exception exception_optional_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
exception exception_optional_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
exception exception_optional_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
exception exception_optional_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
exception exception_optional_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
exception exception_optional_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
exception exception_optional_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
exception exception_optional_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
exception exception_optional_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
exception exception_optional_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
exception exception_optional_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
exception exception_optional_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
exception exception_optional_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
exception exception_optional_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
exception exception_optional_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
exception exception_optional_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
exception exception_optional_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
exception exception_optional_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
exception exception_optional_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
exception exception_optional_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
exception exception_optional_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
exception exception_optional_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
exception exception_optional_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
exception exception_optional_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
exception exception_optional_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
exception exception_optional_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
exception exception_optional_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
exception exception_optional_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
exception exception_optional_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
exception exception_optional_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
exception exception_optional_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
exception exception_optional_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
exception exception_optional_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
exception exception_optional_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
exception exception_optional_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
exception exception_optional_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
exception exception_optional_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
exception exception_optional_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
exception exception_optional_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
exception exception_optional_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
exception exception_optional_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
exception exception_optional_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
exception exception_optional_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
exception exception_optional_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
exception exception_optional_bool {
  1: optional bool field_1;
}
exception exception_optional_byte {
  1: optional byte field_1;
}
exception exception_optional_i16 {
  1: optional i16 field_1;
}
exception exception_optional_i32 {
  1: optional i32 field_1;
}
exception exception_optional_i64 {
  1: optional i64 field_1;
}
exception exception_optional_float {
  1: optional float field_1;
}
exception exception_optional_double {
  1: optional double field_1;
}
exception exception_optional_binary {
  1: optional binary field_1;
}
exception exception_optional_string {
  1: optional string field_1;
}
exception exception_optional_bool_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
exception exception_optional_byte_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 1;
}
exception exception_optional_i16_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 2;
}
exception exception_optional_i32_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 3;
}
exception exception_optional_i64_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 4;
}
exception exception_optional_float_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 5;
}
exception exception_optional_double_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 6;
}
exception exception_optional_binary_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "7";
}
exception exception_optional_string_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "8";
}
exception exception_optional_bool_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
exception exception_optional_byte_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 10;
}
exception exception_optional_i16_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 20;
}
exception exception_optional_i32_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 30;
}
exception exception_optional_i64_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 40;
}
exception exception_optional_float_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 50;
}
exception exception_optional_double_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 60;
}
exception exception_optional_binary_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "70";
}
exception exception_optional_string_alternative_custom_default {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "80";
}
exception exception_required_list_bool {
  1: required list<bool> field_1;
}
exception exception_required_list_byte {
  1: required list<byte> field_1;
}
exception exception_required_list_i16 {
  1: required list<i16> field_1;
}
exception exception_required_list_i32 {
  1: required list<i32> field_1;
}
exception exception_required_list_i64 {
  1: required list<i64> field_1;
}
exception exception_required_list_float {
  1: required list<float> field_1;
}
exception exception_required_list_double {
  1: required list<double> field_1;
}
exception exception_required_list_binary {
  1: required list<binary> field_1;
}
exception exception_required_list_string {
  1: required list<string> field_1;
}
exception exception_required_list_struct_empty {
  1: required list<struct_empty> field_1;
}
exception exception_required_list_list_bool {
  1: required list<list<bool>> field_1;
}
exception exception_required_list_list_byte {
  1: required list<list<byte>> field_1;
}
exception exception_required_list_list_i16 {
  1: required list<list<i16>> field_1;
}
exception exception_required_list_list_i32 {
  1: required list<list<i32>> field_1;
}
exception exception_required_list_list_i64 {
  1: required list<list<i64>> field_1;
}
exception exception_required_list_list_float {
  1: required list<list<float>> field_1;
}
exception exception_required_list_list_double {
  1: required list<list<double>> field_1;
}
exception exception_required_list_list_binary {
  1: required list<list<binary>> field_1;
}
exception exception_required_list_list_string {
  1: required list<list<string>> field_1;
}
exception exception_required_list_list_struct_empty {
  1: required list<list<struct_empty>> field_1;
}
exception exception_required_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
exception exception_required_set_byte {
  1: required set<byte> field_1;
}
exception exception_required_set_i16 {
  1: required set<i16> field_1;
}
exception exception_required_set_i32 {
  1: required set<i32> field_1;
}
exception exception_required_set_i64 {
  1: required set<i64> field_1;
}
exception exception_required_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
exception exception_required_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
exception exception_required_set_binary {
  1: required set<binary> field_1;
}
exception exception_required_set_string {
  1: required set<string> field_1;
}
exception exception_required_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
exception exception_required_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
exception exception_required_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
exception exception_required_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
exception exception_required_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
exception exception_required_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
exception exception_required_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
exception exception_required_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
exception exception_required_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
exception exception_required_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
exception exception_required_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
exception exception_required_map_string_bool {
  1: required map<string, bool> field_1;
}
exception exception_required_map_string_byte {
  1: required map<string, byte> field_1;
}
exception exception_required_map_string_i16 {
  1: required map<string, i16> field_1;
}
exception exception_required_map_string_i32 {
  1: required map<string, i32> field_1;
}
exception exception_required_map_string_i64 {
  1: required map<string, i64> field_1;
}
exception exception_required_map_string_float {
  1: required map<string, float> field_1;
}
exception exception_required_map_string_double {
  1: required map<string, double> field_1;
}
exception exception_required_map_string_binary {
  1: required map<string, binary> field_1;
}
exception exception_required_map_string_string {
  1: required map<string, string> field_1;
}
exception exception_required_map_string_struct_empty {
  1: required map<string, struct_empty> field_1;
}
exception exception_required_map_i64_bool {
  1: required map<i64, bool> field_1;
}
exception exception_required_map_i64_byte {
  1: required map<i64, byte> field_1;
}
exception exception_required_map_i64_i16 {
  1: required map<i64, i16> field_1;
}
exception exception_required_map_i64_i32 {
  1: required map<i64, i32> field_1;
}
exception exception_required_map_i64_i64 {
  1: required map<i64, i64> field_1;
}
exception exception_required_map_i64_float {
  1: required map<i64, float> field_1;
}
exception exception_required_map_i64_double {
  1: required map<i64, double> field_1;
}
exception exception_required_map_i64_binary {
  1: required map<i64, binary> field_1;
}
exception exception_required_map_i64_string {
  1: required map<i64, string> field_1;
}
exception exception_required_map_i64_struct_empty {
  1: required map<i64, struct_empty> field_1;
}
exception exception_required_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
exception exception_required_map_string_set_byte {
  1: required map<string, set<byte>> field_1;
}
exception exception_required_map_string_set_i16 {
  1: required map<string, set<i16>> field_1;
}
exception exception_required_map_string_set_i32 {
  1: required map<string, set<i32>> field_1;
}
exception exception_required_map_string_set_i64 {
  1: required map<string, set<i64>> field_1;
}
exception exception_required_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
exception exception_required_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
exception exception_required_map_string_set_binary {
  1: required map<string, set<binary>> field_1;
}
exception exception_required_map_string_set_string {
  1: required map<string, set<string>> field_1;
}
exception exception_required_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
exception exception_required_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
exception exception_required_map_i64_set_byte {
  1: required map<i64, set<byte>> field_1;
}
exception exception_required_map_i64_set_i16 {
  1: required map<i64, set<i16>> field_1;
}
exception exception_required_map_i64_set_i32 {
  1: required map<i64, set<i32>> field_1;
}
exception exception_required_map_i64_set_i64 {
  1: required map<i64, set<i64>> field_1;
}
exception exception_required_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
exception exception_required_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
exception exception_required_map_i64_set_binary {
  1: required map<i64, set<binary>> field_1;
}
exception exception_required_map_i64_set_string {
  1: required map<i64, set<string>> field_1;
}
exception exception_required_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
exception exception_required_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
exception exception_required_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
exception exception_required_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
exception exception_required_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
exception exception_required_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
exception exception_required_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
exception exception_required_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
exception exception_required_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
exception exception_required_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
exception exception_required_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
exception exception_required_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
exception exception_required_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
exception exception_required_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
exception exception_required_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
exception exception_required_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
exception exception_required_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
exception exception_required_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
exception exception_required_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
exception exception_required_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
exception exception_required_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
exception exception_required_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
exception exception_required_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
exception exception_required_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
exception exception_required_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
exception exception_required_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
exception exception_required_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
exception exception_required_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
exception exception_required_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
exception exception_required_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
exception exception_required_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
exception exception_required_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
exception exception_required_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
exception exception_required_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
exception exception_required_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
exception exception_required_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
exception exception_required_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
exception exception_required_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
exception exception_required_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
exception exception_required_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
exception exception_required_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
exception exception_required_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
exception exception_required_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
exception exception_required_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
exception exception_required_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
exception exception_required_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
exception exception_required_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
exception exception_required_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
exception exception_required_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
exception exception_required_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
exception exception_required_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
exception exception_required_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
exception exception_required_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
exception exception_required_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
exception exception_required_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
exception exception_required_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
exception exception_required_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
exception exception_required_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
exception exception_required_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
exception exception_required_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
exception exception_required_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
exception exception_required_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
exception exception_required_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
exception exception_required_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
exception exception_required_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
exception exception_required_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
exception exception_required_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
exception exception_required_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
exception exception_required_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
exception exception_required_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
exception exception_required_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
exception exception_required_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
exception exception_required_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
exception exception_required_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
exception exception_required_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
exception exception_required_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
exception exception_required_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
exception exception_required_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
exception exception_required_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
exception exception_required_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
exception exception_required_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
exception exception_required_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
exception exception_required_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
exception exception_required_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
exception exception_required_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
exception exception_required_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
exception exception_required_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
exception exception_required_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
exception exception_required_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
exception exception_required_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
exception exception_required_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
exception exception_required_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
exception exception_required_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
exception exception_required_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
exception exception_required_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
exception exception_required_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
exception exception_required_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
exception exception_required_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
exception exception_required_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
exception exception_required_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
exception exception_required_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
exception exception_required_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
exception exception_required_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
exception exception_required_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
exception exception_required_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
exception exception_required_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
exception exception_required_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
exception exception_required_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
exception exception_required_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
exception exception_required_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
exception exception_required_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
exception exception_required_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
exception exception_required_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
exception exception_required_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
exception exception_required_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
exception exception_required_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
exception exception_required_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
exception exception_required_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
exception exception_required_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
exception exception_required_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
exception exception_required_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
exception exception_required_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
exception exception_required_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
exception exception_required_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
exception exception_required_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
exception exception_required_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
exception exception_required_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
exception exception_required_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
exception exception_required_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
exception exception_required_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
exception exception_required_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
exception exception_required_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
exception exception_required_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
exception exception_required_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
exception exception_required_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
exception exception_required_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
exception exception_required_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
exception exception_required_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
exception exception_required_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
exception exception_required_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
exception exception_required_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
exception exception_required_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
exception exception_required_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
exception exception_required_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
exception exception_required_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
exception exception_required_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
exception exception_required_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
exception exception_required_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
exception exception_required_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
exception exception_required_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
exception exception_required_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
exception exception_required_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
exception exception_required_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
exception exception_required_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
exception exception_required_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
exception exception_required_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
exception exception_required_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
exception exception_required_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
exception exception_required_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
exception exception_required_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
exception exception_required_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
exception exception_required_bool {
  1: required bool field_1;
}
exception exception_required_byte {
  1: required byte field_1;
}
exception exception_required_i16 {
  1: required i16 field_1;
}
exception exception_required_i32 {
  1: required i32 field_1;
}
exception exception_required_i64 {
  1: required i64 field_1;
}
exception exception_required_float {
  1: required float field_1;
}
exception exception_required_double {
  1: required double field_1;
}
exception exception_required_binary {
  1: required binary field_1;
}
exception exception_required_string {
  1: required string field_1;
}
exception exception_required_bool_custom_default {
  1: required bool field_1 = true;
}
exception exception_required_byte_custom_default {
  1: required byte field_1 = 1;
}
exception exception_required_i16_custom_default {
  1: required i16 field_1 = 2;
}
exception exception_required_i32_custom_default {
  1: required i32 field_1 = 3;
}
exception exception_required_i64_custom_default {
  1: required i64 field_1 = 4;
}
exception exception_required_float_custom_default {
  1: required float field_1 = 5;
}
exception exception_required_double_custom_default {
  1: required double field_1 = 6;
}
exception exception_required_binary_custom_default {
  1: required binary field_1 = "7";
}
exception exception_required_string_custom_default {
  1: required string field_1 = "8";
}
exception exception_required_bool_alternative_custom_default {
  1: required bool field_1 = true;
}
exception exception_required_byte_alternative_custom_default {
  1: required byte field_1 = 10;
}
exception exception_required_i16_alternative_custom_default {
  1: required i16 field_1 = 20;
}
exception exception_required_i32_alternative_custom_default {
  1: required i32 field_1 = 30;
}
exception exception_required_i64_alternative_custom_default {
  1: required i64 field_1 = 40;
}
exception exception_required_float_alternative_custom_default {
  1: required float field_1 = 50;
}
exception exception_required_double_alternative_custom_default {
  1: required double field_1 = 60;
}
exception exception_required_binary_alternative_custom_default {
  1: required binary field_1 = "70";
}
exception exception_required_string_alternative_custom_default {
  1: required string field_1 = "80";
}
exception exception_terse_list_bool {
  @thrift.TerseWrite
  1: list<bool> field_1;
}
exception exception_terse_list_byte {
  @thrift.TerseWrite
  1: list<byte> field_1;
}
exception exception_terse_list_i16 {
  @thrift.TerseWrite
  1: list<i16> field_1;
}
exception exception_terse_list_i32 {
  @thrift.TerseWrite
  1: list<i32> field_1;
}
exception exception_terse_list_i64 {
  @thrift.TerseWrite
  1: list<i64> field_1;
}
exception exception_terse_list_float {
  @thrift.TerseWrite
  1: list<float> field_1;
}
exception exception_terse_list_double {
  @thrift.TerseWrite
  1: list<double> field_1;
}
exception exception_terse_list_binary {
  @thrift.TerseWrite
  1: list<binary> field_1;
}
exception exception_terse_list_string {
  @thrift.TerseWrite
  1: list<string> field_1;
}
exception exception_terse_list_struct_empty {
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
exception exception_terse_list_list_bool {
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
exception exception_terse_list_list_byte {
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
exception exception_terse_list_list_i16 {
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
exception exception_terse_list_list_i32 {
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
exception exception_terse_list_list_i64 {
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
exception exception_terse_list_list_float {
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
exception exception_terse_list_list_double {
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
exception exception_terse_list_list_binary {
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
exception exception_terse_list_list_string {
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
exception exception_terse_list_list_struct_empty {
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
exception exception_terse_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
exception exception_terse_set_byte {
  @thrift.TerseWrite
  1: set<byte> field_1;
}
exception exception_terse_set_i16 {
  @thrift.TerseWrite
  1: set<i16> field_1;
}
exception exception_terse_set_i32 {
  @thrift.TerseWrite
  1: set<i32> field_1;
}
exception exception_terse_set_i64 {
  @thrift.TerseWrite
  1: set<i64> field_1;
}
exception exception_terse_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
exception exception_terse_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
exception exception_terse_set_binary {
  @thrift.TerseWrite
  1: set<binary> field_1;
}
exception exception_terse_set_string {
  @thrift.TerseWrite
  1: set<string> field_1;
}
exception exception_terse_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
exception exception_terse_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
exception exception_terse_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
exception exception_terse_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
exception exception_terse_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
exception exception_terse_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
exception exception_terse_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
exception exception_terse_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
exception exception_terse_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
exception exception_terse_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
exception exception_terse_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
exception exception_terse_map_string_bool {
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
exception exception_terse_map_string_byte {
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
exception exception_terse_map_string_i16 {
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
exception exception_terse_map_string_i32 {
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
exception exception_terse_map_string_i64 {
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
exception exception_terse_map_string_float {
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
exception exception_terse_map_string_double {
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
exception exception_terse_map_string_binary {
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
exception exception_terse_map_string_string {
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
exception exception_terse_map_string_struct_empty {
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
exception exception_terse_map_i64_bool {
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
exception exception_terse_map_i64_byte {
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
exception exception_terse_map_i64_i16 {
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
exception exception_terse_map_i64_i32 {
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
exception exception_terse_map_i64_i64 {
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
exception exception_terse_map_i64_float {
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
exception exception_terse_map_i64_double {
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
exception exception_terse_map_i64_binary {
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
exception exception_terse_map_i64_string {
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
exception exception_terse_map_i64_struct_empty {
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
exception exception_terse_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
exception exception_terse_map_string_set_byte {
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
exception exception_terse_map_string_set_i16 {
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
exception exception_terse_map_string_set_i32 {
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
exception exception_terse_map_string_set_i64 {
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
exception exception_terse_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
exception exception_terse_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
exception exception_terse_map_string_set_binary {
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
exception exception_terse_map_string_set_string {
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
exception exception_terse_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
exception exception_terse_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
exception exception_terse_map_i64_set_byte {
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
exception exception_terse_map_i64_set_i16 {
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
exception exception_terse_map_i64_set_i32 {
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
exception exception_terse_map_i64_set_i64 {
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
exception exception_terse_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
exception exception_terse_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
exception exception_terse_map_i64_set_binary {
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
exception exception_terse_map_i64_set_string {
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
exception exception_terse_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_terse_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
exception exception_terse_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
exception exception_terse_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
exception exception_terse_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
exception exception_terse_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
exception exception_terse_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
exception exception_terse_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
exception exception_terse_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
exception exception_terse_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
exception exception_terse_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
exception exception_terse_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
exception exception_terse_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
exception exception_terse_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
exception exception_terse_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
exception exception_terse_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
exception exception_terse_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
exception exception_terse_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
exception exception_terse_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
exception exception_terse_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
exception exception_terse_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
exception exception_terse_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
exception exception_terse_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
exception exception_terse_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
exception exception_terse_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
exception exception_terse_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
exception exception_terse_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
exception exception_terse_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
exception exception_terse_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
exception exception_terse_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
exception exception_terse_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
exception exception_terse_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
exception exception_terse_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
exception exception_terse_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
exception exception_terse_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
exception exception_terse_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
exception exception_terse_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
exception exception_terse_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
exception exception_terse_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
exception exception_terse_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
exception exception_terse_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
exception exception_terse_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
exception exception_terse_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
exception exception_terse_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
exception exception_terse_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
exception exception_terse_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
exception exception_terse_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
exception exception_terse_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
exception exception_terse_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
exception exception_terse_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
exception exception_terse_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
exception exception_terse_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
exception exception_terse_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
exception exception_terse_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
exception exception_terse_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
exception exception_terse_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
exception exception_terse_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
exception exception_terse_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
exception exception_terse_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
exception exception_terse_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
exception exception_terse_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
exception exception_terse_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
exception exception_terse_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
exception exception_terse_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
exception exception_terse_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
exception exception_terse_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
exception exception_terse_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
exception exception_terse_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
exception exception_terse_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
exception exception_terse_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
exception exception_terse_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
exception exception_terse_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
exception exception_terse_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
exception exception_terse_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
exception exception_terse_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
exception exception_terse_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
exception exception_terse_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
exception exception_terse_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
exception exception_terse_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
exception exception_terse_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
exception exception_terse_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_terse_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
exception exception_terse_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
exception exception_terse_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
exception exception_terse_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
exception exception_terse_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
exception exception_terse_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
exception exception_terse_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
exception exception_terse_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
exception exception_terse_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
exception exception_terse_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
exception exception_terse_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
exception exception_terse_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
exception exception_terse_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
exception exception_terse_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
exception exception_terse_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
exception exception_terse_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
exception exception_terse_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
exception exception_terse_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
exception exception_terse_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
exception exception_terse_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
exception exception_terse_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
exception exception_terse_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
exception exception_terse_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
exception exception_terse_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
exception exception_terse_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
exception exception_terse_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
exception exception_terse_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
exception exception_terse_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
exception exception_terse_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
exception exception_terse_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
exception exception_terse_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
exception exception_terse_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
exception exception_terse_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
exception exception_terse_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
exception exception_terse_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
exception exception_terse_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
exception exception_terse_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
exception exception_terse_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
exception exception_terse_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
exception exception_terse_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
exception exception_terse_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
exception exception_terse_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
exception exception_terse_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
exception exception_terse_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
exception exception_terse_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
exception exception_terse_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
exception exception_terse_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
exception exception_terse_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
exception exception_terse_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
exception exception_terse_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
exception exception_terse_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
exception exception_terse_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
exception exception_terse_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
exception exception_terse_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
exception exception_terse_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
exception exception_terse_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
exception exception_terse_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
exception exception_terse_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
exception exception_terse_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
exception exception_terse_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
exception exception_terse_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
exception exception_terse_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
exception exception_terse_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
exception exception_terse_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
exception exception_terse_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
exception exception_terse_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
exception exception_terse_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
exception exception_terse_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
exception exception_terse_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
exception exception_terse_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
exception exception_terse_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
exception exception_terse_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
exception exception_terse_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
exception exception_terse_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
exception exception_terse_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
exception exception_terse_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
exception exception_terse_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
exception exception_terse_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
exception exception_terse_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
exception exception_terse_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_terse_bool {
  @thrift.TerseWrite
  1: bool field_1;
}
exception exception_terse_byte {
  @thrift.TerseWrite
  1: byte field_1;
}
exception exception_terse_i16 {
  @thrift.TerseWrite
  1: i16 field_1;
}
exception exception_terse_i32 {
  @thrift.TerseWrite
  1: i32 field_1;
}
exception exception_terse_i64 {
  @thrift.TerseWrite
  1: i64 field_1;
}
exception exception_terse_float {
  @thrift.TerseWrite
  1: float field_1;
}
exception exception_terse_double {
  @thrift.TerseWrite
  1: double field_1;
}
exception exception_terse_binary {
  @thrift.TerseWrite
  1: binary field_1;
}
exception exception_terse_string {
  @thrift.TerseWrite
  1: string field_1;
}
exception exception_optional_list_bool_box {
  @thrift.Box
  1: optional list<bool> field_1;
}
exception exception_optional_list_byte_box {
  @thrift.Box
  1: optional list<byte> field_1;
}
exception exception_optional_list_i16_box {
  @thrift.Box
  1: optional list<i16> field_1;
}
exception exception_optional_list_i32_box {
  @thrift.Box
  1: optional list<i32> field_1;
}
exception exception_optional_list_i64_box {
  @thrift.Box
  1: optional list<i64> field_1;
}
exception exception_optional_list_float_box {
  @thrift.Box
  1: optional list<float> field_1;
}
exception exception_optional_list_double_box {
  @thrift.Box
  1: optional list<double> field_1;
}
exception exception_optional_list_binary_box {
  @thrift.Box
  1: optional list<binary> field_1;
}
exception exception_optional_list_string_box {
  @thrift.Box
  1: optional list<string> field_1;
}
exception exception_optional_list_struct_empty_box {
  @thrift.Box
  1: optional list<struct_empty> field_1;
}
exception exception_optional_list_list_bool_box {
  @thrift.Box
  1: optional list<list<bool>> field_1;
}
exception exception_optional_list_list_byte_box {
  @thrift.Box
  1: optional list<list<byte>> field_1;
}
exception exception_optional_list_list_i16_box {
  @thrift.Box
  1: optional list<list<i16>> field_1;
}
exception exception_optional_list_list_i32_box {
  @thrift.Box
  1: optional list<list<i32>> field_1;
}
exception exception_optional_list_list_i64_box {
  @thrift.Box
  1: optional list<list<i64>> field_1;
}
exception exception_optional_list_list_float_box {
  @thrift.Box
  1: optional list<list<float>> field_1;
}
exception exception_optional_list_list_double_box {
  @thrift.Box
  1: optional list<list<double>> field_1;
}
exception exception_optional_list_list_binary_box {
  @thrift.Box
  1: optional list<list<binary>> field_1;
}
exception exception_optional_list_list_string_box {
  @thrift.Box
  1: optional list<list<string>> field_1;
}
exception exception_optional_list_list_struct_empty_box {
  @thrift.Box
  1: optional list<list<struct_empty>> field_1;
}
exception exception_optional_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
exception exception_optional_set_byte_box {
  @thrift.Box
  1: optional set<byte> field_1;
}
exception exception_optional_set_i16_box {
  @thrift.Box
  1: optional set<i16> field_1;
}
exception exception_optional_set_i32_box {
  @thrift.Box
  1: optional set<i32> field_1;
}
exception exception_optional_set_i64_box {
  @thrift.Box
  1: optional set<i64> field_1;
}
exception exception_optional_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
exception exception_optional_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
exception exception_optional_set_binary_box {
  @thrift.Box
  1: optional set<binary> field_1;
}
exception exception_optional_set_string_box {
  @thrift.Box
  1: optional set<string> field_1;
}
exception exception_optional_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
exception exception_optional_set_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
exception exception_optional_set_set_byte_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
exception exception_optional_set_set_i16_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
exception exception_optional_set_set_i32_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
exception exception_optional_set_set_i64_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
exception exception_optional_set_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
exception exception_optional_set_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
exception exception_optional_set_set_binary_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
exception exception_optional_set_set_string_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
exception exception_optional_set_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
exception exception_optional_map_string_bool_box {
  @thrift.Box
  1: optional map<string, bool> field_1;
}
exception exception_optional_map_string_byte_box {
  @thrift.Box
  1: optional map<string, byte> field_1;
}
exception exception_optional_map_string_i16_box {
  @thrift.Box
  1: optional map<string, i16> field_1;
}
exception exception_optional_map_string_i32_box {
  @thrift.Box
  1: optional map<string, i32> field_1;
}
exception exception_optional_map_string_i64_box {
  @thrift.Box
  1: optional map<string, i64> field_1;
}
exception exception_optional_map_string_float_box {
  @thrift.Box
  1: optional map<string, float> field_1;
}
exception exception_optional_map_string_double_box {
  @thrift.Box
  1: optional map<string, double> field_1;
}
exception exception_optional_map_string_binary_box {
  @thrift.Box
  1: optional map<string, binary> field_1;
}
exception exception_optional_map_string_string_box {
  @thrift.Box
  1: optional map<string, string> field_1;
}
exception exception_optional_map_string_struct_empty_box {
  @thrift.Box
  1: optional map<string, struct_empty> field_1;
}
exception exception_optional_map_i64_bool_box {
  @thrift.Box
  1: optional map<i64, bool> field_1;
}
exception exception_optional_map_i64_byte_box {
  @thrift.Box
  1: optional map<i64, byte> field_1;
}
exception exception_optional_map_i64_i16_box {
  @thrift.Box
  1: optional map<i64, i16> field_1;
}
exception exception_optional_map_i64_i32_box {
  @thrift.Box
  1: optional map<i64, i32> field_1;
}
exception exception_optional_map_i64_i64_box {
  @thrift.Box
  1: optional map<i64, i64> field_1;
}
exception exception_optional_map_i64_float_box {
  @thrift.Box
  1: optional map<i64, float> field_1;
}
exception exception_optional_map_i64_double_box {
  @thrift.Box
  1: optional map<i64, double> field_1;
}
exception exception_optional_map_i64_binary_box {
  @thrift.Box
  1: optional map<i64, binary> field_1;
}
exception exception_optional_map_i64_string_box {
  @thrift.Box
  1: optional map<i64, string> field_1;
}
exception exception_optional_map_i64_struct_empty_box {
  @thrift.Box
  1: optional map<i64, struct_empty> field_1;
}
exception exception_optional_map_string_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
exception exception_optional_map_string_set_byte_box {
  @thrift.Box
  1: optional map<string, set<byte>> field_1;
}
exception exception_optional_map_string_set_i16_box {
  @thrift.Box
  1: optional map<string, set<i16>> field_1;
}
exception exception_optional_map_string_set_i32_box {
  @thrift.Box
  1: optional map<string, set<i32>> field_1;
}
exception exception_optional_map_string_set_i64_box {
  @thrift.Box
  1: optional map<string, set<i64>> field_1;
}
exception exception_optional_map_string_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
exception exception_optional_map_string_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
exception exception_optional_map_string_set_binary_box {
  @thrift.Box
  1: optional map<string, set<binary>> field_1;
}
exception exception_optional_map_string_set_string_box {
  @thrift.Box
  1: optional map<string, set<string>> field_1;
}
exception exception_optional_map_string_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
exception exception_optional_map_i64_set_bool_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
exception exception_optional_map_i64_set_byte_box {
  @thrift.Box
  1: optional map<i64, set<byte>> field_1;
}
exception exception_optional_map_i64_set_i16_box {
  @thrift.Box
  1: optional map<i64, set<i16>> field_1;
}
exception exception_optional_map_i64_set_i32_box {
  @thrift.Box
  1: optional map<i64, set<i32>> field_1;
}
exception exception_optional_map_i64_set_i64_box {
  @thrift.Box
  1: optional map<i64, set<i64>> field_1;
}
exception exception_optional_map_i64_set_float_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
exception exception_optional_map_i64_set_double_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
exception exception_optional_map_i64_set_binary_box {
  @thrift.Box
  1: optional map<i64, set<binary>> field_1;
}
exception exception_optional_map_i64_set_string_box {
  @thrift.Box
  1: optional map<i64, set<string>> field_1;
}
exception exception_optional_map_i64_set_struct_empty_box {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
exception exception_adapted_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_bool'}
  1: bool field_1;
}
exception exception_adapted_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_byte'}
  1: byte field_1;
}
exception exception_adapted_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i16'}
  1: i16 field_1;
}
exception exception_adapted_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i32'}
  1: i32 field_1;
}
exception exception_adapted_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i64'}
  1: i64 field_1;
}
exception exception_adapted_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_float'}
  1: float field_1;
}
exception exception_adapted_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_double'}
  1: double field_1;
}
exception exception_adapted_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_binary'}
  1: binary field_1;
}
exception exception_adapted_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_string'}
  1: string field_1;
}
exception exception_adapted_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_bool'}
  1: list<bool> field_1;
}
exception exception_adapted_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_byte'}
  1: list<byte> field_1;
}
exception exception_adapted_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i16'}
  1: list<i16> field_1;
}
exception exception_adapted_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i32'}
  1: list<i32> field_1;
}
exception exception_adapted_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i64'}
  1: list<i64> field_1;
}
exception exception_adapted_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_float'}
  1: list<float> field_1;
}
exception exception_adapted_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_double'}
  1: list<double> field_1;
}
exception exception_adapted_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_binary'}
  1: list<binary> field_1;
}
exception exception_adapted_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_string'}
  1: list<string> field_1;
}
exception exception_adapted_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_struct_empty'}
  1: list<struct_empty> field_1;
}
exception exception_adapted_list_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_bool'}
  1: list<list<bool>> field_1;
}
exception exception_adapted_list_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_byte'}
  1: list<list<byte>> field_1;
}
exception exception_adapted_list_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i16'}
  1: list<list<i16>> field_1;
}
exception exception_adapted_list_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i32'}
  1: list<list<i32>> field_1;
}
exception exception_adapted_list_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i64'}
  1: list<list<i64>> field_1;
}
exception exception_adapted_list_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_float'}
  1: list<list<float>> field_1;
}
exception exception_adapted_list_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_double'}
  1: list<list<double>> field_1;
}
exception exception_adapted_list_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_binary'}
  1: list<list<binary>> field_1;
}
exception exception_adapted_list_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_string'}
  1: list<list<string>> field_1;
}
exception exception_adapted_list_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_struct_empty'}
  1: list<list<struct_empty>> field_1;
}
exception exception_adapted_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_adapted_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_byte'}
  1: set<byte> field_1;
}
exception exception_adapted_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i16'}
  1: set<i16> field_1;
}
exception exception_adapted_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i32'}
  1: set<i32> field_1;
}
exception exception_adapted_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i64'}
  1: set<i64> field_1;
}
exception exception_adapted_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_adapted_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_adapted_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_binary'}
  1: set<binary> field_1;
}
exception exception_adapted_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_string'}
  1: set<string> field_1;
}
exception exception_adapted_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_adapted_set_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_adapted_set_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_byte'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_adapted_set_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i16'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_adapted_set_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i32'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_adapted_set_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i64'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_adapted_set_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_adapted_set_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_adapted_set_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_binary'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_adapted_set_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_string'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_adapted_set_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_adapted_map_string_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_bool'}
  1: map<string, bool> field_1;
}
exception exception_adapted_map_string_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_byte'}
  1: map<string, byte> field_1;
}
exception exception_adapted_map_string_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i16'}
  1: map<string, i16> field_1;
}
exception exception_adapted_map_string_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i32'}
  1: map<string, i32> field_1;
}
exception exception_adapted_map_string_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i64'}
  1: map<string, i64> field_1;
}
exception exception_adapted_map_string_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_float'}
  1: map<string, float> field_1;
}
exception exception_adapted_map_string_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_double'}
  1: map<string, double> field_1;
}
exception exception_adapted_map_string_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_binary'}
  1: map<string, binary> field_1;
}
exception exception_adapted_map_string_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_string'}
  1: map<string, string> field_1;
}
exception exception_adapted_map_string_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_struct_empty'}
  1: map<string, struct_empty> field_1;
}
exception exception_adapted_map_i64_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_bool'}
  1: map<i64, bool> field_1;
}
exception exception_adapted_map_i64_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_byte'}
  1: map<i64, byte> field_1;
}
exception exception_adapted_map_i64_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i16'}
  1: map<i64, i16> field_1;
}
exception exception_adapted_map_i64_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i32'}
  1: map<i64, i32> field_1;
}
exception exception_adapted_map_i64_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i64'}
  1: map<i64, i64> field_1;
}
exception exception_adapted_map_i64_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_float'}
  1: map<i64, float> field_1;
}
exception exception_adapted_map_i64_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_double'}
  1: map<i64, double> field_1;
}
exception exception_adapted_map_i64_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_binary'}
  1: map<i64, binary> field_1;
}
exception exception_adapted_map_i64_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_string'}
  1: map<i64, string> field_1;
}
exception exception_adapted_map_i64_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_struct_empty'}
  1: map<i64, struct_empty> field_1;
}
exception exception_adapted_map_string_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_adapted_map_string_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_byte'}
  1: map<string, set<byte>> field_1;
}
exception exception_adapted_map_string_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i16'}
  1: map<string, set<i16>> field_1;
}
exception exception_adapted_map_string_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i32'}
  1: map<string, set<i32>> field_1;
}
exception exception_adapted_map_string_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i64'}
  1: map<string, set<i64>> field_1;
}
exception exception_adapted_map_string_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_adapted_map_string_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_adapted_map_string_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_binary'}
  1: map<string, set<binary>> field_1;
}
exception exception_adapted_map_string_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_string'}
  1: map<string, set<string>> field_1;
}
exception exception_adapted_map_string_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_adapted_map_i64_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_adapted_map_i64_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_byte'}
  1: map<i64, set<byte>> field_1;
}
exception exception_adapted_map_i64_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i16'}
  1: map<i64, set<i16>> field_1;
}
exception exception_adapted_map_i64_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i32'}
  1: map<i64, set<i32>> field_1;
}
exception exception_adapted_map_i64_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i64'}
  1: map<i64, set<i64>> field_1;
}
exception exception_adapted_map_i64_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_adapted_map_i64_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_adapted_map_i64_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_binary'}
  1: map<i64, set<binary>> field_1;
}
exception exception_adapted_map_i64_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_string'}
  1: map<i64, set<string>> field_1;
}
exception exception_adapted_map_i64_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_field_adapted_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: bool field_1;
}
exception exception_field_adapted_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: byte field_1;
}
exception exception_field_adapted_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i16 field_1;
}
exception exception_field_adapted_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i32 field_1;
}
exception exception_field_adapted_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i64 field_1;
}
exception exception_field_adapted_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: float field_1;
}
exception exception_field_adapted_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: double field_1;
}
exception exception_field_adapted_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: binary field_1;
}
exception exception_field_adapted_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: string field_1;
}
exception exception_field_adapted_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<bool> field_1;
}
exception exception_field_adapted_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<byte> field_1;
}
exception exception_field_adapted_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i16> field_1;
}
exception exception_field_adapted_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i32> field_1;
}
exception exception_field_adapted_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i64> field_1;
}
exception exception_field_adapted_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<float> field_1;
}
exception exception_field_adapted_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<double> field_1;
}
exception exception_field_adapted_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<binary> field_1;
}
exception exception_field_adapted_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<string> field_1;
}
exception exception_field_adapted_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<struct_empty> field_1;
}
exception exception_field_adapted_list_list_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<bool>> field_1;
}
exception exception_field_adapted_list_list_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<byte>> field_1;
}
exception exception_field_adapted_list_list_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i16>> field_1;
}
exception exception_field_adapted_list_list_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i32>> field_1;
}
exception exception_field_adapted_list_list_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i64>> field_1;
}
exception exception_field_adapted_list_list_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<float>> field_1;
}
exception exception_field_adapted_list_list_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<double>> field_1;
}
exception exception_field_adapted_list_list_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<binary>> field_1;
}
exception exception_field_adapted_list_list_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<string>> field_1;
}
exception exception_field_adapted_list_list_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<struct_empty>> field_1;
}
exception exception_field_adapted_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_field_adapted_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<byte> field_1;
}
exception exception_field_adapted_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i16> field_1;
}
exception exception_field_adapted_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i32> field_1;
}
exception exception_field_adapted_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i64> field_1;
}
exception exception_field_adapted_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_field_adapted_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_field_adapted_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<binary> field_1;
}
exception exception_field_adapted_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<string> field_1;
}
exception exception_field_adapted_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_field_adapted_set_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_field_adapted_set_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_field_adapted_set_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_field_adapted_set_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_field_adapted_set_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_field_adapted_set_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_field_adapted_set_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_field_adapted_set_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_field_adapted_set_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_field_adapted_set_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_field_adapted_map_string_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, bool> field_1;
}
exception exception_field_adapted_map_string_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, byte> field_1;
}
exception exception_field_adapted_map_string_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i16> field_1;
}
exception exception_field_adapted_map_string_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i32> field_1;
}
exception exception_field_adapted_map_string_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i64> field_1;
}
exception exception_field_adapted_map_string_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, float> field_1;
}
exception exception_field_adapted_map_string_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, double> field_1;
}
exception exception_field_adapted_map_string_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, binary> field_1;
}
exception exception_field_adapted_map_string_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, string> field_1;
}
exception exception_field_adapted_map_string_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, struct_empty> field_1;
}
exception exception_field_adapted_map_i64_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, bool> field_1;
}
exception exception_field_adapted_map_i64_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, byte> field_1;
}
exception exception_field_adapted_map_i64_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i16> field_1;
}
exception exception_field_adapted_map_i64_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i32> field_1;
}
exception exception_field_adapted_map_i64_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i64> field_1;
}
exception exception_field_adapted_map_i64_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, float> field_1;
}
exception exception_field_adapted_map_i64_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, double> field_1;
}
exception exception_field_adapted_map_i64_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, binary> field_1;
}
exception exception_field_adapted_map_i64_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, string> field_1;
}
exception exception_field_adapted_map_i64_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, struct_empty> field_1;
}
exception exception_field_adapted_map_string_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_field_adapted_map_string_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<byte>> field_1;
}
exception exception_field_adapted_map_string_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i16>> field_1;
}
exception exception_field_adapted_map_string_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i32>> field_1;
}
exception exception_field_adapted_map_string_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i64>> field_1;
}
exception exception_field_adapted_map_string_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_field_adapted_map_string_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_field_adapted_map_string_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<binary>> field_1;
}
exception exception_field_adapted_map_string_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<string>> field_1;
}
exception exception_field_adapted_map_string_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_field_adapted_map_i64_set_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_field_adapted_map_i64_set_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<byte>> field_1;
}
exception exception_field_adapted_map_i64_set_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i16>> field_1;
}
exception exception_field_adapted_map_i64_set_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i32>> field_1;
}
exception exception_field_adapted_map_i64_set_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i64>> field_1;
}
exception exception_field_adapted_map_i64_set_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_field_adapted_map_i64_set_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_field_adapted_map_i64_set_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<binary>> field_1;
}
exception exception_field_adapted_map_i64_set_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<string>> field_1;
}
exception exception_field_adapted_map_i64_set_struct_empty {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_list_bool_lazy {
  @cpp.Lazy
  1: list<bool> field_1;
}
exception exception_list_byte_lazy {
  @cpp.Lazy
  1: list<byte> field_1;
}
exception exception_list_i16_lazy {
  @cpp.Lazy
  1: list<i16> field_1;
}
exception exception_list_i32_lazy {
  @cpp.Lazy
  1: list<i32> field_1;
}
exception exception_list_i64_lazy {
  @cpp.Lazy
  1: list<i64> field_1;
}
exception exception_list_float_lazy {
  @cpp.Lazy
  1: list<float> field_1;
}
exception exception_list_double_lazy {
  @cpp.Lazy
  1: list<double> field_1;
}
exception exception_list_binary_lazy {
  @cpp.Lazy
  1: list<binary> field_1;
}
exception exception_list_string_lazy {
  @cpp.Lazy
  1: list<string> field_1;
}
exception exception_list_struct_empty_lazy {
  @cpp.Lazy
  1: list<struct_empty> field_1;
}
exception exception_list_list_bool_lazy {
  @cpp.Lazy
  1: list<list<bool>> field_1;
}
exception exception_list_list_byte_lazy {
  @cpp.Lazy
  1: list<list<byte>> field_1;
}
exception exception_list_list_i16_lazy {
  @cpp.Lazy
  1: list<list<i16>> field_1;
}
exception exception_list_list_i32_lazy {
  @cpp.Lazy
  1: list<list<i32>> field_1;
}
exception exception_list_list_i64_lazy {
  @cpp.Lazy
  1: list<list<i64>> field_1;
}
exception exception_list_list_float_lazy {
  @cpp.Lazy
  1: list<list<float>> field_1;
}
exception exception_list_list_double_lazy {
  @cpp.Lazy
  1: list<list<double>> field_1;
}
exception exception_list_list_binary_lazy {
  @cpp.Lazy
  1: list<list<binary>> field_1;
}
exception exception_list_list_string_lazy {
  @cpp.Lazy
  1: list<list<string>> field_1;
}
exception exception_list_list_struct_empty_lazy {
  @cpp.Lazy
  1: list<list<struct_empty>> field_1;
}
exception exception_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
exception exception_set_byte_lazy {
  @cpp.Lazy
  1: set<byte> field_1;
}
exception exception_set_i16_lazy {
  @cpp.Lazy
  1: set<i16> field_1;
}
exception exception_set_i32_lazy {
  @cpp.Lazy
  1: set<i32> field_1;
}
exception exception_set_i64_lazy {
  @cpp.Lazy
  1: set<i64> field_1;
}
exception exception_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
exception exception_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
exception exception_set_binary_lazy {
  @cpp.Lazy
  1: set<binary> field_1;
}
exception exception_set_string_lazy {
  @cpp.Lazy
  1: set<string> field_1;
}
exception exception_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
exception exception_set_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
exception exception_set_set_byte_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
exception exception_set_set_i16_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
exception exception_set_set_i32_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
exception exception_set_set_i64_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
exception exception_set_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
exception exception_set_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
exception exception_set_set_binary_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
exception exception_set_set_string_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
exception exception_set_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
exception exception_map_string_bool_lazy {
  @cpp.Lazy
  1: map<string, bool> field_1;
}
exception exception_map_string_byte_lazy {
  @cpp.Lazy
  1: map<string, byte> field_1;
}
exception exception_map_string_i16_lazy {
  @cpp.Lazy
  1: map<string, i16> field_1;
}
exception exception_map_string_i32_lazy {
  @cpp.Lazy
  1: map<string, i32> field_1;
}
exception exception_map_string_i64_lazy {
  @cpp.Lazy
  1: map<string, i64> field_1;
}
exception exception_map_string_float_lazy {
  @cpp.Lazy
  1: map<string, float> field_1;
}
exception exception_map_string_double_lazy {
  @cpp.Lazy
  1: map<string, double> field_1;
}
exception exception_map_string_binary_lazy {
  @cpp.Lazy
  1: map<string, binary> field_1;
}
exception exception_map_string_string_lazy {
  @cpp.Lazy
  1: map<string, string> field_1;
}
exception exception_map_string_struct_empty_lazy {
  @cpp.Lazy
  1: map<string, struct_empty> field_1;
}
exception exception_map_i64_bool_lazy {
  @cpp.Lazy
  1: map<i64, bool> field_1;
}
exception exception_map_i64_byte_lazy {
  @cpp.Lazy
  1: map<i64, byte> field_1;
}
exception exception_map_i64_i16_lazy {
  @cpp.Lazy
  1: map<i64, i16> field_1;
}
exception exception_map_i64_i32_lazy {
  @cpp.Lazy
  1: map<i64, i32> field_1;
}
exception exception_map_i64_i64_lazy {
  @cpp.Lazy
  1: map<i64, i64> field_1;
}
exception exception_map_i64_float_lazy {
  @cpp.Lazy
  1: map<i64, float> field_1;
}
exception exception_map_i64_double_lazy {
  @cpp.Lazy
  1: map<i64, double> field_1;
}
exception exception_map_i64_binary_lazy {
  @cpp.Lazy
  1: map<i64, binary> field_1;
}
exception exception_map_i64_string_lazy {
  @cpp.Lazy
  1: map<i64, string> field_1;
}
exception exception_map_i64_struct_empty_lazy {
  @cpp.Lazy
  1: map<i64, struct_empty> field_1;
}
exception exception_map_string_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
exception exception_map_string_set_byte_lazy {
  @cpp.Lazy
  1: map<string, set<byte>> field_1;
}
exception exception_map_string_set_i16_lazy {
  @cpp.Lazy
  1: map<string, set<i16>> field_1;
}
exception exception_map_string_set_i32_lazy {
  @cpp.Lazy
  1: map<string, set<i32>> field_1;
}
exception exception_map_string_set_i64_lazy {
  @cpp.Lazy
  1: map<string, set<i64>> field_1;
}
exception exception_map_string_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
exception exception_map_string_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
exception exception_map_string_set_binary_lazy {
  @cpp.Lazy
  1: map<string, set<binary>> field_1;
}
exception exception_map_string_set_string_lazy {
  @cpp.Lazy
  1: map<string, set<string>> field_1;
}
exception exception_map_string_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
exception exception_map_i64_set_bool_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
exception exception_map_i64_set_byte_lazy {
  @cpp.Lazy
  1: map<i64, set<byte>> field_1;
}
exception exception_map_i64_set_i16_lazy {
  @cpp.Lazy
  1: map<i64, set<i16>> field_1;
}
exception exception_map_i64_set_i32_lazy {
  @cpp.Lazy
  1: map<i64, set<i32>> field_1;
}
exception exception_map_i64_set_i64_lazy {
  @cpp.Lazy
  1: map<i64, set<i64>> field_1;
}
exception exception_map_i64_set_float_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
exception exception_map_i64_set_double_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
exception exception_map_i64_set_binary_lazy {
  @cpp.Lazy
  1: map<i64, set<binary>> field_1;
}
exception exception_map_i64_set_string_lazy {
  @cpp.Lazy
  1: map<i64, set<string>> field_1;
}
exception exception_map_i64_set_struct_empty_lazy {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
exception exception_string_lazy {
  @cpp.Lazy
  1: string field_1;
}
@cpp.UseOpEncode
exception exception_empty_op_encoded {
}
@cpp.UseOpEncode
exception exception_list_bool_op_encoded {
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_list_byte_op_encoded {
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_list_i16_op_encoded {
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_list_i32_op_encoded {
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_list_i64_op_encoded {
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_list_float_op_encoded {
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_list_double_op_encoded {
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_list_binary_op_encoded {
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_list_string_op_encoded {
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_list_struct_empty_op_encoded {
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_bool_op_encoded {
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_byte_op_encoded {
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i16_op_encoded {
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i32_op_encoded {
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i64_op_encoded {
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_float_op_encoded {
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_double_op_encoded {
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_binary_op_encoded {
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_string_op_encoded {
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_struct_empty_op_encoded {
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_set_byte_op_encoded {
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_set_i16_op_encoded {
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_set_i32_op_encoded {
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_set_i64_op_encoded {
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_set_binary_op_encoded {
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_set_string_op_encoded {
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_bool_op_encoded {
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_byte_op_encoded {
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i16_op_encoded {
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i32_op_encoded {
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i64_op_encoded {
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_float_op_encoded {
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_double_op_encoded {
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_binary_op_encoded {
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_string_op_encoded {
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_struct_empty_op_encoded {
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_bool_op_encoded {
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_byte_op_encoded {
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i16_op_encoded {
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i32_op_encoded {
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i64_op_encoded {
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_float_op_encoded {
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_double_op_encoded {
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_binary_op_encoded {
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_string_op_encoded {
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_struct_empty_op_encoded {
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_byte_op_encoded {
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i16_op_encoded {
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i32_op_encoded {
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i64_op_encoded {
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_binary_op_encoded {
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_string_op_encoded {
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_byte_op_encoded {
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i16_op_encoded {
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i32_op_encoded {
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i64_op_encoded {
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_binary_op_encoded {
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_string_op_encoded {
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_bool_op_encoded {
  1: bool field_1;
}
@cpp.UseOpEncode
exception exception_byte_op_encoded {
  1: byte field_1;
}
@cpp.UseOpEncode
exception exception_i16_op_encoded {
  1: i16 field_1;
}
@cpp.UseOpEncode
exception exception_i32_op_encoded {
  1: i32 field_1;
}
@cpp.UseOpEncode
exception exception_i64_op_encoded {
  1: i64 field_1;
}
@cpp.UseOpEncode
exception exception_float_op_encoded {
  1: float field_1;
}
@cpp.UseOpEncode
exception exception_double_op_encoded {
  1: double field_1;
}
@cpp.UseOpEncode
exception exception_binary_op_encoded {
  1: binary field_1;
}
@cpp.UseOpEncode
exception exception_string_op_encoded {
  1: string field_1;
}
@cpp.UseOpEncode
exception exception_bool_custom_default_op_encoded {
  1: bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_byte_custom_default_op_encoded {
  1: byte field_1 = 1;
}
@cpp.UseOpEncode
exception exception_i16_custom_default_op_encoded {
  1: i16 field_1 = 2;
}
@cpp.UseOpEncode
exception exception_i32_custom_default_op_encoded {
  1: i32 field_1 = 3;
}
@cpp.UseOpEncode
exception exception_i64_custom_default_op_encoded {
  1: i64 field_1 = 4;
}
@cpp.UseOpEncode
exception exception_float_custom_default_op_encoded {
  1: float field_1 = 5;
}
@cpp.UseOpEncode
exception exception_double_custom_default_op_encoded {
  1: double field_1 = 6;
}
@cpp.UseOpEncode
exception exception_binary_custom_default_op_encoded {
  1: binary field_1 = "7";
}
@cpp.UseOpEncode
exception exception_string_custom_default_op_encoded {
  1: string field_1 = "8";
}
@cpp.UseOpEncode
exception exception_bool_alternative_custom_default_op_encoded {
  1: bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_byte_alternative_custom_default_op_encoded {
  1: byte field_1 = 10;
}
@cpp.UseOpEncode
exception exception_i16_alternative_custom_default_op_encoded {
  1: i16 field_1 = 20;
}
@cpp.UseOpEncode
exception exception_i32_alternative_custom_default_op_encoded {
  1: i32 field_1 = 30;
}
@cpp.UseOpEncode
exception exception_i64_alternative_custom_default_op_encoded {
  1: i64 field_1 = 40;
}
@cpp.UseOpEncode
exception exception_float_alternative_custom_default_op_encoded {
  1: float field_1 = 50;
}
@cpp.UseOpEncode
exception exception_double_alternative_custom_default_op_encoded {
  1: double field_1 = 60;
}
@cpp.UseOpEncode
exception exception_binary_alternative_custom_default_op_encoded {
  1: binary field_1 = "70";
}
@cpp.UseOpEncode
exception exception_string_alternative_custom_default_op_encoded {
  1: string field_1 = "80";
}
@cpp.UseOpEncode
exception exception_optional_list_bool_op_encoded {
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_byte_op_encoded {
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i16_op_encoded {
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i32_op_encoded {
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i64_op_encoded {
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_float_op_encoded {
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_double_op_encoded {
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_binary_op_encoded {
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_string_op_encoded {
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_struct_empty_op_encoded {
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_bool_op_encoded {
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_byte_op_encoded {
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i16_op_encoded {
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i32_op_encoded {
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i64_op_encoded {
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_float_op_encoded {
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_double_op_encoded {
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_binary_op_encoded {
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_string_op_encoded {
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_struct_empty_op_encoded {
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_byte_op_encoded {
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i16_op_encoded {
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i32_op_encoded {
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i64_op_encoded {
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_binary_op_encoded {
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_string_op_encoded {
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_bool_op_encoded {
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_byte_op_encoded {
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i16_op_encoded {
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i32_op_encoded {
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i64_op_encoded {
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_float_op_encoded {
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_double_op_encoded {
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_binary_op_encoded {
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_string_op_encoded {
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_struct_empty_op_encoded {
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_bool_op_encoded {
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_byte_op_encoded {
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i16_op_encoded {
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i32_op_encoded {
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i64_op_encoded {
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_float_op_encoded {
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_double_op_encoded {
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_binary_op_encoded {
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_string_op_encoded {
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_struct_empty_op_encoded {
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_byte_op_encoded {
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i16_op_encoded {
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i32_op_encoded {
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i64_op_encoded {
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_binary_op_encoded {
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_string_op_encoded {
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_byte_op_encoded {
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i16_op_encoded {
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i32_op_encoded {
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i64_op_encoded {
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_binary_op_encoded {
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_string_op_encoded {
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_bool_op_encoded {
  1: optional bool field_1;
}
@cpp.UseOpEncode
exception exception_optional_byte_op_encoded {
  1: optional byte field_1;
}
@cpp.UseOpEncode
exception exception_optional_i16_op_encoded {
  1: optional i16 field_1;
}
@cpp.UseOpEncode
exception exception_optional_i32_op_encoded {
  1: optional i32 field_1;
}
@cpp.UseOpEncode
exception exception_optional_i64_op_encoded {
  1: optional i64 field_1;
}
@cpp.UseOpEncode
exception exception_optional_float_op_encoded {
  1: optional float field_1;
}
@cpp.UseOpEncode
exception exception_optional_double_op_encoded {
  1: optional double field_1;
}
@cpp.UseOpEncode
exception exception_optional_binary_op_encoded {
  1: optional binary field_1;
}
@cpp.UseOpEncode
exception exception_optional_string_op_encoded {
  1: optional string field_1;
}
@cpp.UseOpEncode
exception exception_optional_bool_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_optional_byte_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 1;
}
@cpp.UseOpEncode
exception exception_optional_i16_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 2;
}
@cpp.UseOpEncode
exception exception_optional_i32_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 3;
}
@cpp.UseOpEncode
exception exception_optional_i64_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 4;
}
@cpp.UseOpEncode
exception exception_optional_float_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 5;
}
@cpp.UseOpEncode
exception exception_optional_double_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 6;
}
@cpp.UseOpEncode
exception exception_optional_binary_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "7";
}
@cpp.UseOpEncode
exception exception_optional_string_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "8";
}
@cpp.UseOpEncode
exception exception_optional_bool_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_optional_byte_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional byte field_1 = 10;
}
@cpp.UseOpEncode
exception exception_optional_i16_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i16 field_1 = 20;
}
@cpp.UseOpEncode
exception exception_optional_i32_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i32 field_1 = 30;
}
@cpp.UseOpEncode
exception exception_optional_i64_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional i64 field_1 = 40;
}
@cpp.UseOpEncode
exception exception_optional_float_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional float field_1 = 50;
}
@cpp.UseOpEncode
exception exception_optional_double_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional double field_1 = 60;
}
@cpp.UseOpEncode
exception exception_optional_binary_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional binary field_1 = "70";
}
@cpp.UseOpEncode
exception exception_optional_string_alternative_custom_default_op_encoded {
  @thrift.AllowUnsafeOptionalCustomDefaultValue
  1: optional string field_1 = "80";
}
@cpp.UseOpEncode
exception exception_required_list_bool_op_encoded {
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_byte_op_encoded {
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i16_op_encoded {
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i32_op_encoded {
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i64_op_encoded {
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_float_op_encoded {
  1: required list<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_double_op_encoded {
  1: required list<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_binary_op_encoded {
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_string_op_encoded {
  1: required list<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_struct_empty_op_encoded {
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_bool_op_encoded {
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_byte_op_encoded {
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i16_op_encoded {
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i32_op_encoded {
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i64_op_encoded {
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_float_op_encoded {
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_double_op_encoded {
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_binary_op_encoded {
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_string_op_encoded {
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_struct_empty_op_encoded {
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_byte_op_encoded {
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i16_op_encoded {
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i32_op_encoded {
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i64_op_encoded {
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_binary_op_encoded {
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_string_op_encoded {
  1: required set<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_bool_op_encoded {
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_byte_op_encoded {
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i16_op_encoded {
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i32_op_encoded {
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i64_op_encoded {
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_float_op_encoded {
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_double_op_encoded {
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_binary_op_encoded {
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_string_op_encoded {
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_struct_empty_op_encoded {
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_bool_op_encoded {
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_byte_op_encoded {
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i16_op_encoded {
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i32_op_encoded {
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i64_op_encoded {
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_float_op_encoded {
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_double_op_encoded {
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_binary_op_encoded {
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_string_op_encoded {
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_struct_empty_op_encoded {
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_byte_op_encoded {
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i16_op_encoded {
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i32_op_encoded {
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i64_op_encoded {
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_binary_op_encoded {
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_string_op_encoded {
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_byte_op_encoded {
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i16_op_encoded {
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i32_op_encoded {
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i64_op_encoded {
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_binary_op_encoded {
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_string_op_encoded {
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<float> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<double> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required set<string> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: required map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_required_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: required map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_required_bool_op_encoded {
  1: required bool field_1;
}
@cpp.UseOpEncode
exception exception_required_byte_op_encoded {
  1: required byte field_1;
}
@cpp.UseOpEncode
exception exception_required_i16_op_encoded {
  1: required i16 field_1;
}
@cpp.UseOpEncode
exception exception_required_i32_op_encoded {
  1: required i32 field_1;
}
@cpp.UseOpEncode
exception exception_required_i64_op_encoded {
  1: required i64 field_1;
}
@cpp.UseOpEncode
exception exception_required_float_op_encoded {
  1: required float field_1;
}
@cpp.UseOpEncode
exception exception_required_double_op_encoded {
  1: required double field_1;
}
@cpp.UseOpEncode
exception exception_required_binary_op_encoded {
  1: required binary field_1;
}
@cpp.UseOpEncode
exception exception_required_string_op_encoded {
  1: required string field_1;
}
@cpp.UseOpEncode
exception exception_required_bool_custom_default_op_encoded {
  1: required bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_required_byte_custom_default_op_encoded {
  1: required byte field_1 = 1;
}
@cpp.UseOpEncode
exception exception_required_i16_custom_default_op_encoded {
  1: required i16 field_1 = 2;
}
@cpp.UseOpEncode
exception exception_required_i32_custom_default_op_encoded {
  1: required i32 field_1 = 3;
}
@cpp.UseOpEncode
exception exception_required_i64_custom_default_op_encoded {
  1: required i64 field_1 = 4;
}
@cpp.UseOpEncode
exception exception_required_float_custom_default_op_encoded {
  1: required float field_1 = 5;
}
@cpp.UseOpEncode
exception exception_required_double_custom_default_op_encoded {
  1: required double field_1 = 6;
}
@cpp.UseOpEncode
exception exception_required_binary_custom_default_op_encoded {
  1: required binary field_1 = "7";
}
@cpp.UseOpEncode
exception exception_required_string_custom_default_op_encoded {
  1: required string field_1 = "8";
}
@cpp.UseOpEncode
exception exception_required_bool_alternative_custom_default_op_encoded {
  1: required bool field_1 = true;
}
@cpp.UseOpEncode
exception exception_required_byte_alternative_custom_default_op_encoded {
  1: required byte field_1 = 10;
}
@cpp.UseOpEncode
exception exception_required_i16_alternative_custom_default_op_encoded {
  1: required i16 field_1 = 20;
}
@cpp.UseOpEncode
exception exception_required_i32_alternative_custom_default_op_encoded {
  1: required i32 field_1 = 30;
}
@cpp.UseOpEncode
exception exception_required_i64_alternative_custom_default_op_encoded {
  1: required i64 field_1 = 40;
}
@cpp.UseOpEncode
exception exception_required_float_alternative_custom_default_op_encoded {
  1: required float field_1 = 50;
}
@cpp.UseOpEncode
exception exception_required_double_alternative_custom_default_op_encoded {
  1: required double field_1 = 60;
}
@cpp.UseOpEncode
exception exception_required_binary_alternative_custom_default_op_encoded {
  1: required binary field_1 = "70";
}
@cpp.UseOpEncode
exception exception_required_string_alternative_custom_default_op_encoded {
  1: required string field_1 = "80";
}
@cpp.UseOpEncode
exception exception_terse_list_bool_op_encoded {
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_byte_op_encoded {
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i16_op_encoded {
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i32_op_encoded {
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i64_op_encoded {
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_float_op_encoded {
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_double_op_encoded {
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_binary_op_encoded {
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_string_op_encoded {
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_bool_op_encoded {
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_byte_op_encoded {
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i16_op_encoded {
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i32_op_encoded {
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i64_op_encoded {
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_float_op_encoded {
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_double_op_encoded {
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_binary_op_encoded {
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_string_op_encoded {
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_byte_op_encoded {
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i16_op_encoded {
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i32_op_encoded {
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i64_op_encoded {
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_binary_op_encoded {
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_string_op_encoded {
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_bool_op_encoded {
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_byte_op_encoded {
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i16_op_encoded {
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i32_op_encoded {
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i64_op_encoded {
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_float_op_encoded {
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_double_op_encoded {
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_binary_op_encoded {
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_string_op_encoded {
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_bool_op_encoded {
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_byte_op_encoded {
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i16_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i32_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i64_op_encoded {
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_float_op_encoded {
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_double_op_encoded {
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_binary_op_encoded {
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_string_op_encoded {
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_struct_empty_op_encoded {
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_byte_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i16_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i32_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i64_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_binary_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_string_op_encoded {
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_byte_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i16_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i32_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i64_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_binary_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_string_op_encoded {
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @thrift.TerseWrite
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @thrift.TerseWrite
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_terse_bool_op_encoded {
  @thrift.TerseWrite
  1: bool field_1;
}
@cpp.UseOpEncode
exception exception_terse_byte_op_encoded {
  @thrift.TerseWrite
  1: byte field_1;
}
@cpp.UseOpEncode
exception exception_terse_i16_op_encoded {
  @thrift.TerseWrite
  1: i16 field_1;
}
@cpp.UseOpEncode
exception exception_terse_i32_op_encoded {
  @thrift.TerseWrite
  1: i32 field_1;
}
@cpp.UseOpEncode
exception exception_terse_i64_op_encoded {
  @thrift.TerseWrite
  1: i64 field_1;
}
@cpp.UseOpEncode
exception exception_terse_float_op_encoded {
  @thrift.TerseWrite
  1: float field_1;
}
@cpp.UseOpEncode
exception exception_terse_double_op_encoded {
  @thrift.TerseWrite
  1: double field_1;
}
@cpp.UseOpEncode
exception exception_terse_binary_op_encoded {
  @thrift.TerseWrite
  1: binary field_1;
}
@cpp.UseOpEncode
exception exception_terse_string_op_encoded {
  @thrift.TerseWrite
  1: string field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_bool_box_op_encoded {
  @thrift.Box
  1: optional list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_byte_box_op_encoded {
  @thrift.Box
  1: optional list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i16_box_op_encoded {
  @thrift.Box
  1: optional list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i32_box_op_encoded {
  @thrift.Box
  1: optional list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_i64_box_op_encoded {
  @thrift.Box
  1: optional list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_float_box_op_encoded {
  @thrift.Box
  1: optional list<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_double_box_op_encoded {
  @thrift.Box
  1: optional list<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_binary_box_op_encoded {
  @thrift.Box
  1: optional list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_string_box_op_encoded {
  @thrift.Box
  1: optional list<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_bool_box_op_encoded {
  @thrift.Box
  1: optional list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_byte_box_op_encoded {
  @thrift.Box
  1: optional list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i16_box_op_encoded {
  @thrift.Box
  1: optional list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i32_box_op_encoded {
  @thrift.Box
  1: optional list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_i64_box_op_encoded {
  @thrift.Box
  1: optional list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_float_box_op_encoded {
  @thrift.Box
  1: optional list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_double_box_op_encoded {
  @thrift.Box
  1: optional list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_binary_box_op_encoded {
  @thrift.Box
  1: optional list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_string_box_op_encoded {
  @thrift.Box
  1: optional list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_list_list_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_byte_box_op_encoded {
  @thrift.Box
  1: optional set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i16_box_op_encoded {
  @thrift.Box
  1: optional set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i32_box_op_encoded {
  @thrift.Box
  1: optional set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_i64_box_op_encoded {
  @thrift.Box
  1: optional set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_binary_box_op_encoded {
  @thrift.Box
  1: optional set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_string_box_op_encoded {
  @thrift.Box
  1: optional set<string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_byte_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i16_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i32_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_i64_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_binary_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_string_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_set_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_bool_box_op_encoded {
  @thrift.Box
  1: optional map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_byte_box_op_encoded {
  @thrift.Box
  1: optional map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i16_box_op_encoded {
  @thrift.Box
  1: optional map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i32_box_op_encoded {
  @thrift.Box
  1: optional map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_i64_box_op_encoded {
  @thrift.Box
  1: optional map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_float_box_op_encoded {
  @thrift.Box
  1: optional map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_double_box_op_encoded {
  @thrift.Box
  1: optional map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_binary_box_op_encoded {
  @thrift.Box
  1: optional map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_string_box_op_encoded {
  @thrift.Box
  1: optional map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_bool_box_op_encoded {
  @thrift.Box
  1: optional map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_byte_box_op_encoded {
  @thrift.Box
  1: optional map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i16_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i32_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_i64_box_op_encoded {
  @thrift.Box
  1: optional map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_float_box_op_encoded {
  @thrift.Box
  1: optional map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_double_box_op_encoded {
  @thrift.Box
  1: optional map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_binary_box_op_encoded {
  @thrift.Box
  1: optional map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_string_box_op_encoded {
  @thrift.Box
  1: optional map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_struct_empty_box_op_encoded {
  @thrift.Box
  1: optional map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_byte_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i16_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i32_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_i64_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_binary_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_string_box_op_encoded {
  @thrift.Box
  1: optional map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_string_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_bool_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_byte_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i16_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i32_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_i64_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_float_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_double_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_binary_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_string_box_op_encoded {
  @thrift.Box
  1: optional map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_optional_map_i64_set_struct_empty_box_op_encoded {
  @thrift.Box
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: optional map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_bool'}
  1: bool field_1;
}
@cpp.UseOpEncode
exception exception_adapted_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_byte'}
  1: byte field_1;
}
@cpp.UseOpEncode
exception exception_adapted_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i16'}
  1: i16 field_1;
}
@cpp.UseOpEncode
exception exception_adapted_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i32'}
  1: i32 field_1;
}
@cpp.UseOpEncode
exception exception_adapted_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_i64'}
  1: i64 field_1;
}
@cpp.UseOpEncode
exception exception_adapted_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_float'}
  1: float field_1;
}
@cpp.UseOpEncode
exception exception_adapted_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_double'}
  1: double field_1;
}
@cpp.UseOpEncode
exception exception_adapted_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_binary'}
  1: binary field_1;
}
@cpp.UseOpEncode
exception exception_adapted_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_string'}
  1: string field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_bool'}
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_byte'}
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i16'}
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i32'}
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_i64'}
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_float'}
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_double'}
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_binary'}
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_string'}
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_struct_empty'}
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_bool'}
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_byte'}
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i16'}
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i32'}
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_i64'}
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_float'}
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_double'}
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_binary'}
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_string'}
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_list_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_list_list_struct_empty'}
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_byte'}
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i16'}
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i32'}
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_i64'}
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_binary'}
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_string'}
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_byte'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i16'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i32'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_i64'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_binary'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_string'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_set_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_set_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_bool'}
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_byte'}
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i16'}
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i32'}
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_i64'}
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_float'}
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_double'}
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_binary'}
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_string'}
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_struct_empty'}
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_bool'}
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_byte'}
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i16'}
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i32'}
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_i64'}
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_float'}
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_double'}
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_binary'}
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_string'}
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_struct_empty'}
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_byte'}
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i16'}
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i32'}
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_i64'}
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_binary'}
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_string'}
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_string_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_string_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_bool'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_byte'}
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i16'}
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i32'}
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_i64'}
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_float'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_double'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_binary'}
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_string'}
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_adapted_map_i64_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_map_i64_set_struct_empty'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: bool field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: byte field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i16 field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i32 field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: i64 field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: float field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: double field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: binary field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: string field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_list_list_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_set_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_string_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_bool_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_byte_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_i16_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_i32_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_i64_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_float_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_double_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_binary_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_string_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_field_adapted_map_i64_set_struct_empty_op_encoded {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_list_bool_lazy_op_encoded {
  @cpp.Lazy
  1: list<bool> field_1;
}
@cpp.UseOpEncode
exception exception_list_byte_lazy_op_encoded {
  @cpp.Lazy
  1: list<byte> field_1;
}
@cpp.UseOpEncode
exception exception_list_i16_lazy_op_encoded {
  @cpp.Lazy
  1: list<i16> field_1;
}
@cpp.UseOpEncode
exception exception_list_i32_lazy_op_encoded {
  @cpp.Lazy
  1: list<i32> field_1;
}
@cpp.UseOpEncode
exception exception_list_i64_lazy_op_encoded {
  @cpp.Lazy
  1: list<i64> field_1;
}
@cpp.UseOpEncode
exception exception_list_float_lazy_op_encoded {
  @cpp.Lazy
  1: list<float> field_1;
}
@cpp.UseOpEncode
exception exception_list_double_lazy_op_encoded {
  @cpp.Lazy
  1: list<double> field_1;
}
@cpp.UseOpEncode
exception exception_list_binary_lazy_op_encoded {
  @cpp.Lazy
  1: list<binary> field_1;
}
@cpp.UseOpEncode
exception exception_list_string_lazy_op_encoded {
  @cpp.Lazy
  1: list<string> field_1;
}
@cpp.UseOpEncode
exception exception_list_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: list<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_bool_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_byte_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i16_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i32_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_i64_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_float_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<float>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_double_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<double>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_binary_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_string_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<string>> field_1;
}
@cpp.UseOpEncode
exception exception_list_list_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: list<list<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
}
@cpp.UseOpEncode
exception exception_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: set<byte> field_1;
}
@cpp.UseOpEncode
exception exception_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: set<i16> field_1;
}
@cpp.UseOpEncode
exception exception_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: set<i32> field_1;
}
@cpp.UseOpEncode
exception exception_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: set<i64> field_1;
}
@cpp.UseOpEncode
exception exception_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
}
@cpp.UseOpEncode
exception exception_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
}
@cpp.UseOpEncode
exception exception_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: set<binary> field_1;
}
@cpp.UseOpEncode
exception exception_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: set<string> field_1;
}
@cpp.UseOpEncode
exception exception_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_byte_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i16_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i32_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_i64_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_binary_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_string_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_set_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_bool_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_float_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_double_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_bool_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, bool> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, byte> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i16> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i32> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, i64> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_float_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, float> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_double_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, double> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, binary> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, string> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, struct_empty> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<string, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_string_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_bool_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_byte_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<byte>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i16_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i16>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i32_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i32>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_i64_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<i64>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_float_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_double_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_binary_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<binary>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_string_lazy_op_encoded {
  @cpp.Lazy
  1: map<i64, set<string>> field_1;
}
@cpp.UseOpEncode
exception exception_map_i64_set_struct_empty_lazy_op_encoded {
  @cpp.Lazy
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
}
@cpp.UseOpEncode
exception exception_string_lazy_op_encoded {
  @cpp.Lazy
  1: string field_1;
}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_bool'}
  typedef bool adapted_typedef_bool 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_byte'}
  typedef byte adapted_typedef_byte 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_i16'}
  typedef i16 adapted_typedef_i16 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_i32'}
  typedef i32 adapted_typedef_i32 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_i64'}
  typedef i64 adapted_typedef_i64 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_float'}
  typedef float adapted_typedef_float 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_double'}
  typedef double adapted_typedef_double 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_binary'}
  typedef binary adapted_typedef_binary 
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Adapter{name = 'ConformanceTestAdapter_adapted_typedef_string'}
  typedef string adapted_typedef_string 
@cpp.UseOpEncode
struct struct_adapted_typedef_bool {
  1: adapted_typedef_bool field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_byte {
  1: adapted_typedef_byte field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i16 {
  1: adapted_typedef_i16 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i32 {
  1: adapted_typedef_i32 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i64 {
  1: adapted_typedef_i64 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_float {
  1: adapted_typedef_float field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_double {
  1: adapted_typedef_double field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_binary {
  1: adapted_typedef_binary field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_string {
  1: adapted_typedef_string field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_bool {
  1: list<adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_byte {
  1: list<adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_i16 {
  1: list<adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_i32 {
  1: list<adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_i64 {
  1: list<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_float {
  1: list<adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_double {
  1: list<adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_binary {
  1: list<adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_list_adapted_typedef_string {
  1: list<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_set_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_set_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_string_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_map_adapted_typedef_i64_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_bool_custom_default {
  1: adapted_typedef_bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_byte_custom_default {
  1: adapted_typedef_byte field_1 = 1;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i16_custom_default {
  1: adapted_typedef_i16 field_1 = 2;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i32_custom_default {
  1: adapted_typedef_i32 field_1 = 3;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i64_custom_default {
  1: adapted_typedef_i64 field_1 = 4;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_float_custom_default {
  1: adapted_typedef_float field_1 = 5;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_double_custom_default {
  1: adapted_typedef_double field_1 = 6;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_binary_custom_default {
  1: adapted_typedef_binary field_1 = "7";
}
@cpp.UseOpEncode
struct struct_adapted_typedef_string_custom_default {
  1: adapted_typedef_string field_1 = "8";
}
@cpp.UseOpEncode
struct struct_adapted_typedef_bool_alternative_custom_default {
  1: adapted_typedef_bool field_1 = true;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_byte_alternative_custom_default {
  1: adapted_typedef_byte field_1 = 10;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i16_alternative_custom_default {
  1: adapted_typedef_i16 field_1 = 20;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i32_alternative_custom_default {
  1: adapted_typedef_i32 field_1 = 30;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_i64_alternative_custom_default {
  1: adapted_typedef_i64 field_1 = 40;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_float_alternative_custom_default {
  1: adapted_typedef_float field_1 = 50;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_double_alternative_custom_default {
  1: adapted_typedef_double field_1 = 60;
}
@cpp.UseOpEncode
struct struct_adapted_typedef_binary_alternative_custom_default {
  1: adapted_typedef_binary field_1 = "70";
}
@cpp.UseOpEncode
struct struct_adapted_typedef_string_alternative_custom_default {
  1: adapted_typedef_string field_1 = "80";
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_bool field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_byte field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_i16 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_i32 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_i64 field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_float field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_double field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_binary field_1;
}
@cpp.UseOpEncode
struct struct_adapted_adapted_typedef_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: adapted_typedef_string field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_list_adapted_typedef_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: list<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: set<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_set_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: set<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_string_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_string, adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_adapted_map_adapted_typedef_i64_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestAdapter'}
  @java.Adapter{adapterClassName = 'com.facebook.thrift.adapter.test.GenericTypeAdapter', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.Wrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  1: map<adapted_typedef_i64, adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_bool field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_byte field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_i16 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_i32 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_i64 field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_float field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_double field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_binary field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_adapted_typedef_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: adapted_typedef_string field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_bool {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_byte {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_i16 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_i32 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_i64 {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_float {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_double {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_binary {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_list_adapted_typedef_string {
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: list<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_set_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: set<adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_string_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_string, adapted_typedef_string> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_bool> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_byte> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_i16> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_i32> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_i64> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_float> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_double> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_binary> field_1;
}
@cpp.UseOpEncode
struct struct_field_adapted_map_adapted_typedef_i64_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  @cpp.Adapter{name = '::apache::thrift::test::TemplatedTestFieldAdapter'}
  @java.Wrapper{wrapperClassName = 'com.facebook.thrift.adapter.test.GenericWrapper', typeClassName = 'com.facebook.thrift.adapter.test.Wrapped'}
  @python.Adapter{name = 'thrift.python.test.adapters.noop.FieldWrapper', typeHint = 'thrift.python.test.adapters.noop.Wrapped[]',}
  @hack.Wrapper{name = '\ConformanceTestFieldWrapper'}
  1: map<adapted_typedef_i64, adapted_typedef_string> field_1;
}
union union_empty {
}
union union_list_bool {
  1: list<bool> field_1;
  2: list<bool> field_2;
}
union union_list_byte {
  1: list<byte> field_1;
  2: list<byte> field_2;
}
union union_list_i16 {
  1: list<i16> field_1;
  2: list<i16> field_2;
}
union union_list_i32 {
  1: list<i32> field_1;
  2: list<i32> field_2;
}
union union_list_i64 {
  1: list<i64> field_1;
  2: list<i64> field_2;
}
union union_list_float {
  1: list<float> field_1;
  2: list<float> field_2;
}
union union_list_double {
  1: list<double> field_1;
  2: list<double> field_2;
}
union union_list_binary {
  1: list<binary> field_1;
  2: list<binary> field_2;
}
union union_list_string {
  1: list<string> field_1;
  2: list<string> field_2;
}
union union_list_struct_empty {
  1: list<struct_empty> field_1;
  2: list<struct_empty> field_2;
}
union union_list_list_bool {
  1: list<list<bool>> field_1;
  2: list<list<bool>> field_2;
}
union union_list_list_byte {
  1: list<list<byte>> field_1;
  2: list<list<byte>> field_2;
}
union union_list_list_i16 {
  1: list<list<i16>> field_1;
  2: list<list<i16>> field_2;
}
union union_list_list_i32 {
  1: list<list<i32>> field_1;
  2: list<list<i32>> field_2;
}
union union_list_list_i64 {
  1: list<list<i64>> field_1;
  2: list<list<i64>> field_2;
}
union union_list_list_float {
  1: list<list<float>> field_1;
  2: list<list<float>> field_2;
}
union union_list_list_double {
  1: list<list<double>> field_1;
  2: list<list<double>> field_2;
}
union union_list_list_binary {
  1: list<list<binary>> field_1;
  2: list<list<binary>> field_2;
}
union union_list_list_string {
  1: list<list<string>> field_1;
  2: list<list<string>> field_2;
}
union union_list_list_struct_empty {
  1: list<list<struct_empty>> field_1;
  2: list<list<struct_empty>> field_2;
}
union union_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
union union_set_byte {
  1: set<byte> field_1;
  2: set<byte> field_2;
}
union union_set_i16 {
  1: set<i16> field_1;
  2: set<i16> field_2;
}
union union_set_i32 {
  1: set<i32> field_1;
  2: set<i32> field_2;
}
union union_set_i64 {
  1: set<i64> field_1;
  2: set<i64> field_2;
}
union union_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
union union_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
union union_set_binary {
  1: set<binary> field_1;
  2: set<binary> field_2;
}
union union_set_string {
  1: set<string> field_1;
  2: set<string> field_2;
}
union union_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
union union_set_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
union union_set_set_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
union union_set_set_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
union union_set_set_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
union union_set_set_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
union union_set_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
union union_set_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
union union_set_set_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
union union_set_set_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
union union_set_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
union union_map_string_bool {
  1: map<string, bool> field_1;
  2: map<string, bool> field_2;
}
union union_map_string_byte {
  1: map<string, byte> field_1;
  2: map<string, byte> field_2;
}
union union_map_string_i16 {
  1: map<string, i16> field_1;
  2: map<string, i16> field_2;
}
union union_map_string_i32 {
  1: map<string, i32> field_1;
  2: map<string, i32> field_2;
}
union union_map_string_i64 {
  1: map<string, i64> field_1;
  2: map<string, i64> field_2;
}
union union_map_string_float {
  1: map<string, float> field_1;
  2: map<string, float> field_2;
}
union union_map_string_double {
  1: map<string, double> field_1;
  2: map<string, double> field_2;
}
union union_map_string_binary {
  1: map<string, binary> field_1;
  2: map<string, binary> field_2;
}
union union_map_string_string {
  1: map<string, string> field_1;
  2: map<string, string> field_2;
}
union union_map_string_struct_empty {
  1: map<string, struct_empty> field_1;
  2: map<string, struct_empty> field_2;
}
union union_map_i64_bool {
  1: map<i64, bool> field_1;
  2: map<i64, bool> field_2;
}
union union_map_i64_byte {
  1: map<i64, byte> field_1;
  2: map<i64, byte> field_2;
}
union union_map_i64_i16 {
  1: map<i64, i16> field_1;
  2: map<i64, i16> field_2;
}
union union_map_i64_i32 {
  1: map<i64, i32> field_1;
  2: map<i64, i32> field_2;
}
union union_map_i64_i64 {
  1: map<i64, i64> field_1;
  2: map<i64, i64> field_2;
}
union union_map_i64_float {
  1: map<i64, float> field_1;
  2: map<i64, float> field_2;
}
union union_map_i64_double {
  1: map<i64, double> field_1;
  2: map<i64, double> field_2;
}
union union_map_i64_binary {
  1: map<i64, binary> field_1;
  2: map<i64, binary> field_2;
}
union union_map_i64_string {
  1: map<i64, string> field_1;
  2: map<i64, string> field_2;
}
union union_map_i64_struct_empty {
  1: map<i64, struct_empty> field_1;
  2: map<i64, struct_empty> field_2;
}
union union_map_string_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
union union_map_string_set_byte {
  1: map<string, set<byte>> field_1;
  2: map<string, set<byte>> field_2;
}
union union_map_string_set_i16 {
  1: map<string, set<i16>> field_1;
  2: map<string, set<i16>> field_2;
}
union union_map_string_set_i32 {
  1: map<string, set<i32>> field_1;
  2: map<string, set<i32>> field_2;
}
union union_map_string_set_i64 {
  1: map<string, set<i64>> field_1;
  2: map<string, set<i64>> field_2;
}
union union_map_string_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
union union_map_string_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
union union_map_string_set_binary {
  1: map<string, set<binary>> field_1;
  2: map<string, set<binary>> field_2;
}
union union_map_string_set_string {
  1: map<string, set<string>> field_1;
  2: map<string, set<string>> field_2;
}
union union_map_string_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
union union_map_i64_set_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
union union_map_i64_set_byte {
  1: map<i64, set<byte>> field_1;
  2: map<i64, set<byte>> field_2;
}
union union_map_i64_set_i16 {
  1: map<i64, set<i16>> field_1;
  2: map<i64, set<i16>> field_2;
}
union union_map_i64_set_i32 {
  1: map<i64, set<i32>> field_1;
  2: map<i64, set<i32>> field_2;
}
union union_map_i64_set_i64 {
  1: map<i64, set<i64>> field_1;
  2: map<i64, set<i64>> field_2;
}
union union_map_i64_set_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
union union_map_i64_set_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
union union_map_i64_set_binary {
  1: map<i64, set<binary>> field_1;
  2: map<i64, set<binary>> field_2;
}
union union_map_i64_set_string {
  1: map<i64, set<string>> field_1;
  2: map<i64, set<string>> field_2;
}
union union_map_i64_set_struct_empty {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
union union_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<bool> field_2;
}
union union_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<byte> field_2;
}
union union_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i16> field_2;
}
union union_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i32> field_2;
}
union union_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i64> field_2;
}
union union_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<float> field_2;
}
union union_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<double> field_2;
}
union union_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<binary> field_2;
}
union union_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<string> field_2;
}
union union_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<struct_empty> field_2;
}
union union_list_list_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<bool>> field_2;
}
union union_list_list_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<byte>> field_2;
}
union union_list_list_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i16>> field_2;
}
union union_list_list_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i32>> field_2;
}
union union_list_list_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i64>> field_2;
}
union union_list_list_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<float>> field_2;
}
union union_list_list_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<double>> field_2;
}
union union_list_list_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<binary>> field_2;
}
union union_list_list_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<string>> field_2;
}
union union_list_list_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<struct_empty>> field_2;
}
union union_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
union union_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<byte> field_2;
}
union union_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i16> field_2;
}
union union_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i32> field_2;
}
union union_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i64> field_2;
}
union union_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
union union_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
union union_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<binary> field_2;
}
union union_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<string> field_2;
}
union union_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
union union_set_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
union union_set_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
union union_set_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
union union_set_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
union union_set_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
union union_set_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
union union_set_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
union union_set_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
union union_set_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
union union_set_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
union union_map_string_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, bool> field_2;
}
union union_map_string_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, byte> field_2;
}
union union_map_string_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i16> field_2;
}
union union_map_string_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i32> field_2;
}
union union_map_string_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i64> field_2;
}
union union_map_string_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, float> field_2;
}
union union_map_string_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, double> field_2;
}
union union_map_string_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, binary> field_2;
}
union union_map_string_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, string> field_2;
}
union union_map_string_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, struct_empty> field_2;
}
union union_map_i64_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, bool> field_2;
}
union union_map_i64_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, byte> field_2;
}
union union_map_i64_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i16> field_2;
}
union union_map_i64_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i32> field_2;
}
union union_map_i64_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i64> field_2;
}
union union_map_i64_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, float> field_2;
}
union union_map_i64_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, double> field_2;
}
union union_map_i64_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, binary> field_2;
}
union union_map_i64_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, string> field_2;
}
union union_map_i64_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, struct_empty> field_2;
}
union union_map_string_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
union union_map_string_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<byte>> field_2;
}
union union_map_string_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i16>> field_2;
}
union union_map_string_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i32>> field_2;
}
union union_map_string_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i64>> field_2;
}
union union_map_string_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
union union_map_string_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
union union_map_string_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<binary>> field_2;
}
union union_map_string_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<string>> field_2;
}
union union_map_string_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
union union_map_i64_set_bool_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
union union_map_i64_set_byte_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<byte>> field_2;
}
union union_map_i64_set_i16_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i16>> field_2;
}
union union_map_i64_set_i32_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i32>> field_2;
}
union union_map_i64_set_i64_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i64>> field_2;
}
union union_map_i64_set_float_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
union union_map_i64_set_double_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
union union_map_i64_set_binary_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<binary>> field_2;
}
union union_map_i64_set_string_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<string>> field_2;
}
union union_map_i64_set_struct_empty_cpp_ref {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
union union_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<bool> field_2;
}
union union_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<byte> field_2;
}
union union_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i16> field_2;
}
union union_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i32> field_2;
}
union union_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i64> field_2;
}
union union_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<float> field_2;
}
union union_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<double> field_2;
}
union union_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<binary> field_2;
}
union union_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<string> field_2;
}
union union_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<struct_empty> field_2;
}
union union_list_list_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<bool>> field_2;
}
union union_list_list_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<byte>> field_2;
}
union union_list_list_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i16>> field_2;
}
union union_list_list_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i32>> field_2;
}
union union_list_list_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i64>> field_2;
}
union union_list_list_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<float>> field_2;
}
union union_list_list_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<double>> field_2;
}
union union_list_list_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<binary>> field_2;
}
union union_list_list_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<string>> field_2;
}
union union_list_list_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<struct_empty>> field_2;
}
union union_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
union union_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<byte> field_2;
}
union union_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i16> field_2;
}
union union_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i32> field_2;
}
union union_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i64> field_2;
}
union union_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
union union_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
union union_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<binary> field_2;
}
union union_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<string> field_2;
}
union union_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
union union_set_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
union union_set_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
union union_set_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
union union_set_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
union union_set_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
union union_set_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
union union_set_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
union union_set_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
union union_set_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
union union_set_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
union union_map_string_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, bool> field_2;
}
union union_map_string_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, byte> field_2;
}
union union_map_string_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i16> field_2;
}
union union_map_string_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i32> field_2;
}
union union_map_string_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i64> field_2;
}
union union_map_string_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, float> field_2;
}
union union_map_string_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, double> field_2;
}
union union_map_string_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, binary> field_2;
}
union union_map_string_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, string> field_2;
}
union union_map_string_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, struct_empty> field_2;
}
union union_map_i64_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, bool> field_2;
}
union union_map_i64_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, byte> field_2;
}
union union_map_i64_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i16> field_2;
}
union union_map_i64_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i32> field_2;
}
union union_map_i64_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i64> field_2;
}
union union_map_i64_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, float> field_2;
}
union union_map_i64_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, double> field_2;
}
union union_map_i64_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, binary> field_2;
}
union union_map_i64_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, string> field_2;
}
union union_map_i64_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, struct_empty> field_2;
}
union union_map_string_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
union union_map_string_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<byte>> field_2;
}
union union_map_string_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i16>> field_2;
}
union union_map_string_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i32>> field_2;
}
union union_map_string_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i64>> field_2;
}
union union_map_string_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
union union_map_string_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
union union_map_string_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<binary>> field_2;
}
union union_map_string_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<string>> field_2;
}
union union_map_string_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
union union_map_i64_set_bool_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
union union_map_i64_set_byte_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<byte>> field_2;
}
union union_map_i64_set_i16_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i16>> field_2;
}
union union_map_i64_set_i32_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i32>> field_2;
}
union union_map_i64_set_i64_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i64>> field_2;
}
union union_map_i64_set_float_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
union union_map_i64_set_double_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
union union_map_i64_set_binary_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<binary>> field_2;
}
union union_map_i64_set_string_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<string>> field_2;
}
union union_map_i64_set_struct_empty_shared_cpp_ref {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
union union_bool {
  1: bool field_1;
  2: bool field_2;
}
union union_byte {
  1: byte field_1;
  2: byte field_2;
}
union union_i16 {
  1: i16 field_1;
  2: i16 field_2;
}
union union_i32 {
  1: i32 field_1;
  2: i32 field_2;
}
union union_i64 {
  1: i64 field_1;
  2: i64 field_2;
}
union union_float {
  1: float field_1;
  2: float field_2;
}
union union_double {
  1: double field_1;
  2: double field_2;
}
union union_binary {
  1: binary field_1;
  2: binary field_2;
}
union union_string {
  1: string field_1;
  2: string field_2;
}
@cpp.UseOpEncode
union union_empty_op_encoded {
}
@cpp.UseOpEncode
union union_list_bool_op_encoded {
  1: list<bool> field_1;
  2: list<bool> field_2;
}
@cpp.UseOpEncode
union union_list_byte_op_encoded {
  1: list<byte> field_1;
  2: list<byte> field_2;
}
@cpp.UseOpEncode
union union_list_i16_op_encoded {
  1: list<i16> field_1;
  2: list<i16> field_2;
}
@cpp.UseOpEncode
union union_list_i32_op_encoded {
  1: list<i32> field_1;
  2: list<i32> field_2;
}
@cpp.UseOpEncode
union union_list_i64_op_encoded {
  1: list<i64> field_1;
  2: list<i64> field_2;
}
@cpp.UseOpEncode
union union_list_float_op_encoded {
  1: list<float> field_1;
  2: list<float> field_2;
}
@cpp.UseOpEncode
union union_list_double_op_encoded {
  1: list<double> field_1;
  2: list<double> field_2;
}
@cpp.UseOpEncode
union union_list_binary_op_encoded {
  1: list<binary> field_1;
  2: list<binary> field_2;
}
@cpp.UseOpEncode
union union_list_string_op_encoded {
  1: list<string> field_1;
  2: list<string> field_2;
}
@cpp.UseOpEncode
union union_list_struct_empty_op_encoded {
  1: list<struct_empty> field_1;
  2: list<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_list_list_bool_op_encoded {
  1: list<list<bool>> field_1;
  2: list<list<bool>> field_2;
}
@cpp.UseOpEncode
union union_list_list_byte_op_encoded {
  1: list<list<byte>> field_1;
  2: list<list<byte>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i16_op_encoded {
  1: list<list<i16>> field_1;
  2: list<list<i16>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i32_op_encoded {
  1: list<list<i32>> field_1;
  2: list<list<i32>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i64_op_encoded {
  1: list<list<i64>> field_1;
  2: list<list<i64>> field_2;
}
@cpp.UseOpEncode
union union_list_list_float_op_encoded {
  1: list<list<float>> field_1;
  2: list<list<float>> field_2;
}
@cpp.UseOpEncode
union union_list_list_double_op_encoded {
  1: list<list<double>> field_1;
  2: list<list<double>> field_2;
}
@cpp.UseOpEncode
union union_list_list_binary_op_encoded {
  1: list<list<binary>> field_1;
  2: list<list<binary>> field_2;
}
@cpp.UseOpEncode
union union_list_list_string_op_encoded {
  1: list<list<string>> field_1;
  2: list<list<string>> field_2;
}
@cpp.UseOpEncode
union union_list_list_struct_empty_op_encoded {
  1: list<list<struct_empty>> field_1;
  2: list<list<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
@cpp.UseOpEncode
union union_set_byte_op_encoded {
  1: set<byte> field_1;
  2: set<byte> field_2;
}
@cpp.UseOpEncode
union union_set_i16_op_encoded {
  1: set<i16> field_1;
  2: set<i16> field_2;
}
@cpp.UseOpEncode
union union_set_i32_op_encoded {
  1: set<i32> field_1;
  2: set<i32> field_2;
}
@cpp.UseOpEncode
union union_set_i64_op_encoded {
  1: set<i64> field_1;
  2: set<i64> field_2;
}
@cpp.UseOpEncode
union union_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
@cpp.UseOpEncode
union union_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
@cpp.UseOpEncode
union union_set_binary_op_encoded {
  1: set<binary> field_1;
  2: set<binary> field_2;
}
@cpp.UseOpEncode
union union_set_string_op_encoded {
  1: set<string> field_1;
  2: set<string> field_2;
}
@cpp.UseOpEncode
union union_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_set_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
@cpp.UseOpEncode
union union_set_set_byte_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i16_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i32_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i64_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
@cpp.UseOpEncode
union union_set_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
@cpp.UseOpEncode
union union_set_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
@cpp.UseOpEncode
union union_set_set_binary_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
@cpp.UseOpEncode
union union_set_set_string_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
@cpp.UseOpEncode
union union_set_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_string_bool_op_encoded {
  1: map<string, bool> field_1;
  2: map<string, bool> field_2;
}
@cpp.UseOpEncode
union union_map_string_byte_op_encoded {
  1: map<string, byte> field_1;
  2: map<string, byte> field_2;
}
@cpp.UseOpEncode
union union_map_string_i16_op_encoded {
  1: map<string, i16> field_1;
  2: map<string, i16> field_2;
}
@cpp.UseOpEncode
union union_map_string_i32_op_encoded {
  1: map<string, i32> field_1;
  2: map<string, i32> field_2;
}
@cpp.UseOpEncode
union union_map_string_i64_op_encoded {
  1: map<string, i64> field_1;
  2: map<string, i64> field_2;
}
@cpp.UseOpEncode
union union_map_string_float_op_encoded {
  1: map<string, float> field_1;
  2: map<string, float> field_2;
}
@cpp.UseOpEncode
union union_map_string_double_op_encoded {
  1: map<string, double> field_1;
  2: map<string, double> field_2;
}
@cpp.UseOpEncode
union union_map_string_binary_op_encoded {
  1: map<string, binary> field_1;
  2: map<string, binary> field_2;
}
@cpp.UseOpEncode
union union_map_string_string_op_encoded {
  1: map<string, string> field_1;
  2: map<string, string> field_2;
}
@cpp.UseOpEncode
union union_map_string_struct_empty_op_encoded {
  1: map<string, struct_empty> field_1;
  2: map<string, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_i64_bool_op_encoded {
  1: map<i64, bool> field_1;
  2: map<i64, bool> field_2;
}
@cpp.UseOpEncode
union union_map_i64_byte_op_encoded {
  1: map<i64, byte> field_1;
  2: map<i64, byte> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i16_op_encoded {
  1: map<i64, i16> field_1;
  2: map<i64, i16> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i32_op_encoded {
  1: map<i64, i32> field_1;
  2: map<i64, i32> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i64_op_encoded {
  1: map<i64, i64> field_1;
  2: map<i64, i64> field_2;
}
@cpp.UseOpEncode
union union_map_i64_float_op_encoded {
  1: map<i64, float> field_1;
  2: map<i64, float> field_2;
}
@cpp.UseOpEncode
union union_map_i64_double_op_encoded {
  1: map<i64, double> field_1;
  2: map<i64, double> field_2;
}
@cpp.UseOpEncode
union union_map_i64_binary_op_encoded {
  1: map<i64, binary> field_1;
  2: map<i64, binary> field_2;
}
@cpp.UseOpEncode
union union_map_i64_string_op_encoded {
  1: map<i64, string> field_1;
  2: map<i64, string> field_2;
}
@cpp.UseOpEncode
union union_map_i64_struct_empty_op_encoded {
  1: map<i64, struct_empty> field_1;
  2: map<i64, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_byte_op_encoded {
  1: map<string, set<byte>> field_1;
  2: map<string, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i16_op_encoded {
  1: map<string, set<i16>> field_1;
  2: map<string, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i32_op_encoded {
  1: map<string, set<i32>> field_1;
  2: map<string, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i64_op_encoded {
  1: map<string, set<i64>> field_1;
  2: map<string, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_binary_op_encoded {
  1: map<string, set<binary>> field_1;
  2: map<string, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_string_op_encoded {
  1: map<string, set<string>> field_1;
  2: map<string, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_bool_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_byte_op_encoded {
  1: map<i64, set<byte>> field_1;
  2: map<i64, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i16_op_encoded {
  1: map<i64, set<i16>> field_1;
  2: map<i64, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i32_op_encoded {
  1: map<i64, set<i32>> field_1;
  2: map<i64, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i64_op_encoded {
  1: map<i64, set<i64>> field_1;
  2: map<i64, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_float_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_double_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_binary_op_encoded {
  1: map<i64, set<binary>> field_1;
  2: map<i64, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_string_op_encoded {
  1: map<i64, set<string>> field_1;
  2: map<i64, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_struct_empty_op_encoded {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<bool> field_2;
}
@cpp.UseOpEncode
union union_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<byte> field_2;
}
@cpp.UseOpEncode
union union_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i16> field_2;
}
@cpp.UseOpEncode
union union_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i32> field_2;
}
@cpp.UseOpEncode
union union_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i64> field_2;
}
@cpp.UseOpEncode
union union_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<float> field_2;
}
@cpp.UseOpEncode
union union_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<double> field_2;
}
@cpp.UseOpEncode
union union_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<binary> field_2;
}
@cpp.UseOpEncode
union union_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<string> field_2;
}
@cpp.UseOpEncode
union union_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_list_list_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<bool>> field_2;
}
@cpp.UseOpEncode
union union_list_list_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<byte>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i16>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i32>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i64>> field_2;
}
@cpp.UseOpEncode
union union_list_list_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<float>> field_2;
}
@cpp.UseOpEncode
union union_list_list_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<double>> field_2;
}
@cpp.UseOpEncode
union union_list_list_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<binary>> field_2;
}
@cpp.UseOpEncode
union union_list_list_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<string>> field_2;
}
@cpp.UseOpEncode
union union_list_list_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
@cpp.UseOpEncode
union union_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<byte> field_2;
}
@cpp.UseOpEncode
union union_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i16> field_2;
}
@cpp.UseOpEncode
union union_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i32> field_2;
}
@cpp.UseOpEncode
union union_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i64> field_2;
}
@cpp.UseOpEncode
union union_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
@cpp.UseOpEncode
union union_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
@cpp.UseOpEncode
union union_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<binary> field_2;
}
@cpp.UseOpEncode
union union_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: set<string> field_2;
}
@cpp.UseOpEncode
union union_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_set_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
@cpp.UseOpEncode
union union_set_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
@cpp.UseOpEncode
union union_set_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
@cpp.UseOpEncode
union union_set_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
@cpp.UseOpEncode
union union_set_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
@cpp.UseOpEncode
union union_set_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
@cpp.UseOpEncode
union union_set_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_string_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, bool> field_2;
}
@cpp.UseOpEncode
union union_map_string_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, byte> field_2;
}
@cpp.UseOpEncode
union union_map_string_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i16> field_2;
}
@cpp.UseOpEncode
union union_map_string_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i32> field_2;
}
@cpp.UseOpEncode
union union_map_string_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i64> field_2;
}
@cpp.UseOpEncode
union union_map_string_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, float> field_2;
}
@cpp.UseOpEncode
union union_map_string_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, double> field_2;
}
@cpp.UseOpEncode
union union_map_string_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, binary> field_2;
}
@cpp.UseOpEncode
union union_map_string_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, string> field_2;
}
@cpp.UseOpEncode
union union_map_string_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_i64_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, bool> field_2;
}
@cpp.UseOpEncode
union union_map_i64_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, byte> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i16> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i32> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i64> field_2;
}
@cpp.UseOpEncode
union union_map_i64_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, float> field_2;
}
@cpp.UseOpEncode
union union_map_i64_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, double> field_2;
}
@cpp.UseOpEncode
union union_map_i64_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, binary> field_2;
}
@cpp.UseOpEncode
union union_map_i64_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, string> field_2;
}
@cpp.UseOpEncode
union union_map_i64_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_bool_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_byte_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i16_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i32_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i64_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_float_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_double_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_binary_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_string_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_struct_empty_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.Unique}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<bool> field_2;
}
@cpp.UseOpEncode
union union_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<byte> field_2;
}
@cpp.UseOpEncode
union union_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i16> field_2;
}
@cpp.UseOpEncode
union union_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i32> field_2;
}
@cpp.UseOpEncode
union union_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<i64> field_2;
}
@cpp.UseOpEncode
union union_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<float> field_2;
}
@cpp.UseOpEncode
union union_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<double> field_2;
}
@cpp.UseOpEncode
union union_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<binary> field_2;
}
@cpp.UseOpEncode
union union_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<string> field_2;
}
@cpp.UseOpEncode
union union_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_list_list_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<bool>> field_2;
}
@cpp.UseOpEncode
union union_list_list_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<byte>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i16>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i32>> field_2;
}
@cpp.UseOpEncode
union union_list_list_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<i64>> field_2;
}
@cpp.UseOpEncode
union union_list_list_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<float>> field_2;
}
@cpp.UseOpEncode
union union_list_list_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<double>> field_2;
}
@cpp.UseOpEncode
union union_list_list_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<binary>> field_2;
}
@cpp.UseOpEncode
union union_list_list_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<string>> field_2;
}
@cpp.UseOpEncode
union union_list_list_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: list<list<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: list<list<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<bool> field_2;
}
@cpp.UseOpEncode
union union_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<byte> field_2;
}
@cpp.UseOpEncode
union union_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i16> field_2;
}
@cpp.UseOpEncode
union union_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i32> field_2;
}
@cpp.UseOpEncode
union union_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<i64> field_2;
}
@cpp.UseOpEncode
union union_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<float> field_2;
}
@cpp.UseOpEncode
union union_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<double> field_2;
}
@cpp.UseOpEncode
union union_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<binary> field_2;
}
@cpp.UseOpEncode
union union_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: set<string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: set<string> field_2;
}
@cpp.UseOpEncode
union union_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<struct_empty> field_2;
}
@cpp.UseOpEncode
union union_set_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<bool>> field_2;
}
@cpp.UseOpEncode
union union_set_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<byte>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i16>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i32>> field_2;
}
@cpp.UseOpEncode
union union_set_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<i64>> field_2;
}
@cpp.UseOpEncode
union union_set_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<float>> field_2;
}
@cpp.UseOpEncode
union union_set_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<double>> field_2;
}
@cpp.UseOpEncode
union union_set_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<binary>> field_2;
}
@cpp.UseOpEncode
union union_set_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<string>> field_2;
}
@cpp.UseOpEncode
union union_set_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_string_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, bool> field_2;
}
@cpp.UseOpEncode
union union_map_string_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, byte> field_2;
}
@cpp.UseOpEncode
union union_map_string_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i16> field_2;
}
@cpp.UseOpEncode
union union_map_string_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i32> field_2;
}
@cpp.UseOpEncode
union union_map_string_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, i64> field_2;
}
@cpp.UseOpEncode
union union_map_string_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, float> field_2;
}
@cpp.UseOpEncode
union union_map_string_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, double> field_2;
}
@cpp.UseOpEncode
union union_map_string_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, binary> field_2;
}
@cpp.UseOpEncode
union union_map_string_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, string> field_2;
}
@cpp.UseOpEncode
union union_map_string_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_i64_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, bool> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, bool> field_2;
}
@cpp.UseOpEncode
union union_map_i64_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, byte> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, byte> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i16> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i16> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i32> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i32> field_2;
}
@cpp.UseOpEncode
union union_map_i64_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, i64> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, i64> field_2;
}
@cpp.UseOpEncode
union union_map_i64_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, float> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, float> field_2;
}
@cpp.UseOpEncode
union union_map_i64_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, double> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, double> field_2;
}
@cpp.UseOpEncode
union union_map_i64_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, binary> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, binary> field_2;
}
@cpp.UseOpEncode
union union_map_i64_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, string> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, string> field_2;
}
@cpp.UseOpEncode
union union_map_i64_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, struct_empty> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, struct_empty> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<string, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<string, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_string_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<string, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<string, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_bool_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<bool>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<bool>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_byte_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<byte>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<byte>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i16_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i16>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i16>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i32_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i32>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i32>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_i64_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<i64>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<i64>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_float_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<float>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<float>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_double_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<double>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<double>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_binary_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<binary>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<binary>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_string_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  1: map<i64, set<string>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  2: map<i64, set<string>> field_2;
}
@cpp.UseOpEncode
union union_map_i64_set_struct_empty_shared_cpp_ref_op_encoded {
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<i64, set<struct_empty>> field_1;
  @cpp.Ref{type = cpp.RefType.SharedMutable}
  @cpp.AllowLegacyNonOptionalRef
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<i64, set<struct_empty>> field_2;
}
@cpp.UseOpEncode
union union_bool_op_encoded {
  1: bool field_1;
  2: bool field_2;
}
@cpp.UseOpEncode
union union_byte_op_encoded {
  1: byte field_1;
  2: byte field_2;
}
@cpp.UseOpEncode
union union_i16_op_encoded {
  1: i16 field_1;
  2: i16 field_2;
}
@cpp.UseOpEncode
union union_i32_op_encoded {
  1: i32 field_1;
  2: i32 field_2;
}
@cpp.UseOpEncode
union union_i64_op_encoded {
  1: i64 field_1;
  2: i64 field_2;
}
@cpp.UseOpEncode
union union_float_op_encoded {
  1: float field_1;
  2: float field_2;
}
@cpp.UseOpEncode
union union_double_op_encoded {
  1: double field_1;
  2: double field_2;
}
@cpp.UseOpEncode
union union_binary_op_encoded {
  1: binary field_1;
  2: binary field_2;
}
@cpp.UseOpEncode
union union_string_op_encoded {
  1: string field_1;
  2: string field_2;
}
union union_adapted_typedef_bool {
  1: adapted_typedef_bool field_1;
  2: adapted_typedef_bool field_2;
}
union union_adapted_typedef_byte {
  1: adapted_typedef_byte field_1;
  2: adapted_typedef_byte field_2;
}
union union_adapted_typedef_i16 {
  1: adapted_typedef_i16 field_1;
  2: adapted_typedef_i16 field_2;
}
union union_adapted_typedef_i32 {
  1: adapted_typedef_i32 field_1;
  2: adapted_typedef_i32 field_2;
}
union union_adapted_typedef_i64 {
  1: adapted_typedef_i64 field_1;
  2: adapted_typedef_i64 field_2;
}
union union_adapted_typedef_float {
  1: adapted_typedef_float field_1;
  2: adapted_typedef_float field_2;
}
union union_adapted_typedef_double {
  1: adapted_typedef_double field_1;
  2: adapted_typedef_double field_2;
}
union union_adapted_typedef_binary {
  1: adapted_typedef_binary field_1;
  2: adapted_typedef_binary field_2;
}
union union_adapted_typedef_string {
  1: adapted_typedef_string field_1;
  2: adapted_typedef_string field_2;
}
union union_list_adapted_typedef_bool {
  1: list<adapted_typedef_bool> field_1;
  2: list<adapted_typedef_bool> field_2;
}
union union_list_adapted_typedef_byte {
  1: list<adapted_typedef_byte> field_1;
  2: list<adapted_typedef_byte> field_2;
}
union union_list_adapted_typedef_i16 {
  1: list<adapted_typedef_i16> field_1;
  2: list<adapted_typedef_i16> field_2;
}
union union_list_adapted_typedef_i32 {
  1: list<adapted_typedef_i32> field_1;
  2: list<adapted_typedef_i32> field_2;
}
union union_list_adapted_typedef_i64 {
  1: list<adapted_typedef_i64> field_1;
  2: list<adapted_typedef_i64> field_2;
}
union union_list_adapted_typedef_float {
  1: list<adapted_typedef_float> field_1;
  2: list<adapted_typedef_float> field_2;
}
union union_list_adapted_typedef_double {
  1: list<adapted_typedef_double> field_1;
  2: list<adapted_typedef_double> field_2;
}
union union_list_adapted_typedef_binary {
  1: list<adapted_typedef_binary> field_1;
  2: list<adapted_typedef_binary> field_2;
}
union union_list_adapted_typedef_string {
  1: list<adapted_typedef_string> field_1;
  2: list<adapted_typedef_string> field_2;
}
union union_set_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_string> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<adapted_typedef_string> field_2;
}
union union_set_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_i64> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: set<adapted_typedef_i64> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_bool> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_bool> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_byte> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_byte> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i16> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_i16> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i32> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_i32> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i64> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_i64> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_float> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_float> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_double> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_double> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_binary> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_binary> field_2;
}
union union_map_adapted_typedef_string_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_string> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_string, adapted_typedef_string> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_bool> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_bool> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_byte> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_byte> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i16> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_i16> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i32> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_i32> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i64> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_i64> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_float> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_float> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_double> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_double> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_binary> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_binary> field_2;
}
union union_map_adapted_typedef_i64_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_string> field_1;
  @hack.SkipCodegen{reason = 'Invalid key type'}
  2: map<adapted_typedef_i64, adapted_typedef_string> field_2;
}
exception exception_adapted_typedef_bool {
  1: adapted_typedef_bool field_1;
}
exception exception_adapted_typedef_byte {
  1: adapted_typedef_byte field_1;
}
exception exception_adapted_typedef_i16 {
  1: adapted_typedef_i16 field_1;
}
exception exception_adapted_typedef_i32 {
  1: adapted_typedef_i32 field_1;
}
exception exception_adapted_typedef_i64 {
  1: adapted_typedef_i64 field_1;
}
exception exception_adapted_typedef_float {
  1: adapted_typedef_float field_1;
}
exception exception_adapted_typedef_double {
  1: adapted_typedef_double field_1;
}
exception exception_adapted_typedef_binary {
  1: adapted_typedef_binary field_1;
}
exception exception_adapted_typedef_string {
  1: adapted_typedef_string field_1;
}
exception exception_list_adapted_typedef_bool {
  1: list<adapted_typedef_bool> field_1;
}
exception exception_list_adapted_typedef_byte {
  1: list<adapted_typedef_byte> field_1;
}
exception exception_list_adapted_typedef_i16 {
  1: list<adapted_typedef_i16> field_1;
}
exception exception_list_adapted_typedef_i32 {
  1: list<adapted_typedef_i32> field_1;
}
exception exception_list_adapted_typedef_i64 {
  1: list<adapted_typedef_i64> field_1;
}
exception exception_list_adapted_typedef_float {
  1: list<adapted_typedef_float> field_1;
}
exception exception_list_adapted_typedef_double {
  1: list<adapted_typedef_double> field_1;
}
exception exception_list_adapted_typedef_binary {
  1: list<adapted_typedef_binary> field_1;
}
exception exception_list_adapted_typedef_string {
  1: list<adapted_typedef_string> field_1;
}
exception exception_set_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_string> field_1;
}
exception exception_set_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: set<adapted_typedef_i64> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_bool> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_byte> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i16> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i32> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_i64> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_float> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_double> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_binary> field_1;
}
exception exception_map_adapted_typedef_string_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_string, adapted_typedef_string> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_bool {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_bool> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_byte {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_byte> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_i16 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i16> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_i32 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i32> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_i64 {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_i64> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_float {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_float> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_double {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_double> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_binary {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_binary> field_1;
}
exception exception_map_adapted_typedef_i64_adapted_typedef_string {
  @hack.SkipCodegen{reason = 'Invalid key type'}
  1: map<adapted_typedef_i64, adapted_typedef_string> field_1;
}
