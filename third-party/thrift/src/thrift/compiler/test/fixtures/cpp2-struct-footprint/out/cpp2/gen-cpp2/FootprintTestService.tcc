/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/cpp2-struct-footprint/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#pragma once

#include "thrift/compiler/test/fixtures/cpp2-struct-footprint/gen-cpp2/FootprintTestService.h"

#include <thrift/lib/cpp2/gen/service_tcc.h>

namespace cpp2_struct_footprint {
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::binary, ::cpp2_struct_footprint::IOBuf*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::binary, ::cpp2_struct_footprint::IOBufPtr*>, apache::thrift::FieldData<3, ::apache::thrift::type_class::integral, ::cpp2_struct_footprint::I32Alias*>> FootprintTestService_processIOBuf_pargs;
typedef apache::thrift::ThriftPresult<true> FootprintTestService_processIOBuf_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getStruct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::SimpleStruct*>> FootprintTestService_getStruct_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::SimpleStruct*>> FootprintTestService_setStruct_pargs;
typedef apache::thrift::ThriftPresult<true> FootprintTestService_setStruct_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<::cpp2_struct_footprint::SimpleStruct>*>> FootprintTestService_setStructList_pargs;
typedef apache::thrift::ThriftPresult<true> FootprintTestService_setStructList_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getStructList_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::std::vector<::cpp2_struct_footprint::SimpleStruct>*>> FootprintTestService_getStructList_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getNestedContainer_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>>, ::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>*>> FootprintTestService_getNestedContainer_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getTypedefStruct_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::MyStruct*>> FootprintTestService_getTypedefStruct_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getTypedefList_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>, ::cpp2_struct_footprint::StructList*>> FootprintTestService_getTypedefList_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getUnion_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::variant, ::cpp2_struct_footprint::TestUnion*>> FootprintTestService_getUnion_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_getCalculator_pargs;
typedef apache::thrift::ThriftPresult<true> FootprintTestService_getCalculator_presult;
typedef apache::thrift::ThriftPresult<false> FootprintTestService_streamStructs_pargs;
typedef apache::thrift::ThriftPResultStream<
    apache::thrift::ThriftPresult<true>,
    apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::SimpleStruct*>>
    > FootprintTestService_streamStructs_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> FootprintTestService_streamWithSinkInitial_pargs;
typedef apache::thrift::ThriftPResultStream<
    apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::Struct1*>>,
    apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::SimpleStruct*>>
    > FootprintTestService_streamWithSinkInitial_presult;
typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>> FootprintTestService_streamWithSinkException_pargs;
typedef apache::thrift::ThriftPResultStream<
    apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::Struct1*>, apache::thrift::FieldData<-1, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::ExStruct>>,
    apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::structure, ::cpp2_struct_footprint::SimpleStruct*>>
    > FootprintTestService_streamWithSinkException_presult;
//
// Service Methods
//

//
// Method 'processIOBuf'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_processIOBuf(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_processIOBuf<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_processIOBuf(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::cpp2_struct_footprint::IOBuf> uarg_buf = std::make_unique<::cpp2_struct_footprint::IOBuf>();
    std::unique_ptr<::cpp2_struct_footprint::IOBufPtr> uarg_ptr = std::make_unique<::cpp2_struct_footprint::IOBufPtr>();
    ::cpp2_struct_footprint::I32Alias uarg_alias{0};
    FootprintTestService_processIOBuf_pargs pargs() {
      FootprintTestService_processIOBuf_pargs args;
      args.get<0>().value = uarg_buf.get();
      args.get<1>().value = uarg_ptr.get();
      args.get<2>().value = &uarg_alias;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_buf),
        std::as_const(*uarg_ptr),
        std::as_const(uarg_alias)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.processIOBuf",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "processIOBuf",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "processIOBuf");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "processIOBuf",
      /* .qualifiedMethodName =*/ "FootprintTestService.processIOBuf"};
  apache::thrift::HandlerCallback<void>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_processIOBuf};
 auto callback =
      apache::thrift::HandlerCallbackPtr<void>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_processIOBuf<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_processIOBuf<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_processIOBuf.
  iface_->fbthrift_execute_decorators_before_processIOBuf(*serverRequest.requestContext(), *args.uarg_buf, *args.uarg_ptr, args.uarg_alias);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_processIOBuf(std::move(cb), std::move(args.uarg_buf), std::move(args.uarg_ptr), args.uarg_alias);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_processIOBuf(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_processIOBuf_presult result;
  return serializeResponse("processIOBuf", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_processIOBuf(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "processIOBuf");
    return;
  }
}
//
// End of Method 'processIOBuf'
//

//
// Method 'getStruct'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getStruct<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getStruct(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getStruct_pargs pargs() {
      FootprintTestService_getStruct_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getStruct",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getStruct",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getStruct");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getStruct",
      /* .qualifiedMethodName =*/ "FootprintTestService.getStruct"};
  apache::thrift::HandlerCallback<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getStruct};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getStruct<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getStruct<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getStruct.
  iface_->fbthrift_execute_decorators_before_getStruct(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getStruct(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getStruct(
    apache::thrift::ContextStack* ctx,
    ::cpp2_struct_footprint::SimpleStruct const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getStruct_presult result;
  result.get<0>().value = const_cast<::cpp2_struct_footprint::SimpleStruct*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getStruct", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getStruct");
    return;
  }
}
//
// End of Method 'getStruct'
//

//
// Method 'setStruct'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_setStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_setStruct<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_setStruct(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::cpp2_struct_footprint::SimpleStruct> uarg_input = std::make_unique<::cpp2_struct_footprint::SimpleStruct>();
    FootprintTestService_setStruct_pargs pargs() {
      FootprintTestService_setStruct_pargs args;
      args.get<0>().value = uarg_input.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.setStruct",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "setStruct",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "setStruct");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "setStruct",
      /* .qualifiedMethodName =*/ "FootprintTestService.setStruct"};
  apache::thrift::HandlerCallback<void>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_setStruct};
 auto callback =
      apache::thrift::HandlerCallbackPtr<void>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_setStruct<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_setStruct<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_setStruct.
  iface_->fbthrift_execute_decorators_before_setStruct(*serverRequest.requestContext(), *args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_setStruct(std::move(cb), std::move(args.uarg_input));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_setStruct(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_setStruct_presult result;
  return serializeResponse("setStruct", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_setStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "setStruct");
    return;
  }
}
//
// End of Method 'setStruct'
//

//
// Method 'setStructList'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_setStructList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_setStructList<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_setStructList(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>> uarg_items = std::make_unique<::std::vector<::cpp2_struct_footprint::SimpleStruct>>();
    FootprintTestService_setStructList_pargs pargs() {
      FootprintTestService_setStructList_pargs args;
      args.get<0>().value = uarg_items.get();
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(*uarg_items)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.setStructList",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "setStructList",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "setStructList");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "setStructList",
      /* .qualifiedMethodName =*/ "FootprintTestService.setStructList"};
  apache::thrift::HandlerCallback<void>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_setStructList};
 auto callback =
      apache::thrift::HandlerCallbackPtr<void>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_setStructList<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_setStructList<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_setStructList.
  iface_->fbthrift_execute_decorators_before_setStructList(*serverRequest.requestContext(), *args.uarg_items);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_setStructList(std::move(cb), std::move(args.uarg_items));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_setStructList(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_setStructList_presult result;
  return serializeResponse("setStructList", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_setStructList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "setStructList");
    return;
  }
}
//
// End of Method 'setStructList'
//

//
// Method 'getStructList'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getStructList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getStructList<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getStructList(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getStructList_pargs pargs() {
      FootprintTestService_getStructList_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getStructList",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getStructList",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getStructList");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getStructList",
      /* .qualifiedMethodName =*/ "FootprintTestService.getStructList"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getStructList};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::vector<::cpp2_struct_footprint::SimpleStruct>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getStructList<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getStructList<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getStructList.
  iface_->fbthrift_execute_decorators_before_getStructList(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getStructList(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getStructList(
    apache::thrift::ContextStack* ctx,
    ::std::vector<::cpp2_struct_footprint::SimpleStruct> const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getStructList_presult result;
  result.get<0>().value = const_cast<::std::vector<::cpp2_struct_footprint::SimpleStruct>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getStructList", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getStructList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getStructList");
    return;
  }
}
//
// End of Method 'getStructList'
//

//
// Method 'getNestedContainer'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getNestedContainer(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getNestedContainer<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getNestedContainer(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getNestedContainer_pargs pargs() {
      FootprintTestService_getNestedContainer_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getNestedContainer",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getNestedContainer",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getNestedContainer");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getNestedContainer",
      /* .qualifiedMethodName =*/ "FootprintTestService.getNestedContainer"};
  apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getNestedContainer};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getNestedContainer<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getNestedContainer<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getNestedContainer.
  iface_->fbthrift_execute_decorators_before_getNestedContainer(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getNestedContainer(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getNestedContainer(
    apache::thrift::ContextStack* ctx,
    ::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>> const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getNestedContainer_presult result;
  result.get<0>().value = const_cast<::std::map<::std::string, ::std::vector<::cpp2_struct_footprint::SimpleStruct>>*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getNestedContainer", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getNestedContainer(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getNestedContainer");
    return;
  }
}
//
// End of Method 'getNestedContainer'
//

//
// Method 'getTypedefStruct'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getTypedefStruct<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getTypedefStruct(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getTypedefStruct_pargs pargs() {
      FootprintTestService_getTypedefStruct_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getTypedefStruct",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getTypedefStruct",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getTypedefStruct");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getTypedefStruct",
      /* .qualifiedMethodName =*/ "FootprintTestService.getTypedefStruct"};
  apache::thrift::HandlerCallback<std::unique_ptr<::cpp2_struct_footprint::MyStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getTypedefStruct};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::MyStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getTypedefStruct<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getTypedefStruct<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getTypedefStruct.
  iface_->fbthrift_execute_decorators_before_getTypedefStruct(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getTypedefStruct(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getTypedefStruct(
    apache::thrift::ContextStack* ctx,
    ::cpp2_struct_footprint::MyStruct const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getTypedefStruct_presult result;
  result.get<0>().value = const_cast<::cpp2_struct_footprint::MyStruct*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getTypedefStruct", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getTypedefStruct(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getTypedefStruct");
    return;
  }
}
//
// End of Method 'getTypedefStruct'
//

//
// Method 'getTypedefList'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getTypedefList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getTypedefList<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getTypedefList(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getTypedefList_pargs pargs() {
      FootprintTestService_getTypedefList_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getTypedefList",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getTypedefList",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getTypedefList");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getTypedefList",
      /* .qualifiedMethodName =*/ "FootprintTestService.getTypedefList"};
  apache::thrift::HandlerCallback<std::unique_ptr<::cpp2_struct_footprint::StructList>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getTypedefList};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::StructList>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getTypedefList<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getTypedefList<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getTypedefList.
  iface_->fbthrift_execute_decorators_before_getTypedefList(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getTypedefList(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getTypedefList(
    apache::thrift::ContextStack* ctx,
    ::cpp2_struct_footprint::StructList const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getTypedefList_presult result;
  result.get<0>().value = const_cast<::cpp2_struct_footprint::StructList*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getTypedefList", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getTypedefList(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getTypedefList");
    return;
  }
}
//
// End of Method 'getTypedefList'
//

//
// Method 'getUnion'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getUnion(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getUnion<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getUnion(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getUnion_pargs pargs() {
      FootprintTestService_getUnion_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getUnion",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getUnion",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getUnion");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getUnion",
      /* .qualifiedMethodName =*/ "FootprintTestService.getUnion"};
  apache::thrift::HandlerCallback<std::unique_ptr<::cpp2_struct_footprint::TestUnion>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getUnion};
 auto callback =
      apache::thrift::HandlerCallbackPtr<std::unique_ptr<::cpp2_struct_footprint::TestUnion>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getUnion<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getUnion<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_getUnion.
  iface_->fbthrift_execute_decorators_before_getUnion(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getUnion(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getUnion(
    apache::thrift::ContextStack* ctx,
    ::cpp2_struct_footprint::TestUnion const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getUnion_presult result;
  result.get<0>().value = const_cast<::cpp2_struct_footprint::TestUnion*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("getUnion", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getUnion(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getUnion");
    return;
  }
}
//
// End of Method 'getUnion'
//

//
// Method 'getCalculator'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_getCalculator(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_, "Calculator", true)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_getCalculator<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_getCalculator(
    apache::thrift::ServerRequest&& serverRequest) {
  auto tile = serverRequest.requestContext()->releaseTile();
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_getCalculator_pargs pargs() {
      FootprintTestService_getCalculator_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.getCalculator",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "getCalculator",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "getCalculator");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "getCalculator",
      /* .qualifiedMethodName =*/ "FootprintTestService.getCalculator"};
  apache::thrift::HandlerCallback<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_getCalculator};
 auto callback =
      apache::thrift::HandlerCallbackPtr<apache::thrift::TileAndResponse<apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::CalculatorIf, void>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_getCalculator<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_getCalculator<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          std::move(tile),
          std::move(decoratorCallback));
  // Execute method decorator before_getCalculator.
  iface_->fbthrift_execute_decorators_before_getCalculator(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_getCalculator(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_getCalculator(
    apache::thrift::ContextStack* ctx) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_getCalculator_presult result;
  return serializeResponse("getCalculator", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_getCalculator(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "getCalculator");
    return;
  }
}
//
// End of Method 'getCalculator'
//

//
// Method 'streamStructs'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_streamStructs(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_streamStructs<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_streamStructs(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    FootprintTestService_streamStructs_pargs pargs() {
      FootprintTestService_streamStructs_pargs args;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.streamStructs",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "streamStructs",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "streamStructs");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "streamStructs",
      /* .qualifiedMethodName =*/ "FootprintTestService.streamStructs"};
  apache::thrift::HandlerCallback<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_streamStructs};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_streamStructs<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_streamStructs<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_streamStructs.
  iface_->fbthrift_execute_decorators_before_streamStructs(*serverRequest.requestContext());

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_streamStructs(std::move(cb));
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::ResponseAndServerStreamFactory FootprintTestServiceAsyncProcessor::return_streamStructs(
    apache::thrift::ContextStack* ctx,
    folly::Executor::KeepAlive<> executor,
    ::apache::thrift::ServerStream<::cpp2_struct_footprint::SimpleStruct>&& _return) {
  ProtocolOut_ prot;
  FootprintTestService_streamStructs_presult::InitialResponsePResultType result;
  using StreamPResultType = FootprintTestService_streamStructs_presult::StreamPResultType;
  auto& returnStream = _return;
  auto encodedStream = apache::thrift::detail::ap::encode_server_stream<ProtocolOut_, StreamPResultType>(std::move(returnStream), std::move(executor));
  return {serializeResponse("streamStructs", &prot, ctx, result), std::move(encodedStream)};
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_streamStructs(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "streamStructs");
    return;
  }
}
//
// End of Method 'streamStructs'
//

//
// Method 'streamWithSinkInitial'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkInitial(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_streamWithSinkInitial<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkInitial(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int32_t uarg_input{0};
    FootprintTestService_streamWithSinkInitial_pargs pargs() {
      FootprintTestService_streamWithSinkInitial_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.streamWithSinkInitial",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "streamWithSinkInitial",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "streamWithSinkInitial");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "streamWithSinkInitial",
      /* .qualifiedMethodName =*/ "FootprintTestService.streamWithSinkInitial"};
  apache::thrift::HandlerCallback<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_streamWithSinkInitial};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_streamWithSinkInitial<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_streamWithSinkInitial<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_streamWithSinkInitial.
  iface_->fbthrift_execute_decorators_before_streamWithSinkInitial(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_streamWithSinkInitial(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::ResponseAndServerStreamFactory FootprintTestServiceAsyncProcessor::return_streamWithSinkInitial(
    apache::thrift::ContextStack* ctx,
    folly::Executor::KeepAlive<> executor,
    ::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>&& _return) {
  ProtocolOut_ prot;
  FootprintTestService_streamWithSinkInitial_presult::InitialResponsePResultType result;
  using StreamPResultType = FootprintTestService_streamWithSinkInitial_presult::StreamPResultType;
  result.get<0>().value = const_cast<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>::ResponseType*>(&_return.response);
  result.setIsSet(0, true);
  auto& returnStream = _return.stream;
  auto encodedStream = apache::thrift::detail::ap::encode_server_stream<ProtocolOut_, StreamPResultType>(std::move(returnStream), std::move(executor));
  return {serializeResponse("streamWithSinkInitial", &prot, ctx, result), std::move(encodedStream)};
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_streamWithSinkInitial(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "streamWithSinkInitial");
    return;
  }
}
//
// End of Method 'streamWithSinkInitial'
//

//
// Method 'streamWithSinkException'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_streamWithSinkException(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE, iface_)) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_STREAMING_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_streamWithSinkException<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_streamWithSinkException(
    apache::thrift::ServerRequest&& serverRequest) {
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int32_t uarg_input{0};
    FootprintTestService_streamWithSinkException_pargs pargs() {
      FootprintTestService_streamWithSinkException_pargs args;
      args.get<0>().value = &uarg_input;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_input)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.streamWithSinkException",
      serverRequest.requestContext());
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "streamWithSinkException",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "streamWithSinkException");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "streamWithSinkException",
      /* .qualifiedMethodName =*/ "FootprintTestService.streamWithSinkException"};
  apache::thrift::HandlerCallback<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<::cpp2_struct_footprint::FootprintTestService>::fbthrift_invoke_decorator_after_streamWithSinkException};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_streamWithSinkException<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_streamWithSinkException<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          apache::thrift::TilePtr(),
          std::move(decoratorCallback));
  // Execute method decorator before_streamWithSinkException.
  iface_->fbthrift_execute_decorators_before_streamWithSinkException(*serverRequest.requestContext(), args.uarg_input);

  const auto makeExecuteHandler = [&] {
    return [ifacePtr = iface_](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_streamWithSinkException(std::move(cb), args.uarg_input);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::ResponseAndServerStreamFactory FootprintTestServiceAsyncProcessor::return_streamWithSinkException(
    apache::thrift::ContextStack* ctx,
    folly::Executor::KeepAlive<> executor,
    ::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>&& _return) {
  ProtocolOut_ prot;
  FootprintTestService_streamWithSinkException_presult::InitialResponsePResultType result;
  using StreamPResultType = FootprintTestService_streamWithSinkException_presult::StreamPResultType;
  result.get<0>().value = const_cast<::apache::thrift::ResponseAndServerStream<::cpp2_struct_footprint::Struct1, ::cpp2_struct_footprint::SimpleStruct>::ResponseType*>(&_return.response);
  result.setIsSet(0, true);
  auto& returnStream = _return.stream;
  auto encodedStream = apache::thrift::detail::ap::encode_server_stream<ProtocolOut_, StreamPResultType>(std::move(returnStream), std::move(executor));
  return {serializeResponse("streamWithSinkException", &prot, ctx, result), std::move(encodedStream)};
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_streamWithSinkException(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  ::cpp2_struct_footprint::FootprintTestService_streamWithSinkException_presult::InitialResponsePResultType result;
  constexpr bool kHasReturnType = true;
  if (!::apache::thrift::detail::ap::insert_exn<kHasReturnType>(result, ew, [&]<typename Ex>(Ex&){
    if (ctx) {
      ctx->userExceptionWrapped(true, ew);
    }
    ::apache::thrift::util::appendExceptionToHeader(ew, *reqCtx);
    ::apache::thrift::util::appendErrorClassificationToHeader<Ex>(ew, *reqCtx);
  })) {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "streamWithSinkException");
    return;
  }
  ProtocolOut_ prot;
  auto response = serializeResponse("streamWithSinkException", &prot, ctx, result);
  auto payload = std::move(response).extractPayload(
      req->includeEnvelope(),
      prot.protocolType(),
      protoSeqId,
      apache::thrift::MessageType::T_REPLY,
      "streamWithSinkException");
  payload.transform(reqCtx->getHeader()->getWriteTransforms());
  req->sendStreamReply(std::move(payload), apache::thrift::detail::ServerStreamFactory{nullptr});
}
//
// End of Method 'streamWithSinkException'
//

//
// End of Service Methods
//

typedef apache::thrift::ThriftPresult<false, apache::thrift::FieldData<1, ::apache::thrift::type_class::integral, ::std::int32_t*>, apache::thrift::FieldData<2, ::apache::thrift::type_class::integral, ::std::int32_t*>> FootprintTestService_Calculator_add_pargs;
typedef apache::thrift::ThriftPresult<true, apache::thrift::FieldData<0, ::apache::thrift::type_class::integral, ::std::int32_t*>> FootprintTestService_Calculator_add_presult;
//
// Service Methods
//

//
// Method 'add'
//
template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::setUpAndProcess_Calculator_add(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    apache::thrift::SerializedCompressedRequest&& serializedRequest,
    apache::thrift::Cpp2RequestContext* ctx,
    folly::EventBase* eb,
    [[maybe_unused]] apache::thrift::concurrency::ThreadManager* tm) {
  if (!setUpRequestProcessing(
          req, ctx, eb, tm, apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE, iface_, "Calculator")) {
    return;
  }
  auto scope = iface_->getRequestExecutionScope(
      ctx, apache::thrift::concurrency::NORMAL);
  ctx->setRequestExecutionScope(std::move(scope));
  processInThread(
      std::move(req),
      std::move(serializedRequest),
      ctx,
      eb,
      tm,
      apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
      &FootprintTestServiceAsyncProcessor::
          executeRequest_Calculator_add<ProtocolIn_, ProtocolOut_>,
      this);
}

template <typename ProtocolIn_, typename ProtocolOut_>
void FootprintTestServiceAsyncProcessor::executeRequest_Calculator_add(
    apache::thrift::ServerRequest&& serverRequest) {
  auto tile = serverRequest.requestContext()->releaseTile();
  // make sure getRequestContext is null
  // so async calls don't accidentally use it
  iface_->setRequestContext(nullptr);
  struct ArgsState {
    ::std::int32_t uarg_a{0};
    ::std::int32_t uarg_b{0};
    FootprintTestService_Calculator_add_pargs pargs() {
      FootprintTestService_Calculator_add_pargs args;
      args.get<0>().value = &uarg_a;
      args.get<1>().value = &uarg_b;
      return args;
    }

    auto asTupleOfRefs() & {
      return std::tie(
        std::as_const(uarg_a),
        std::as_const(uarg_b)
      );
    }
  } args;

  auto ctxStack = apache::thrift::ContextStack::create(
      this->getEventHandlersSharedPtr(),
      this->getServiceName(),
      "FootprintTestService.Calculator.add",
      serverRequest.requestContext());
  auto& iface = static_cast<apache::thrift::ServiceHandler<FootprintTestService>::CalculatorIf&>(*tile);
  try {
    auto pargs = args.pargs();
    deserializeRequest<ProtocolIn_>(
        pargs,
        "Calculator.add",
        apache::thrift::detail::ServerRequestHelper::compressedRequest(
            std::move(serverRequest))
            .uncompress(),
        ctxStack.get());
  } catch (...) {
    folly::exception_wrapper ew(std::current_exception());
    apache::thrift::detail::ap::process_handle_exn_deserialization<
        ProtocolOut_>(
        ew,
        apache::thrift::detail::ServerRequestHelper::request(std::move(serverRequest)),
            serverRequest.requestContext(),
        apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
        "Calculator.add");
    return;
  }
  auto requestPileNotification =
      apache::thrift::detail::ServerRequestHelper::moveRequestPileNotification(
          serverRequest);
  auto concurrencyControllerNotification =
      apache::thrift::detail::ServerRequestHelper::moveConcurrencyControllerNotification(
          serverRequest);
  apache::thrift::HandlerCallbackBase::MethodNameInfo methodNameInfo{
      /* .serviceName =*/ this->getServiceName(),
      /* .definingServiceName =*/ "FootprintTestService",
      /* .methodName =*/ "Calculator.add",
      /* .qualifiedMethodName =*/ "FootprintTestService.Calculator.add"};
  apache::thrift::HandlerCallback<::std::int32_t>::DecoratorAfterCallback decoratorCallback{
    static_cast<void*>(iface_),
    apache::thrift::ServiceHandler<FootprintTestService>::fbthrift_invoke_decorator_after_Calculator_add};
 auto callback =
      apache::thrift::HandlerCallbackPtr<::std::int32_t>::make(
          apache::thrift::detail::ServerRequestHelper::request(
              std::move(serverRequest)),
          std::move(ctxStack),
          std::move(methodNameInfo),
          return_Calculator_add<ProtocolIn_, ProtocolOut_>,
          throw_wrapped_Calculator_add<ProtocolIn_, ProtocolOut_>,
          serverRequest.requestContext()->getProtoSeqId(),
          apache::thrift::detail::ServerRequestHelper::eventBase(serverRequest),
          apache::thrift::detail::ServerRequestHelper::executor(serverRequest),
          serverRequest.requestContext(),
          requestPileNotification,
          concurrencyControllerNotification,
          std::move(serverRequest.requestData()),
          std::move(tile),
          std::move(decoratorCallback));
  // Execute method decorator before_Calculator_add.
  iface_->fbthrift_execute_decorators_before_Calculator_add(*serverRequest.requestContext(), args.uarg_a, args.uarg_b);
  const auto makeExecuteHandler = [&] {
    return [ifacePtr = &iface](auto&& cb, ArgsState args) mutable {
      (void)args;
      ifacePtr->async_tm_add(std::move(cb), args.uarg_a, args.uarg_b);
    };
  };
#if FOLLY_HAS_COROUTINES
  if (apache::thrift::detail::shouldProcessServiceInterceptorsOnRequest(
          *callback)) {
    [](auto callback, auto executeHandler, ArgsState args)
        -> folly::coro::Task<void> {
      auto argRefs = args.asTupleOfRefs();
      co_await apache::thrift::detail::processServiceInterceptorsOnRequest(
          *callback,
          apache::thrift::detail::ServiceInterceptorOnRequestArguments(
              argRefs));
      executeHandler(std::move(callback), std::move(args));
    }(std::move(callback), makeExecuteHandler(), std::move(args))
               .scheduleOn(
                   apache::thrift::detail::ServerRequestHelper::executor(
                       serverRequest))
               .startInlineUnsafe();
  } else {
    makeExecuteHandler()(std::move(callback), std::move(args));
  }
#else
  makeExecuteHandler()(std::move(callback), std::move(args));
#endif // FOLLY_HAS_COROUTINES
}

template <class ProtocolIn_, class ProtocolOut_>
/* static */ apache::thrift::SerializedResponse FootprintTestServiceAsyncProcessor::return_Calculator_add(
    apache::thrift::ContextStack* ctx,
    ::std::int32_t const& _return) {
  ProtocolOut_ prot;
  ::cpp2_struct_footprint::FootprintTestService_Calculator_add_presult result;
  result.get<0>().value = const_cast<::std::int32_t*>(&_return);
  result.setIsSet(0, true);
  return serializeResponse("Calculator.add", &prot, ctx, result);
}

template <class ProtocolIn_, class ProtocolOut_>
void FootprintTestServiceAsyncProcessor::throw_wrapped_Calculator_add(
    apache::thrift::ResponseChannelRequest::UniquePtr req,
    [[maybe_unused]] int32_t protoSeqId,
    apache::thrift::ContextStack* ctx,
    folly::exception_wrapper ew,
    apache::thrift::Cpp2RequestContext* reqCtx) {
  if (!ew) {
    return;
  }
  {
    apache::thrift::detail::ap::process_throw_wrapped_handler_error<
        ProtocolOut_>(ew, std::move(req), reqCtx, ctx, "Calculator.add");
    return;
  }
}
//
// End of Method 'add'
//

//
// End of Service Methods
//
} // namespace cpp2_struct_footprint
