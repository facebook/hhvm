/*
   +----------------------------------------------------------------------+
   | HipHop for PHP                                                       |
   +----------------------------------------------------------------------+
   | Copyright (c) 2010 Facebook, Inc. (http://www.facebook.com)          |
   +----------------------------------------------------------------------+
   | This source file is subject to version 3.01 of the PHP license,      |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.php.net/license/3_01.txt                                  |
   | If you did not receive a copy of the PHP license and are unable to   |
   | obtain it through the world-wide-web, please send a note to          |
   | license@php.net so we can mail you a copy immediately.               |
   +----------------------------------------------------------------------+
*/
// @generated by HipHop Compiler

#include <runtime/base/hphp_system.h>
#include <runtime/ext/ext.h>
#include <runtime/eval/eval.h>
#include <sys/literal_strings.h>

namespace hphp_impl_starter {}

using namespace std;

namespace HPHP {
///////////////////////////////////////////////////////////////////////////////


// Class Invoke Tables
#define M(x, y) MethodIndex(x, y)
#define H(x,y,z) MethodIndexHMap(#x,MethodIndex(y,z))
#define Z MethodIndexHMap(0,MethodIndex(0,0))
const unsigned g_methodIndexHMapSizeSys = 924;
extern const MethodIndexHMap g_methodIndexHMapSys [];
const MethodIndexHMap g_methodIndexHMapSys [g_methodIndexHMapSizeSys] = {
Z, Z, Z, 
H(getNodePath,58,1), Z, Z, 
Z, Z, Z, 
H(code,155,1), Z, Z, 
Z, H(isOptional,344,1), H(rowcount,274,1), 
H(natsort,16,1), Z, Z, 
H(load,84,1), H(getPath,185,1), H(offsetSet,13,1), 
Z, Z, Z, 
Z, H(c14nfile,59,1), Z, 
Z, H(getResultMessage,229,1), H(item,121,1), 
H(flush,226,1), H(serialize,371,1), H(createAttribute,94,1), 
Z, H(tutorial,148,1), H(importNode,88,1), 
H(key,2,1), H(getFlags,22,1), Z, 
Z, H(saveXML,81,1), H(onAutoComplete,167,1), 
Z, H(getByKey,240,1), Z, 
Z, Z, H(begintransaction,262,1), 
H(send,166,1), H(endDTDAttlist,424,1), H(__isset,381,1), 
Z, H(replaceData,68,1), Z, 
H(writeCData,438,1), H(getNamedItemNS,123,1), Z, 
Z, Z, H(xpath,373,1), 
Z, Z, H(isDestructor,338,1), 
H(getSubPath,280,1), H(relaxNGValidateSource,89,1), Z, 
Z, Z, H(hasAttribute,105,1), 
Z, Z, H(getDeclaringClass,335,1), 
H(relaxNGValidate,77,1), Z, Z, 
H(getPathname,176,1), H(get,219,1), H(getOwner,191,1), 
H(getavailabledrivers,260,1), H(getServerByKey,243,1), Z, 
Z, H(hasChildNodes,64,1), H(setAttributeNS,108,1), 
Z, H(lookupNamespaceUri,49,1), H(isInterface,308,1), 
H(writeRaw,447,1), H(writeDTD,432,1), Z, 
H(getMessage,25,1), Z, H(endComment,431,1), 
H(unserialize,370,1), Z, H(__construct,6,1), 
Z, H(getClass,340,1), Z, 
H(__setsoapheaders,385,1), Z, H(escapestring,356,1), 
H(replace,225,1), H(query,124,1), Z, 
H(getextendedstats,227,1), Z, Z, 
H(reset,367,1), H(getElementsByTagName,72,1), H(getChildren,282,1), 
H(endElement,446,1), Z, H(listIdentifiers,137,1), 
H(getElementsByTagNameNS,75,1), H(mapping,203,1), Z, 
Z, Z, Z, 
Z, Z, H(getstrength,38,1), 
Z, Z, Z, 
H(setcompressthreshold,218,1), Z, H(offsetGet,11,1), 
H(setOption,234,1), Z, H(wrap,165,1), 
H(getStartLine,304,1), H(registerXPathNamespace,374,1), H(getversion,222,1), 
H(getMulti,228,1), H(fstat,418,1), H(printFrame,153,1), 
H(create,40,1), H(getOffset,130,1), Z, 
Z, H(startCData,454,1), H(isPrivate,332,1), 
H(setAttributeNode,116,1), H(__gettypes,393,1), Z, 
Z, Z, Z, 
H(xinclude,95,1), Z, Z, 
H(startDTDEntity,427,1), Z, H(onServer,169,1), 
Z, Z, H(openblob,360,1), 
Z, Z, Z, 
Z, H(getLine,28,1), Z, 
H(replaceByKey,237,1), H(createEntityReference,79,1), H(prepend,235,1), 
H(allowsNull,341,1), H(fwrite,417,1), H(fflush,411,1), 
H(createaggregate,357,1), H(setpersistence,396,1), Z, 
H(openMemory,457,1), H(createDocumentType,118,1), H(isDot,198,1), 
Z, H(lasterrormsg,355,1), Z, 
Z, H(getName,139,1), Z, 
Z, Z, H(setIDAttributeNS,103,1), 
H(isLink,187,1), H(splitText,71,1), H(fetchAll,246,1), 
H(getstats,215,1), H(handle,397,1), H(getFunctions,320,1), 
H(append,5,1), H(closecursor,273,1), H(asXML,377,1), 
H(info,152,1), H(getBasename,175,1), Z, 
H(modify,135,1), H(loadHTMLFile,96,1), H(seek,21,1), 
H(isReadable,181,1), H(__toString,26,1), H(getPathInfo,183,1), 
H(getTimezone,132,1), H(getExtensionName,300,1), H(compare,44,1), 
H(validate,74,1), Z, Z, 
Z, H(getserverstatus,216,1), Z, 
Z, H(hasFeature,119,1), H(sortwithsortkeys,34,1), 
H(getOption,242,1), H(fgetss,403,1), H(decrement,214,1), 
Z, H(deleteData,69,1), H(createfunction,353,1), 
Z, Z, Z, 
H(isInstance,293,1), Z, Z, 
H(getMTime,192,1), H(removeChild,61,1), Z, 
H(getLineNo,45,1), H(offsetUnset,12,1), H(setIndent,451,1), 
H(isSupported,63,1), H(errorcode,254,1), Z, 
H(saveHTMLFile,97,1), H(version,351,1), Z, 
Z, Z, H(cloneNode,52,1), 
H(isUserDefined,286,1), H(isId,48,1), H(endDTDElement,452,1), 
H(setMultiByKey,247,1), H(prepare,263,1), H(setCsvControl,405,1), 
H(getValue,347,1), H(removeAttributeNS,110,1), H(isInternal,318,1), 
H(writeAttributeNS,441,1), H(close,171,1), H(asort,20,1), 
H(__call,8,1), H(next,1,1), H(appendData,67,1), 
Z, Z, Z, 
Z, H(getConstructor,289,1), Z, 
H(ftell,416,1), H(isPassedByReference,346,1), Z, 
Z, Z, Z, 
H(addString,201,1), Z, Z, 
H(print,154,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
H(lastinsertrowid,354,1), Z, H(export,296,1), 
H(getCsvControl,406,1), H(getClosure,331,1), Z, 
H(getDefaultValue,345,1), Z, H(isConstructor,336,1), 
Z, H(setTimezone,134,1), Z, 
Z, H(fpassthru,413,1), Z, 
Z, H(natcasesort,19,1), H(getExtension,288,1), 
Z, Z, Z, 
Z, Z, H(getSubPathname,279,1), 
Z, H(insertData,66,1), H(lookupPrefix,56,1), 
H(columntype,364,1), H(getInterfaceNames,303,1), Z, 
Z, Z, H(getDelayed,233,1), 
Z, H(geterrorcode,37,1), Z, 
Z, Z, H(set,211,1), 
H(children,379,1), H(__unset,376,1), H(isLocal,170,1), 
H(startDocument,426,1), Z, H(writeDTDEntity,448,1), 
H(isSameNode,60,1), H(getProperties,297,1), H(attributes,382,1), 
Z, Z, H(loadextension,352,1), 
Z, Z, H(addByKey,245,1), 
Z, Z, H(bindparam,272,1), 
Z, H(getArrayCopy,14,1), H(text,461,1), 
Z, Z, Z, 
H(helpTitle,146,1), H(setIDAttributeNode,113,1), H(isAbstract,317,1), 
Z, Z, Z, 
H(isStatic,334,1), H(current,7,1), H(fgetc,412,1), 
H(saveHTML,91,1), H(getStackTrace,151,1), H(contains,421,1), 
H(createAttributens,85,1), H(normalizeDocument,100,1), H(increment,213,1), 
Z, H(fseek,402,1), Z, 
Z, Z, Z, 
Z, Z, H(getNumberOfParameters,325,1), 
Z, H(prependByKey,252,1), Z, 
H(listAbbreviations,138,1), H(hasChildren,281,1), Z, 
Z, Z, H(isProtected,333,1), 
H(removeAttributeNode,114,1), Z, Z, 
Z, Z, H(implementsInterface,302,1), 
H(startDTDElement,437,1), Z, H(startElement,435,1), 
Z, Z, H(getFilename,189,1), 
H(getGroup,177,1), Z, H(help,160,1), 
H(read,172,1), Z, Z, 
Z, Z, H(querysingle,362,1), 
Z, Z, Z, 
H(isDefaultValueAvailable,339,1), Z, Z, 
Z, H(isSubclassOf,309,1), H(setDate,129,1), 
H(appendByKey,232,1), Z, Z, 
H(setoptimeout,217,1), Z, Z, 
H(setIDAttribute,112,1), H(addServers,250,1), Z, 
Z, Z, H(commit,259,1), 
H(writeElement,445,1), H(debugdumpparams,278,1), H(createDocument,117,1), 
H(getATime,195,1), Z, Z, 
Z, H(argRest,163,1), H(getDocComment,307,1), 
H(loadXML,92,1), Z, Z, 
Z, Z, Z, 
H(getStaticPropertyValue,285,1), H(open,358,1), H(insertBefore,46,1), 
H(removeAttribute,115,1), H(delete,223,1), H(registerNamespace,127,1), 
Z, H(substringData,65,1), Z, 
Z, H(isDefault,348,1), Z, 
Z, Z, Z, 
H(writeElementNS,422,1), H(argValue,149,1), H(isPublic,337,1), 
H(createCDATASection,73,1), Z, Z, 
Z, H(startDTDAttlist,453,1), H(addsoapheader,395,1), 
H(getConstant,305,1), H(count,15,1), Z, 
Z, Z, Z, 
H(geterrormessage,43,1), H(errorinfo,264,1), H(setMaxLineLen,407,1), 
Z, H(getMaxLineLen,408,1), H(ask,143,1), 
Z, Z, H(setobject,398,1), 
H(isExecutable,196,1), H(getCode,27,1), Z, 
Z, H(getMethod,299,1), Z, 
Z, H(getNamespaces,375,1), H(createElement,86,1), 
Z, Z, Z, 
Z, Z, H(exec,255,1), 
Z, H(fgets,414,1), H(__get,62,1), 
H(__wakeup,257,1), Z, Z, 
Z, Z, H(__dorequest,383,1), 
H(execute,275,1), Z, Z, 
H(setValue,350,1), H(rollback,258,1), H(fetcharray,366,1), 
H(getPosition,342,1), H(hasAttributes,54,1), H(getType,199,1), 
Z, Z, Z, 
Z, Z, Z, 
H(setserverparams,212,1), H(getSize,188,1), Z, 
Z, Z, Z, 
H(getLinkTarget,180,1), Z, H(__soapcall,387,1), 
Z, H(fault,399,1), Z, 
H(appendXML,102,1), Z, Z, 
Z, H(changes,359,1), H(newInstanceArgs,290,1), 
Z, Z, H(writeDTDAttlist,455,1), 
Z, Z, H(isArray,343,1), 
H(getAttributeNS,109,1), Z, Z, 
H(returnsReference,329,1), H(hasAttributeNS,106,1), Z, 
Z, Z, Z, 
H(normalize,57,1), H(__setlocation,388,1), Z, 
Z, Z, Z, 
Z, H(schemaValidateSource,76,1), H(lastinsertid,256,1), 
H(setstrength,39,1), Z, Z, 
H(quote,261,1), H(fetch,249,1), H(getNumberOfRequiredParameters,324,1), 
H(getConstants,306,1), Z, Z, 
Z, H(setfetchmode,270,1), Z, 
H(startDTD,450,1), H(uasort,24,1), Z, 
Z, H(paramcount,369,1), Z, 
H(createProcessingInstruction,82,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, H(deleteByKey,241,1), H(writeAttribute,430,1), 
Z, Z, H(createElementNS,87,1), 
H(addFile,209,1), H(getErrors,207,1), Z, 
H(invoke,330,1), Z, Z, 
Z, Z, Z, 
Z, Z, H(xend,145,1), 
Z, Z, H(addUrl,208,1), 
Z, Z, Z, 
Z, Z, H(test,311,1), 
H(endDTDEntity,433,1), H(fetchcolumn,266,1), H(getMultiByKey,248,1), 
H(writeComment,429,1), H(registerNodeClass,83,1), H(openFile,197,1), 
H(fgetcsv,404,1), Z, H(endDTD,456,1), 
Z, Z, H(setMulti,239,1), 
H(finalize,368,1), H(__set,51,1), H(loadImages,205,1), 
H(getFileInfo,194,1), H(hasMethod,292,1), H(offsetExists,10,1), 
H(setFlags,17,1), H(ftruncate,409,1), H(isDefaultNamespace,47,1), 
H(startElementNS,436,1), Z, H(valid,3,1), 
H(setclass,400,1), H(getDelayedByKey,238,1), H(getTraceAsString,31,1), 
H(clear,206,1), H(fetchobject,276,1), H(openURI,458,1), 
H(helpBody,158,1), H(hasConstant,298,1), H(schemaValidate,80,1), 
H(getPerms,173,1), Z, Z, 
Z, Z, H(getCommand,147,1), 
H(fscanf,401,1), H(endCData,428,1), Z, 
H(replaceChild,53,1), Z, Z, 
H(setStaticPropertyValue,314,1), Z, Z, 
Z, Z, Z, 
Z, Z, Z, 
Z, Z, H(setISODate,133,1), 
H(isFile,190,1), Z, Z, 
Z, Z, Z, 
Z, H(getElementById,98,1), H(nextrowset,268,1), 
H(newInstance,287,1), H(__destruct,35,1), H(getInnerIterator,4,1), 
Z, Z, Z, 
Z, H(getStaticProperties,312,1), H(getInode,186,1), 
Z, H(__getlastrequest,384,1), Z, 
Z, H(isWritable,174,1), H(addChild,380,1), 
Z, H(addserver,210,1), Z, 
H(getClassNames,322,1), H(getDocNamespaces,378,1), H(loadDims,202,1), 
Z, Z, Z, 
H(sort,36,1), Z, H(__getlastrequestheaders,389,1), 
H(getProperty,319,1), H(helpSection,156,1), H(endAttribute,459,1), 
Z, Z, Z, 
Z, Z, Z, 
H(__getlastresponseheaders,391,1), H(getSeverity,200,1), Z, 
H(isnormalized,253,1), H(addAttribute,372,1), Z, 
Z, Z, H(outputMemory,425,1), 
Z, H(getStaticVariables,326,1), Z, 
Z, H(createTextNode,90,1), Z, 
Z, H(c14n,55,1), Z, 
Z, Z, Z, 
Z, H(ksort,23,1), Z, 
Z, H(error,144,1), Z, 
Z, Z, Z, 
Z, H(addCompletion,162,1), H(getINIEntries,321,1), 
H(startComment,462,1), H(__init__,29,1), H(casByKey,236,1), 
Z, H(hasProperty,310,1), H(getEndLine,291,1), 
Z, H(connect,224,1), H(evaluate,125,1), 
Z, Z, Z, 
H(uksort,18,1), H(pconnect,220,1), H(startPI,460,1), 
Z, Z, H(getattribute,33,1), 
H(startAttributens,434,1), H(isIterateable,284,1), H(startAttribute,444,1), 
Z, Z, Z, 
H(__getfunctions,390,1), H(save,93,1), H(isWhitespaceInElementContent,70,1), 
Z, Z, Z, 
Z, H(setAccessible,349,1), Z, 
H(setAttributeNodeNS,107,1), H(getParameters,327,1), H(output,150,1), 
H(getCTime,184,1), Z, H(__setcookie,386,1), 
H(isFinal,294,1), H(add,221,1), Z, 
Z, H(setattribute,41,1), Z, 
H(__getlastresponse,392,1), H(setFileClass,178,1), Z, 
H(getcolumnmeta,267,1), Z, Z, 
Z, Z, H(getModifiers,295,1), 
Z, H(rewind,9,1), Z, 
H(getFile,30,1), H(helpCmds,142,1), H(args,161,1), 
H(eof,410,1), Z, Z, 
Z, Z, H(lasterrorcode,361,1), 
H(getResultCode,230,1), H(getParentClass,301,1), Z, 
H(attach,419,1), Z, Z, 
H(getServerList,244,1), Z, Z, 
Z, Z, H(endDocument,439,1), 
Z, Z, Z, 
H(setByKey,231,1), H(__sleep,265,1), Z, 
Z, Z, Z, 
H(writePI,442,1), Z, H(getAttributeNodeNS,104,1), 
Z, H(getMethods,283,1), Z, 
Z, H(fullEndElement,423,1), H(getNamedItem,120,1), 
H(onClient,168,1), H(css,204,1), H(detach,420,1), 
Z, Z, H(setTime,131,1), 
Z, Z, H(createDocumentFragment,101,1), 
H(arg,141,1), Z, Z, 
H(argCount,140,1), Z, Z, 
H(setIndentString,443,1), H(columncount,271,1), Z, 
H(endPI,449,1), Z, Z, 
H(getTransitions,136,1), H(setInfoClass,179,1), H(loadHTML,78,1), 
Z, H(isInstantiable,315,1), H(getAttributeNode,111,1), 
H(quit,157,1), Z, H(flock,415,1), 
H(getRealPath,182,1), H(getClasses,323,1), Z, 
H(invokeArgs,328,1), Z, H(getInterfaces,316,1), 
H(appendChild,50,1), Z, Z, 
Z, Z, Z, 
Z, H(getTrace,32,1), Z, 
H(getFrame,159,1), Z, Z, 
Z, Z, Z, 
Z, Z, H(columnname,363,1), 
H(numcolumns,365,1), H(writeDTDElement,440,1), H(getIterator,122,1), 
Z, H(getCurrentLocation,164,1), H(getlocale,42,1), 
Z, Z, Z, 
Z, H(format,128,1), Z, 
H(bindcolumn,269,1), Z, H(bindvalue,277,1), 
Z, H(cas,251,1), H(getDefaultProperties,313,1), 
H(createComment,99,1), H(isDir,193,1), Z, 
Z, H(addfunction,394,1), Z, 
Z, H(registerPHPFunctions,126,1), Z
};
#undef M
#undef H
#undef Z
extern const unsigned g_methodIndexReverseCallIndexSys[];
const unsigned g_methodIndexReverseCallIndexSys[] = {0, 
1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,
61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,
101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,
121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,
141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,
181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,
201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,
261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,
281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,
301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,
321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,
341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,
361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,
381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,
401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,
421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,
441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,
461};
extern const char * g_methodIndexReverseIndexSys[];
const char * g_methodIndexReverseIndexSys[] = {
"next", "key", "valid", "getInnerIterator", "append", 
"__construct", "current", "__call", "rewind", "offsetExists", 
"offsetGet", "offsetUnset", "offsetSet", "getArrayCopy", "count", 
"natsort", "setFlags", "uksort", "natcasesort", "asort", 
"seek", "getFlags", "ksort", "uasort", "getMessage", 
"__toString", "getCode", "getLine", "__init__", "getFile", 
"getTraceAsString", "getTrace", "getattribute", "sortwithsortkeys", "__destruct", 
"sort", "geterrorcode", "getstrength", "setstrength", "create", 
"setattribute", "getlocale", "geterrormessage", "compare", "getLineNo", 
"insertBefore", "isDefaultNamespace", "isId", "lookupNamespaceUri", "appendChild", 
"__set", "cloneNode", "replaceChild", "hasAttributes", "c14n", 
"lookupPrefix", "normalize", "getNodePath", "c14nfile", "isSameNode", 
"removeChild", "__get", "isSupported", "hasChildNodes", "substringData", 
"insertData", "appendData", "replaceData", "deleteData", "isWhitespaceInElementContent", 
"splitText", "getElementsByTagName", "createCDATASection", "validate", "getElementsByTagNameNS", 
"schemaValidateSource", "relaxNGValidate", "loadHTML", "createEntityReference", "schemaValidate", 
"saveXML", "createProcessingInstruction", "registerNodeClass", "load", "createAttributens", 
"createElement", "createElementNS", "importNode", "relaxNGValidateSource", "createTextNode", 
"saveHTML", "loadXML", "save", "createAttribute", "xinclude", 
"loadHTMLFile", "saveHTMLFile", "getElementById", "createComment", "normalizeDocument", 
"createDocumentFragment", "appendXML", "setIDAttributeNS", "getAttributeNodeNS", "hasAttribute", 
"hasAttributeNS", "setAttributeNodeNS", "setAttributeNS", "getAttributeNS", "removeAttributeNS", 
"getAttributeNode", "setIDAttribute", "setIDAttributeNode", "removeAttributeNode", "removeAttribute", 
"setAttributeNode", "createDocument", "createDocumentType", "hasFeature", "getNamedItem", 
"item", "getIterator", "getNamedItemNS", "query", "evaluate", 
"registerPHPFunctions", "registerNamespace", "format", "setDate", "getOffset", 
"setTime", "getTimezone", "setISODate", "setTimezone", "modify", 
"getTransitions", "listIdentifiers", "listAbbreviations", "getName", "argCount", 
"arg", "helpCmds", "ask", "error", "xend", 
"helpTitle", "getCommand", "tutorial", "argValue", "output", 
"getStackTrace", "info", "printFrame", "print", "code", 
"helpSection", "quit", "helpBody", "getFrame", "help", 
"args", "addCompletion", "argRest", "getCurrentLocation", "wrap", 
"send", "onAutoComplete", "onClient", "onServer", "isLocal", 
"close", "read", "getPerms", "isWritable", "getBasename", 
"getPathname", "getGroup", "setFileClass", "setInfoClass", "getLinkTarget", 
"isReadable", "getRealPath", "getPathInfo", "getCTime", "getPath", 
"getInode", "isLink", "getSize", "getFilename", "isFile", 
"getOwner", "getMTime", "isDir", "getFileInfo", "getATime", 
"isExecutable", "openFile", "isDot", "getType", "getSeverity", 
"addString", "loadDims", "mapping", "css", "loadImages", 
"clear", "getErrors", "addUrl", "addFile", "addserver", 
"set", "setserverparams", "increment", "decrement", "getstats", 
"getserverstatus", "setoptimeout", "setcompressthreshold", "get", "pconnect", 
"add", "getversion", "delete", "connect", "replace", 
"flush", "getextendedstats", "getMulti", "getResultMessage", "getResultCode", 
"setByKey", "appendByKey", "getDelayed", "setOption", "prepend", 
"casByKey", "replaceByKey", "getDelayedByKey", "setMulti", "getByKey", 
"deleteByKey", "getOption", "getServerByKey", "getServerList", "addByKey", 
"fetchAll", "setMultiByKey", "getMultiByKey", "fetch", "addServers", 
"cas", "prependByKey", "isnormalized", "errorcode", "exec", 
"lastinsertid", "__wakeup", "rollback", "commit", "getavailabledrivers", 
"quote", "begintransaction", "prepare", "errorinfo", "__sleep", 
"fetchcolumn", "getcolumnmeta", "nextrowset", "bindcolumn", "setfetchmode", 
"columncount", "bindparam", "closecursor", "rowcount", "execute", 
"fetchobject", "bindvalue", "debugdumpparams", "getSubPathname", "getSubPath", 
"hasChildren", "getChildren", "getMethods", "isIterateable", "getStaticPropertyValue", 
"isUserDefined", "newInstance", "getExtension", "getConstructor", "newInstanceArgs", 
"getEndLine", "hasMethod", "isInstance", "isFinal", "getModifiers", 
"export", "getProperties", "hasConstant", "getMethod", "getExtensionName", 
"getParentClass", "implementsInterface", "getInterfaceNames", "getStartLine", "getConstant", 
"getConstants", "getDocComment", "isInterface", "isSubclassOf", "hasProperty", 
"test", "getStaticProperties", "getDefaultProperties", "setStaticPropertyValue", "isInstantiable", 
"getInterfaces", "isAbstract", "isInternal", "getProperty", "getFunctions", 
"getINIEntries", "getClassNames", "getClasses", "getNumberOfRequiredParameters", "getNumberOfParameters", 
"getStaticVariables", "getParameters", "invokeArgs", "returnsReference", "invoke", 
"getClosure", "isPrivate", "isProtected", "isStatic", "getDeclaringClass", 
"isConstructor", "isPublic", "isDestructor", "isDefaultValueAvailable", "getClass", 
"allowsNull", "getPosition", "isArray", "isOptional", "getDefaultValue", 
"isPassedByReference", "getValue", "isDefault", "setAccessible", "setValue", 
"version", "loadextension", "createfunction", "lastinsertrowid", "lasterrormsg", 
"escapestring", "createaggregate", "open", "changes", "openblob", 
"lasterrorcode", "querysingle", "columnname", "columntype", "numcolumns", 
"fetcharray", "reset", "finalize", "paramcount", "unserialize", 
"serialize", "addAttribute", "xpath", "registerXPathNamespace", "getNamespaces", 
"__unset", "asXML", "getDocNamespaces", "children", "addChild", 
"__isset", "attributes", "__dorequest", "__getlastrequest", "__setsoapheaders", 
"__setcookie", "__soapcall", "__setlocation", "__getlastrequestheaders", "__getfunctions", 
"__getlastresponseheaders", "__getlastresponse", "__gettypes", "addfunction", "addsoapheader", 
"setpersistence", "handle", "setobject", "fault", "setclass", 
"fscanf", "fseek", "fgetss", "fgetcsv", "setCsvControl", 
"getCsvControl", "setMaxLineLen", "getMaxLineLen", "ftruncate", "eof", 
"fflush", "fgetc", "fpassthru", "fgets", "flock", 
"ftell", "fwrite", "fstat", "attach", "detach", 
"contains", "writeElementNS", "fullEndElement", "endDTDAttlist", "outputMemory", 
"startDocument", "startDTDEntity", "endCData", "writeComment", "writeAttribute", 
"endComment", "writeDTD", "endDTDEntity", "startAttributens", "startElement", 
"startElementNS", "startDTDElement", "writeCData", "endDocument", "writeDTDElement", 
"writeAttributeNS", "writePI", "setIndentString", "startAttribute", "writeElement", 
"endElement", "writeRaw", "writeDTDEntity", "endPI", "startDTD", 
"setIndent", "endDTDElement", "startDTDAttlist", "startCData", "writeDTDAttlist", 
"endDTD", "openMemory", "openURI", "endAttribute", "startPI", 
"text", "startComment"};
extern struct ObjectStaticCallbacks cw_ReflectionFunctionAbstract;
extern struct ObjectStaticCallbacks cw_ReflectionObject;
extern struct ObjectStaticCallbacks cw_SplFileObject;
extern struct ObjectStaticCallbacks cw_UnexpectedValueException;
extern struct ObjectStaticCallbacks cw_stdClass;
extern struct ObjectStaticCallbacks cw_ReflectionException;
extern struct ObjectStaticCallbacks cw_OverflowException;
extern struct ObjectStaticCallbacks cw_SplFileInfo;
extern struct ObjectStaticCallbacks cw_ArrayIterator;
extern struct ObjectStaticCallbacks cw_AppendIterator;
extern struct ObjectStaticCallbacks cw_OutOfBoundsException;
extern struct ObjectStaticCallbacks cw_LogicException;
extern struct ObjectStaticCallbacks cw_RangeException;
extern struct ObjectStaticCallbacks cw_SplObjectStorage;
extern struct ObjectStaticCallbacks cw_InvalidArgumentException;
extern struct ObjectStaticCallbacks cw_ReflectionClass;
extern struct ObjectStaticCallbacks cw_UnderflowException;
extern struct ObjectStaticCallbacks cw_ReflectionExtension;
extern struct ObjectStaticCallbacks cw_OutOfRangeException;
extern struct ObjectStaticCallbacks cw_ReflectionMethod;
extern struct ObjectStaticCallbacks cw_BadMethodCallException;
extern struct ObjectStaticCallbacks cw_ReflectionProperty;
extern struct ObjectStaticCallbacks cw___PHP_Incomplete_Class;
extern struct ObjectStaticCallbacks cw_Exception;
extern struct ObjectStaticCallbacks cw_RuntimeException;
extern struct ObjectStaticCallbacks cw_ReflectionFunction;
extern struct ObjectStaticCallbacks cw_XhprofFrame;
extern struct ObjectStaticCallbacks cw_ErrorException;
extern struct ObjectStaticCallbacks cw_RecursiveDirectoryIterator;
extern struct ObjectStaticCallbacks cw_DirectoryIterator;
extern struct ObjectStaticCallbacks cw_BadFunctionCallException;
extern struct ObjectStaticCallbacks cw_LengthException;
extern struct ObjectStaticCallbacks cw_DomainException;
extern struct ObjectStaticCallbacks cw_RecursiveIteratorIterator;
extern struct ObjectStaticCallbacks cw_Directory;
extern struct ObjectStaticCallbacks cw_FilterIterator;
extern struct ObjectStaticCallbacks cw_ReflectionParameter;
Object co_PDOException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOException)())->dynCreate(params, init));
}
Object coo_PDOException() {
  Object r(NEW(c_PDOException)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
Variant c_PDOException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
Variant c_PDOException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
Variant &c_PDOException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
void c_PDOException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
void c_PDOException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOException
Variant * c_PDOException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
Variant * c_PDOException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
Variant * c_PDOException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
Variant c_PDOException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOException
IMPLEMENT_CLASS(PDOException)
void c_PDOException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOException::cloneImpl() {
  c_PDOException *obj = NEW(c_PDOException)();
  cloneSet(obj);
  return obj;
}
void c_PDOException::cloneSet(c_PDOException *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_PDOException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDOException::ci___destruct((void*)&c_PDOException::i___destruct, (void*)&c_PDOException::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOException::ci___construct((void*)&c_PDOException::i___construct, (void*)&c_PDOException::ifa___construct, 0, 4, 0x0000000000000000LL);
Variant c_PDOException::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOException::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOException::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOException::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOException *self = NULL;
  p_PDOException pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_PDOException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_PDOException::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_PDOException::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_PDOException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_PDOException *c_PDOException::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOException::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDOException::ci___construct;
  mcp.obj = this;
}
void c_PDOException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_PDOException = {
  c_PDOException::os_getInit,
  c_PDOException::os_get,
  c_PDOException::os_lval,
  c_PDOException::os_invoke,
  c_PDOException::os_constant,
  c_PDOException::os_get_call_info
};
Object co_DOMDocumentFragment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentFragment)())->dynCreate(params, init));
}
Object coo_DOMDocumentFragment() {
  Object r(NEW(c_DOMDocumentFragment)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
Variant &c_DOMDocumentFragment::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
void c_DOMDocumentFragment::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
Variant * c_DOMDocumentFragment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentFragment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
Variant c_DOMDocumentFragment::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentFragment
IMPLEMENT_CLASS(DOMDocumentFragment)
void c_DOMDocumentFragment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentFragment::cloneImpl() {
  c_DOMDocumentFragment *obj = NEW(c_DOMDocumentFragment)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentFragment::cloneSet(c_DOMDocumentFragment *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocumentFragment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 1:
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss582264a0, "appendXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
        return (t_appendxml(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentFragment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocumentFragment::ci___destruct((void*)&c_DOMDocumentFragment::i___destruct, (void*)&c_DOMDocumentFragment::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocumentFragment::ci___construct((void*)&c_DOMDocumentFragment::i___construct, (void*)&c_DOMDocumentFragment::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocumentFragment::ci_appendxml((void*)&c_DOMDocumentFragment::i_appendxml, (void*)&c_DOMDocumentFragment::ifa_appendxml, 1, 4, 0x0000000000000000LL);
Variant c_DOMDocumentFragment::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentFragment::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentFragment::i_appendxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appendxml(arg0));
  }
}
Variant c_DOMDocumentFragment::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentFragment::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentFragment::ifa_appendxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentFragment *self = NULL;
  p_DOMDocumentFragment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentFragment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendxml", count, 1, 1, 1);
  return (self->t_appendxml(a0));
}
bool c_DOMDocumentFragment::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 1:
      HASH_GUARD_LITSTR(0x1E44C8E8C1920931LL, NAMSTR(s_sys_ss582264a0, "appendXML")) {
        mcp.ci = &c_DOMDocumentFragment::ci_appendxml;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___destruct;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMDocumentFragment::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocumentFragment::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMDocumentFragment *c_DOMDocumentFragment::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentFragment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentFragment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentFragment::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocumentFragment::ci___construct;
  mcp.obj = this;
}
void c_DOMDocumentFragment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMDocumentFragment = {
  c_DOMDocumentFragment::os_getInit,
  c_DOMDocumentFragment::os_get,
  c_DOMDocumentFragment::os_lval,
  c_DOMDocumentFragment::os_invoke,
  c_DOMDocumentFragment::os_constant,
  c_DOMDocumentFragment::os_get_call_info
};
Object co_DOMText(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMText)())->dynCreate(params, init));
}
Object coo_DOMText() {
  Object r(NEW(c_DOMText)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
Variant c_DOMText::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
Variant c_DOMText::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
Variant &c_DOMText::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
void c_DOMText::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
void c_DOMText::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMText
Variant * c_DOMText::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
Variant * c_DOMText::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
Variant * c_DOMText::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMText
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
Variant c_DOMText::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMText
IMPLEMENT_CLASS(DOMText)
void c_DOMText::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMText::cloneImpl() {
  c_DOMText *obj = NEW(c_DOMText)();
  cloneSet(obj);
  return obj;
}
void c_DOMText::cloneSet(c_DOMText *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
Variant c_DOMText::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss5d3c002e, "splitText")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
        return (t_splittext(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0b391f0b, "isWhitespaceInElementContent")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
        return (t_iswhitespaceinelementcontent());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMText::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMText::ci___destruct((void*)&c_DOMText::i___destruct, (void*)&c_DOMText::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMText::ci___set((void*)&c_DOMText::i___set, (void*)&c_DOMText::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMText::ci___construct((void*)&c_DOMText::i___construct, (void*)&c_DOMText::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMText::ci___get((void*)&c_DOMText::i___get, (void*)&c_DOMText::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMText::ci_iswhitespaceinelementcontent((void*)&c_DOMText::i_iswhitespaceinelementcontent, (void*)&c_DOMText::ifa_iswhitespaceinelementcontent, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMText::ci_splittext((void*)&c_DOMText::i_splittext, (void*)&c_DOMText::ifa_splittext, 1, 4, 0x0000000000000000LL);
Variant c_DOMText::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMText::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMText::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMText::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMText::i_iswhitespaceinelementcontent(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
  return (self->t_iswhitespaceinelementcontent());
}
Variant c_DOMText::i_splittext(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_splittext(arg0));
  }
}
Variant c_DOMText::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMText::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMText::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) return (self->t___construct(), null);
  return (self->t___construct(a0), null);
}
Variant c_DOMText::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMText::ifa_iswhitespaceinelementcontent(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("iswhitespaceinelementcontent", 0, 1);
  return (self->t_iswhitespaceinelementcontent());
}
Variant c_DOMText::ifa_splittext(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMText *self = NULL;
  p_DOMText pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMText*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("splittext", count, 1, 1, 1);
  return (self->t_splittext(a0));
}
bool c_DOMText::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMText::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMText::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x714D38308D8212B7LL, NAMSTR(s_sys_ss5d3c002e, "splitText")) {
        mcp.ci = &c_DOMText::ci_splittext;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x28FBAB4F0F6C02DDLL, NAMSTR(s_sys_ss0b391f0b, "isWhitespaceInElementContent")) {
        mcp.ci = &c_DOMText::ci_iswhitespaceinelementcontent;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMText::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMText::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::os_get_call_info(mcp, hash);
}
bool c_DOMText::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMText *c_DOMText::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMText::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMText::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMText::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMText::ci___construct;
  mcp.obj = this;
}
void c_DOMText::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMText = {
  c_DOMText::os_getInit,
  c_DOMText::os_get,
  c_DOMText::os_lval,
  c_DOMText::os_invoke,
  c_DOMText::os_constant,
  c_DOMText::os_get_call_info
};
Object co_DebuggerClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerClient)())->dynCreate(params, init));
}
Object coo_DebuggerClient() {
  Object r(NEW(c_DebuggerClient)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
Variant c_DebuggerClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
Variant c_DebuggerClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
Variant &c_DebuggerClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
void c_DebuggerClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
void c_DebuggerClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
Variant * c_DebuggerClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
Variant * c_DebuggerClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
Variant * c_DebuggerClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
Variant c_DebuggerClient::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x2038737F45604DE2LL, q_DebuggerClient_AUTO_COMPLETE_VARIABLES, "AUTO_COMPLETE_VARIABLES");
      break;
    case 7:
      HASH_RETURN(0x1B352E31B034F827LL, q_DebuggerClient_AUTO_COMPLETE_FILENAMES, "AUTO_COMPLETE_FILENAMES");
      HASH_RETURN(0x0F17BB5BEC004CA7LL, q_DebuggerClient_AUTO_COMPLETE_CLASSES, "AUTO_COMPLETE_CLASSES");
      break;
    case 9:
      HASH_RETURN(0x6A811D407DC24A29LL, q_DebuggerClient_AUTO_COMPLETE_CLASS_CONSTANTS, "AUTO_COMPLETE_CLASS_CONSTANTS");
      break;
    case 11:
      HASH_RETURN(0x1858E5511222BC8BLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_PROPERTIES, "AUTO_COMPLETE_CLASS_PROPERTIES");
      HASH_RETURN(0x1DE12226E1E87B6BLL, q_DebuggerClient_AUTO_COMPLETE_CODE, "AUTO_COMPLETE_CODE");
      break;
    case 15:
      HASH_RETURN(0x2C29DCF63AAC70EFLL, q_DebuggerClient_AUTO_COMPLETE_CLASS_METHODS, "AUTO_COMPLETE_CLASS_METHODS");
      HASH_RETURN(0x76A6B174D3E2108FLL, q_DebuggerClient_AUTO_COMPLETE_KEYWORDS, "AUTO_COMPLETE_KEYWORDS");
      break;
    case 19:
      HASH_RETURN(0x78221A7B002235D3LL, q_DebuggerClient_AUTO_COMPLETE_CONSTANTS, "AUTO_COMPLETE_CONSTANTS");
      break;
    case 31:
      HASH_RETURN(0x7CAE318E6EF6449FLL, q_DebuggerClient_AUTO_COMPLETE_FUNCTIONS, "AUTO_COMPLETE_FUNCTIONS");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerClient
IMPLEMENT_CLASS(DebuggerClient)
void c_DebuggerClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerClient::cloneImpl() {
  c_DebuggerClient *obj = NEW(c_DebuggerClient)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerClient::cloneSet(c_DebuggerClient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DebuggerClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss38d893f5, "addCompletion")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
        return (t_addcompletion(a0), null);
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss0ddf3c34, "ask")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("ask", count+1, 1);
        if (count <= 1) return (t_ask(count, a0));
        return (t_ask(count, a0,vargs));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss143f106a, "getFrame")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
        return (t_getframe());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss0ab49528, "printFrame")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
        return (t_printframe(a0), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss06898e62, "args")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("args", 0, 1);
        return (t_args());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss6c5c70db, "getCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
        return (t_getcode());
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss6aa5ef61, "helpBody")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
        return (t_helpbody(a0), null);
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss1fae0dcb, "helpCmds")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
        if (count <= 2) return (t_helpcmds(count, a0, a1), null);
        return (t_helpcmds(count, a0, a1,vargs), null);
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss3731975a, "print")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("print", count+1, 1);
        if (count <= 1) return (t_print(count, a0), null);
        return (t_print(count, a0,vargs), null);
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss45e71386, "getCommand")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
        return (t_getcommand());
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss514ac10d, "argRest")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
        return (t_argrest(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss61aea759, "error")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("error", count+1, 1);
        if (count <= 1) return (t_error(count, a0), null);
        return (t_error(count, a0,vargs), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss33988b3e, "info")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("info", count+1, 1);
        if (count <= 1) return (t_info(count, a0), null);
        return (t_info(count, a0,vargs), null);
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss4fa2c4dd, "helpTitle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
        return (t_helptitle(a0), null);
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss4723e39a, "getCurrentLocation")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
        return (t_getcurrentlocation());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss72d6b4ff, "argValue")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
        return (t_argvalue(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss082575cd, "tutorial")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
        return (t_tutorial(a0), null);
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss5916f77a, "argCount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
        return (t_argcount());
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss29d06307, "helpSection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
        return (t_helpsection(a0), null);
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss651e56d8, "arg")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
        return (t_arg(a0, a1));
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss425530dc, "help")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("help", count+1, 1);
        if (count <= 1) return (t_help(count, a0), null);
        return (t_help(count, a0,vargs), null);
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss5d87bdfd, "xend")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
        return (t_xend(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss79892305, "getStackTrace")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
        return (t_getstacktrace());
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss0c730b8d, "wrap")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
        return (t_wrap(a0));
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss5485e214, "code")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
        if (count <= 1) return (t_code(a0), null);
        else if (count == 2) return (t_code(a0, a1), null);
        else if (count == 3) return (t_code(a0, a1, a2), null);
        else return (t_code(a0, a1, a2, a3), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss7e545a5a, "quit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("quit", 0, 1);
        return (t_quit(), null);
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss7a5dbb24, "output")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("output", count+1, 1);
        if (count <= 1) return (t_output(count, a0), null);
        return (t_output(count, a0,vargs), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DebuggerClient::ci_argcount((void*)&c_DebuggerClient::i_argcount, (void*)&c_DebuggerClient::ifa_argcount, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_arg((void*)&c_DebuggerClient::i_arg, (void*)&c_DebuggerClient::ifa_arg, 2, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpcmds((void*)&c_DebuggerClient::i_helpcmds, (void*)&c_DebuggerClient::ifa_helpcmds, 2, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_ask((void*)&c_DebuggerClient::i_ask, (void*)&c_DebuggerClient::ifa_ask, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_error((void*)&c_DebuggerClient::i_error, (void*)&c_DebuggerClient::ifa_error, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_xend((void*)&c_DebuggerClient::i_xend, (void*)&c_DebuggerClient::ifa_xend, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci___destruct((void*)&c_DebuggerClient::i___destruct, (void*)&c_DebuggerClient::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helptitle((void*)&c_DebuggerClient::i_helptitle, (void*)&c_DebuggerClient::ifa_helptitle, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcommand((void*)&c_DebuggerClient::i_getcommand, (void*)&c_DebuggerClient::ifa_getcommand, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_tutorial((void*)&c_DebuggerClient::i_tutorial, (void*)&c_DebuggerClient::ifa_tutorial, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci___construct((void*)&c_DebuggerClient::i___construct, (void*)&c_DebuggerClient::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcode((void*)&c_DebuggerClient::i_getcode, (void*)&c_DebuggerClient::ifa_getcode, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_argvalue((void*)&c_DebuggerClient::i_argvalue, (void*)&c_DebuggerClient::ifa_argvalue, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_output((void*)&c_DebuggerClient::i_output, (void*)&c_DebuggerClient::ifa_output, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getstacktrace((void*)&c_DebuggerClient::i_getstacktrace, (void*)&c_DebuggerClient::ifa_getstacktrace, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_info((void*)&c_DebuggerClient::i_info, (void*)&c_DebuggerClient::ifa_info, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_printframe((void*)&c_DebuggerClient::i_printframe, (void*)&c_DebuggerClient::ifa_printframe, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_print((void*)&c_DebuggerClient::i_print, (void*)&c_DebuggerClient::ifa_print, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_code((void*)&c_DebuggerClient::i_code, (void*)&c_DebuggerClient::ifa_code, 4, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpsection((void*)&c_DebuggerClient::i_helpsection, (void*)&c_DebuggerClient::ifa_helpsection, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_quit((void*)&c_DebuggerClient::i_quit, (void*)&c_DebuggerClient::ifa_quit, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_helpbody((void*)&c_DebuggerClient::i_helpbody, (void*)&c_DebuggerClient::ifa_helpbody, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getframe((void*)&c_DebuggerClient::i_getframe, (void*)&c_DebuggerClient::ifa_getframe, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_help((void*)&c_DebuggerClient::i_help, (void*)&c_DebuggerClient::ifa_help, 1, 5, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_args((void*)&c_DebuggerClient::i_args, (void*)&c_DebuggerClient::ifa_args, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_addcompletion((void*)&c_DebuggerClient::i_addcompletion, (void*)&c_DebuggerClient::ifa_addcompletion, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_argrest((void*)&c_DebuggerClient::i_argrest, (void*)&c_DebuggerClient::ifa_argrest, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_getcurrentlocation((void*)&c_DebuggerClient::i_getcurrentlocation, (void*)&c_DebuggerClient::ifa_getcurrentlocation, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_send((void*)&c_DebuggerClient::i_send, (void*)&c_DebuggerClient::ifa_send, 1, 4, 0x0000000000000000LL);
CallInfo c_DebuggerClient::ci_wrap((void*)&c_DebuggerClient::i_wrap, (void*)&c_DebuggerClient::ifa_wrap, 1, 4, 0x0000000000000000LL);
Variant c_DebuggerClient::i_argcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
  return (self->t_argcount());
}
Variant c_DebuggerClient::i_arg(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_arg(arg0, arg1));
  }
}
Variant c_DebuggerClient::i_helpcmds(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_helpcmds(count, arg0, arg1), null);
    return (self->t_helpcmds(count,arg0, arg1, params.slice(2, count - 2, false)), null);
  }
}
Variant c_DebuggerClient::i_ask(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("ask", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_ask(count, arg0));
    return (self->t_ask(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant c_DebuggerClient::i_error(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("error", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_error(count, arg0), null);
    return (self->t_error(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_xend(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xend(arg0));
  }
}
Variant c_DebuggerClient::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerClient::i_helptitle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helptitle(arg0), null);
  }
}
Variant c_DebuggerClient::i_getcommand(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
  return (self->t_getcommand());
}
Variant c_DebuggerClient::i_tutorial(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_tutorial(arg0), null);
  }
}
Variant c_DebuggerClient::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerClient::i_getcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
  return (self->t_getcode());
}
Variant c_DebuggerClient::i_argvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_argvalue(arg0));
  }
}
Variant c_DebuggerClient::i_output(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("output", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_output(count, arg0), null);
    return (self->t_output(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_getstacktrace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
  return (self->t_getstacktrace());
}
Variant c_DebuggerClient::i_info(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("info", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_info(count, arg0), null);
    return (self->t_info(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_printframe(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_printframe(arg0), null);
  }
}
Variant c_DebuggerClient::i_print(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("print", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_print(count, arg0), null);
    return (self->t_print(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_code(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_code(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_code(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_code(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_code(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_DebuggerClient::i_helpsection(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helpsection(arg0), null);
  }
}
Variant c_DebuggerClient::i_quit(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("quit", 0, 1);
  return (self->t_quit(), null);
}
Variant c_DebuggerClient::i_helpbody(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_helpbody(arg0), null);
  }
}
Variant c_DebuggerClient::i_getframe(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
  return (self->t_getframe());
}
Variant c_DebuggerClient::i_help(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("help", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_help(count, arg0), null);
    return (self->t_help(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_DebuggerClient::i_args(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("args", 0, 1);
  return (self->t_args());
}
Variant c_DebuggerClient::i_addcompletion(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addcompletion(arg0), null);
  }
}
Variant c_DebuggerClient::i_argrest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_argrest(arg0));
  }
}
Variant c_DebuggerClient::i_getcurrentlocation(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
  return (self->t_getcurrentlocation());
}
Variant c_DebuggerClient::i_send(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_send(arg0));
  }
}
Variant c_DebuggerClient::i_wrap(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_wrap(arg0));
  }
}
Variant c_DebuggerClient::ifa_argcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("argcount", 0, 1);
  return (self->t_argcount());
}
Variant c_DebuggerClient::ifa_arg(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("arg", count, 2, 2, 1);
  return (self->t_arg(a0, a1));
}
Variant c_DebuggerClient::ifa_helpcmds(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2) return throw_missing_arguments("helpcmds", count+1, 1);
  if (count <= 2) return (self->t_helpcmds(count, a0, a1), null);
  Array params;
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_helpcmds(count,a0, a1, params), null);
}
Variant c_DebuggerClient::ifa_ask(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("ask", count+1, 1);
  if (count <= 1) return (self->t_ask(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_ask(count,a0, params));
}
Variant c_DebuggerClient::ifa_error(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("error", count+1, 1);
  if (count <= 1) return (self->t_error(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_error(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_xend(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xend", count, 1, 1, 1);
  return (self->t_xend(a0));
}
Variant c_DebuggerClient::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerClient::ifa_helptitle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helptitle", count, 1, 1, 1);
  return (self->t_helptitle(a0), null);
}
Variant c_DebuggerClient::ifa_getcommand(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcommand", 0, 1);
  return (self->t_getcommand());
}
Variant c_DebuggerClient::ifa_tutorial(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("tutorial", count, 1, 1, 1);
  return (self->t_tutorial(a0), null);
}
Variant c_DebuggerClient::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerClient::ifa_getcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcode", 0, 1);
  return (self->t_getcode());
}
Variant c_DebuggerClient::ifa_argvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argvalue", count, 1, 1, 1);
  return (self->t_argvalue(a0));
}
Variant c_DebuggerClient::ifa_output(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("output", count+1, 1);
  if (count <= 1) return (self->t_output(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_output(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_getstacktrace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstacktrace", 0, 1);
  return (self->t_getstacktrace());
}
Variant c_DebuggerClient::ifa_info(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("info", count+1, 1);
  if (count <= 1) return (self->t_info(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_info(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_printframe(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("printframe", count, 1, 1, 1);
  return (self->t_printframe(a0), null);
}
Variant c_DebuggerClient::ifa_print(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("print", count+1, 1);
  if (count <= 1) return (self->t_print(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_print(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_code(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("code", count, 1, 4, 1);
  if (count <= 1) return (self->t_code(a0), null);
  if (count == 2) return (self->t_code(a0, a1), null);
  if (count == 3) return (self->t_code(a0, a1, a2), null);
  return (self->t_code(a0, a1, a2, a3), null);
}
Variant c_DebuggerClient::ifa_helpsection(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpsection", count, 1, 1, 1);
  return (self->t_helpsection(a0), null);
}
Variant c_DebuggerClient::ifa_quit(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("quit", 0, 1);
  return (self->t_quit(), null);
}
Variant c_DebuggerClient::ifa_helpbody(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("helpbody", count, 1, 1, 1);
  return (self->t_helpbody(a0), null);
}
Variant c_DebuggerClient::ifa_getframe(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getframe", 0, 1);
  return (self->t_getframe());
}
Variant c_DebuggerClient::ifa_help(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("help", count+1, 1);
  if (count <= 1) return (self->t_help(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_help(count,a0, params), null);
}
Variant c_DebuggerClient::ifa_args(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("args", 0, 1);
  return (self->t_args());
}
Variant c_DebuggerClient::ifa_addcompletion(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addcompletion", count, 1, 1, 1);
  return (self->t_addcompletion(a0), null);
}
Variant c_DebuggerClient::ifa_argrest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("argrest", count, 1, 1, 1);
  return (self->t_argrest(a0));
}
Variant c_DebuggerClient::ifa_getcurrentlocation(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getcurrentlocation", 0, 1);
  return (self->t_getcurrentlocation());
}
Variant c_DebuggerClient::ifa_send(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  return (self->t_send(a0));
}
Variant c_DebuggerClient::ifa_wrap(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerClient *self = NULL;
  p_DebuggerClient pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("wrap", count, 1, 1, 1);
  return (self->t_wrap(a0));
}
bool c_DebuggerClient::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x07768FF90B181780LL, NAMSTR(s_sys_ss38d893f5, "addCompletion")) {
        mcp.ci = &c_DebuggerClient::ci_addcompletion;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x20F2EA2BBFF5AA42LL, NAMSTR(s_sys_ss0ddf3c34, "ask")) {
        mcp.ci = &c_DebuggerClient::ci_ask;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x0E836DA3377C4984LL, NAMSTR(s_sys_ss143f106a, "getFrame")) {
        mcp.ci = &c_DebuggerClient::ci_getframe;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x1D033DFD1DCAEA85LL, NAMSTR(s_sys_ss0ab49528, "printFrame")) {
        mcp.ci = &c_DebuggerClient::ci_printframe;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        mcp.ci = &c_DebuggerClient::ci_send;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7A24AFD8ADE43B8ELL, NAMSTR(s_sys_ss06898e62, "args")) {
        mcp.ci = &c_DebuggerClient::ci_args;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x5C108B351DC3D04FLL, NAMSTR(s_sys_ss6c5c70db, "getCode")) {
        mcp.ci = &c_DebuggerClient::ci_getcode;
        return true;
      }
      HASH_GUARD_LITSTR(0x6B3BF595A55159CFLL, NAMSTR(s_sys_ss6aa5ef61, "helpBody")) {
        mcp.ci = &c_DebuggerClient::ci_helpbody;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x687DF38195F5B951LL, NAMSTR(s_sys_ss1fae0dcb, "helpCmds")) {
        mcp.ci = &c_DebuggerClient::ci_helpcmds;
        return true;
      }
      HASH_GUARD_LITSTR(0x1015EB3F52B098D1LL, NAMSTR(s_sys_ss3731975a, "print")) {
        mcp.ci = &c_DebuggerClient::ci_print;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x182AC39D2C493A97LL, NAMSTR(s_sys_ss45e71386, "getCommand")) {
        mcp.ci = &c_DebuggerClient::ci_getcommand;
        return true;
      }
      HASH_GUARD_LITSTR(0x67A7ABCB74D168D7LL, NAMSTR(s_sys_ss514ac10d, "argRest")) {
        mcp.ci = &c_DebuggerClient::ci_argrest;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x016509DCA13DB6DFLL, NAMSTR(s_sys_ss61aea759, "error")) {
        mcp.ci = &c_DebuggerClient::ci_error;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DebuggerClient::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0F2EF58F157D479FLL, NAMSTR(s_sys_ss33988b3e, "info")) {
        mcp.ci = &c_DebuggerClient::ci_info;
        return true;
      }
      break;
    case 35:
      HASH_GUARD_LITSTR(0x5F8B4ACA3731C423LL, NAMSTR(s_sys_ss4fa2c4dd, "helpTitle")) {
        mcp.ci = &c_DebuggerClient::ci_helptitle;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x2191643700554726LL, NAMSTR(s_sys_ss4723e39a, "getCurrentLocation")) {
        mcp.ci = &c_DebuggerClient::ci_getcurrentlocation;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x620C55BAC770E928LL, NAMSTR(s_sys_ss72d6b4ff, "argValue")) {
        mcp.ci = &c_DebuggerClient::ci_argvalue;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6CB0A07E0516B6ACLL, NAMSTR(s_sys_ss082575cd, "tutorial")) {
        mcp.ci = &c_DebuggerClient::ci_tutorial;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x5412C8462A696DEFLL, NAMSTR(s_sys_ss5916f77a, "argCount")) {
        mcp.ci = &c_DebuggerClient::ci_argcount;
        return true;
      }
      HASH_GUARD_LITSTR(0x5CE665973E2B4C6FLL, NAMSTR(s_sys_ss29d06307, "helpSection")) {
        mcp.ci = &c_DebuggerClient::ci_helpsection;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DebuggerClient::ci___destruct;
        return true;
      }
      break;
    case 52:
      HASH_GUARD_LITSTR(0x64C0B4BCDA99F6F4LL, NAMSTR(s_sys_ss651e56d8, "arg")) {
        mcp.ci = &c_DebuggerClient::ci_arg;
        return true;
      }
      HASH_GUARD_LITSTR(0x665AFB5CDFD23534LL, NAMSTR(s_sys_ss425530dc, "help")) {
        mcp.ci = &c_DebuggerClient::ci_help;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x04A108469024B7B6LL, NAMSTR(s_sys_ss5d87bdfd, "xend")) {
        mcp.ci = &c_DebuggerClient::ci_xend;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x7C41EEC813FC6FB7LL, NAMSTR(s_sys_ss79892305, "getStackTrace")) {
        mcp.ci = &c_DebuggerClient::ci_getstacktrace;
        return true;
      }
      HASH_GUARD_LITSTR(0x6C5E35754AA2B277LL, NAMSTR(s_sys_ss0c730b8d, "wrap")) {
        mcp.ci = &c_DebuggerClient::ci_wrap;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x58C72230857ACDB9LL, NAMSTR(s_sys_ss5485e214, "code")) {
        mcp.ci = &c_DebuggerClient::ci_code;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0732FA520631017ALL, NAMSTR(s_sys_ss7e545a5a, "quit")) {
        mcp.ci = &c_DebuggerClient::ci_quit;
        return true;
      }
      break;
    case 63:
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss7a5dbb24, "output")) {
        mcp.ci = &c_DebuggerClient::ci_output;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DebuggerClient::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DebuggerClient *c_DebuggerClient::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerClient::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DebuggerClient::ci___construct;
  mcp.obj = this;
}
void c_DebuggerClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DebuggerClient = {
  c_DebuggerClient::os_getInit,
  c_DebuggerClient::os_get,
  c_DebuggerClient::os_lval,
  c_DebuggerClient::os_invoke,
  c_DebuggerClient::os_constant,
  c_DebuggerClient::os_get_call_info
};
Object co_DOMCDATASection(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCDATASection)())->dynCreate(params, init));
}
Object coo_DOMCDATASection() {
  Object r(NEW(c_DOMCDATASection)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
Variant c_DOMCDATASection::os_getInit(CStrRef s) {
  return c_DOMText::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
Variant c_DOMCDATASection::os_get(CStrRef s) {
  return c_DOMText::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
Variant &c_DOMCDATASection::os_lval(CStrRef s) {
  return c_DOMText::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
void c_DOMCDATASection::o_getArray(Array &props) const {
  c_DOMText::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
void c_DOMCDATASection::o_setArray(CArrRef props) {
  c_DOMText::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
Variant * c_DOMCDATASection::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMText::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
Variant * c_DOMCDATASection::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCDATASection
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
Variant c_DOMCDATASection::os_constant(const char *s) {
  return c_DOMText::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCDATASection
IMPLEMENT_CLASS(DOMCDATASection)
void c_DOMCDATASection::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCDATASection::cloneImpl() {
  c_DOMCDATASection *obj = NEW(c_DOMCDATASection)();
  cloneSet(obj);
  return obj;
}
void c_DOMCDATASection::cloneSet(c_DOMCDATASection *clone) {
  c_DOMText::cloneSet(clone);
}
Variant c_DOMCDATASection::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMText::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCDATASection::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMText::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMCDATASection::ci___destruct((void*)&c_DOMCDATASection::i___destruct, (void*)&c_DOMCDATASection::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMCDATASection::ci___construct((void*)&c_DOMCDATASection::i___construct, (void*)&c_DOMCDATASection::ifa___construct, 1, 4, 0x0000000000000000LL);
Variant c_DOMCDATASection::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCDATASection::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMCDATASection::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCDATASection::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCDATASection *self = NULL;
  p_DOMCDATASection pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCDATASection*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
bool c_DOMCDATASection::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMCDATASection::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMCDATASection::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMText::os_get_call_info(mcp, hash);
}
bool c_DOMCDATASection::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMCDATASection *c_DOMCDATASection::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMCDATASection::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMCDATASection::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMCDATASection::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMCDATASection::ci___construct;
  mcp.obj = this;
}
void c_DOMCDATASection::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMCDATASection = {
  c_DOMCDATASection::os_getInit,
  c_DOMCDATASection::os_get,
  c_DOMCDATASection::os_lval,
  c_DOMCDATASection::os_invoke,
  c_DOMCDATASection::os_constant,
  c_DOMCDATASection::os_get_call_info
};
Object co_Locale(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Locale)())->dynCreate(params, init));
}
Object coo_Locale() {
  Object r(NEW(c_Locale)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
Variant c_Locale::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
Variant c_Locale::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
Variant &c_Locale::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
void c_Locale::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
void c_Locale::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Locale
Variant * c_Locale::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
Variant * c_Locale::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
Variant * c_Locale::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Locale
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
Variant c_Locale::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_RETURN(0x78695696B47AF8CDLL, q_Locale_ACTUAL_LOCALE, "ACTUAL_LOCALE");
      HASH_RETURN(0x35B10383BBF3BAE1LL, q_Locale_VALID_LOCALE, "VALID_LOCALE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Locale
IMPLEMENT_CLASS(Locale)
void c_Locale::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Locale::cloneImpl() {
  c_Locale *obj = NEW(c_Locale)();
  cloneSet(obj);
  return obj;
}
void c_Locale::cloneSet(c_Locale *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Locale::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Locale::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Locale::ci___destruct((void*)&c_Locale::i___destruct, (void*)&c_Locale::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_Locale::ci___construct((void*)&c_Locale::i___construct, (void*)&c_Locale::ifa___construct, 0, 4, 0x0000000000000000LL);
Variant c_Locale::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Locale::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Locale::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Locale::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Locale *self = NULL;
  p_Locale pobj;
  if (mcp.obj) {
    self = static_cast<c_Locale*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_Locale::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_Locale::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_Locale::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Locale::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Locale *c_Locale::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Locale::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Locale::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Locale::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Locale::ci___construct;
  mcp.obj = this;
}
void c_Locale::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Locale = {
  c_Locale::os_getInit,
  c_Locale::os_get,
  c_Locale::os_lval,
  c_Locale::os_invoke,
  c_Locale::os_constant,
  c_Locale::os_get_call_info
};
Object co_DOMDocumentType(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocumentType)())->dynCreate(params, init));
}
Object coo_DOMDocumentType() {
  Object r(NEW(c_DOMDocumentType)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
Variant c_DOMDocumentType::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
Variant c_DOMDocumentType::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
Variant &c_DOMDocumentType::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
void c_DOMDocumentType::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
void c_DOMDocumentType::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
Variant * c_DOMDocumentType::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
Variant * c_DOMDocumentType::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocumentType
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
Variant c_DOMDocumentType::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocumentType
IMPLEMENT_CLASS(DOMDocumentType)
void c_DOMDocumentType::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocumentType::cloneImpl() {
  c_DOMDocumentType *obj = NEW(c_DOMDocumentType)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocumentType::cloneSet(c_DOMDocumentType *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocumentType::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocumentType::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocumentType::ci___destruct((void*)&c_DOMDocumentType::i___destruct, (void*)&c_DOMDocumentType::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___set((void*)&c_DOMDocumentType::i___set, (void*)&c_DOMDocumentType::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___construct((void*)&c_DOMDocumentType::i___construct, (void*)&c_DOMDocumentType::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocumentType::ci___get((void*)&c_DOMDocumentType::i___get, (void*)&c_DOMDocumentType::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMDocumentType::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentType::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMDocumentType::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentType::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMDocumentType::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocumentType::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMDocumentType::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMDocumentType::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocumentType *self = NULL;
  p_DOMDocumentType pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocumentType*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMDocumentType::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMDocumentType::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMDocumentType::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMDocumentType::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMDocumentType::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocumentType::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMDocumentType *c_DOMDocumentType::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMDocumentType::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMDocumentType::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMDocumentType::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocumentType::ci___construct;
  mcp.obj = this;
}
void c_DOMDocumentType::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMDocumentType = {
  c_DOMDocumentType::os_getInit,
  c_DOMDocumentType::os_get,
  c_DOMDocumentType::os_lval,
  c_DOMDocumentType::os_invoke,
  c_DOMDocumentType::os_constant,
  c_DOMDocumentType::os_get_call_info
};
Object co_SQLite3Stmt(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Stmt)())->dynCreate(params, init));
}
Object coo_SQLite3Stmt() {
  Object r(NEW(c_SQLite3Stmt)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
Variant c_SQLite3Stmt::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
Variant c_SQLite3Stmt::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
Variant &c_SQLite3Stmt::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
void c_SQLite3Stmt::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
Variant * c_SQLite3Stmt::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Stmt
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
Variant c_SQLite3Stmt::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Stmt
IMPLEMENT_CLASS(SQLite3Stmt)
void c_SQLite3Stmt::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Stmt::cloneImpl() {
  c_SQLite3Stmt *obj = NEW(c_SQLite3Stmt)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Stmt::cloneSet(c_SQLite3Stmt *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3Stmt::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss5c8999e5, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss0e2f6a78, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss7d4c47c4, "clear")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("clear", 0, 1);
        return (t_clear());
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss5ac66c5d, "execute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("execute", 0, 1);
        return (t_execute());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1b64dec9, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else return (t_bindparam(a0, ref(a1), a2));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss727dc9b8, "paramcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
        return (t_paramcount());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Stmt::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3Stmt::ci___destruct((void*)&c_SQLite3Stmt::i___destruct, (void*)&c_SQLite3Stmt::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci___construct((void*)&c_SQLite3Stmt::i___construct, (void*)&c_SQLite3Stmt::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_close((void*)&c_SQLite3Stmt::i_close, (void*)&c_SQLite3Stmt::ifa_close, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_paramcount((void*)&c_SQLite3Stmt::i_paramcount, (void*)&c_SQLite3Stmt::ifa_paramcount, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_bindparam((void*)&c_SQLite3Stmt::i_bindparam, (void*)&c_SQLite3Stmt::ifa_bindparam, 3, 4, 0x0000000000000002LL);
CallInfo c_SQLite3Stmt::ci_execute((void*)&c_SQLite3Stmt::i_execute, (void*)&c_SQLite3Stmt::ifa_execute, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_reset((void*)&c_SQLite3Stmt::i_reset, (void*)&c_SQLite3Stmt::ifa_reset, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_clear((void*)&c_SQLite3Stmt::i_clear, (void*)&c_SQLite3Stmt::ifa_clear, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Stmt::ci_bindvalue((void*)&c_SQLite3Stmt::i_bindvalue, (void*)&c_SQLite3Stmt::ifa_bindvalue, 3, 4, 0x0000000000000000LL);
Variant c_SQLite3Stmt::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Stmt::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SQLite3Stmt::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3Stmt::i_paramcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
  return (self->t_paramcount());
}
Variant c_SQLite3Stmt::i_bindparam(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindparam(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindparam(arg0, arg1, arg2));
  }
}
Variant c_SQLite3Stmt::i_execute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("execute", 0, 1);
  return (self->t_execute());
}
Variant c_SQLite3Stmt::i_reset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Stmt::i_clear(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("clear", 0, 1);
  return (self->t_clear());
}
Variant c_SQLite3Stmt::i_bindvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindvalue(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindvalue(arg0, arg1, arg2));
  }
}
Variant c_SQLite3Stmt::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Stmt::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  return (self->t___construct(a0, a1), null);
}
Variant c_SQLite3Stmt::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3Stmt::ifa_paramcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("paramcount", 0, 1);
  return (self->t_paramcount());
}
Variant c_SQLite3Stmt::ifa_bindparam(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindparam", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindparam(a0, ref(a1)));
  return (self->t_bindparam(a0, ref(a1), a2));
}
Variant c_SQLite3Stmt::ifa_execute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("execute", 0, 1);
  return (self->t_execute());
}
Variant c_SQLite3Stmt::ifa_reset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Stmt::ifa_clear(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("clear", 0, 1);
  return (self->t_clear());
}
Variant c_SQLite3Stmt::ifa_bindvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Stmt *self = NULL;
  p_SQLite3Stmt pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Stmt*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindvalue(a0, a1));
  return (self->t_bindvalue(a0, a1, a2));
}
bool c_SQLite3Stmt::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss5c8999e5, "reset")) {
        mcp.ci = &c_SQLite3Stmt::ci_reset;
        return true;
      }
      break;
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        mcp.ci = &c_SQLite3Stmt::ci_close;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss0e2f6a78, "bindvalue")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindvalue;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss7d4c47c4, "clear")) {
        mcp.ci = &c_SQLite3Stmt::ci_clear;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss5ac66c5d, "execute")) {
        mcp.ci = &c_SQLite3Stmt::ci_execute;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SQLite3Stmt::ci___destruct;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1b64dec9, "bindparam")) {
        mcp.ci = &c_SQLite3Stmt::ci_bindparam;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x72FA987001E93357LL, NAMSTR(s_sys_ss727dc9b8, "paramcount")) {
        mcp.ci = &c_SQLite3Stmt::ci_paramcount;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SQLite3Stmt::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3Stmt::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SQLite3Stmt *c_SQLite3Stmt::create(Object a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SQLite3Stmt::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SQLite3Stmt::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SQLite3Stmt::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3Stmt::ci___construct;
  mcp.obj = this;
}
void c_SQLite3Stmt::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SQLite3Stmt = {
  c_SQLite3Stmt::os_getInit,
  c_SQLite3Stmt::os_get,
  c_SQLite3Stmt::os_lval,
  c_SQLite3Stmt::os_invoke,
  c_SQLite3Stmt::os_constant,
  c_SQLite3Stmt::os_get_call_info
};
Object co_DOMNodeList(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeList)())->dynCreate(params, init));
}
Object coo_DOMNodeList() {
  Object r(NEW(c_DOMNodeList)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
Variant c_DOMNodeList::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
Variant c_DOMNodeList::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
Variant &c_DOMNodeList::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
void c_DOMNodeList::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
void c_DOMNodeList::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
Variant * c_DOMNodeList::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
Variant * c_DOMNodeList::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
Variant * c_DOMNodeList::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeList
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
Variant c_DOMNodeList::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeList
IMPLEMENT_CLASS(DOMNodeList)
void c_DOMNodeList::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeList::cloneImpl() {
  c_DOMNodeList *obj = NEW(c_DOMNodeList)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeList::cloneSet(c_DOMNodeList *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNodeList::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss1247a693, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeList::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNodeList::ci_item((void*)&c_DOMNodeList::i_item, (void*)&c_DOMNodeList::ifa_item, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___destruct((void*)&c_DOMNodeList::i___destruct, (void*)&c_DOMNodeList::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___set((void*)&c_DOMNodeList::i___set, (void*)&c_DOMNodeList::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___construct((void*)&c_DOMNodeList::i___construct, (void*)&c_DOMNodeList::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci_getiterator((void*)&c_DOMNodeList::i_getiterator, (void*)&c_DOMNodeList::ifa_getiterator, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeList::ci___get((void*)&c_DOMNodeList::i___get, (void*)&c_DOMNodeList::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMNodeList::i_item(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_item(arg0));
  }
}
Variant c_DOMNodeList::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeList::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNodeList::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeList::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNodeList::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNodeList::ifa_item(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  return (self->t_item(a0));
}
Variant c_DOMNodeList::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeList::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNodeList::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeList::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNodeList::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeList *self = NULL;
  p_DOMNodeList pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeList*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMNodeList::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMNodeList::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        mcp.ci = &c_DOMNodeList::ci_getiterator;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMNodeList::ci___set;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss1247a693, "item")) {
        mcp.ci = &c_DOMNodeList::ci_item;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMNodeList::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMNodeList::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNodeList::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMNodeList *c_DOMNodeList::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeList::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeList::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeList::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNodeList::ci___construct;
  mcp.obj = this;
}
void c_DOMNodeList::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNodeList = {
  c_DOMNodeList::os_getInit,
  c_DOMNodeList::os_get,
  c_DOMNodeList::os_lval,
  c_DOMNodeList::os_invoke,
  c_DOMNodeList::os_constant,
  c_DOMNodeList::os_get_call_info
};
Object co_Normalizer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Normalizer)())->dynCreate(params, init));
}
Object coo_Normalizer() {
  Object r(NEW(c_Normalizer)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
Variant c_Normalizer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
Variant c_Normalizer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
Variant &c_Normalizer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
void c_Normalizer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
void c_Normalizer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
Variant * c_Normalizer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
Variant * c_Normalizer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
Variant * c_Normalizer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Normalizer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
Variant c_Normalizer::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 1:
      HASH_RETURN(0x2C9DA0E379A28381LL, q_Normalizer_FORM_KD, "FORM_KD");
      HASH_RETURN(0x1C369D0E14B76C41LL, q_Normalizer_FORM_KC, "FORM_KC");
      HASH_RETURN(0x3E3AA0A97BD09921LL, q_Normalizer_NFKC, "NFKC");
      break;
    case 2:
      HASH_RETURN(0x07512AA38ADD1AE2LL, q_Normalizer_FORM_D, "FORM_D");
      break;
    case 6:
      HASH_RETURN(0x51422F059BEFCD86LL, q_Normalizer_NFC, "NFC");
      break;
    case 15:
      HASH_RETURN(0x58B301790FA834EFLL, q_Normalizer_NFD, "NFD");
      HASH_RETURN(0x3CF19F2D23C185CFLL, q_Normalizer_NFKD, "NFKD");
      break;
    case 19:
      HASH_RETURN(0x2EFDCA1922BFB273LL, q_Normalizer_NONE, "NONE");
      break;
    case 31:
      HASH_RETURN(0x3BE3511FDA9A9E7FLL, q_Normalizer_FORM_C, "FORM_C");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Normalizer
IMPLEMENT_CLASS(Normalizer)
void c_Normalizer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Normalizer::cloneImpl() {
  c_Normalizer *obj = NEW(c_Normalizer)();
  cloneSet(obj);
  return obj;
}
void c_Normalizer::cloneSet(c_Normalizer *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Normalizer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss679e8b98, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(o_getClassName(), a0));
        else return (ti_normalize(o_getClassName(), a0, a1));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss34cb01dd, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(o_getClassName(), a0));
        else return (ti_isnormalized(o_getClassName(), a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Normalizer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 1:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss34cb01dd, "isnormalized")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
        if (count <= 1) return (ti_isnormalized(c, a0));
        else return (ti_isnormalized(c, a0, a1));
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss679e8b98, "normalize")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
        if (count <= 1) return (ti_normalize(c, a0));
        else return (ti_normalize(c, a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Normalizer::ci___destruct((void*)&c_Normalizer::i___destruct, (void*)&c_Normalizer::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_Normalizer::ci___construct((void*)&c_Normalizer::i___construct, (void*)&c_Normalizer::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_Normalizer::ci_normalize((void*)&c_Normalizer::i_normalize, (void*)&c_Normalizer::ifa_normalize, 2, 12, 0x0000000000000000LL);
CallInfo c_Normalizer::ci_isnormalized((void*)&c_Normalizer::i_isnormalized, (void*)&c_Normalizer::ifa_isnormalized, 2, 12, 0x0000000000000000LL);
Variant c_Normalizer::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Normalizer::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Normalizer::i_normalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (c_Normalizer::ti_normalize(c, arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (c_Normalizer::ti_normalize(c, arg0, arg1));
  }
}
Variant c_Normalizer::i_isnormalized(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (c_Normalizer::ti_isnormalized(c, arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (c_Normalizer::ti_isnormalized(c, arg0, arg1));
  }
}
Variant c_Normalizer::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Normalizer::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Normalizer *self = NULL;
  p_Normalizer pobj;
  if (mcp.obj) {
    self = static_cast<c_Normalizer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Normalizer::ifa_normalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count < 1 || count > 2) return throw_wrong_arguments("normalize", count, 1, 2, 1);
  if (count <= 1) return (c_Normalizer::ti_normalize(c, a0));
  return (c_Normalizer::ti_normalize(c, a0, a1));
}
Variant c_Normalizer::ifa_isnormalized(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count < 1 || count > 2) return throw_wrong_arguments("isnormalized", count, 1, 2, 1);
  if (count <= 1) return (c_Normalizer::ti_isnormalized(c, a0));
  return (c_Normalizer::ti_isnormalized(c, a0, a1));
}
bool c_Normalizer::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 2:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss679e8b98, "normalize")) {
        mcp.ci = &c_Normalizer::ci_normalize;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_Normalizer::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x58CF37E15F66ED1DLL, NAMSTR(s_sys_ss34cb01dd, "isnormalized")) {
        mcp.ci = &c_Normalizer::ci_isnormalized;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_Normalizer::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Normalizer::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Normalizer *c_Normalizer::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Normalizer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Normalizer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Normalizer::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Normalizer::ci___construct;
  mcp.obj = this;
}
void c_Normalizer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Normalizer = {
  c_Normalizer::os_getInit,
  c_Normalizer::os_get,
  c_Normalizer::os_lval,
  c_Normalizer::os_invoke,
  c_Normalizer::os_constant,
  c_Normalizer::os_get_call_info
};
Object co_DOMCharacterData(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMCharacterData)())->dynCreate(params, init));
}
Object coo_DOMCharacterData() {
  Object r(NEW(c_DOMCharacterData)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
Variant c_DOMCharacterData::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
Variant c_DOMCharacterData::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
Variant &c_DOMCharacterData::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
void c_DOMCharacterData::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
void c_DOMCharacterData::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
Variant * c_DOMCharacterData::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
Variant * c_DOMCharacterData::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMCharacterData
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
Variant c_DOMCharacterData::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMCharacterData
IMPLEMENT_CLASS(DOMCharacterData)
void c_DOMCharacterData::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMCharacterData::cloneImpl() {
  c_DOMCharacterData *obj = NEW(c_DOMCharacterData)();
  cloneSet(obj);
  return obj;
}
void c_DOMCharacterData::cloneSet(c_DOMCharacterData *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMCharacterData::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 13:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss3efc66d1, "appendData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
        return (t_appenddata(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss05c2645c, "substringData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
        return (t_substringdata(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss2107c673, "replaceData")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
        return (t_replacedata(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss01c141eb, "deleteData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
        return (t_deletedata(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss21f66b11, "insertData")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
        return (t_insertdata(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMCharacterData::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMCharacterData::ci___destruct((void*)&c_DOMCharacterData::i___destruct, (void*)&c_DOMCharacterData::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_substringdata((void*)&c_DOMCharacterData::i_substringdata, (void*)&c_DOMCharacterData::ifa_substringdata, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___set((void*)&c_DOMCharacterData::i___set, (void*)&c_DOMCharacterData::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_insertdata((void*)&c_DOMCharacterData::i_insertdata, (void*)&c_DOMCharacterData::ifa_insertdata, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___construct((void*)&c_DOMCharacterData::i___construct, (void*)&c_DOMCharacterData::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_appenddata((void*)&c_DOMCharacterData::i_appenddata, (void*)&c_DOMCharacterData::ifa_appenddata, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci___get((void*)&c_DOMCharacterData::i___get, (void*)&c_DOMCharacterData::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_replacedata((void*)&c_DOMCharacterData::i_replacedata, (void*)&c_DOMCharacterData::ifa_replacedata, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMCharacterData::ci_deletedata((void*)&c_DOMCharacterData::i_deletedata, (void*)&c_DOMCharacterData::ifa_deletedata, 2, 4, 0x0000000000000000LL);
Variant c_DOMCharacterData::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCharacterData::i_substringdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_substringdata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i_insertdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_insertdata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMCharacterData::i_appenddata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appenddata(arg0));
  }
}
Variant c_DOMCharacterData::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMCharacterData::i_replacedata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replacedata(arg0, arg1, arg2));
  }
}
Variant c_DOMCharacterData::i_deletedata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_deletedata(arg0, arg1));
  }
}
Variant c_DOMCharacterData::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMCharacterData::ifa_substringdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("substringdata", count, 2, 2, 1);
  return (self->t_substringdata(a0, a1));
}
Variant c_DOMCharacterData::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMCharacterData::ifa_insertdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("insertdata", count, 2, 2, 1);
  return (self->t_insertdata(a0, a1));
}
Variant c_DOMCharacterData::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMCharacterData::ifa_appenddata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appenddata", count, 1, 1, 1);
  return (self->t_appenddata(a0));
}
Variant c_DOMCharacterData::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMCharacterData::ifa_replacedata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("replacedata", count, 3, 3, 1);
  return (self->t_replacedata(a0, a1, a2));
}
Variant c_DOMCharacterData::ifa_deletedata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMCharacterData *self = NULL;
  p_DOMCharacterData pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMCharacterData*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("deletedata", count, 2, 2, 1);
  return (self->t_deletedata(a0, a1));
}
bool c_DOMCharacterData::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 13:
      HASH_GUARD_LITSTR(0x3DAC04A51FD2D92DLL, NAMSTR(s_sys_ss3efc66d1, "appendData")) {
        mcp.ci = &c_DOMCharacterData::ci_appenddata;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMCharacterData::ci___get;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x2D8D2253C2149972LL, NAMSTR(s_sys_ss05c2645c, "substringData")) {
        mcp.ci = &c_DOMCharacterData::ci_substringdata;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMCharacterData::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x470F2F0EA1F3D4B4LL, NAMSTR(s_sys_ss2107c673, "replaceData")) {
        mcp.ci = &c_DOMCharacterData::ci_replacedata;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMCharacterData::ci___set;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x7543EC746714D118LL, NAMSTR(s_sys_ss01c141eb, "deleteData")) {
        mcp.ci = &c_DOMCharacterData::ci_deletedata;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x0E19CE7886BCEF3DLL, NAMSTR(s_sys_ss21f66b11, "insertData")) {
        mcp.ci = &c_DOMCharacterData::ci_insertdata;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMCharacterData::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMCharacterData::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMCharacterData *c_DOMCharacterData::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMCharacterData::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMCharacterData::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMCharacterData::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMCharacterData::ci___construct;
  mcp.obj = this;
}
void c_DOMCharacterData::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMCharacterData = {
  c_DOMCharacterData::os_getInit,
  c_DOMCharacterData::os_get,
  c_DOMCharacterData::os_lval,
  c_DOMCharacterData::os_invoke,
  c_DOMCharacterData::os_constant,
  c_DOMCharacterData::os_get_call_info
};
Object co_DOMEntityReference(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntityReference)())->dynCreate(params, init));
}
Object coo_DOMEntityReference() {
  Object r(NEW(c_DOMEntityReference)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
Variant c_DOMEntityReference::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
Variant c_DOMEntityReference::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
Variant &c_DOMEntityReference::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
void c_DOMEntityReference::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
void c_DOMEntityReference::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
Variant * c_DOMEntityReference::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
Variant * c_DOMEntityReference::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntityReference
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
Variant c_DOMEntityReference::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntityReference
IMPLEMENT_CLASS(DOMEntityReference)
void c_DOMEntityReference::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntityReference::cloneImpl() {
  c_DOMEntityReference *obj = NEW(c_DOMEntityReference)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntityReference::cloneSet(c_DOMEntityReference *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMEntityReference::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntityReference::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMEntityReference::ci___destruct((void*)&c_DOMEntityReference::i___destruct, (void*)&c_DOMEntityReference::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMEntityReference::ci___construct((void*)&c_DOMEntityReference::i___construct, (void*)&c_DOMEntityReference::ifa___construct, 1, 4, 0x0000000000000000LL);
Variant c_DOMEntityReference::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntityReference::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMEntityReference::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntityReference::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntityReference *self = NULL;
  p_DOMEntityReference pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntityReference*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
bool c_DOMEntityReference::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMEntityReference::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMEntityReference::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMEntityReference::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMEntityReference *c_DOMEntityReference::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMEntityReference::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMEntityReference::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMEntityReference::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMEntityReference::ci___construct;
  mcp.obj = this;
}
void c_DOMEntityReference::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMEntityReference = {
  c_DOMEntityReference::os_getInit,
  c_DOMEntityReference::os_get,
  c_DOMEntityReference::os_lval,
  c_DOMEntityReference::os_invoke,
  c_DOMEntityReference::os_constant,
  c_DOMEntityReference::os_get_call_info
};
Object co_SimpleXMLElementIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElementIterator)())->dynCreate(params, init));
}
Object coo_SimpleXMLElementIterator() {
  Object r(NEW(c_SimpleXMLElementIterator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
Variant &c_SimpleXMLElementIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
void c_SimpleXMLElementIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
Variant * c_SimpleXMLElementIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElementIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
Variant c_SimpleXMLElementIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElementIterator
IMPLEMENT_CLASS(SimpleXMLElementIterator)
void c_SimpleXMLElementIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElementIterator::cloneImpl() {
  c_SimpleXMLElementIterator *obj = NEW(c_SimpleXMLElementIterator)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElementIterator::cloneSet(c_SimpleXMLElementIterator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SimpleXMLElementIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElementIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SimpleXMLElementIterator::ci_next((void*)&c_SimpleXMLElementIterator::i_next, (void*)&c_SimpleXMLElementIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_key((void*)&c_SimpleXMLElementIterator::i_key, (void*)&c_SimpleXMLElementIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_valid((void*)&c_SimpleXMLElementIterator::i_valid, (void*)&c_SimpleXMLElementIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci___destruct((void*)&c_SimpleXMLElementIterator::i___destruct, (void*)&c_SimpleXMLElementIterator::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci___construct((void*)&c_SimpleXMLElementIterator::i___construct, (void*)&c_SimpleXMLElementIterator::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_current((void*)&c_SimpleXMLElementIterator::i_current, (void*)&c_SimpleXMLElementIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElementIterator::ci_rewind((void*)&c_SimpleXMLElementIterator::i_rewind, (void*)&c_SimpleXMLElementIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_SimpleXMLElementIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_SimpleXMLElementIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_SimpleXMLElementIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_SimpleXMLElementIterator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElementIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SimpleXMLElementIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_SimpleXMLElementIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_SimpleXMLElementIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_SimpleXMLElementIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_SimpleXMLElementIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_SimpleXMLElementIterator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElementIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SimpleXMLElementIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_SimpleXMLElementIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElementIterator *self = NULL;
  p_SimpleXMLElementIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElementIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_SimpleXMLElementIterator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_key;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_valid;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_next;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_rewind;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci_current;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SimpleXMLElementIterator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SimpleXMLElementIterator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SimpleXMLElementIterator *c_SimpleXMLElementIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SimpleXMLElementIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SimpleXMLElementIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SimpleXMLElementIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SimpleXMLElementIterator::ci___construct;
  mcp.obj = this;
}
void c_SimpleXMLElementIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SimpleXMLElementIterator = {
  c_SimpleXMLElementIterator::os_getInit,
  c_SimpleXMLElementIterator::os_get,
  c_SimpleXMLElementIterator::os_lval,
  c_SimpleXMLElementIterator::os_invoke,
  c_SimpleXMLElementIterator::os_constant,
  c_SimpleXMLElementIterator::os_get_call_info
};
Object co_DateTimeZone(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTimeZone)())->dynCreate(params, init));
}
Object coo_DateTimeZone() {
  Object r(NEW(c_DateTimeZone)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
Variant c_DateTimeZone::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
Variant c_DateTimeZone::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
Variant &c_DateTimeZone::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
void c_DateTimeZone::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
void c_DateTimeZone::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
Variant * c_DateTimeZone::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
Variant * c_DateTimeZone::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
Variant * c_DateTimeZone::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTimeZone
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
Variant c_DateTimeZone::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 2:
      HASH_RETURN(0x5213CDB166554802LL, q_DateTimeZone_AFRICA, "AFRICA");
      break;
    case 10:
      HASH_RETURN(0x1F67AB7044E3CA2ALL, q_DateTimeZone_EUROPE, "EUROPE");
      break;
    case 12:
      HASH_RETURN(0x76F99914EEA96ECCLL, q_DateTimeZone_ARCTIC, "ARCTIC");
      break;
    case 13:
      HASH_RETURN(0x338F44565E0C038DLL, q_DateTimeZone_AMERICA, "AMERICA");
      break;
    case 15:
      HASH_RETURN(0x22CAA6990573E5EFLL, q_DateTimeZone_PACIFIC, "PACIFIC");
      break;
    case 19:
      HASH_RETURN(0x7879534F49C301F3LL, q_DateTimeZone_PER_COUNTRY, "PER_COUNTRY");
      break;
    case 20:
      HASH_RETURN(0x6FB9D84AA364CA14LL, q_DateTimeZone_UTC, "UTC");
      break;
    case 23:
      HASH_RETURN(0x5A01AACAA61E0FF7LL, q_DateTimeZone_ASIA, "ASIA");
      HASH_RETURN(0x3E74CAEDAD25E137LL, q_DateTimeZone_INDIAN, "INDIAN");
      break;
    case 24:
      HASH_RETURN(0x0C4F30470A9EEBF8LL, q_DateTimeZone_ALL, "ALL");
      break;
    case 25:
      HASH_RETURN(0x2BEDCED53E63BC79LL, q_DateTimeZone_ATLANTIC, "ATLANTIC");
      break;
    case 30:
      HASH_RETURN(0x3C168ED86522549ELL, q_DateTimeZone_AUSTRALIA, "AUSTRALIA");
      HASH_RETURN(0x690180C3BA732B5ELL, q_DateTimeZone_ALL_WITH_BC, "ALL_WITH_BC");
      break;
    case 31:
      HASH_RETURN(0x6B29DE65F46EAFDFLL, q_DateTimeZone_ANTARCTICA, "ANTARCTICA");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTimeZone
IMPLEMENT_CLASS(DateTimeZone)
void c_DateTimeZone::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTimeZone::cloneImpl() {
  c_DateTimeZone *obj = NEW(c_DateTimeZone)();
  cloneSet(obj);
  return obj;
}
void c_DateTimeZone::cloneSet(c_DateTimeZone *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DateTimeZone::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss6640e60f, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(o_getClassName()));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss4960e6a0, "getTransitions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
        return (t_gettransitions());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss3d20de82, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss5cbda8d0, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(o_getClassName()));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss71028683, "getOffset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
        return (t_getoffset(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTimeZone::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 0:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss5cbda8d0, "listAbbreviations")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
        return (ti_listabbreviations(c));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss6640e60f, "listIdentifiers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
        return (ti_listidentifiers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DateTimeZone::ci_gettransitions((void*)&c_DateTimeZone::i_gettransitions, (void*)&c_DateTimeZone::ifa_gettransitions, 0, 4, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_listidentifiers((void*)&c_DateTimeZone::i_listidentifiers, (void*)&c_DateTimeZone::ifa_listidentifiers, 0, 12, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci___destruct((void*)&c_DateTimeZone::i___destruct, (void*)&c_DateTimeZone::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_getoffset((void*)&c_DateTimeZone::i_getoffset, (void*)&c_DateTimeZone::ifa_getoffset, 1, 4, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci___construct((void*)&c_DateTimeZone::i___construct, (void*)&c_DateTimeZone::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_listabbreviations((void*)&c_DateTimeZone::i_listabbreviations, (void*)&c_DateTimeZone::ifa_listabbreviations, 0, 12, 0x0000000000000000LL);
CallInfo c_DateTimeZone::ci_getname((void*)&c_DateTimeZone::i_getname, (void*)&c_DateTimeZone::ifa_getname, 0, 4, 0x0000000000000000LL);
Variant c_DateTimeZone::i_gettransitions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
  return (self->t_gettransitions());
}
Variant c_DateTimeZone::i_listidentifiers(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
  return (c_DateTimeZone::ti_listidentifiers(c));
}
Variant c_DateTimeZone::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTimeZone::i_getoffset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getoffset(arg0));
  }
}
Variant c_DateTimeZone::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DateTimeZone::i_listabbreviations(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
  return (c_DateTimeZone::ti_listabbreviations(c));
}
Variant c_DateTimeZone::i_getname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_DateTimeZone::ifa_gettransitions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettransitions", 0, 1);
  return (self->t_gettransitions());
}
Variant c_DateTimeZone::ifa_listidentifiers(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("listidentifiers", 0, 1);
  return (c_DateTimeZone::ti_listidentifiers(c));
}
Variant c_DateTimeZone::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTimeZone::ifa_getoffset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoffset", count, 1, 1, 1);
  return (self->t_getoffset(a0));
}
Variant c_DateTimeZone::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_DateTimeZone::ifa_listabbreviations(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("listabbreviations", 0, 1);
  return (c_DateTimeZone::ti_listabbreviations(c));
}
Variant c_DateTimeZone::ifa_getname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTimeZone *self = NULL;
  p_DateTimeZone pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTimeZone*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
bool c_DateTimeZone::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x6D7CD16BBA93D063LL, NAMSTR(s_sys_ss6640e60f, "listIdentifiers")) {
        mcp.ci = &c_DateTimeZone::ci_listidentifiers;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DateTimeZone::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x63D3CF3884CE93F4LL, NAMSTR(s_sys_ss4960e6a0, "getTransitions")) {
        mcp.ci = &c_DateTimeZone::ci_gettransitions;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss3d20de82, "getName")) {
        mcp.ci = &c_DateTimeZone::ci_getname;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x2D0CCAB16C3ED068LL, NAMSTR(s_sys_ss5cbda8d0, "listAbbreviations")) {
        mcp.ci = &c_DateTimeZone::ci_listabbreviations;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss71028683, "getOffset")) {
        mcp.ci = &c_DateTimeZone::ci_getoffset;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DateTimeZone::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DateTimeZone::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DateTimeZone *c_DateTimeZone::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DateTimeZone::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DateTimeZone::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DateTimeZone::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DateTimeZone::ci___construct;
  mcp.obj = this;
}
void c_DateTimeZone::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DateTimeZone = {
  c_DateTimeZone::os_getInit,
  c_DateTimeZone::os_get,
  c_DateTimeZone::os_lval,
  c_DateTimeZone::os_invoke,
  c_DateTimeZone::os_constant,
  c_DateTimeZone::os_get_call_info
};
Object co_DOMNodeIterator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNodeIterator)())->dynCreate(params, init));
}
Object coo_DOMNodeIterator() {
  Object r(NEW(c_DOMNodeIterator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
Variant c_DOMNodeIterator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
Variant c_DOMNodeIterator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
Variant &c_DOMNodeIterator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
void c_DOMNodeIterator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
Variant * c_DOMNodeIterator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNodeIterator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
Variant c_DOMNodeIterator::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNodeIterator
IMPLEMENT_CLASS(DOMNodeIterator)
void c_DOMNodeIterator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNodeIterator::cloneImpl() {
  c_DOMNodeIterator *obj = NEW(c_DOMNodeIterator)();
  cloneSet(obj);
  return obj;
}
void c_DOMNodeIterator::cloneSet(c_DOMNodeIterator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNodeIterator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNodeIterator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNodeIterator::ci_next((void*)&c_DOMNodeIterator::i_next, (void*)&c_DOMNodeIterator::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_key((void*)&c_DOMNodeIterator::i_key, (void*)&c_DOMNodeIterator::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_valid((void*)&c_DOMNodeIterator::i_valid, (void*)&c_DOMNodeIterator::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci___destruct((void*)&c_DOMNodeIterator::i___destruct, (void*)&c_DOMNodeIterator::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci___construct((void*)&c_DOMNodeIterator::i___construct, (void*)&c_DOMNodeIterator::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_current((void*)&c_DOMNodeIterator::i_current, (void*)&c_DOMNodeIterator::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNodeIterator::ci_rewind((void*)&c_DOMNodeIterator::i_rewind, (void*)&c_DOMNodeIterator::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_DOMNodeIterator::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_DOMNodeIterator::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_DOMNodeIterator::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_DOMNodeIterator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeIterator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeIterator::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_DOMNodeIterator::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_DOMNodeIterator::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_DOMNodeIterator::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_DOMNodeIterator::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_DOMNodeIterator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNodeIterator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNodeIterator::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_DOMNodeIterator::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNodeIterator *self = NULL;
  p_DOMNodeIterator pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNodeIterator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_DOMNodeIterator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 1:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        mcp.ci = &c_DOMNodeIterator::ci_key;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMNodeIterator::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        mcp.ci = &c_DOMNodeIterator::ci_valid;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        mcp.ci = &c_DOMNodeIterator::ci_next;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        mcp.ci = &c_DOMNodeIterator::ci_rewind;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        mcp.ci = &c_DOMNodeIterator::ci_current;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMNodeIterator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNodeIterator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMNodeIterator *c_DOMNodeIterator::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNodeIterator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNodeIterator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNodeIterator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNodeIterator::ci___construct;
  mcp.obj = this;
}
void c_DOMNodeIterator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNodeIterator = {
  c_DOMNodeIterator::os_getInit,
  c_DOMNodeIterator::os_get,
  c_DOMNodeIterator::os_lval,
  c_DOMNodeIterator::os_invoke,
  c_DOMNodeIterator::os_constant,
  c_DOMNodeIterator::os_get_call_info
};
Object co_DOMImplementation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMImplementation)())->dynCreate(params, init));
}
Object coo_DOMImplementation() {
  Object r(NEW(c_DOMImplementation)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
Variant c_DOMImplementation::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
Variant c_DOMImplementation::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
Variant &c_DOMImplementation::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
void c_DOMImplementation::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
void c_DOMImplementation::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
Variant * c_DOMImplementation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
Variant * c_DOMImplementation::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
Variant * c_DOMImplementation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMImplementation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
Variant c_DOMImplementation::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMImplementation
IMPLEMENT_CLASS(DOMImplementation)
void c_DOMImplementation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMImplementation::cloneImpl() {
  c_DOMImplementation *obj = NEW(c_DOMImplementation)();
  cloneSet(obj);
  return obj;
}
void c_DOMImplementation::cloneSet(c_DOMImplementation *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMImplementation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss7a1c6fcd, "createDocumentType")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
        if (count <= 0) return (t_createdocumenttype());
        else if (count == 1) return (t_createdocumenttype(a0));
        else if (count == 2) return (t_createdocumenttype(a0, a1));
        else return (t_createdocumenttype(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss08d2b5d8, "hasFeature")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
        return (t_hasfeature(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss3dea3a84, "createDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
        if (count <= 0) return (t_createdocument());
        else if (count == 1) return (t_createdocument(a0));
        else if (count == 2) return (t_createdocument(a0, a1));
        else return (t_createdocument(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMImplementation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMImplementation::ci_createdocument((void*)&c_DOMImplementation::i_createdocument, (void*)&c_DOMImplementation::ifa_createdocument, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci_createdocumenttype((void*)&c_DOMImplementation::i_createdocumenttype, (void*)&c_DOMImplementation::ifa_createdocumenttype, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci___destruct((void*)&c_DOMImplementation::i___destruct, (void*)&c_DOMImplementation::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci___construct((void*)&c_DOMImplementation::i___construct, (void*)&c_DOMImplementation::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMImplementation::ci_hasfeature((void*)&c_DOMImplementation::i_hasfeature, (void*)&c_DOMImplementation::ifa_hasfeature, 2, 4, 0x0000000000000000LL);
Variant c_DOMImplementation::i_createdocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_createdocument());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_createdocument(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_createdocument(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createdocument(arg0, arg1, arg2));
  }
}
Variant c_DOMImplementation::i_createdocumenttype(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_createdocumenttype());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_createdocumenttype(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_createdocumenttype(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createdocumenttype(arg0, arg1, arg2));
  }
}
Variant c_DOMImplementation::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMImplementation::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMImplementation::i_hasfeature(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_hasfeature(arg0, arg1));
  }
}
Variant c_DOMImplementation::ifa_createdocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocument", 3, 1);
  if (count <= 0) return (self->t_createdocument());
  if (count == 1) return (self->t_createdocument(a0));
  if (count == 2) return (self->t_createdocument(a0, a1));
  return (self->t_createdocument(a0, a1, a2));
}
Variant c_DOMImplementation::ifa_createdocumenttype(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("createdocumenttype", 3, 1);
  if (count <= 0) return (self->t_createdocumenttype());
  if (count == 1) return (self->t_createdocumenttype(a0));
  if (count == 2) return (self->t_createdocumenttype(a0, a1));
  return (self->t_createdocumenttype(a0, a1, a2));
}
Variant c_DOMImplementation::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMImplementation::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMImplementation::ifa_hasfeature(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMImplementation *self = NULL;
  p_DOMImplementation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMImplementation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasfeature", count, 2, 2, 1);
  return (self->t_hasfeature(a0, a1));
}
bool c_DOMImplementation::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x3CB56A796F3DBAC3LL, NAMSTR(s_sys_ss7a1c6fcd, "createDocumentType")) {
        mcp.ci = &c_DOMImplementation::ci_createdocumenttype;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMImplementation::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x280878EAC306A6A3LL, NAMSTR(s_sys_ss08d2b5d8, "hasFeature")) {
        mcp.ci = &c_DOMImplementation::ci_hasfeature;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x30855E95B37D1B4ELL, NAMSTR(s_sys_ss3dea3a84, "createDocument")) {
        mcp.ci = &c_DOMImplementation::ci_createdocument;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMImplementation::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMImplementation::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMImplementation *c_DOMImplementation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMImplementation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMImplementation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMImplementation::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMImplementation::ci___construct;
  mcp.obj = this;
}
void c_DOMImplementation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMImplementation = {
  c_DOMImplementation::os_getInit,
  c_DOMImplementation::os_get,
  c_DOMImplementation::os_lval,
  c_DOMImplementation::os_invoke,
  c_DOMImplementation::os_constant,
  c_DOMImplementation::os_get_call_info
};
Object co_SoapHeader(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapHeader)())->dynCreate(params, init));
}
Object coo_SoapHeader() {
  Object r(NEW(c_SoapHeader)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
Variant c_SoapHeader::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
Variant c_SoapHeader::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
Variant &c_SoapHeader::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
void c_SoapHeader::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
void c_SoapHeader::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
Variant * c_SoapHeader::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
Variant * c_SoapHeader::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
Variant * c_SoapHeader::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapHeader
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
Variant c_SoapHeader::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapHeader
IMPLEMENT_CLASS(SoapHeader)
void c_SoapHeader::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapHeader::cloneImpl() {
  c_SoapHeader *obj = NEW(c_SoapHeader)();
  cloneSet(obj);
  return obj;
}
void c_SoapHeader::cloneSet(c_SoapHeader *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapHeader::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapHeader::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapHeader::ci___destruct((void*)&c_SoapHeader::i___destruct, (void*)&c_SoapHeader::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapHeader::ci___construct((void*)&c_SoapHeader::i___construct, (void*)&c_SoapHeader::ifa___construct, 5, 4, 0x0000000000000000LL);
Variant c_SoapHeader::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapHeader::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SoapHeader::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapHeader::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapHeader *self = NULL;
  p_SoapHeader pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapHeader*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__construct", count, 2, 5, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  return (self->t___construct(a0, a1, a2, a3, a4), null);
}
bool c_SoapHeader::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapHeader::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapHeader::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapHeader::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapHeader *c_SoapHeader::create(String a0, String a1, Variant a2, bool a3, Variant a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SoapHeader::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SoapHeader::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SoapHeader::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapHeader::ci___construct;
  mcp.obj = this;
}
void c_SoapHeader::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 5) throw_wrong_arguments("__construct", count, 2, 5, 1);
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
struct ObjectStaticCallbacks cw_SoapHeader = {
  c_SoapHeader::os_getInit,
  c_SoapHeader::os_get,
  c_SoapHeader::os_lval,
  c_SoapHeader::os_invoke,
  c_SoapHeader::os_constant,
  c_SoapHeader::os_get_call_info
};
Object co_DOMNotation(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNotation)())->dynCreate(params, init));
}
Object coo_DOMNotation() {
  Object r(NEW(c_DOMNotation)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
Variant c_DOMNotation::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
Variant c_DOMNotation::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
Variant &c_DOMNotation::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
void c_DOMNotation::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
void c_DOMNotation::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
Variant * c_DOMNotation::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
Variant * c_DOMNotation::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
Variant * c_DOMNotation::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNotation
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
Variant c_DOMNotation::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNotation
IMPLEMENT_CLASS(DOMNotation)
void c_DOMNotation::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNotation::cloneImpl() {
  c_DOMNotation *obj = NEW(c_DOMNotation)();
  cloneSet(obj);
  return obj;
}
void c_DOMNotation::cloneSet(c_DOMNotation *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMNotation::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNotation::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNotation::ci___destruct((void*)&c_DOMNotation::i___destruct, (void*)&c_DOMNotation::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___set((void*)&c_DOMNotation::i___set, (void*)&c_DOMNotation::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___construct((void*)&c_DOMNotation::i___construct, (void*)&c_DOMNotation::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNotation::ci___get((void*)&c_DOMNotation::i___get, (void*)&c_DOMNotation::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMNotation::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNotation::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNotation::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNotation::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNotation::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNotation::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNotation::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNotation::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNotation *self = NULL;
  p_DOMNotation pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNotation*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMNotation::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMNotation::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMNotation::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMNotation::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMNotation::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMNotation::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMNotation *c_DOMNotation::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNotation::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNotation::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNotation::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNotation::ci___construct;
  mcp.obj = this;
}
void c_DOMNotation::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNotation = {
  c_DOMNotation::os_getInit,
  c_DOMNotation::os_get,
  c_DOMNotation::os_lval,
  c_DOMNotation::os_invoke,
  c_DOMNotation::os_constant,
  c_DOMNotation::os_get_call_info
};
Object co_DebuggerProxy(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DebuggerProxy)())->dynCreate(params, init));
}
Object coo_DebuggerProxy() {
  Object r(NEW(c_DebuggerProxy)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
Variant c_DebuggerProxy::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
Variant c_DebuggerProxy::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
Variant &c_DebuggerProxy::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
void c_DebuggerProxy::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
void c_DebuggerProxy::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
Variant * c_DebuggerProxy::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
Variant * c_DebuggerProxy::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DebuggerProxy
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
Variant c_DebuggerProxy::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DebuggerProxy
IMPLEMENT_CLASS(DebuggerProxy)
void c_DebuggerProxy::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DebuggerProxy::cloneImpl() {
  c_DebuggerProxy *obj = NEW(c_DebuggerProxy)();
  cloneSet(obj);
  return obj;
}
void c_DebuggerProxy::cloneSet(c_DebuggerProxy *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DebuggerProxy::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
        return (t_send(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss139484bb, "isLocal")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
        return (t_islocal());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DebuggerProxy::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DebuggerProxy::ci_islocal((void*)&c_DebuggerProxy::i_islocal, (void*)&c_DebuggerProxy::ifa_islocal, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci___destruct((void*)&c_DebuggerProxy::i___destruct, (void*)&c_DebuggerProxy::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci___construct((void*)&c_DebuggerProxy::i___construct, (void*)&c_DebuggerProxy::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DebuggerProxy::ci_send((void*)&c_DebuggerProxy::i_send, (void*)&c_DebuggerProxy::ifa_send, 1, 4, 0x0000000000000000LL);
Variant c_DebuggerProxy::i_islocal(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
  return (self->t_islocal());
}
Variant c_DebuggerProxy::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerProxy::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerProxy::i_send(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_send(arg0));
  }
}
Variant c_DebuggerProxy::ifa_islocal(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("islocal", 0, 1);
  return (self->t_islocal());
}
Variant c_DebuggerProxy::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DebuggerProxy::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DebuggerProxy::ifa_send(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DebuggerProxy *self = NULL;
  p_DebuggerProxy pobj;
  if (mcp.obj) {
    self = static_cast<c_DebuggerProxy*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("send", count, 1, 1, 1);
  return (self->t_send(a0));
}
bool c_DebuggerProxy::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 0:
      HASH_GUARD_LITSTR(0x3E0170A7802E3888LL, NAMSTR(s_sys_ss70eaeb85, "send")) {
        mcp.ci = &c_DebuggerProxy::ci_send;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DebuggerProxy::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x7B58587A529D270CLL, NAMSTR(s_sys_ss139484bb, "isLocal")) {
        mcp.ci = &c_DebuggerProxy::ci_islocal;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DebuggerProxy::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DebuggerProxy::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DebuggerProxy *c_DebuggerProxy::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DebuggerProxy::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DebuggerProxy::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DebuggerProxy::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DebuggerProxy::ci___construct;
  mcp.obj = this;
}
void c_DebuggerProxy::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DebuggerProxy = {
  c_DebuggerProxy::os_getInit,
  c_DebuggerProxy::os_get,
  c_DebuggerProxy::os_lval,
  c_DebuggerProxy::os_invoke,
  c_DebuggerProxy::os_constant,
  c_DebuggerProxy::os_get_call_info
};
Object co_Memcached(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Memcached)())->dynCreate(params, init));
}
Object coo_Memcached() {
  Object r(NEW(c_Memcached)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcached
Variant c_Memcached::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcached
Variant c_Memcached::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcached
Variant &c_Memcached::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcached
void c_Memcached::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcached
void c_Memcached::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Memcached
Variant * c_Memcached::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcached
Variant * c_Memcached::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcached
Variant * c_Memcached::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcached
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcached
Variant c_Memcached::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 127) {
    case 3:
      HASH_RETURN(0x2CCABB2638D29583LL, q_Memcached_RES_ERRNO, "RES_ERRNO");
      break;
    case 5:
      HASH_RETURN(0x6AF4D4CD7B6B9E85LL, q_Memcached_OPT_TCP_NODELAY, "OPT_TCP_NODELAY");
      break;
    case 7:
      HASH_RETURN(0x1FBB5AC58A77E707LL, q_Memcached_RES_BUFFERED, "RES_BUFFERED");
      break;
    case 10:
      HASH_RETURN(0x261AB88649B2E58ALL, q_Memcached_OPT_SERVER_FAILURE_LIMIT, "OPT_SERVER_FAILURE_LIMIT");
      HASH_RETURN(0x2072FB05B0D6540ALL, q_Memcached_RES_NO_SERVERS, "RES_NO_SERVERS");
      break;
    case 13:
      HASH_RETURN(0x5EC3EFCB1563B68DLL, q_Memcached_OPT_LIBKETAMA_COMPATIBLE, "OPT_LIBKETAMA_COMPATIBLE");
      HASH_RETURN(0x0C53D08ECD9ACC0DLL, q_Memcached_RES_SUCCESS, "RES_SUCCESS");
      break;
    case 22:
      HASH_RETURN(0x7071566611A71D96LL, q_Memcached_OPT_PREFIX_KEY, "OPT_PREFIX_KEY");
      HASH_RETURN(0x425EDC08E649F716LL, q_Memcached_OPT_HASH, "OPT_HASH");
      break;
    case 24:
      HASH_RETURN(0x64B6C925C7A41498LL, q_Memcached_DISTRIBUTION_CONSISTENT, "DISTRIBUTION_CONSISTENT");
      break;
    case 28:
      HASH_RETURN(0x200711C7E62DFB1CLL, q_Memcached_HASH_HSIEH, "HASH_HSIEH");
      HASH_RETURN(0x6B8DE2AA09E1749CLL, q_Memcached_OPT_BINARY_PROTOCOL, "OPT_BINARY_PROTOCOL");
      HASH_RETURN(0x47FC6D6596D2411CLL, q_Memcached_RES_UNKNOWN_READ_FAILURE, "RES_UNKNOWN_READ_FAILURE");
      break;
    case 29:
      HASH_RETURN(0x6364909F8AA5869DLL, q_Memcached_RES_NOTFOUND, "RES_NOTFOUND");
      break;
    case 34:
      HASH_RETURN(0x56E8EF0A2966E7A2LL, q_Memcached_RES_PROTOCOL_ERROR, "RES_PROTOCOL_ERROR");
      HASH_RETURN(0x4A25210D326D0922LL, q_Memcached_RES_CLIENT_ERROR, "RES_CLIENT_ERROR");
      break;
    case 35:
      HASH_RETURN(0x2B230612FB5D80A3LL, q_Memcached_RES_SERVER_ERROR, "RES_SERVER_ERROR");
      break;
    case 37:
      HASH_RETURN(0x49D8D4184B78B3A5LL, q_Memcached_HASH_FNV1A_64, "HASH_FNV1A_64");
      break;
    case 47:
      HASH_RETURN(0x6808EBB81DDE422FLL, q_Memcached_OPT_CACHE_LOOKUPS, "OPT_CACHE_LOOKUPS");
      break;
    case 50:
      HASH_RETURN(0x3A7E842A627341B2LL, q_Memcached_HASH_FNV1_64, "HASH_FNV1_64");
      break;
    case 52:
      HASH_RETURN(0x56895500D1F05334LL, q_Memcached_OPT_SEND_TIMEOUT, "OPT_SEND_TIMEOUT");
      break;
    case 67:
      HASH_RETURN(0x6BC90BF53C6E7CC3LL, q_Memcached_RES_TIMEOUT, "RES_TIMEOUT");
      HASH_RETURN(0x4155BF3DCFA655C3LL, q_Memcached_RES_BAD_KEY_PROVIDED, "RES_BAD_KEY_PROVIDED");
      break;
    case 68:
      HASH_RETURN(0x490A114712BBA544LL, q_Memcached_RES_SOME_ERRORS, "RES_SOME_ERRORS");
      break;
    case 70:
      HASH_RETURN(0x68724938D592E4C6LL, q_Memcached_OPT_SOCKET_SEND_SIZE, "OPT_SOCKET_SEND_SIZE");
      break;
    case 71:
      HASH_RETURN(0x073E4D38138A7DC7LL, q_Memcached_OPT_COMPRESSION, "OPT_COMPRESSION");
      break;
    case 72:
      HASH_RETURN(0x7B91B2E2CC4DE648LL, q_Memcached_SERIALIZER_PHP, "SERIALIZER_PHP");
      break;
    case 75:
      HASH_RETURN(0x138CD297B9FD244BLL, q_Memcached_OPT_RETRY_TIMEOUT, "OPT_RETRY_TIMEOUT");
      break;
    case 78:
      HASH_RETURN(0x74824687F4C8D7CELL, q_Memcached_HAVE_JSON, "HAVE_JSON");
      break;
    case 80:
      HASH_RETURN(0x7AC058297870C1D0LL, q_Memcached_SERIALIZER_JSON, "SERIALIZER_JSON");
      break;
    case 81:
      HASH_RETURN(0x2B4E411F0C7596D1LL, q_Memcached_SERIALIZER_IGBINARY, "SERIALIZER_IGBINARY");
      HASH_RETURN(0x1E8ABFABE00D2651LL, q_Memcached_OPT_NO_BLOCK, "OPT_NO_BLOCK");
      break;
    case 84:
      HASH_RETURN(0x49856B6165627AD4LL, q_Memcached_DISTRIBUTION_MODULA, "DISTRIBUTION_MODULA");
      break;
    case 85:
      HASH_RETURN(0x02FAAD1AB87BA2D5LL, q_Memcached_HASH_CRC, "HASH_CRC");
      HASH_RETURN(0x1045EAC17F112855LL, q_Memcached_RES_WRITE_FAILURE, "RES_WRITE_FAILURE");
      break;
    case 87:
      HASH_RETURN(0x3A3731492FB1B557LL, q_Memcached_HASH_FNV1_32, "HASH_FNV1_32");
      HASH_RETURN(0x345B7B934684B3D7LL, q_Memcached_OPT_SOCKET_RECV_SIZE, "OPT_SOCKET_RECV_SIZE");
      break;
    case 88:
      HASH_RETURN(0x296424A39A9F1AD8LL, q_Memcached_OPT_POLL_TIMEOUT, "OPT_POLL_TIMEOUT");
      break;
    case 91:
      HASH_RETURN(0x3DD14F50C65BCDDBLL, q_Memcached_OPT_DISTRIBUTION, "OPT_DISTRIBUTION");
      HASH_RETURN(0x0224412EA957C9DBLL, q_Memcached_RES_CONNECTION_SOCKET_CREATE_FAILURE, "RES_CONNECTION_SOCKET_CREATE_FAILURE");
      break;
    case 94:
      HASH_RETURN(0x6460D48B93209DDELL, q_Memcached_OPT_RECV_TIMEOUT, "OPT_RECV_TIMEOUT");
      break;
    case 97:
      HASH_RETURN(0x68D025242664C361LL, q_Memcached_GET_PRESERVE_ORDER, "GET_PRESERVE_ORDER");
      break;
    case 100:
      HASH_RETURN(0x53A1149CE01E8C64LL, q_Memcached_HASH_DEFAULT, "HASH_DEFAULT");
      break;
    case 107:
      HASH_RETURN(0x76B0604A2B4408EBLL, q_Memcached_OPT_BUFFER_WRITES, "OPT_BUFFER_WRITES");
      break;
    case 108:
      HASH_RETURN(0x3C4C4E1BC9DFDCECLL, q_Memcached_HASH_FNV1A_32, "HASH_FNV1A_32");
      HASH_RETURN(0x4197FC89C9F88DECLL, q_Memcached_RES_HOST_LOOKUP_FAILURE, "RES_HOST_LOOKUP_FAILURE");
      break;
    case 109:
      HASH_RETURN(0x56C85759C5701DEDLL, q_Memcached_RES_DATA_EXISTS, "RES_DATA_EXISTS");
      break;
    case 110:
      HASH_RETURN(0x153143A96D687E6ELL, q_Memcached_RES_NOTSTORED, "RES_NOTSTORED");
      break;
    case 112:
      HASH_RETURN(0x2BB4CFA54A5085F0LL, q_Memcached_HASH_MD5, "HASH_MD5");
      break;
    case 113:
      HASH_RETURN(0x74109B06DAD2F9F1LL, q_Memcached_RES_END, "RES_END");
      break;
    case 116:
      HASH_RETURN(0x73ABA23A4A0C5D74LL, q_Memcached_OPT_SERIALIZER, "OPT_SERIALIZER");
      break;
    case 120:
      HASH_RETURN(0x460A66958F0524F8LL, q_Memcached_RES_FAILURE, "RES_FAILURE");
      break;
    case 121:
      HASH_RETURN(0x1C014F2A2E707EF9LL, q_Memcached_HAVE_IGBINARY, "HAVE_IGBINARY");
      break;
    case 123:
      HASH_RETURN(0x0443DA24DAD42EFBLL, q_Memcached_OPT_CONNECT_TIMEOUT, "OPT_CONNECT_TIMEOUT");
      HASH_RETURN(0x35B252ECC21E5F7BLL, q_Memcached_RES_PARTIAL_READ, "RES_PARTIAL_READ");
      break;
    case 126:
      HASH_RETURN(0x7A68C36A2F5D27FELL, q_Memcached_HASH_MURMUR, "HASH_MURMUR");
      break;
    case 127:
      HASH_RETURN(0x6948F797B210F37FLL, q_Memcached_RES_PAYLOAD_FAILURE, "RES_PAYLOAD_FAILURE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcached
IMPLEMENT_CLASS(Memcached)
void c_Memcached::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Memcached::cloneImpl() {
  c_Memcached *obj = NEW(c_Memcached)();
  cloneSet(obj);
  return obj;
}
void c_Memcached::cloneSet(c_Memcached *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Memcached::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x38998A4858382D82LL, NAMSTR(s_sys_ss6c5e1663, "getMultiByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("getmultibykey", count, 2, 4, 1);
        if (count <= 2) return (t_getmultibykey(a0, a1));
        else if (count == 3) return (t_getmultibykey(a0, a1, ref(a2)));
        else return (t_getmultibykey(a0, a1, ref(a2), a3));
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x4F31CCB24341F605LL, NAMSTR(s_sys_ss0939351d, "getMulti")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("getmulti", count, 1, 3, 1);
        if (count <= 1) return (t_getmulti(a0));
        else if (count == 2) return (t_getmulti(a0, ref(a1)));
        else return (t_getmulti(a0, ref(a1), a2));
      }
      HASH_GUARD_LITSTR(0x6FB9087461635285LL, NAMSTR(s_sys_ss2f8e5140, "setOption")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setoption", count, 2, 2, 1);
        return (t_setoption(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x06E29D289FC0AF87LL, NAMSTR(s_sys_ss41cb9189, "addServers")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addservers", count, 1, 1, 1);
        return (t_addservers(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss6db5a215, "add")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("add", count, 2, 3, 1);
        if (count <= 2) return (t_add(a0, a1));
        else return (t_add(a0, a1, a2));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x1C80DDD00742930FLL, NAMSTR(s_sys_ss0fe15fdf, "getServerByKey")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getserverbykey", count, 1, 1, 1);
        return (t_getserverbykey(a0));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss1b5e3529, "getVersion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x65C5EF328C77C917LL, NAMSTR(s_sys_ss2da130db, "prepend")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("prepend", count, 2, 2, 1);
        return (t_prepend(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x3B7F419ECE80EE19LL, NAMSTR(s_sys_ss038035c6, "setMulti")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setmulti", count, 1, 2, 1);
        if (count <= 1) return (t_setmulti(a0));
        else return (t_setmulti(a0, a1));
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss0241fb06, "set")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("set", count, 2, 3, 1);
        if (count <= 2) return (t_set(a0, a1));
        else return (t_set(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x573E46DE52BFF8A1LL, NAMSTR(s_sys_ss449b0823, "cas")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("cas", count, 3, 4, 1);
        if (count <= 3) return (t_cas(a0, a1, a2));
        else return (t_cas(a0, a1, a2, a3));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss153b6861, "get")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("get", count, 1, 3, 1);
        if (count <= 1) return (t_get(a0));
        else if (count == 2) return (t_get(a0, a1));
        else return (t_get(a0, a1, ref(a2)));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x00FBB16B058D5C2FLL, NAMSTR(s_sys_ss69e3dc9b, "getDelayedByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("getdelayedbykey", count, 2, 4, 1);
        if (count <= 2) return (t_getdelayedbykey(a0, a1));
        else if (count == 3) return (t_getdelayedbykey(a0, a1, a2));
        else return (t_getdelayedbykey(a0, a1, a2, a3));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7F4CB6AD55C9F7B8LL, NAMSTR(s_sys_ss5097084d, "setByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("setbykey", count, 3, 4, 1);
        if (count <= 3) return (t_setbykey(a0, a1, a2));
        else return (t_setbykey(a0, a1, a2, a3));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x303DBA91556D773DLL, NAMSTR(s_sys_ss18bebdc2, "replaceByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("replacebykey", count, 3, 4, 1);
        if (count <= 3) return (t_replacebykey(a0, a1, a2));
        else return (t_replacebykey(a0, a1, a2, a3));
      }
      break;
    case 64:
      HASH_GUARD_LITSTR(0x402DD1A85CAEA6C0LL, NAMSTR(s_sys_ss7d2a9ef4, "getOption")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getoption", count, 1, 1, 1);
        return (t_getoption(a0));
      }
      break;
    case 65:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss21dd0673, "fetchAll")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fetchall", 0, 1);
        return (t_fetchall());
      }
      break;
    case 66:
      HASH_GUARD_LITSTR(0x4DEE4A472DC69EC2LL, NAMSTR(s_sys_ss459a2a12, "append")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("append", count, 2, 2, 1);
        return (t_append(a0, a1));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x5BB1AF59B155E144LL, NAMSTR(s_sys_ss2ec4df0b, "getResultMessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getresultmessage", 0, 1);
        return (t_getresultmessage());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss3029c43a, "replace")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("replace", count, 2, 3, 1);
        if (count <= 2) return (t_replace(a0, a1));
        else return (t_replace(a0, a1, a2));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss312d8bcf, "increment")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss4ca209c3, "delete")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x344A3DC90A5BD1D7LL, NAMSTR(s_sys_ss33591ad3, "getByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("getbykey", count, 2, 4, 1);
        if (count <= 2) return (t_getbykey(a0, a1));
        else if (count == 3) return (t_getbykey(a0, a1, a2));
        else return (t_getbykey(a0, a1, a2, ref(a3)));
      }
      HASH_GUARD_LITSTR(0x5044B38DE4461A57LL, NAMSTR(s_sys_ss7e17c9c6, "getServerList")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getserverlist", 0, 1);
        return (t_getserverlist());
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss3a0ef2e6, "getStats")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstats", 0, 1);
        return (t_getstats());
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2a19cdf6, "decrement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    case 96:
      HASH_GUARD_LITSTR(0x086C8D4E944C0FE0LL, NAMSTR(s_sys_ss31a97990, "appendByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("appendbykey", count, 3, 3, 1);
        return (t_appendbykey(a0, a1, a2));
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss163bad01, "addServer")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("addserver", count, 2, 3, 1);
        if (count <= 2) return (t_addserver(a0, a1));
        else return (t_addserver(a0, a1, a2));
      }
      break;
    case 110:
      HASH_GUARD_LITSTR(0x0EE9EC6BCA56B46ELL, NAMSTR(s_sys_ss106b4dd7, "prependByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("prependbykey", count, 3, 3, 1);
        return (t_prependbykey(a0, a1, a2));
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x3B59E52110B990F2LL, NAMSTR(s_sys_ss172df677, "deleteByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("deletebykey", count, 2, 3, 1);
        if (count <= 2) return (t_deletebykey(a0, a1));
        else return (t_deletebykey(a0, a1, a2));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 118:
      HASH_GUARD_LITSTR(0x18A8B25BF74FA276LL, NAMSTR(s_sys_ss4bab1591, "getDelayed")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("getdelayed", count, 1, 3, 1);
        if (count <= 1) return (t_getdelayed(a0));
        else if (count == 2) return (t_getdelayed(a0, a1));
        else return (t_getdelayed(a0, a1, a2));
      }
      break;
    case 119:
      HASH_GUARD_LITSTR(0x03F8E65E47097177LL, NAMSTR(s_sys_ss6ae7fa54, "addByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("addbykey", count, 3, 4, 1);
        if (count <= 3) return (t_addbykey(a0, a1, a2));
        else return (t_addbykey(a0, a1, a2, a3));
      }
      HASH_GUARD_LITSTR(0x6AB1842FE8684D77LL, NAMSTR(s_sys_ss1cfbc2c8, "setMultiByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setmultibykey", count, 2, 3, 1);
        if (count <= 2) return (t_setmultibykey(a0, a1));
        else return (t_setmultibykey(a0, a1, a2));
      }
      break;
    case 121:
      HASH_GUARD_LITSTR(0x50BC469CFA9BF579LL, NAMSTR(s_sys_ss3bd544b6, "casByKey")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("casbykey", count, 4, 5, 1);
        if (count <= 4) return (t_casbykey(a0, a1, a2, a3));
        else return (t_casbykey(a0, a1, a2, a3, a4));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss0b929a80, "fetch")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fetch", 0, 1);
        return (t_fetch());
      }
      break;
    case 125:
      HASH_GUARD_LITSTR(0x3F460132535C00FDLL, NAMSTR(s_sys_ss4efec04e, "getResultCode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getresultcode", 0, 1);
        return (t_getresultcode());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Memcached::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Memcached::ci_getmulti((void*)&c_Memcached::i_getmulti, (void*)&c_Memcached::ifa_getmulti, 3, 4, 0x0000000000000002LL);
CallInfo c_Memcached::ci_getresultmessage((void*)&c_Memcached::i_getresultmessage, (void*)&c_Memcached::ifa_getresultmessage, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getresultcode((void*)&c_Memcached::i_getresultcode, (void*)&c_Memcached::ifa_getresultcode, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_setbykey((void*)&c_Memcached::i_setbykey, (void*)&c_Memcached::ifa_setbykey, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_addserver((void*)&c_Memcached::i_addserver, (void*)&c_Memcached::ifa_addserver, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_set((void*)&c_Memcached::i_set, (void*)&c_Memcached::ifa_set, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_appendbykey((void*)&c_Memcached::i_appendbykey, (void*)&c_Memcached::ifa_appendbykey, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getdelayed((void*)&c_Memcached::i_getdelayed, (void*)&c_Memcached::ifa_getdelayed, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_setoption((void*)&c_Memcached::i_setoption, (void*)&c_Memcached::ifa_setoption, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci___destruct((void*)&c_Memcached::i___destruct, (void*)&c_Memcached::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_prepend((void*)&c_Memcached::i_prepend, (void*)&c_Memcached::ifa_prepend, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_append((void*)&c_Memcached::i_append, (void*)&c_Memcached::ifa_append, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci___construct((void*)&c_Memcached::i___construct, (void*)&c_Memcached::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_replacebykey((void*)&c_Memcached::i_replacebykey, (void*)&c_Memcached::ifa_replacebykey, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_casbykey((void*)&c_Memcached::i_casbykey, (void*)&c_Memcached::ifa_casbykey, 5, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_increment((void*)&c_Memcached::i_increment, (void*)&c_Memcached::ifa_increment, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_decrement((void*)&c_Memcached::i_decrement, (void*)&c_Memcached::ifa_decrement, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getstats((void*)&c_Memcached::i_getstats, (void*)&c_Memcached::ifa_getstats, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getdelayedbykey((void*)&c_Memcached::i_getdelayedbykey, (void*)&c_Memcached::ifa_getdelayedbykey, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_setmulti((void*)&c_Memcached::i_setmulti, (void*)&c_Memcached::ifa_setmulti, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getbykey((void*)&c_Memcached::i_getbykey, (void*)&c_Memcached::ifa_getbykey, 4, 4, 0x0000000000000008LL);
CallInfo c_Memcached::ci_deletebykey((void*)&c_Memcached::i_deletebykey, (void*)&c_Memcached::ifa_deletebykey, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_get((void*)&c_Memcached::i_get, (void*)&c_Memcached::ifa_get, 3, 4, 0x0000000000000004LL);
CallInfo c_Memcached::ci_getoption((void*)&c_Memcached::i_getoption, (void*)&c_Memcached::ifa_getoption, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_add((void*)&c_Memcached::i_add, (void*)&c_Memcached::ifa_add, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getserverbykey((void*)&c_Memcached::i_getserverbykey, (void*)&c_Memcached::ifa_getserverbykey, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getserverlist((void*)&c_Memcached::i_getserverlist, (void*)&c_Memcached::ifa_getserverlist, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_addbykey((void*)&c_Memcached::i_addbykey, (void*)&c_Memcached::ifa_addbykey, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getversion((void*)&c_Memcached::i_getversion, (void*)&c_Memcached::ifa_getversion, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_fetchall((void*)&c_Memcached::i_fetchall, (void*)&c_Memcached::ifa_fetchall, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_delete((void*)&c_Memcached::i_delete, (void*)&c_Memcached::ifa_delete, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_setmultibykey((void*)&c_Memcached::i_setmultibykey, (void*)&c_Memcached::ifa_setmultibykey, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_getmultibykey((void*)&c_Memcached::i_getmultibykey, (void*)&c_Memcached::ifa_getmultibykey, 4, 4, 0x0000000000000004LL);
CallInfo c_Memcached::ci_fetch((void*)&c_Memcached::i_fetch, (void*)&c_Memcached::ifa_fetch, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_addservers((void*)&c_Memcached::i_addservers, (void*)&c_Memcached::ifa_addservers, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_replace((void*)&c_Memcached::i_replace, (void*)&c_Memcached::ifa_replace, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_flush((void*)&c_Memcached::i_flush, (void*)&c_Memcached::ifa_flush, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_cas((void*)&c_Memcached::i_cas, (void*)&c_Memcached::ifa_cas, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcached::ci_prependbykey((void*)&c_Memcached::i_prependbykey, (void*)&c_Memcached::ifa_prependbykey, 3, 4, 0x0000000000000000LL);
Variant c_Memcached::i_getmulti(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("getmulti", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_getmulti(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getmulti(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getmulti(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_getresultmessage(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getresultmessage", 0, 1);
  return (self->t_getresultmessage());
}
Variant c_Memcached::i_getresultcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getresultcode", 0, 1);
  return (self->t_getresultcode());
}
Variant c_Memcached::i_setbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("setbykey", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_setbykey(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setbykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_addserver(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addserver", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_addserver(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addserver(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("set", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_set(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_set(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_appendbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("appendbykey", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_appendbykey(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_getdelayed(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("getdelayed", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_getdelayed(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getdelayed(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getdelayed(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_setoption(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setoption", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setoption(arg0, arg1));
  }
}
Variant c_Memcached::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcached::i_prepend(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("prepend", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_prepend(arg0, arg1));
  }
}
Variant c_Memcached::i_append(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("append", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_append(arg0, arg1));
  }
}
Variant c_Memcached::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_Memcached::i_replacebykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("replacebykey", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_replacebykey(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replacebykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_casbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("casbykey", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (self->t_casbykey(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_casbykey(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_Memcached::i_increment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_increment(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_increment(arg0, arg1));
  }
}
Variant c_Memcached::i_decrement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_decrement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_decrement(arg0, arg1));
  }
}
Variant c_Memcached::i_getstats(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstats", 0, 1);
  return (self->t_getstats());
}
Variant c_Memcached::i_getdelayedbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getdelayedbykey", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_getdelayedbykey(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_getdelayedbykey(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getdelayedbykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_setmulti(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setmulti", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setmulti(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setmulti(arg0, arg1));
  }
}
Variant c_Memcached::i_getbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getbykey", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_getbykey(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_getbykey(arg0, arg1, arg2));
    CVarRef arg3(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t_getbykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_deletebykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("deletebykey", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_deletebykey(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_deletebykey(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("get", count, 1, 3, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_get(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_get(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t_get(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_getoption(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoption", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getoption(arg0));
  }
}
Variant c_Memcached::i_add(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("add", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_add(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_add(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_getserverbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getserverbykey", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getserverbykey(arg0));
  }
}
Variant c_Memcached::i_getserverlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getserverlist", 0, 1);
  return (self->t_getserverlist());
}
Variant c_Memcached::i_addbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("addbykey", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_addbykey(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addbykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_getversion(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcached::i_fetchall(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fetchall", 0, 1);
  return (self->t_fetchall());
}
Variant c_Memcached::i_delete(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_delete(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_delete(arg0, arg1));
  }
}
Variant c_Memcached::i_setmultibykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setmultibykey", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_setmultibykey(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setmultibykey(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_getmultibykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getmultibykey", count, 2, 4, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_getmultibykey(arg0, arg1));
    CVarRef arg2(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_getmultibykey(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getmultibykey(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_fetch(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fetch", 0, 1);
  return (self->t_fetch());
}
Variant c_Memcached::i_addservers(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addservers", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addservers(arg0));
  }
}
Variant c_Memcached::i_replace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("replace", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_replace(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replace(arg0, arg1, arg2));
  }
}
Variant c_Memcached::i_flush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_flush());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_flush(arg0));
  }
}
Variant c_Memcached::i_cas(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("cas", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_cas(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_cas(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcached::i_prependbykey(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("prependbykey", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_prependbykey(arg0, arg1, arg2));
  }
}
Variant c_Memcached::ifa_getmulti(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("getmulti", count, 1, 3, 1);
  if (count <= 1) return (self->t_getmulti(a0));
  if (count == 2) return (self->t_getmulti(a0, ref(a1)));
  return (self->t_getmulti(a0, ref(a1), a2));
}
Variant c_Memcached::ifa_getresultmessage(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getresultmessage", 0, 1);
  return (self->t_getresultmessage());
}
Variant c_Memcached::ifa_getresultcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getresultcode", 0, 1);
  return (self->t_getresultcode());
}
Variant c_Memcached::ifa_setbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("setbykey", count, 3, 4, 1);
  if (count <= 3) return (self->t_setbykey(a0, a1, a2));
  return (self->t_setbykey(a0, a1, a2, a3));
}
Variant c_Memcached::ifa_addserver(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addserver", count, 2, 3, 1);
  if (count <= 2) return (self->t_addserver(a0, a1));
  return (self->t_addserver(a0, a1, a2));
}
Variant c_Memcached::ifa_set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("set", count, 2, 3, 1);
  if (count <= 2) return (self->t_set(a0, a1));
  return (self->t_set(a0, a1, a2));
}
Variant c_Memcached::ifa_appendbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("appendbykey", count, 3, 3, 1);
  return (self->t_appendbykey(a0, a1, a2));
}
Variant c_Memcached::ifa_getdelayed(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("getdelayed", count, 1, 3, 1);
  if (count <= 1) return (self->t_getdelayed(a0));
  if (count == 2) return (self->t_getdelayed(a0, a1));
  return (self->t_getdelayed(a0, a1, a2));
}
Variant c_Memcached::ifa_setoption(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setoption", count, 2, 2, 1);
  return (self->t_setoption(a0, a1));
}
Variant c_Memcached::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcached::ifa_prepend(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("prepend", count, 2, 2, 1);
  return (self->t_prepend(a0, a1));
}
Variant c_Memcached::ifa_append(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("append", count, 2, 2, 1);
  return (self->t_append(a0, a1));
}
Variant c_Memcached::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) return (self->t___construct(), null);
  return (self->t___construct(a0), null);
}
Variant c_Memcached::ifa_replacebykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("replacebykey", count, 3, 4, 1);
  if (count <= 3) return (self->t_replacebykey(a0, a1, a2));
  return (self->t_replacebykey(a0, a1, a2, a3));
}
Variant c_Memcached::ifa_casbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("casbykey", count, 4, 5, 1);
  if (count <= 4) return (self->t_casbykey(a0, a1, a2, a3));
  return (self->t_casbykey(a0, a1, a2, a3, a4));
}
Variant c_Memcached::ifa_increment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  if (count <= 1) return (self->t_increment(a0));
  return (self->t_increment(a0, a1));
}
Variant c_Memcached::ifa_decrement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  if (count <= 1) return (self->t_decrement(a0));
  return (self->t_decrement(a0, a1));
}
Variant c_Memcached::ifa_getstats(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstats", 0, 1);
  return (self->t_getstats());
}
Variant c_Memcached::ifa_getdelayedbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getdelayedbykey", count, 2, 4, 1);
  if (count <= 2) return (self->t_getdelayedbykey(a0, a1));
  if (count == 3) return (self->t_getdelayedbykey(a0, a1, a2));
  return (self->t_getdelayedbykey(a0, a1, a2, a3));
}
Variant c_Memcached::ifa_setmulti(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setmulti", count, 1, 2, 1);
  if (count <= 1) return (self->t_setmulti(a0));
  return (self->t_setmulti(a0, a1));
}
Variant c_Memcached::ifa_getbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getbykey", count, 2, 4, 1);
  if (count <= 2) return (self->t_getbykey(a0, a1));
  if (count == 3) return (self->t_getbykey(a0, a1, a2));
  return (self->t_getbykey(a0, a1, a2, ref(a3)));
}
Variant c_Memcached::ifa_deletebykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("deletebykey", count, 2, 3, 1);
  if (count <= 2) return (self->t_deletebykey(a0, a1));
  return (self->t_deletebykey(a0, a1, a2));
}
Variant c_Memcached::ifa_get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("get", count, 1, 3, 1);
  if (count <= 1) return (self->t_get(a0));
  if (count == 2) return (self->t_get(a0, a1));
  return (self->t_get(a0, a1, ref(a2)));
}
Variant c_Memcached::ifa_getoption(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getoption", count, 1, 1, 1);
  return (self->t_getoption(a0));
}
Variant c_Memcached::ifa_add(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("add", count, 2, 3, 1);
  if (count <= 2) return (self->t_add(a0, a1));
  return (self->t_add(a0, a1, a2));
}
Variant c_Memcached::ifa_getserverbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getserverbykey", count, 1, 1, 1);
  return (self->t_getserverbykey(a0));
}
Variant c_Memcached::ifa_getserverlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getserverlist", 0, 1);
  return (self->t_getserverlist());
}
Variant c_Memcached::ifa_addbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("addbykey", count, 3, 4, 1);
  if (count <= 3) return (self->t_addbykey(a0, a1, a2));
  return (self->t_addbykey(a0, a1, a2, a3));
}
Variant c_Memcached::ifa_getversion(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcached::ifa_fetchall(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fetchall", 0, 1);
  return (self->t_fetchall());
}
Variant c_Memcached::ifa_delete(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  if (count <= 1) return (self->t_delete(a0));
  return (self->t_delete(a0, a1));
}
Variant c_Memcached::ifa_setmultibykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setmultibykey", count, 2, 3, 1);
  if (count <= 2) return (self->t_setmultibykey(a0, a1));
  return (self->t_setmultibykey(a0, a1, a2));
}
Variant c_Memcached::ifa_getmultibykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("getmultibykey", count, 2, 4, 1);
  if (count <= 2) return (self->t_getmultibykey(a0, a1));
  if (count == 3) return (self->t_getmultibykey(a0, a1, ref(a2)));
  return (self->t_getmultibykey(a0, a1, ref(a2), a3));
}
Variant c_Memcached::ifa_fetch(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fetch", 0, 1);
  return (self->t_fetch());
}
Variant c_Memcached::ifa_addservers(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addservers", count, 1, 1, 1);
  return (self->t_addservers(a0));
}
Variant c_Memcached::ifa_replace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("replace", count, 2, 3, 1);
  if (count <= 2) return (self->t_replace(a0, a1));
  return (self->t_replace(a0, a1, a2));
}
Variant c_Memcached::ifa_flush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  if (count <= 0) return (self->t_flush());
  return (self->t_flush(a0));
}
Variant c_Memcached::ifa_cas(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("cas", count, 3, 4, 1);
  if (count <= 3) return (self->t_cas(a0, a1, a2));
  return (self->t_cas(a0, a1, a2, a3));
}
Variant c_Memcached::ifa_prependbykey(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcached *self = NULL;
  p_Memcached pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcached*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("prependbykey", count, 3, 3, 1);
  return (self->t_prependbykey(a0, a1, a2));
}
bool c_Memcached::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x38998A4858382D82LL, NAMSTR(s_sys_ss6c5e1663, "getMultiByKey")) {
        mcp.ci = &c_Memcached::ci_getmultibykey;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x4F31CCB24341F605LL, NAMSTR(s_sys_ss0939351d, "getMulti")) {
        mcp.ci = &c_Memcached::ci_getmulti;
        return true;
      }
      HASH_GUARD_LITSTR(0x6FB9087461635285LL, NAMSTR(s_sys_ss2f8e5140, "setOption")) {
        mcp.ci = &c_Memcached::ci_setoption;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x06E29D289FC0AF87LL, NAMSTR(s_sys_ss41cb9189, "addServers")) {
        mcp.ci = &c_Memcached::ci_addservers;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss6db5a215, "add")) {
        mcp.ci = &c_Memcached::ci_add;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x1C80DDD00742930FLL, NAMSTR(s_sys_ss0fe15fdf, "getServerByKey")) {
        mcp.ci = &c_Memcached::ci_getserverbykey;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss1b5e3529, "getVersion")) {
        mcp.ci = &c_Memcached::ci_getversion;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x65C5EF328C77C917LL, NAMSTR(s_sys_ss2da130db, "prepend")) {
        mcp.ci = &c_Memcached::ci_prepend;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x3B7F419ECE80EE19LL, NAMSTR(s_sys_ss038035c6, "setMulti")) {
        mcp.ci = &c_Memcached::ci_setmulti;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss0241fb06, "set")) {
        mcp.ci = &c_Memcached::ci_set;
        return true;
      }
      HASH_GUARD_LITSTR(0x573E46DE52BFF8A1LL, NAMSTR(s_sys_ss449b0823, "cas")) {
        mcp.ci = &c_Memcached::ci_cas;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss153b6861, "get")) {
        mcp.ci = &c_Memcached::ci_get;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x00FBB16B058D5C2FLL, NAMSTR(s_sys_ss69e3dc9b, "getDelayedByKey")) {
        mcp.ci = &c_Memcached::ci_getdelayedbykey;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7F4CB6AD55C9F7B8LL, NAMSTR(s_sys_ss5097084d, "setByKey")) {
        mcp.ci = &c_Memcached::ci_setbykey;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x303DBA91556D773DLL, NAMSTR(s_sys_ss18bebdc2, "replaceByKey")) {
        mcp.ci = &c_Memcached::ci_replacebykey;
        return true;
      }
      break;
    case 64:
      HASH_GUARD_LITSTR(0x402DD1A85CAEA6C0LL, NAMSTR(s_sys_ss7d2a9ef4, "getOption")) {
        mcp.ci = &c_Memcached::ci_getoption;
        return true;
      }
      break;
    case 65:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss21dd0673, "fetchAll")) {
        mcp.ci = &c_Memcached::ci_fetchall;
        return true;
      }
      break;
    case 66:
      HASH_GUARD_LITSTR(0x4DEE4A472DC69EC2LL, NAMSTR(s_sys_ss459a2a12, "append")) {
        mcp.ci = &c_Memcached::ci_append;
        return true;
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x5BB1AF59B155E144LL, NAMSTR(s_sys_ss2ec4df0b, "getResultMessage")) {
        mcp.ci = &c_Memcached::ci_getresultmessage;
        return true;
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss3029c43a, "replace")) {
        mcp.ci = &c_Memcached::ci_replace;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss312d8bcf, "increment")) {
        mcp.ci = &c_Memcached::ci_increment;
        return true;
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss4ca209c3, "delete")) {
        mcp.ci = &c_Memcached::ci_delete;
        return true;
      }
      break;
    case 87:
      HASH_GUARD_LITSTR(0x344A3DC90A5BD1D7LL, NAMSTR(s_sys_ss33591ad3, "getByKey")) {
        mcp.ci = &c_Memcached::ci_getbykey;
        return true;
      }
      HASH_GUARD_LITSTR(0x5044B38DE4461A57LL, NAMSTR(s_sys_ss7e17c9c6, "getServerList")) {
        mcp.ci = &c_Memcached::ci_getserverlist;
        return true;
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss3a0ef2e6, "getStats")) {
        mcp.ci = &c_Memcached::ci_getstats;
        return true;
      }
      break;
    case 90:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2a19cdf6, "decrement")) {
        mcp.ci = &c_Memcached::ci_decrement;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_Memcached::ci___construct;
        return true;
      }
      break;
    case 96:
      HASH_GUARD_LITSTR(0x086C8D4E944C0FE0LL, NAMSTR(s_sys_ss31a97990, "appendByKey")) {
        mcp.ci = &c_Memcached::ci_appendbykey;
        return true;
      }
      break;
    case 102:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss163bad01, "addServer")) {
        mcp.ci = &c_Memcached::ci_addserver;
        return true;
      }
      break;
    case 110:
      HASH_GUARD_LITSTR(0x0EE9EC6BCA56B46ELL, NAMSTR(s_sys_ss106b4dd7, "prependByKey")) {
        mcp.ci = &c_Memcached::ci_prependbykey;
        return true;
      }
      break;
    case 114:
      HASH_GUARD_LITSTR(0x3B59E52110B990F2LL, NAMSTR(s_sys_ss172df677, "deleteByKey")) {
        mcp.ci = &c_Memcached::ci_deletebykey;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_Memcached::ci___destruct;
        return true;
      }
      break;
    case 118:
      HASH_GUARD_LITSTR(0x18A8B25BF74FA276LL, NAMSTR(s_sys_ss4bab1591, "getDelayed")) {
        mcp.ci = &c_Memcached::ci_getdelayed;
        return true;
      }
      break;
    case 119:
      HASH_GUARD_LITSTR(0x03F8E65E47097177LL, NAMSTR(s_sys_ss6ae7fa54, "addByKey")) {
        mcp.ci = &c_Memcached::ci_addbykey;
        return true;
      }
      HASH_GUARD_LITSTR(0x6AB1842FE8684D77LL, NAMSTR(s_sys_ss1cfbc2c8, "setMultiByKey")) {
        mcp.ci = &c_Memcached::ci_setmultibykey;
        return true;
      }
      break;
    case 121:
      HASH_GUARD_LITSTR(0x50BC469CFA9BF579LL, NAMSTR(s_sys_ss3bd544b6, "casByKey")) {
        mcp.ci = &c_Memcached::ci_casbykey;
        return true;
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        mcp.ci = &c_Memcached::ci_flush;
        return true;
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss0b929a80, "fetch")) {
        mcp.ci = &c_Memcached::ci_fetch;
        return true;
      }
      break;
    case 125:
      HASH_GUARD_LITSTR(0x3F460132535C00FDLL, NAMSTR(s_sys_ss4efec04e, "getResultCode")) {
        mcp.ci = &c_Memcached::ci_getresultcode;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Memcached::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Memcached *c_Memcached::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_Memcached::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_Memcached::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_Memcached::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Memcached::ci___construct;
  mcp.obj = this;
}
void c_Memcached::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_Memcached = {
  c_Memcached::os_getInit,
  c_Memcached::os_get,
  c_Memcached::os_lval,
  c_Memcached::os_invoke,
  c_Memcached::os_constant,
  c_Memcached::os_get_call_info
};
Object co_DOMComment(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMComment)())->dynCreate(params, init));
}
Object coo_DOMComment() {
  Object r(NEW(c_DOMComment)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
Variant c_DOMComment::os_getInit(CStrRef s) {
  return c_DOMCharacterData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
Variant c_DOMComment::os_get(CStrRef s) {
  return c_DOMCharacterData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
Variant &c_DOMComment::os_lval(CStrRef s) {
  return c_DOMCharacterData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
void c_DOMComment::o_getArray(Array &props) const {
  c_DOMCharacterData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
void c_DOMComment::o_setArray(CArrRef props) {
  c_DOMCharacterData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
Variant * c_DOMComment::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
Variant * c_DOMComment::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMCharacterData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
Variant * c_DOMComment::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMComment
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
Variant c_DOMComment::os_constant(const char *s) {
  return c_DOMCharacterData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMComment
IMPLEMENT_CLASS(DOMComment)
void c_DOMComment::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMComment::cloneImpl() {
  c_DOMComment *obj = NEW(c_DOMComment)();
  cloneSet(obj);
  return obj;
}
void c_DOMComment::cloneSet(c_DOMComment *clone) {
  c_DOMCharacterData::cloneSet(clone);
}
Variant c_DOMComment::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
        if (count <= 0) return (t___construct(), null);
        else return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMComment::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMCharacterData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMComment::ci___destruct((void*)&c_DOMComment::i___destruct, (void*)&c_DOMComment::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMComment::ci___construct((void*)&c_DOMComment::i___construct, (void*)&c_DOMComment::ifa___construct, 1, 4, 0x0000000000000000LL);
Variant c_DOMComment::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMComment::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMComment::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMComment::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMComment *self = NULL;
  p_DOMComment pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMComment*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) return (self->t___construct(), null);
  return (self->t___construct(a0), null);
}
bool c_DOMComment::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMComment::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMComment::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMCharacterData::os_get_call_info(mcp, hash);
}
bool c_DOMComment::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMComment *c_DOMComment::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMComment::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 1) throw_toomany_arguments("__construct", 1, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    } while (false);
  }
  return this;
}
void c_DOMComment::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  } while (false);
}
void c_DOMComment::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMComment::ci___construct;
  mcp.obj = this;
}
void c_DOMComment::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 1) throw_toomany_arguments("__construct", 1, 1);
  if (count <= 0) (t___construct(), null);
  else (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMComment = {
  c_DOMComment::os_getInit,
  c_DOMComment::os_get,
  c_DOMComment::os_lval,
  c_DOMComment::os_invoke,
  c_DOMComment::os_constant,
  c_DOMComment::os_get_call_info
};
Object co_SQLite3(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3)())->dynCreate(params, init));
}
Object coo_SQLite3() {
  Object r(NEW(c_SQLite3)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
Variant c_SQLite3::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
Variant c_SQLite3::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
Variant &c_SQLite3::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
void c_SQLite3::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
void c_SQLite3::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
Variant * c_SQLite3::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
Variant * c_SQLite3::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
Variant * c_SQLite3::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
Variant c_SQLite3::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3
IMPLEMENT_CLASS(SQLite3)
void c_SQLite3::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3::cloneImpl() {
  c_SQLite3 *obj = NEW(c_SQLite3)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3::cloneSet(c_SQLite3 *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss500f232f, "lasterrormsg")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
        return (t_lasterrormsg());
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss2351cce7, "openblob")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
        if (count <= 3) return (t_openblob(a0, a1, a2));
        else return (t_openblob(a0, a1, a2, a3));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss786e966e, "createaggregate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
        if (count <= 3) return (t_createaggregate(a0, a1, a2));
        else return (t_createaggregate(a0, a1, a2, a3));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss39fdd73a, "open")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
        if (count <= 1) return (t_open(a0), null);
        else if (count == 2) return (t_open(a0, a1), null);
        else return (t_open(a0, a1, a2), null);
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss556e9ccf, "lasterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
        return (t_lasterrorcode());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss17f0e883, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss1f612ec4, "createfunction")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
        if (count <= 2) return (t_createfunction(a0, a1));
        else return (t_createfunction(a0, a1, a2));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss2a44d071, "changes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("changes", 0, 1);
        return (t_changes());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss4d19daaa, "loadextension")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
        return (t_loadextension(a0));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss1bbd440a, "lastinsertrowid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
        return (t_lastinsertrowid());
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss7cd91db4, "version")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("version", 0, 1);
        return (t_version());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss733880ae, "querysingle")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
        if (count <= 1) return (t_querysingle(a0));
        else return (t_querysingle(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss48724660, "prepare")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
        return (t_prepare(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss69f4b5d8, "escapestring")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
        return (t_escapestring(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3::ci_exec((void*)&c_SQLite3::i_exec, (void*)&c_SQLite3::ifa_exec, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_version((void*)&c_SQLite3::i_version, (void*)&c_SQLite3::ifa_version, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_loadextension((void*)&c_SQLite3::i_loadextension, (void*)&c_SQLite3::ifa_loadextension, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci___destruct((void*)&c_SQLite3::i___destruct, (void*)&c_SQLite3::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_createfunction((void*)&c_SQLite3::i_createfunction, (void*)&c_SQLite3::ifa_createfunction, 3, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci___construct((void*)&c_SQLite3::i___construct, (void*)&c_SQLite3::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lastinsertrowid((void*)&c_SQLite3::i_lastinsertrowid, (void*)&c_SQLite3::ifa_lastinsertrowid, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_query((void*)&c_SQLite3::i_query, (void*)&c_SQLite3::ifa_query, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_close((void*)&c_SQLite3::i_close, (void*)&c_SQLite3::ifa_close, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_escapestring((void*)&c_SQLite3::i_escapestring, (void*)&c_SQLite3::ifa_escapestring, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lasterrormsg((void*)&c_SQLite3::i_lasterrormsg, (void*)&c_SQLite3::ifa_lasterrormsg, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_createaggregate((void*)&c_SQLite3::i_createaggregate, (void*)&c_SQLite3::ifa_createaggregate, 4, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_open((void*)&c_SQLite3::i_open, (void*)&c_SQLite3::ifa_open, 3, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_changes((void*)&c_SQLite3::i_changes, (void*)&c_SQLite3::ifa_changes, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_openblob((void*)&c_SQLite3::i_openblob, (void*)&c_SQLite3::ifa_openblob, 4, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_lasterrorcode((void*)&c_SQLite3::i_lasterrorcode, (void*)&c_SQLite3::ifa_lasterrorcode, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_prepare((void*)&c_SQLite3::i_prepare, (void*)&c_SQLite3::ifa_prepare, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3::ci_querysingle((void*)&c_SQLite3::i_querysingle, (void*)&c_SQLite3::ifa_querysingle, 2, 4, 0x0000000000000000LL);
Variant c_SQLite3::i_exec(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_exec(arg0));
  }
}
Variant c_SQLite3::i_version(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("version", 0, 1);
  return (self->t_version());
}
Variant c_SQLite3::i_loadextension(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadextension(arg0));
  }
}
Variant c_SQLite3::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3::i_createfunction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_createfunction(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createfunction(arg0, arg1, arg2));
  }
}
Variant c_SQLite3::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3::i_lastinsertrowid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
  return (self->t_lastinsertrowid());
}
Variant c_SQLite3::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_query(arg0));
  }
}
Variant c_SQLite3::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3::i_escapestring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_escapestring(arg0));
  }
}
Variant c_SQLite3::i_lasterrormsg(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
  return (self->t_lasterrormsg());
}
Variant c_SQLite3::i_createaggregate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_createaggregate(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createaggregate(arg0, arg1, arg2, arg3));
  }
}
Variant c_SQLite3::i_open(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_open(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_open(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_open(arg0, arg1, arg2), null);
  }
}
Variant c_SQLite3::i_changes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("changes", 0, 1);
  return (self->t_changes());
}
Variant c_SQLite3::i_openblob(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_openblob(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_openblob(arg0, arg1, arg2, arg3));
  }
}
Variant c_SQLite3::i_lasterrorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
  return (self->t_lasterrorcode());
}
Variant c_SQLite3::i_prepare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_prepare(arg0));
  }
}
Variant c_SQLite3::i_querysingle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_querysingle(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_querysingle(arg0, arg1));
  }
}
Variant c_SQLite3::ifa_exec(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  return (self->t_exec(a0));
}
Variant c_SQLite3::ifa_version(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("version", 0, 1);
  return (self->t_version());
}
Variant c_SQLite3::ifa_loadextension(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadextension", count, 1, 1, 1);
  return (self->t_loadextension(a0));
}
Variant c_SQLite3::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3::ifa_createfunction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createfunction", count, 2, 3, 1);
  if (count <= 2) return (self->t_createfunction(a0, a1));
  return (self->t_createfunction(a0, a1, a2));
}
Variant c_SQLite3::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3::ifa_lastinsertrowid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lastinsertrowid", 0, 1);
  return (self->t_lastinsertrowid());
}
Variant c_SQLite3::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  return (self->t_query(a0));
}
Variant c_SQLite3::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_SQLite3::ifa_escapestring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("escapestring", count, 1, 1, 1);
  return (self->t_escapestring(a0));
}
Variant c_SQLite3::ifa_lasterrormsg(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrormsg", 0, 1);
  return (self->t_lasterrormsg());
}
Variant c_SQLite3::ifa_createaggregate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("createaggregate", count, 3, 4, 1);
  if (count <= 3) return (self->t_createaggregate(a0, a1, a2));
  return (self->t_createaggregate(a0, a1, a2, a3));
}
Variant c_SQLite3::ifa_open(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("open", count, 1, 3, 1);
  if (count <= 1) return (self->t_open(a0), null);
  if (count == 2) return (self->t_open(a0, a1), null);
  return (self->t_open(a0, a1, a2), null);
}
Variant c_SQLite3::ifa_changes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("changes", 0, 1);
  return (self->t_changes());
}
Variant c_SQLite3::ifa_openblob(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("openblob", count, 3, 4, 1);
  if (count <= 3) return (self->t_openblob(a0, a1, a2));
  return (self->t_openblob(a0, a1, a2, a3));
}
Variant c_SQLite3::ifa_lasterrorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("lasterrorcode", 0, 1);
  return (self->t_lasterrorcode());
}
Variant c_SQLite3::ifa_prepare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("prepare", count, 1, 1, 1);
  return (self->t_prepare(a0));
}
Variant c_SQLite3::ifa_querysingle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3 *self = NULL;
  p_SQLite3 pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("querysingle", count, 1, 2, 1);
  if (count <= 1) return (self->t_querysingle(a0));
  return (self->t_querysingle(a0, a1));
}
bool c_SQLite3::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        mcp.ci = &c_SQLite3::ci_close;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6081F282094466C2LL, NAMSTR(s_sys_ss500f232f, "lasterrormsg")) {
        mcp.ci = &c_SQLite3::ci_lasterrormsg;
        return true;
      }
      HASH_GUARD_LITSTR(0x65BD6700742BF3C2LL, NAMSTR(s_sys_ss2351cce7, "openblob")) {
        mcp.ci = &c_SQLite3::ci_openblob;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x3AA4CCEC6BD68143LL, NAMSTR(s_sys_ss786e966e, "createaggregate")) {
        mcp.ci = &c_SQLite3::ci_createaggregate;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x21F68C010C124BC4LL, NAMSTR(s_sys_ss39fdd73a, "open")) {
        mcp.ci = &c_SQLite3::ci_open;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x632B468FC2FCAB0ALL, NAMSTR(s_sys_ss556e9ccf, "lasterrorcode")) {
        mcp.ci = &c_SQLite3::ci_lasterrorcode;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss17f0e883, "exec")) {
        mcp.ci = &c_SQLite3::ci_exec;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x7CECF508291057CDLL, NAMSTR(s_sys_ss1f612ec4, "createfunction")) {
        mcp.ci = &c_SQLite3::ci_createfunction;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x64D2BDB189B02819LL, NAMSTR(s_sys_ss2a44d071, "changes")) {
        mcp.ci = &c_SQLite3::ci_changes;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SQLite3::ci___construct;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x1B3CDE890A487664LL, NAMSTR(s_sys_ss4d19daaa, "loadextension")) {
        mcp.ci = &c_SQLite3::ci_loadextension;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x5024F08DB0FDCBE6LL, NAMSTR(s_sys_ss1bbd440a, "lastinsertrowid")) {
        mcp.ci = &c_SQLite3::ci_lastinsertrowid;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x5AE41239FF63D86ALL, NAMSTR(s_sys_ss7cd91db4, "version")) {
        mcp.ci = &c_SQLite3::ci_version;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x156B1FAE4132ABEELL, NAMSTR(s_sys_ss733880ae, "querysingle")) {
        mcp.ci = &c_SQLite3::ci_querysingle;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss48724660, "prepare")) {
        mcp.ci = &c_SQLite3::ci_prepare;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SQLite3::ci___destruct;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x607C4C73BB251635LL, NAMSTR(s_sys_ss69f4b5d8, "escapestring")) {
        mcp.ci = &c_SQLite3::ci_escapestring;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        mcp.ci = &c_SQLite3::ci_query;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SQLite3 *c_SQLite3::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3::ci___construct;
  mcp.obj = this;
}
void c_SQLite3::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SQLite3 = {
  c_SQLite3::os_getInit,
  c_SQLite3::os_get,
  c_SQLite3::os_lval,
  c_SQLite3::os_invoke,
  c_SQLite3::os_constant,
  c_SQLite3::os_get_call_info
};
Object co_DOMAttr(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMAttr)())->dynCreate(params, init));
}
Object coo_DOMAttr() {
  Object r(NEW(c_DOMAttr)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
Variant c_DOMAttr::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
Variant c_DOMAttr::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
Variant &c_DOMAttr::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
void c_DOMAttr::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
void c_DOMAttr::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
Variant * c_DOMAttr::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
Variant * c_DOMAttr::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
Variant * c_DOMAttr::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMAttr
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
Variant c_DOMAttr::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMAttr
IMPLEMENT_CLASS(DOMAttr)
void c_DOMAttr::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMAttr::cloneImpl() {
  c_DOMAttr *obj = NEW(c_DOMAttr)();
  cloneSet(obj);
  return obj;
}
void c_DOMAttr::cloneSet(c_DOMAttr *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMAttr::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss78810491, "isId")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("isid", 0, 1);
        return (t_isid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMAttr::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMAttr::ci_isid((void*)&c_DOMAttr::i_isid, (void*)&c_DOMAttr::ifa_isid, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___destruct((void*)&c_DOMAttr::i___destruct, (void*)&c_DOMAttr::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___set((void*)&c_DOMAttr::i___set, (void*)&c_DOMAttr::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___construct((void*)&c_DOMAttr::i___construct, (void*)&c_DOMAttr::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMAttr::ci___get((void*)&c_DOMAttr::i___get, (void*)&c_DOMAttr::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMAttr::i_isid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("isid", 0, 1);
  return (self->t_isid());
}
Variant c_DOMAttr::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMAttr::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMAttr::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMAttr::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMAttr::ifa_isid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("isid", 0, 1);
  return (self->t_isid());
}
Variant c_DOMAttr::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMAttr::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMAttr::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMAttr::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMAttr *self = NULL;
  p_DOMAttr pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMAttr*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMAttr::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMAttr::ci___destruct;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x30A9329415D17F24LL, NAMSTR(s_sys_ss78810491, "isId")) {
        mcp.ci = &c_DOMAttr::ci_isid;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMAttr::ci___set;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMAttr::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMAttr::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMAttr::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMAttr *c_DOMAttr::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMAttr::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMAttr::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMAttr::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMAttr::ci___construct;
  mcp.obj = this;
}
void c_DOMAttr::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMAttr = {
  c_DOMAttr::os_getInit,
  c_DOMAttr::os_get,
  c_DOMAttr::os_lval,
  c_DOMAttr::os_invoke,
  c_DOMAttr::os_constant,
  c_DOMAttr::os_get_call_info
};
Object co_SoapVar(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapVar)())->dynCreate(params, init));
}
Object coo_SoapVar() {
  Object r(NEW(c_SoapVar)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
Variant c_SoapVar::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
Variant c_SoapVar::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
Variant &c_SoapVar::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
void c_SoapVar::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
void c_SoapVar::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
Variant * c_SoapVar::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
Variant * c_SoapVar::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
Variant * c_SoapVar::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapVar
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
Variant c_SoapVar::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapVar
IMPLEMENT_CLASS(SoapVar)
void c_SoapVar::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapVar::cloneImpl() {
  c_SoapVar *obj = NEW(c_SoapVar)();
  cloneSet(obj);
  return obj;
}
void c_SoapVar::cloneSet(c_SoapVar *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapVar::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapVar::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapVar::ci___destruct((void*)&c_SoapVar::i___destruct, (void*)&c_SoapVar::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapVar::ci___construct((void*)&c_SoapVar::i___construct, (void*)&c_SoapVar::ifa___construct, 6, 4, 0x0000000000000000LL);
Variant c_SoapVar::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapVar::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant c_SoapVar::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapVar::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapVar *self = NULL;
  p_SoapVar pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapVar*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  if (count == 5) return (self->t___construct(a0, a1, a2, a3, a4), null);
  return (self->t___construct(a0, a1, a2, a3, a4, a5), null);
}
bool c_SoapVar::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapVar::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapVar::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapVar::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapVar *c_SoapVar::create(Variant a0, Variant a1, String a2, String a3, String a4, String a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapVar::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapVar::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapVar::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapVar::ci___construct;
  mcp.obj = this;
}
void c_SoapVar::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
struct ObjectStaticCallbacks cw_SoapVar = {
  c_SoapVar::os_getInit,
  c_SoapVar::os_get,
  c_SoapVar::os_lval,
  c_SoapVar::os_invoke,
  c_SoapVar::os_constant,
  c_SoapVar::os_get_call_info
};
Object co_DOMNamedNodeMap(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNamedNodeMap)())->dynCreate(params, init));
}
Object coo_DOMNamedNodeMap() {
  Object r(NEW(c_DOMNamedNodeMap)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
Variant &c_DOMNamedNodeMap::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
void c_DOMNamedNodeMap::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
Variant * c_DOMNamedNodeMap::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNamedNodeMap
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
Variant c_DOMNamedNodeMap::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNamedNodeMap
IMPLEMENT_CLASS(DOMNamedNodeMap)
void c_DOMNamedNodeMap::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNamedNodeMap::cloneImpl() {
  c_DOMNamedNodeMap *obj = NEW(c_DOMNamedNodeMap)();
  cloneSet(obj);
  return obj;
}
void c_DOMNamedNodeMap::cloneSet(c_DOMNamedNodeMap *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNamedNodeMap::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss1247a693, "item")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
        return (t_item(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss21369918, "getNamedItem")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
        return (t_getnameditem(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss7cd11f20, "getNamedItemNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
        return (t_getnameditemns(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNamedNodeMap::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNamedNodeMap::ci_item((void*)&c_DOMNamedNodeMap::i_item, (void*)&c_DOMNamedNodeMap::ifa_item, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getnameditem((void*)&c_DOMNamedNodeMap::i_getnameditem, (void*)&c_DOMNamedNodeMap::ifa_getnameditem, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___destruct((void*)&c_DOMNamedNodeMap::i___destruct, (void*)&c_DOMNamedNodeMap::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___set((void*)&c_DOMNamedNodeMap::i___set, (void*)&c_DOMNamedNodeMap::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___construct((void*)&c_DOMNamedNodeMap::i___construct, (void*)&c_DOMNamedNodeMap::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getiterator((void*)&c_DOMNamedNodeMap::i_getiterator, (void*)&c_DOMNamedNodeMap::ifa_getiterator, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci___get((void*)&c_DOMNamedNodeMap::i___get, (void*)&c_DOMNamedNodeMap::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNamedNodeMap::ci_getnameditemns((void*)&c_DOMNamedNodeMap::i_getnameditemns, (void*)&c_DOMNamedNodeMap::ifa_getnameditemns, 2, 4, 0x0000000000000000LL);
Variant c_DOMNamedNodeMap::i_item(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_item(arg0));
  }
}
Variant c_DOMNamedNodeMap::i_getnameditem(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getnameditem(arg0));
  }
}
Variant c_DOMNamedNodeMap::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNamedNodeMap::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNamedNodeMap::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNamedNodeMap::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNamedNodeMap::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNamedNodeMap::i_getnameditemns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getnameditemns(arg0, arg1));
  }
}
Variant c_DOMNamedNodeMap::ifa_item(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("item", count, 1, 1, 1);
  return (self->t_item(a0));
}
Variant c_DOMNamedNodeMap::ifa_getnameditem(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getnameditem", count, 1, 1, 1);
  return (self->t_getnameditem(a0));
}
Variant c_DOMNamedNodeMap::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNamedNodeMap::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNamedNodeMap::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNamedNodeMap::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_DOMNamedNodeMap::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMNamedNodeMap::ifa_getnameditemns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNamedNodeMap *self = NULL;
  p_DOMNamedNodeMap pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNamedNodeMap*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getnameditemns", count, 2, 2, 1);
  return (self->t_getnameditemns(a0, a1));
}
bool c_DOMNamedNodeMap::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getiterator;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___set;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x0A41DBE0830902C6LL, NAMSTR(s_sys_ss1247a693, "item")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_item;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x5D3CEC627F9ADC3ALL, NAMSTR(s_sys_ss21369918, "getNamedItem")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditem;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x53B4D840FF4F0F1BLL, NAMSTR(s_sys_ss7cd11f20, "getNamedItemNS")) {
        mcp.ci = &c_DOMNamedNodeMap::ci_getnameditemns;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMNamedNodeMap::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNamedNodeMap::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMNamedNodeMap *c_DOMNamedNodeMap::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNamedNodeMap::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNamedNodeMap::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNamedNodeMap::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNamedNodeMap::ci___construct;
  mcp.obj = this;
}
void c_DOMNamedNodeMap::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNamedNodeMap = {
  c_DOMNamedNodeMap::os_getInit,
  c_DOMNamedNodeMap::os_get,
  c_DOMNamedNodeMap::os_lval,
  c_DOMNamedNodeMap::os_invoke,
  c_DOMNamedNodeMap::os_constant,
  c_DOMNamedNodeMap::os_get_call_info
};
Object co_SQLite3Result(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SQLite3Result)())->dynCreate(params, init));
}
Object coo_SQLite3Result() {
  Object r(NEW(c_SQLite3Result)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
Variant c_SQLite3Result::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
Variant c_SQLite3Result::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
Variant &c_SQLite3Result::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
void c_SQLite3Result::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
void c_SQLite3Result::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
Variant * c_SQLite3Result::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
Variant * c_SQLite3Result::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
Variant * c_SQLite3Result::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SQLite3Result
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
Variant c_SQLite3Result::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SQLite3Result
IMPLEMENT_CLASS(SQLite3Result)
void c_SQLite3Result::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SQLite3Result::cloneImpl() {
  c_SQLite3Result *obj = NEW(c_SQLite3Result)();
  cloneSet(obj);
  return obj;
}
void c_SQLite3Result::cloneSet(c_SQLite3Result *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SQLite3Result::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss5c8999e5, "reset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("reset", 0, 1);
        return (t_reset());
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss64e0c478, "numcolumns")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
        return (t_numcolumns());
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss72bc97a5, "columnname")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
        return (t_columnname(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss42994feb, "fetcharray")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
        if (count <= 0) return (t_fetcharray());
        else return (t_fetcharray(a0));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss2d350426, "finalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
        return (t_finalize());
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss3c4bceb1, "columntype")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
        return (t_columntype(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SQLite3Result::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SQLite3Result::ci_columnname((void*)&c_SQLite3Result::i_columnname, (void*)&c_SQLite3Result::ifa_columnname, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_columntype((void*)&c_SQLite3Result::i_columntype, (void*)&c_SQLite3Result::ifa_columntype, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci___destruct((void*)&c_SQLite3Result::i___destruct, (void*)&c_SQLite3Result::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci___construct((void*)&c_SQLite3Result::i___construct, (void*)&c_SQLite3Result::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_numcolumns((void*)&c_SQLite3Result::i_numcolumns, (void*)&c_SQLite3Result::ifa_numcolumns, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_fetcharray((void*)&c_SQLite3Result::i_fetcharray, (void*)&c_SQLite3Result::ifa_fetcharray, 1, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_reset((void*)&c_SQLite3Result::i_reset, (void*)&c_SQLite3Result::ifa_reset, 0, 4, 0x0000000000000000LL);
CallInfo c_SQLite3Result::ci_finalize((void*)&c_SQLite3Result::i_finalize, (void*)&c_SQLite3Result::ifa_finalize, 0, 4, 0x0000000000000000LL);
Variant c_SQLite3Result::i_columnname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_columnname(arg0));
  }
}
Variant c_SQLite3Result::i_columntype(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_columntype(arg0));
  }
}
Variant c_SQLite3Result::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Result::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3Result::i_numcolumns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
  return (self->t_numcolumns());
}
Variant c_SQLite3Result::i_fetcharray(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetcharray());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_fetcharray(arg0));
  }
}
Variant c_SQLite3Result::i_reset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Result::i_finalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
  return (self->t_finalize());
}
Variant c_SQLite3Result::ifa_columnname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columnname", count, 1, 1, 1);
  return (self->t_columnname(a0));
}
Variant c_SQLite3Result::ifa_columntype(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("columntype", count, 1, 1, 1);
  return (self->t_columntype(a0));
}
Variant c_SQLite3Result::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SQLite3Result::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_SQLite3Result::ifa_numcolumns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("numcolumns", 0, 1);
  return (self->t_numcolumns());
}
Variant c_SQLite3Result::ifa_fetcharray(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetcharray", 1, 1);
  if (count <= 0) return (self->t_fetcharray());
  return (self->t_fetcharray(a0));
}
Variant c_SQLite3Result::ifa_reset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("reset", 0, 1);
  return (self->t_reset());
}
Variant c_SQLite3Result::ifa_finalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SQLite3Result *self = NULL;
  p_SQLite3Result pobj;
  if (mcp.obj) {
    self = static_cast<c_SQLite3Result*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("finalize", 0, 1);
  return (self->t_finalize());
}
bool c_SQLite3Result::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 0:
      HASH_GUARD_LITSTR(0x340A51AE22A924E0LL, NAMSTR(s_sys_ss5c8999e5, "reset")) {
        mcp.ci = &c_SQLite3Result::ci_reset;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SQLite3Result::ci___destruct;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x4C7702FC22784996LL, NAMSTR(s_sys_ss64e0c478, "numcolumns")) {
        mcp.ci = &c_SQLite3Result::ci_numcolumns;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x696EFC04EE7E47F8LL, NAMSTR(s_sys_ss72bc97a5, "columnname")) {
        mcp.ci = &c_SQLite3Result::ci_columnname;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x59F73C4DEF1C3A6BLL, NAMSTR(s_sys_ss42994feb, "fetcharray")) {
        mcp.ci = &c_SQLite3Result::ci_fetcharray;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x32A58B0CE493957CLL, NAMSTR(s_sys_ss2d350426, "finalize")) {
        mcp.ci = &c_SQLite3Result::ci_finalize;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x42EDB5CA009D8C6DLL, NAMSTR(s_sys_ss3c4bceb1, "columntype")) {
        mcp.ci = &c_SQLite3Result::ci_columntype;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SQLite3Result::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SQLite3Result::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SQLite3Result *c_SQLite3Result::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_SQLite3Result::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_SQLite3Result::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_SQLite3Result::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SQLite3Result::ci___construct;
  mcp.obj = this;
}
void c_SQLite3Result::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_SQLite3Result = {
  c_SQLite3Result::os_getInit,
  c_SQLite3Result::os_get,
  c_SQLite3Result::os_lval,
  c_SQLite3Result::os_invoke,
  c_SQLite3Result::os_constant,
  c_SQLite3Result::os_get_call_info
};
Object co_SimpleXMLElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SimpleXMLElement)())->dynCreate(params, init));
}
Object coo_SimpleXMLElement() {
  Object r(NEW(c_SimpleXMLElement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
Variant c_SimpleXMLElement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
Variant c_SimpleXMLElement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
Variant &c_SimpleXMLElement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
void c_SimpleXMLElement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
Variant * c_SimpleXMLElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SimpleXMLElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
Variant c_SimpleXMLElement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SimpleXMLElement
IMPLEMENT_CLASS(SimpleXMLElement)
void c_SimpleXMLElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SimpleXMLElement::cloneImpl() {
  c_SimpleXMLElement *obj = NEW(c_SimpleXMLElement)();
  cloneSet(obj);
  return obj;
}
void c_SimpleXMLElement::cloneSet(c_SimpleXMLElement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SimpleXMLElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss6cc6b367, "offsetExists")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
        return (t_offsetexists(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
        return (t_getiterator());
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss0d54babb, "count")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("count", 0, 1);
        return (t_count());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss793fe5ea, "addChild")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
        if (count <= 1) return (t_addchild(a0));
        else if (count == 2) return (t_addchild(a0, a1));
        else return (t_addchild(a0, a1, a2));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss48139170, "addAttribute")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
        if (count <= 1) return (t_addattribute(a0), null);
        else if (count == 2) return (t_addattribute(a0, a1), null);
        else return (t_addattribute(a0, a1, a2), null);
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss62975ff0, "offsetGet")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
        return (t_offsetget(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss1fe1e1ea, "xpath")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
        return (t_xpath(a0));
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss32d46a21, "__unset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
        return (t___unset(a0));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss0fc37e03, "attributes")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
        if (count <= 0) return (t_attributes());
        else if (count == 1) return (t_attributes(a0));
        else return (t_attributes(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else return (t___construct(a0, a1, a2, a3, a4), null);
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss3d20de82, "getName")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getname", 0, 1);
        return (t_getname());
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss36a35582, "getNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
        if (count <= 0) return (t_getnamespaces());
        else return (t_getnamespaces(a0));
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss20098bac, "asXML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
        if (count <= 0) return (t_asxml());
        else return (t_asxml(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss717877f6, "children")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("children", 2, 1);
        if (count <= 0) return (t_children());
        else if (count == 1) return (t_children(a0));
        else return (t_children(a0, a1));
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss4cfc0bef, "__isset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
        return (t___isset(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss6456a3a6, "getDocNamespaces")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
        if (count <= 0) return (t_getdocnamespaces());
        else return (t_getdocnamespaces(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss41d45e54, "offsetSet")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
        return (t_offsetset(a0, a1), null);
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss1a6fd792, "offsetUnset")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
        return (t_offsetunset(a0), null);
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss50ad79e8, "registerXPathNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
        return (t_registerxpathnamespace(a0, a1));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SimpleXMLElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SimpleXMLElement::ci_addattribute((void*)&c_SimpleXMLElement::i_addattribute, (void*)&c_SimpleXMLElement::ifa_addattribute, 3, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_count((void*)&c_SimpleXMLElement::i_count, (void*)&c_SimpleXMLElement::ifa_count, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___tostring((void*)&c_SimpleXMLElement::i___tostring, (void*)&c_SimpleXMLElement::ifa___tostring, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_xpath((void*)&c_SimpleXMLElement::i_xpath, (void*)&c_SimpleXMLElement::ifa_xpath, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___destruct((void*)&c_SimpleXMLElement::i___destruct, (void*)&c_SimpleXMLElement::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___set((void*)&c_SimpleXMLElement::i___set, (void*)&c_SimpleXMLElement::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___construct((void*)&c_SimpleXMLElement::i___construct, (void*)&c_SimpleXMLElement::ifa___construct, 5, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetexists((void*)&c_SimpleXMLElement::i_offsetexists, (void*)&c_SimpleXMLElement::ifa_offsetexists, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getiterator((void*)&c_SimpleXMLElement::i_getiterator, (void*)&c_SimpleXMLElement::ifa_getiterator, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_registerxpathnamespace((void*)&c_SimpleXMLElement::i_registerxpathnamespace, (void*)&c_SimpleXMLElement::ifa_registerxpathnamespace, 2, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetget((void*)&c_SimpleXMLElement::i_offsetget, (void*)&c_SimpleXMLElement::ifa_offsetget, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getnamespaces((void*)&c_SimpleXMLElement::i_getnamespaces, (void*)&c_SimpleXMLElement::ifa_getnamespaces, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___unset((void*)&c_SimpleXMLElement::i___unset, (void*)&c_SimpleXMLElement::ifa___unset, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_asxml((void*)&c_SimpleXMLElement::i_asxml, (void*)&c_SimpleXMLElement::ifa_asxml, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getdocnamespaces((void*)&c_SimpleXMLElement::i_getdocnamespaces, (void*)&c_SimpleXMLElement::ifa_getdocnamespaces, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetunset((void*)&c_SimpleXMLElement::i_offsetunset, (void*)&c_SimpleXMLElement::ifa_offsetunset, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___get((void*)&c_SimpleXMLElement::i___get, (void*)&c_SimpleXMLElement::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_children((void*)&c_SimpleXMLElement::i_children, (void*)&c_SimpleXMLElement::ifa_children, 2, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_addchild((void*)&c_SimpleXMLElement::i_addchild, (void*)&c_SimpleXMLElement::ifa_addchild, 3, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci___isset((void*)&c_SimpleXMLElement::i___isset, (void*)&c_SimpleXMLElement::ifa___isset, 1, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_getname((void*)&c_SimpleXMLElement::i_getname, (void*)&c_SimpleXMLElement::ifa_getname, 0, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_attributes((void*)&c_SimpleXMLElement::i_attributes, (void*)&c_SimpleXMLElement::ifa_attributes, 2, 4, 0x0000000000000000LL);
CallInfo c_SimpleXMLElement::ci_offsetset((void*)&c_SimpleXMLElement::i_offsetset, (void*)&c_SimpleXMLElement::ifa_offsetset, 2, 4, 0x0000000000000000LL);
Variant c_SimpleXMLElement::i_addattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addattribute(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addattribute(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addattribute(arg0, arg1, arg2), null);
  }
}
Variant c_SimpleXMLElement::i_count(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("count", 0, 1);
  return (self->t_count());
}
Variant c_SimpleXMLElement::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SimpleXMLElement::i_xpath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xpath(arg0));
  }
}
Variant c_SimpleXMLElement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElement::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SimpleXMLElement::i_offsetexists(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetexists(arg0));
  }
}
Variant c_SimpleXMLElement::i_getiterator(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_SimpleXMLElement::i_registerxpathnamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registerxpathnamespace(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_offsetget(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetget(arg0));
  }
}
Variant c_SimpleXMLElement::i_getnamespaces(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getnamespaces());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getnamespaces(arg0));
  }
}
Variant c_SimpleXMLElement::i___unset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___unset(arg0));
  }
}
Variant c_SimpleXMLElement::i_asxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_asxml());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_asxml(arg0));
  }
}
Variant c_SimpleXMLElement::i_getdocnamespaces(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getdocnamespaces());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getdocnamespaces(arg0));
  }
}
Variant c_SimpleXMLElement::i_offsetunset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_offsetunset(arg0), null);
  }
}
Variant c_SimpleXMLElement::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_SimpleXMLElement::i_children(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("children", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_children());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_children(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_children(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_addchild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addchild(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addchild(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addchild(arg0, arg1, arg2));
  }
}
Variant c_SimpleXMLElement::i___isset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___isset(arg0));
  }
}
Variant c_SimpleXMLElement::i_getname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_SimpleXMLElement::i_attributes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_attributes());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_attributes(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_attributes(arg0, arg1));
  }
}
Variant c_SimpleXMLElement::i_offsetset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_offsetset(arg0, arg1), null);
  }
}
Variant c_SimpleXMLElement::ifa_addattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addattribute", count, 1, 3, 1);
  if (count <= 1) return (self->t_addattribute(a0), null);
  if (count == 2) return (self->t_addattribute(a0, a1), null);
  return (self->t_addattribute(a0, a1, a2), null);
}
Variant c_SimpleXMLElement::ifa_count(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("count", 0, 1);
  return (self->t_count());
}
Variant c_SimpleXMLElement::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SimpleXMLElement::ifa_xpath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("xpath", count, 1, 1, 1);
  return (self->t_xpath(a0));
}
Variant c_SimpleXMLElement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SimpleXMLElement::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_SimpleXMLElement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("__construct", count, 1, 5, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  return (self->t___construct(a0, a1, a2, a3, a4), null);
}
Variant c_SimpleXMLElement::ifa_offsetexists(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetexists", count, 1, 1, 1);
  return (self->t_offsetexists(a0));
}
Variant c_SimpleXMLElement::ifa_getiterator(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getiterator", 0, 1);
  return (self->t_getiterator());
}
Variant c_SimpleXMLElement::ifa_registerxpathnamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registerxpathnamespace", count, 2, 2, 1);
  return (self->t_registerxpathnamespace(a0, a1));
}
Variant c_SimpleXMLElement::ifa_offsetget(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetget", count, 1, 1, 1);
  return (self->t_offsetget(a0));
}
Variant c_SimpleXMLElement::ifa_getnamespaces(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getnamespaces", 1, 1);
  if (count <= 0) return (self->t_getnamespaces());
  return (self->t_getnamespaces(a0));
}
Variant c_SimpleXMLElement::ifa___unset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__unset", count, 1, 1, 1);
  return (self->t___unset(a0));
}
Variant c_SimpleXMLElement::ifa_asxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("asxml", 1, 1);
  if (count <= 0) return (self->t_asxml());
  return (self->t_asxml(a0));
}
Variant c_SimpleXMLElement::ifa_getdocnamespaces(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getdocnamespaces", 1, 1);
  if (count <= 0) return (self->t_getdocnamespaces());
  return (self->t_getdocnamespaces(a0));
}
Variant c_SimpleXMLElement::ifa_offsetunset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("offsetunset", count, 1, 1, 1);
  return (self->t_offsetunset(a0), null);
}
Variant c_SimpleXMLElement::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_SimpleXMLElement::ifa_children(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("children", 2, 1);
  if (count <= 0) return (self->t_children());
  if (count == 1) return (self->t_children(a0));
  return (self->t_children(a0, a1));
}
Variant c_SimpleXMLElement::ifa_addchild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addchild", count, 1, 3, 1);
  if (count <= 1) return (self->t_addchild(a0));
  if (count == 2) return (self->t_addchild(a0, a1));
  return (self->t_addchild(a0, a1, a2));
}
Variant c_SimpleXMLElement::ifa___isset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__isset", count, 1, 1, 1);
  return (self->t___isset(a0));
}
Variant c_SimpleXMLElement::ifa_getname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getname", 0, 1);
  return (self->t_getname());
}
Variant c_SimpleXMLElement::ifa_attributes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("attributes", 2, 1);
  if (count <= 0) return (self->t_attributes());
  if (count == 1) return (self->t_attributes(a0));
  return (self->t_attributes(a0, a1));
}
Variant c_SimpleXMLElement::ifa_offsetset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SimpleXMLElement *self = NULL;
  p_SimpleXMLElement pobj;
  if (mcp.obj) {
    self = static_cast<c_SimpleXMLElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("offsetset", count, 2, 2, 1);
  return (self->t_offsetset(a0, a1), null);
}
bool c_SimpleXMLElement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 0:
      HASH_GUARD_LITSTR(0x3E6BCFB9742FC700LL, NAMSTR(s_sys_ss6cc6b367, "offsetExists")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetexists;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x570B2E1232A12503LL, NAMSTR(s_sys_ss0167520c, "getIterator")) {
        mcp.ci = &c_SimpleXMLElement::ci_getiterator;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_SimpleXMLElement::ci___get;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x5CEFA5A265104D10LL, NAMSTR(s_sys_ss0d54babb, "count")) {
        mcp.ci = &c_SimpleXMLElement::ci_count;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss6974a1cc, "__toString")) {
        mcp.ci = &c_SimpleXMLElement::ci___tostring;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x2DDE12A9866FC794LL, NAMSTR(s_sys_ss793fe5ea, "addChild")) {
        mcp.ci = &c_SimpleXMLElement::ci_addchild;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_SimpleXMLElement::ci___set;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x52F7AA6C19BEEAD6LL, NAMSTR(s_sys_ss48139170, "addAttribute")) {
        mcp.ci = &c_SimpleXMLElement::ci_addattribute;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x61D11ECEF4404498LL, NAMSTR(s_sys_ss62975ff0, "offsetGet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetget;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x0817454F196A9A1BLL, NAMSTR(s_sys_ss1fe1e1ea, "xpath")) {
        mcp.ci = &c_SimpleXMLElement::ci_xpath;
        return true;
      }
      HASH_GUARD_LITSTR(0x04FB7028C9A2079BLL, NAMSTR(s_sys_ss32d46a21, "__unset")) {
        mcp.ci = &c_SimpleXMLElement::ci___unset;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4B65E1A09A33F21DLL, NAMSTR(s_sys_ss0fc37e03, "attributes")) {
        mcp.ci = &c_SimpleXMLElement::ci_attributes;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SimpleXMLElement::ci___construct;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x23F51CDECC198965LL, NAMSTR(s_sys_ss3d20de82, "getName")) {
        mcp.ci = &c_SimpleXMLElement::ci_getname;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x6D9D75B7E3B40FA6LL, NAMSTR(s_sys_ss36a35582, "getNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getnamespaces;
        return true;
      }
      HASH_GUARD_LITSTR(0x5C09D9345FD864A6LL, NAMSTR(s_sys_ss20098bac, "asXML")) {
        mcp.ci = &c_SimpleXMLElement::ci_asxml;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x2B299E949E2E82ADLL, NAMSTR(s_sys_ss717877f6, "children")) {
        mcp.ci = &c_SimpleXMLElement::ci_children;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x4FE08FDDAE2178EELL, NAMSTR(s_sys_ss4cfc0bef, "__isset")) {
        mcp.ci = &c_SimpleXMLElement::ci___isset;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x0D08AA5F0B2F34F1LL, NAMSTR(s_sys_ss6456a3a6, "getDocNamespaces")) {
        mcp.ci = &c_SimpleXMLElement::ci_getdocnamespaces;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SimpleXMLElement::ci___destruct;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x0957F693A48AF738LL, NAMSTR(s_sys_ss41d45e54, "offsetSet")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetset;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x08329980E6369ABALL, NAMSTR(s_sys_ss1a6fd792, "offsetUnset")) {
        mcp.ci = &c_SimpleXMLElement::ci_offsetunset;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x3FE8F6937854F83DLL, NAMSTR(s_sys_ss50ad79e8, "registerXPathNamespace")) {
        mcp.ci = &c_SimpleXMLElement::ci_registerxpathnamespace;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SimpleXMLElement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SimpleXMLElement *c_SimpleXMLElement::create(String a0, int64 a1, bool a2, String a3, bool a4) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4);
  return this;
}
ObjectData *c_SimpleXMLElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4));
    } while (false);
  }
  return this;
}
void c_SimpleXMLElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4));
  } while (false);
}
void c_SimpleXMLElement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SimpleXMLElement::ci___construct;
  mcp.obj = this;
}
void c_SimpleXMLElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 5) throw_wrong_arguments("__construct", count, 1, 5, 1);
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else (t___construct(a0, a1, a2, a3, a4), null);
}
struct ObjectStaticCallbacks cw_SimpleXMLElement = {
  c_SimpleXMLElement::os_getInit,
  c_SimpleXMLElement::os_get,
  c_SimpleXMLElement::os_lval,
  c_SimpleXMLElement::os_invoke,
  c_SimpleXMLElement::os_constant,
  c_SimpleXMLElement::os_get_call_info
};
Object co_Memcache(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Memcache)())->dynCreate(params, init));
}
Object coo_Memcache() {
  Object r(NEW(c_Memcache)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
Variant c_Memcache::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
Variant c_Memcache::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
Variant &c_Memcache::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
void c_Memcache::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
void c_Memcache::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Memcache
Variant * c_Memcache::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
Variant * c_Memcache::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
Variant * c_Memcache::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Memcache
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
Variant c_Memcache::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Memcache
IMPLEMENT_CLASS(Memcache)
void c_Memcache::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Memcache::cloneImpl() {
  c_Memcache *obj = NEW(c_Memcache)();
  cloneSet(obj);
  return obj;
}
void c_Memcache::cloneSet(c_Memcache *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Memcache::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("close", 0, 1);
        return (t_close());
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss3029c43a, "replace")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
        if (count <= 2) return (t_replace(a0, a1));
        else if (count == 3) return (t_replace(a0, a1, a2));
        else return (t_replace(a0, a1, a2, a3));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss312d8bcf, "increment")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
        if (count <= 1) return (t_increment(a0));
        else return (t_increment(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss49ecd311, "setoptimeout")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
        return (t_setoptimeout(a0));
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss6db5a215, "add")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
        if (count <= 2) return (t_add(a0, a1));
        else if (count == 3) return (t_add(a0, a1, a2));
        else return (t_add(a0, a1, a2, a3));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss2f8c5ff7, "getserverstatus")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
        if (count <= 1) return (t_getserverstatus(a0));
        else return (t_getserverstatus(a0, a1));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss542ed87e, "setcompressthreshold")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
        if (count <= 1) return (t_setcompressthreshold(a0));
        else return (t_setcompressthreshold(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss4ca209c3, "delete")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
        if (count <= 1) return (t_delete(a0));
        else return (t_delete(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3504108f, "getversion")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
        return (t_getversion());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss3403085f, "getstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
        if (count <= 0) return (t_getstats());
        else if (count == 1) return (t_getstats(a0));
        else if (count == 2) return (t_getstats(a0, a1));
        else return (t_getstats(a0, a1, a2));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2a19cdf6, "decrement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
        if (count <= 1) return (t_decrement(a0));
        else return (t_decrement(a0, a1));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss0241fb06, "set")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
        if (count <= 2) return (t_set(a0, a1));
        else if (count == 3) return (t_set(a0, a1, a2));
        else return (t_set(a0, a1, a2, a3));
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss3f63bb07, "getextendedstats")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
        if (count <= 0) return (t_getextendedstats());
        else if (count == 1) return (t_getextendedstats(a0));
        else if (count == 2) return (t_getextendedstats(a0, a1));
        else return (t_getextendedstats(a0, a1, a2));
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss0eb9302b, "addserver")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        Variant a6;
        Variant a7;
        Variant a8;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a6 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a7 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a8 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
        if (count <= 1) return (t_addserver(a0));
        else if (count == 2) return (t_addserver(a0, a1));
        else if (count == 3) return (t_addserver(a0, a1, a2));
        else if (count == 4) return (t_addserver(a0, a1, a2, a3));
        else if (count == 5) return (t_addserver(a0, a1, a2, a3, a4));
        else if (count == 6) return (t_addserver(a0, a1, a2, a3, a4, a5));
        else if (count == 7) return (t_addserver(a0, a1, a2, a3, a4, a5, a6));
        else if (count == 8) return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7));
        else return (t_addserver(a0, a1, a2, a3, a4, a5, a6, a7, a8));
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss153b6861, "get")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
        if (count <= 1) return (t_get(a0));
        else return (t_get(a0, ref(a1)));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss452eaf4f, "pconnect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
        if (count <= 1) return (t_pconnect(a0));
        else if (count == 2) return (t_pconnect(a0, a1));
        else if (count == 3) return (t_pconnect(a0, a1, a2));
        else return (t_pconnect(a0, a1, a2, a3));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss2d912142, "setserverparams")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
        if (count <= 1) return (t_setserverparams(a0));
        else if (count == 2) return (t_setserverparams(a0, a1));
        else if (count == 3) return (t_setserverparams(a0, a1, a2));
        else if (count == 4) return (t_setserverparams(a0, a1, a2, a3));
        else if (count == 5) return (t_setserverparams(a0, a1, a2, a3, a4));
        else return (t_setserverparams(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss53985c4b, "connect")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
        if (count <= 1) return (t_connect(a0));
        else if (count == 2) return (t_connect(a0, a1));
        else if (count == 3) return (t_connect(a0, a1, a2));
        else return (t_connect(a0, a1, a2, a3));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Memcache::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Memcache::ci_addserver((void*)&c_Memcache::i_addserver, (void*)&c_Memcache::ifa_addserver, 9, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_set((void*)&c_Memcache::i_set, (void*)&c_Memcache::ifa_set, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setserverparams((void*)&c_Memcache::i_setserverparams, (void*)&c_Memcache::ifa_setserverparams, 6, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci___destruct((void*)&c_Memcache::i___destruct, (void*)&c_Memcache::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci___construct((void*)&c_Memcache::i___construct, (void*)&c_Memcache::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_increment((void*)&c_Memcache::i_increment, (void*)&c_Memcache::ifa_increment, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_decrement((void*)&c_Memcache::i_decrement, (void*)&c_Memcache::ifa_decrement, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getstats((void*)&c_Memcache::i_getstats, (void*)&c_Memcache::ifa_getstats, 3, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getserverstatus((void*)&c_Memcache::i_getserverstatus, (void*)&c_Memcache::ifa_getserverstatus, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_close((void*)&c_Memcache::i_close, (void*)&c_Memcache::ifa_close, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setoptimeout((void*)&c_Memcache::i_setoptimeout, (void*)&c_Memcache::ifa_setoptimeout, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_setcompressthreshold((void*)&c_Memcache::i_setcompressthreshold, (void*)&c_Memcache::ifa_setcompressthreshold, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_get((void*)&c_Memcache::i_get, (void*)&c_Memcache::ifa_get, 2, 4, 0x0000000000000002LL);
CallInfo c_Memcache::ci_add((void*)&c_Memcache::i_add, (void*)&c_Memcache::ifa_add, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_pconnect((void*)&c_Memcache::i_pconnect, (void*)&c_Memcache::ifa_pconnect, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getversion((void*)&c_Memcache::i_getversion, (void*)&c_Memcache::ifa_getversion, 0, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_delete((void*)&c_Memcache::i_delete, (void*)&c_Memcache::ifa_delete, 2, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_connect((void*)&c_Memcache::i_connect, (void*)&c_Memcache::ifa_connect, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_flush((void*)&c_Memcache::i_flush, (void*)&c_Memcache::ifa_flush, 1, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_replace((void*)&c_Memcache::i_replace, (void*)&c_Memcache::ifa_replace, 4, 4, 0x0000000000000000LL);
CallInfo c_Memcache::ci_getextendedstats((void*)&c_Memcache::i_getextendedstats, (void*)&c_Memcache::ifa_getextendedstats, 3, 4, 0x0000000000000000LL);
Variant c_Memcache::i_addserver(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addserver(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addserver(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_addserver(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_addserver(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 6) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5));
    CVarRef arg6((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 7) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
    CVarRef arg7((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 8) return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7));
    CVarRef arg8((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addserver(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8));
  }
}
Variant c_Memcache::i_set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_set(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_set(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_set(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_setserverparams(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setserverparams(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_setserverparams(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_setserverparams(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_setserverparams(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_setserverparams(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setserverparams(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant c_Memcache::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcache::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Memcache::i_increment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_increment(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_increment(arg0, arg1));
  }
}
Variant c_Memcache::i_decrement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_decrement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_decrement(arg0, arg1));
  }
}
Variant c_Memcache::i_getstats(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getstats());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_getstats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getstats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getstats(arg0, arg1, arg2));
  }
}
Variant c_Memcache::i_getserverstatus(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_getserverstatus(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getserverstatus(arg0, arg1));
  }
}
Variant c_Memcache::i_close(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_Memcache::i_setoptimeout(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setoptimeout(arg0));
  }
}
Variant c_Memcache::i_setcompressthreshold(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setcompressthreshold(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setcompressthreshold(arg0, arg1));
  }
}
Variant c_Memcache::i_get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_get(arg0));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t_get(arg0, arg1));
  }
}
Variant c_Memcache::i_add(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_add(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_add(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_add(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_pconnect(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_pconnect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_pconnect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_pconnect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_pconnect(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_getversion(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcache::i_delete(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_delete(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_delete(arg0, arg1));
  }
}
Variant c_Memcache::i_connect(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_connect(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_connect(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_connect(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_connect(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_flush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_flush());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_flush(arg0));
  }
}
Variant c_Memcache::i_replace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_replace(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_replace(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replace(arg0, arg1, arg2, arg3));
  }
}
Variant c_Memcache::i_getextendedstats(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getextendedstats());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_getextendedstats(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_getextendedstats(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getextendedstats(arg0, arg1, arg2));
  }
}
Variant c_Memcache::ifa_addserver(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 9) return throw_wrong_arguments("addserver", count, 1, 9, 1);
  if (count <= 1) return (self->t_addserver(a0));
  if (count == 2) return (self->t_addserver(a0, a1));
  if (count == 3) return (self->t_addserver(a0, a1, a2));
  if (count == 4) return (self->t_addserver(a0, a1, a2, a3));
  if (count == 5) return (self->t_addserver(a0, a1, a2, a3, a4));
  return (self->t_addserver(a0, a1, a2, a3, a4, a5));
}
Variant c_Memcache::ifa_set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("set", count, 2, 4, 1);
  if (count <= 2) return (self->t_set(a0, a1));
  if (count == 3) return (self->t_set(a0, a1, a2));
  return (self->t_set(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_setserverparams(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 6) return throw_wrong_arguments("setserverparams", count, 1, 6, 1);
  if (count <= 1) return (self->t_setserverparams(a0));
  if (count == 2) return (self->t_setserverparams(a0, a1));
  if (count == 3) return (self->t_setserverparams(a0, a1, a2));
  if (count == 4) return (self->t_setserverparams(a0, a1, a2, a3));
  if (count == 5) return (self->t_setserverparams(a0, a1, a2, a3, a4));
  return (self->t_setserverparams(a0, a1, a2, a3, a4, a5));
}
Variant c_Memcache::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Memcache::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_Memcache::ifa_increment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("increment", count, 1, 2, 1);
  if (count <= 1) return (self->t_increment(a0));
  return (self->t_increment(a0, a1));
}
Variant c_Memcache::ifa_decrement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("decrement", count, 1, 2, 1);
  if (count <= 1) return (self->t_decrement(a0));
  return (self->t_decrement(a0, a1));
}
Variant c_Memcache::ifa_getstats(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getstats", 3, 1);
  if (count <= 0) return (self->t_getstats());
  if (count == 1) return (self->t_getstats(a0));
  if (count == 2) return (self->t_getstats(a0, a1));
  return (self->t_getstats(a0, a1, a2));
}
Variant c_Memcache::ifa_getserverstatus(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("getserverstatus", count, 1, 2, 1);
  if (count <= 1) return (self->t_getserverstatus(a0));
  return (self->t_getserverstatus(a0, a1));
}
Variant c_Memcache::ifa_close(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("close", 0, 1);
  return (self->t_close());
}
Variant c_Memcache::ifa_setoptimeout(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setoptimeout", count, 1, 1, 1);
  return (self->t_setoptimeout(a0));
}
Variant c_Memcache::ifa_setcompressthreshold(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("setcompressthreshold", count, 1, 2, 1);
  if (count <= 1) return (self->t_setcompressthreshold(a0));
  return (self->t_setcompressthreshold(a0, a1));
}
Variant c_Memcache::ifa_get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("get", count, 1, 2, 1);
  if (count <= 1) return (self->t_get(a0));
  return (self->t_get(a0, ref(a1)));
}
Variant c_Memcache::ifa_add(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("add", count, 2, 4, 1);
  if (count <= 2) return (self->t_add(a0, a1));
  if (count == 3) return (self->t_add(a0, a1, a2));
  return (self->t_add(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_pconnect(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("pconnect", count, 1, 4, 1);
  if (count <= 1) return (self->t_pconnect(a0));
  if (count == 2) return (self->t_pconnect(a0, a1));
  if (count == 3) return (self->t_pconnect(a0, a1, a2));
  return (self->t_pconnect(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_getversion(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getversion", 0, 1);
  return (self->t_getversion());
}
Variant c_Memcache::ifa_delete(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("delete", count, 1, 2, 1);
  if (count <= 1) return (self->t_delete(a0));
  return (self->t_delete(a0, a1));
}
Variant c_Memcache::ifa_connect(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("connect", count, 1, 4, 1);
  if (count <= 1) return (self->t_connect(a0));
  if (count == 2) return (self->t_connect(a0, a1));
  if (count == 3) return (self->t_connect(a0, a1, a2));
  return (self->t_connect(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_flush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  if (count <= 0) return (self->t_flush());
  return (self->t_flush(a0));
}
Variant c_Memcache::ifa_replace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 4) return throw_wrong_arguments("replace", count, 2, 4, 1);
  if (count <= 2) return (self->t_replace(a0, a1));
  if (count == 3) return (self->t_replace(a0, a1, a2));
  return (self->t_replace(a0, a1, a2, a3));
}
Variant c_Memcache::ifa_getextendedstats(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Memcache *self = NULL;
  p_Memcache pobj;
  if (mcp.obj) {
    self = static_cast<c_Memcache*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("getextendedstats", 3, 1);
  if (count <= 0) return (self->t_getextendedstats());
  if (count == 1) return (self->t_getextendedstats(a0));
  if (count == 2) return (self->t_getextendedstats(a0, a1));
  return (self->t_getextendedstats(a0, a1, a2));
}
bool c_Memcache::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x78AE97BFBEBF5341LL, NAMSTR(s_sys_ss0fad1395, "close")) {
        mcp.ci = &c_Memcache::ci_close;
        return true;
      }
      break;
    case 6:
      HASH_GUARD_LITSTR(0x42FAC655280A6146LL, NAMSTR(s_sys_ss3029c43a, "replace")) {
        mcp.ci = &c_Memcache::ci_replace;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x39099707DF7945C7LL, NAMSTR(s_sys_ss312d8bcf, "increment")) {
        mcp.ci = &c_Memcache::ci_increment;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x3BF3710A1661DE0BLL, NAMSTR(s_sys_ss49ecd311, "setoptimeout")) {
        mcp.ci = &c_Memcache::ci_setoptimeout;
        return true;
      }
      HASH_GUARD_LITSTR(0x15D34462FC79458BLL, NAMSTR(s_sys_ss6db5a215, "add")) {
        mcp.ci = &c_Memcache::ci_add;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x710DE893BB376C4FLL, NAMSTR(s_sys_ss2f8c5ff7, "getserverstatus")) {
        mcp.ci = &c_Memcache::ci_getserverstatus;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x030429D528A8EA92LL, NAMSTR(s_sys_ss542ed87e, "setcompressthreshold")) {
        mcp.ci = &c_Memcache::ci_setcompressthreshold;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x1C660E5BFA6F55D3LL, NAMSTR(s_sys_ss4ca209c3, "delete")) {
        mcp.ci = &c_Memcache::ci_delete;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x7521E8833BE3D316LL, NAMSTR(s_sys_ss3504108f, "getversion")) {
        mcp.ci = &c_Memcache::ci_getversion;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x1CCDC4317CE59BD9LL, NAMSTR(s_sys_ss3403085f, "getstats")) {
        mcp.ci = &c_Memcache::ci_getstats;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x2A733FC12BA4C1DALL, NAMSTR(s_sys_ss2a19cdf6, "decrement")) {
        mcp.ci = &c_Memcache::ci_decrement;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_Memcache::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x399A6427C2185621LL, NAMSTR(s_sys_ss0241fb06, "set")) {
        mcp.ci = &c_Memcache::ci_set;
        return true;
      }
      break;
    case 37:
      HASH_GUARD_LITSTR(0x4770E54B86BF7765LL, NAMSTR(s_sys_ss3f63bb07, "getextendedstats")) {
        mcp.ci = &c_Memcache::ci_getextendedstats;
        return true;
      }
      break;
    case 38:
      HASH_GUARD_LITSTR(0x56CD24186237AAE6LL, NAMSTR(s_sys_ss0eb9302b, "addserver")) {
        mcp.ci = &c_Memcache::ci_addserver;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x25DCCC35D69AD828LL, NAMSTR(s_sys_ss153b6861, "get")) {
        mcp.ci = &c_Memcache::ci_get;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_Memcache::ci___destruct;
        return true;
      }
      break;
    case 57:
      HASH_GUARD_LITSTR(0x742B441E13CD7279LL, NAMSTR(s_sys_ss452eaf4f, "pconnect")) {
        mcp.ci = &c_Memcache::ci_pconnect;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        mcp.ci = &c_Memcache::ci_flush;
        return true;
      }
      break;
    case 61:
      HASH_GUARD_LITSTR(0x1780351E8EFF92BDLL, NAMSTR(s_sys_ss2d912142, "setserverparams")) {
        mcp.ci = &c_Memcache::ci_setserverparams;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x7032C660AD16D7FELL, NAMSTR(s_sys_ss53985c4b, "connect")) {
        mcp.ci = &c_Memcache::ci_connect;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Memcache::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Memcache *c_Memcache::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_Memcache::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_Memcache::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_Memcache::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Memcache::ci___construct;
  mcp.obj = this;
}
void c_Memcache::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_Memcache = {
  c_Memcache::os_getInit,
  c_Memcache::os_get,
  c_Memcache::os_lval,
  c_Memcache::os_invoke,
  c_Memcache::os_constant,
  c_Memcache::os_get_call_info
};
Object co_DOMProcessingInstruction(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMProcessingInstruction)())->dynCreate(params, init));
}
Object coo_DOMProcessingInstruction() {
  Object r(NEW(c_DOMProcessingInstruction)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
Variant &c_DOMProcessingInstruction::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
void c_DOMProcessingInstruction::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
Variant * c_DOMProcessingInstruction::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMProcessingInstruction
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
Variant c_DOMProcessingInstruction::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMProcessingInstruction
IMPLEMENT_CLASS(DOMProcessingInstruction)
void c_DOMProcessingInstruction::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMProcessingInstruction::cloneImpl() {
  c_DOMProcessingInstruction *obj = NEW(c_DOMProcessingInstruction)();
  cloneSet(obj);
  return obj;
}
void c_DOMProcessingInstruction::cloneSet(c_DOMProcessingInstruction *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMProcessingInstruction::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMProcessingInstruction::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMProcessingInstruction::ci___destruct((void*)&c_DOMProcessingInstruction::i___destruct, (void*)&c_DOMProcessingInstruction::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___set((void*)&c_DOMProcessingInstruction::i___set, (void*)&c_DOMProcessingInstruction::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___construct((void*)&c_DOMProcessingInstruction::i___construct, (void*)&c_DOMProcessingInstruction::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMProcessingInstruction::ci___get((void*)&c_DOMProcessingInstruction::i___get, (void*)&c_DOMProcessingInstruction::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMProcessingInstruction::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMProcessingInstruction::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMProcessingInstruction::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMProcessingInstruction::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMProcessingInstruction::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMProcessingInstruction::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMProcessingInstruction::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMProcessingInstruction::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMProcessingInstruction *self = NULL;
  p_DOMProcessingInstruction pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMProcessingInstruction*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMProcessingInstruction::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMProcessingInstruction::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMProcessingInstruction::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMProcessingInstruction *c_DOMProcessingInstruction::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMProcessingInstruction::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMProcessingInstruction::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMProcessingInstruction::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMProcessingInstruction::ci___construct;
  mcp.obj = this;
}
void c_DOMProcessingInstruction::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMProcessingInstruction = {
  c_DOMProcessingInstruction::os_getInit,
  c_DOMProcessingInstruction::os_get,
  c_DOMProcessingInstruction::os_lval,
  c_DOMProcessingInstruction::os_invoke,
  c_DOMProcessingInstruction::os_constant,
  c_DOMProcessingInstruction::os_get_call_info
};
Object co_PDOStatement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDOStatement)())->dynCreate(params, init));
}
Object coo_PDOStatement() {
  Object r(NEW(c_PDOStatement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
Variant c_PDOStatement::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
Variant c_PDOStatement::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
Variant &c_PDOStatement::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
void c_PDOStatement::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
void c_PDOStatement::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
Variant * c_PDOStatement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
Variant * c_PDOStatement::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
Variant * c_PDOStatement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDOStatement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
Variant c_PDOStatement::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDOStatement
IMPLEMENT_CLASS(PDOStatement)
void c_PDOStatement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDOStatement::cloneImpl() {
  c_PDOStatement *obj = NEW(c_PDOStatement)();
  cloneSet(obj);
  return obj;
}
void c_PDOStatement::cloneSet(c_PDOStatement *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_PDOStatement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss6018bb35, "fetchall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
        if (count <= 0) return (t_fetchall());
        else if (count == 1) return (t_fetchall(a0));
        else if (count == 2) return (t_fetchall(a0, a1));
        else return (t_fetchall(a0, a1, a2));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss0e2f6a78, "bindvalue")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
        if (count <= 2) return (t_bindvalue(a0, a1));
        else return (t_bindvalue(a0, a1, a2));
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("valid", 0, 1);
        return (t_valid());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss74e55247, "closecursor")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
        return (t_closecursor());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss31a11388, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss5ac66c5d, "execute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("execute", 1, 1);
        if (count <= 0) return (t_execute());
        else return (t_execute(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss2b845c3b, "columncount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
        return (t_columncount());
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("key", 0, 1);
        return (t_key());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss04bcc4ac, "nextrowset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
        return (t_nextrowset());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1b64dec9, "bindparam")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
        if (count <= 2) return (t_bindparam(a0, ref(a1)));
        else if (count == 3) return (t_bindparam(a0, ref(a1), a2));
        else if (count == 4) return (t_bindparam(a0, ref(a1), a2, a3));
        else return (t_bindparam(a0, ref(a1), a2, a3, a4));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss46e7e29a, "fetchcolumn")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
        if (count <= 0) return (t_fetchcolumn());
        else return (t_fetchcolumn(a0));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss0a95ac22, "rowcount")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
        return (t_rowcount());
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss0723515e, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("current", 0, 1);
        return (t_current());
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss55c15f8a, "bindcolumn")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
        if (count <= 2) return (t_bindcolumn(a0, ref(a1)));
        else if (count == 3) return (t_bindcolumn(a0, ref(a1), a2));
        else if (count == 4) return (t_bindcolumn(a0, ref(a1), a2, a3));
        else return (t_bindcolumn(a0, ref(a1), a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss45f15bcd, "fetchobject")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
        if (count <= 0) return (t_fetchobject());
        else if (count == 1) return (t_fetchobject(a0));
        else return (t_fetchobject(a0, a1));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss07706afb, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss7fd7d2bc, "setfetchmode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
        if (count <= 1) return (t_setfetchmode(count, a0));
        return (t_setfetchmode(count, a0,vargs));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss2d73fa0d, "debugdumpparams")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
        return (t_debugdumpparams());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
        return (t_rewind());
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss0c905545, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("next", 0, 1);
        return (t_next());
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss6b51d6cb, "getcolumnmeta")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
        return (t_getcolumnmeta(a0));
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss0b929a80, "fetch")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
        if (count <= 0) return (t_fetch());
        else if (count == 1) return (t_fetch(a0));
        else if (count == 2) return (t_fetch(a0, a1));
        else return (t_fetch(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDOStatement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDOStatement::ci_next((void*)&c_PDOStatement::i_next, (void*)&c_PDOStatement::ifa_next, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_errorcode((void*)&c_PDOStatement::i_errorcode, (void*)&c_PDOStatement::ifa_errorcode, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_getattribute((void*)&c_PDOStatement::i_getattribute, (void*)&c_PDOStatement::ifa_getattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchcolumn((void*)&c_PDOStatement::i_fetchcolumn, (void*)&c_PDOStatement::ifa_fetchcolumn, 1, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_key((void*)&c_PDOStatement::i_key, (void*)&c_PDOStatement::ifa_key, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_getcolumnmeta((void*)&c_PDOStatement::i_getcolumnmeta, (void*)&c_PDOStatement::ifa_getcolumnmeta, 1, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_valid((void*)&c_PDOStatement::i_valid, (void*)&c_PDOStatement::ifa_valid, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_nextrowset((void*)&c_PDOStatement::i_nextrowset, (void*)&c_PDOStatement::ifa_nextrowset, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___destruct((void*)&c_PDOStatement::i___destruct, (void*)&c_PDOStatement::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___wakeup((void*)&c_PDOStatement::i___wakeup, (void*)&c_PDOStatement::ifa___wakeup, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___construct((void*)&c_PDOStatement::i___construct, (void*)&c_PDOStatement::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindcolumn((void*)&c_PDOStatement::i_bindcolumn, (void*)&c_PDOStatement::ifa_bindcolumn, 5, 4, 0x0000000000000002LL);
CallInfo c_PDOStatement::ci_setfetchmode((void*)&c_PDOStatement::i_setfetchmode, (void*)&c_PDOStatement::ifa_setfetchmode, 1, 5, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_columncount((void*)&c_PDOStatement::i_columncount, (void*)&c_PDOStatement::ifa_columncount, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindparam((void*)&c_PDOStatement::i_bindparam, (void*)&c_PDOStatement::ifa_bindparam, 5, 4, 0x0000000000000002LL);
CallInfo c_PDOStatement::ci_closecursor((void*)&c_PDOStatement::i_closecursor, (void*)&c_PDOStatement::ifa_closecursor, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_setattribute((void*)&c_PDOStatement::i_setattribute, (void*)&c_PDOStatement::ifa_setattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_rowcount((void*)&c_PDOStatement::i_rowcount, (void*)&c_PDOStatement::ifa_rowcount, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_execute((void*)&c_PDOStatement::i_execute, (void*)&c_PDOStatement::ifa_execute, 1, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchobject((void*)&c_PDOStatement::i_fetchobject, (void*)&c_PDOStatement::ifa_fetchobject, 2, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_bindvalue((void*)&c_PDOStatement::i_bindvalue, (void*)&c_PDOStatement::ifa_bindvalue, 3, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetchall((void*)&c_PDOStatement::i_fetchall, (void*)&c_PDOStatement::ifa_fetchall, 3, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_fetch((void*)&c_PDOStatement::i_fetch, (void*)&c_PDOStatement::ifa_fetch, 3, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_current((void*)&c_PDOStatement::i_current, (void*)&c_PDOStatement::ifa_current, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_errorinfo((void*)&c_PDOStatement::i_errorinfo, (void*)&c_PDOStatement::ifa_errorinfo, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci___sleep((void*)&c_PDOStatement::i___sleep, (void*)&c_PDOStatement::ifa___sleep, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_debugdumpparams((void*)&c_PDOStatement::i_debugdumpparams, (void*)&c_PDOStatement::ifa_debugdumpparams, 0, 4, 0x0000000000000000LL);
CallInfo c_PDOStatement::ci_rewind((void*)&c_PDOStatement::i_rewind, (void*)&c_PDOStatement::ifa_rewind, 0, 4, 0x0000000000000000LL);
Variant c_PDOStatement::i_next(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_PDOStatement::i_errorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDOStatement::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_PDOStatement::i_fetchcolumn(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchcolumn());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_fetchcolumn(arg0));
  }
}
Variant c_PDOStatement::i_key(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_PDOStatement::i_getcolumnmeta(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getcolumnmeta(arg0));
  }
}
Variant c_PDOStatement::i_valid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_PDOStatement::i_nextrowset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
  return (self->t_nextrowset());
}
Variant c_PDOStatement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOStatement::i___wakeup(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDOStatement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOStatement::i_bindcolumn(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindcolumn(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_bindcolumn(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_bindcolumn(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindcolumn(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_PDOStatement::i_setfetchmode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setfetchmode(count, arg0));
    return (self->t_setfetchmode(count,arg0, params.slice(1, count - 1, false)));
  }
}
Variant c_PDOStatement::i_columncount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
  return (self->t_columncount());
}
Variant c_PDOStatement::i_bindparam(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindparam(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_bindparam(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_bindparam(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindparam(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_PDOStatement::i_closecursor(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
  return (self->t_closecursor());
}
Variant c_PDOStatement::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_PDOStatement::i_rowcount(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
  return (self->t_rowcount());
}
Variant c_PDOStatement::i_execute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("execute", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_execute());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_execute(arg0));
  }
}
Variant c_PDOStatement::i_fetchobject(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchobject());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetchobject(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetchobject(arg0, arg1));
  }
}
Variant c_PDOStatement::i_bindvalue(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_bindvalue(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_bindvalue(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_fetchall(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetchall());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetchall(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_fetchall(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetchall(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_fetch(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_fetch());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_fetch(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_fetch(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fetch(arg0, arg1, arg2));
  }
}
Variant c_PDOStatement::i_current(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_PDOStatement::i_errorinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDOStatement::i___sleep(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDOStatement::i_debugdumpparams(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
  return (self->t_debugdumpparams());
}
Variant c_PDOStatement::i_rewind(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
Variant c_PDOStatement::ifa_next(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("next", 0, 1);
  return (self->t_next());
}
Variant c_PDOStatement::ifa_errorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDOStatement::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_PDOStatement::ifa_fetchcolumn(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("fetchcolumn", 1, 1);
  if (count <= 0) return (self->t_fetchcolumn());
  return (self->t_fetchcolumn(a0));
}
Variant c_PDOStatement::ifa_key(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("key", 0, 1);
  return (self->t_key());
}
Variant c_PDOStatement::ifa_getcolumnmeta(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getcolumnmeta", count, 1, 1, 1);
  return (self->t_getcolumnmeta(a0));
}
Variant c_PDOStatement::ifa_valid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("valid", 0, 1);
  return (self->t_valid());
}
Variant c_PDOStatement::ifa_nextrowset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("nextrowset", 0, 1);
  return (self->t_nextrowset());
}
Variant c_PDOStatement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDOStatement::ifa___wakeup(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDOStatement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_PDOStatement::ifa_bindcolumn(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindcolumn", count, 2, 5, 1);
  if (count <= 2) return (self->t_bindcolumn(a0, ref(a1)));
  if (count == 3) return (self->t_bindcolumn(a0, ref(a1), a2));
  if (count == 4) return (self->t_bindcolumn(a0, ref(a1), a2, a3));
  return (self->t_bindcolumn(a0, ref(a1), a2, a3, a4));
}
Variant c_PDOStatement::ifa_setfetchmode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setfetchmode", count+1, 1);
  if (count <= 1) return (self->t_setfetchmode(count, a0));
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_setfetchmode(count,a0, params));
}
Variant c_PDOStatement::ifa_columncount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("columncount", 0, 1);
  return (self->t_columncount());
}
Variant c_PDOStatement::ifa_bindparam(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("bindparam", count, 2, 5, 1);
  if (count <= 2) return (self->t_bindparam(a0, ref(a1)));
  if (count == 3) return (self->t_bindparam(a0, ref(a1), a2));
  if (count == 4) return (self->t_bindparam(a0, ref(a1), a2, a3));
  return (self->t_bindparam(a0, ref(a1), a2, a3, a4));
}
Variant c_PDOStatement::ifa_closecursor(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("closecursor", 0, 1);
  return (self->t_closecursor());
}
Variant c_PDOStatement::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_PDOStatement::ifa_rowcount(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rowcount", 0, 1);
  return (self->t_rowcount());
}
Variant c_PDOStatement::ifa_execute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("execute", 1, 1);
  if (count <= 0) return (self->t_execute());
  return (self->t_execute(a0));
}
Variant c_PDOStatement::ifa_fetchobject(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("fetchobject", 2, 1);
  if (count <= 0) return (self->t_fetchobject());
  if (count == 1) return (self->t_fetchobject(a0));
  return (self->t_fetchobject(a0, a1));
}
Variant c_PDOStatement::ifa_bindvalue(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("bindvalue", count, 2, 3, 1);
  if (count <= 2) return (self->t_bindvalue(a0, a1));
  return (self->t_bindvalue(a0, a1, a2));
}
Variant c_PDOStatement::ifa_fetchall(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetchall", 3, 1);
  if (count <= 0) return (self->t_fetchall());
  if (count == 1) return (self->t_fetchall(a0));
  if (count == 2) return (self->t_fetchall(a0, a1));
  return (self->t_fetchall(a0, a1, a2));
}
Variant c_PDOStatement::ifa_fetch(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("fetch", 3, 1);
  if (count <= 0) return (self->t_fetch());
  if (count == 1) return (self->t_fetch(a0));
  if (count == 2) return (self->t_fetch(a0, a1));
  return (self->t_fetch(a0, a1, a2));
}
Variant c_PDOStatement::ifa_current(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("current", 0, 1);
  return (self->t_current());
}
Variant c_PDOStatement::ifa_errorinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDOStatement::ifa___sleep(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDOStatement::ifa_debugdumpparams(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("debugdumpparams", 0, 1);
  return (self->t_debugdumpparams());
}
Variant c_PDOStatement::ifa_rewind(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDOStatement *self = NULL;
  p_PDOStatement pobj;
  if (mcp.obj) {
    self = static_cast<c_PDOStatement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rewind", 0, 1);
  return (self->t_rewind());
}
bool c_PDOStatement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 1:
      HASH_GUARD_LITSTR(0x5740729B65EB8E41LL, NAMSTR(s_sys_ss6018bb35, "fetchall")) {
        mcp.ci = &c_PDOStatement::ci_fetchall;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x436E6AFC3628E403LL, NAMSTR(s_sys_ss0e2f6a78, "bindvalue")) {
        mcp.ci = &c_PDOStatement::ci_bindvalue;
        return true;
      }
      break;
    case 4:
      HASH_GUARD_LITSTR(0x6413CB5154808C44LL, NAMSTR(s_sys_ss66bc340c, "valid")) {
        mcp.ci = &c_PDOStatement::ci_valid;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x75A2E23098C65C05LL, NAMSTR(s_sys_ss74e55247, "closecursor")) {
        mcp.ci = &c_PDOStatement::ci_closecursor;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss31a11388, "errorcode")) {
        mcp.ci = &c_PDOStatement::ci_errorcode;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        mcp.ci = &c_PDOStatement::ci_setattribute;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x187C7F43EB57714ELL, NAMSTR(s_sys_ss5ac66c5d, "execute")) {
        mcp.ci = &c_PDOStatement::ci_execute;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x32A381ECDC91918FLL, NAMSTR(s_sys_ss2b845c3b, "columncount")) {
        mcp.ci = &c_PDOStatement::ci_columncount;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x56EDB60C824E8C51LL, NAMSTR(s_sys_ss12e90587, "key")) {
        mcp.ci = &c_PDOStatement::ci_key;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x31A8917EC4F2A252LL, NAMSTR(s_sys_ss04bcc4ac, "nextrowset")) {
        mcp.ci = &c_PDOStatement::ci_nextrowset;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x77B13FCF1BA41696LL, NAMSTR(s_sys_ss1b64dec9, "bindparam")) {
        mcp.ci = &c_PDOStatement::ci_bindparam;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x5C38814410C5FFD9LL, NAMSTR(s_sys_ss46e7e29a, "fetchcolumn")) {
        mcp.ci = &c_PDOStatement::ci_fetchcolumn;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0D43A7148903299ALL, NAMSTR(s_sys_ss0a95ac22, "rowcount")) {
        mcp.ci = &c_PDOStatement::ci_rowcount;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss0723515e, "__wakeup")) {
        mcp.ci = &c_PDOStatement::ci___wakeup;
        return true;
      }
      HASH_GUARD_LITSTR(0x5B3A4A72846B21DCLL, NAMSTR(s_sys_ss4c5a3e4d, "current")) {
        mcp.ci = &c_PDOStatement::ci_current;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x1C87AD14A095219DLL, NAMSTR(s_sys_ss55c15f8a, "bindcolumn")) {
        mcp.ci = &c_PDOStatement::ci_bindcolumn;
        return true;
      }
      HASH_GUARD_LITSTR(0x0E1814AA3327229DLL, NAMSTR(s_sys_ss45f15bcd, "fetchobject")) {
        mcp.ci = &c_PDOStatement::ci_fetchobject;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss07706afb, "errorinfo")) {
        mcp.ci = &c_PDOStatement::ci_errorinfo;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_PDOStatement::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x78C9BF8620136861LL, NAMSTR(s_sys_ss7fd7d2bc, "setfetchmode")) {
        mcp.ci = &c_PDOStatement::ci_setfetchmode;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x699F5A1E3BD7B2A2LL, NAMSTR(s_sys_ss2d73fa0d, "debugdumpparams")) {
        mcp.ci = &c_PDOStatement::ci_debugdumpparams;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        mcp.ci = &c_PDOStatement::ci_getattribute;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1670096FDE27AF6ALL, NAMSTR(s_sys_ss6be35da1, "rewind")) {
        mcp.ci = &c_PDOStatement::ci_rewind;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss0c905545, "__sleep")) {
        mcp.ci = &c_PDOStatement::ci___sleep;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_PDOStatement::ci___destruct;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x3C6D50F3BB8102B8LL, NAMSTR(s_sys_ss50652d33, "next")) {
        mcp.ci = &c_PDOStatement::ci_next;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x5B6B980006E717FBLL, NAMSTR(s_sys_ss6b51d6cb, "getcolumnmeta")) {
        mcp.ci = &c_PDOStatement::ci_getcolumnmeta;
        return true;
      }
      HASH_GUARD_LITSTR(0x5E82B850BB90B0FBLL, NAMSTR(s_sys_ss0b929a80, "fetch")) {
        mcp.ci = &c_PDOStatement::ci_fetch;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_PDOStatement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_PDOStatement *c_PDOStatement::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_PDOStatement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_PDOStatement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_PDOStatement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDOStatement::ci___construct;
  mcp.obj = this;
}
void c_PDOStatement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_PDOStatement = {
  c_PDOStatement::os_getInit,
  c_PDOStatement::os_get,
  c_PDOStatement::os_lval,
  c_PDOStatement::os_invoke,
  c_PDOStatement::os_constant,
  c_PDOStatement::os_get_call_info
};
Object co_SoapClient(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapClient)())->dynCreate(params, init));
}
Object coo_SoapClient() {
  Object r(NEW(c_SoapClient)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
Variant c_SoapClient::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
Variant c_SoapClient::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
Variant &c_SoapClient::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
void c_SoapClient::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
void c_SoapClient::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
Variant * c_SoapClient::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
Variant * c_SoapClient::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
Variant * c_SoapClient::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapClient
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
Variant c_SoapClient::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapClient
IMPLEMENT_CLASS(SoapClient)
void c_SoapClient::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapClient::cloneImpl() {
  c_SoapClient *obj = NEW(c_SoapClient)();
  cloneSet(obj);
  return obj;
}
void c_SoapClient::cloneSet(c_SoapClient *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapClient::doCall(Variant v_name, Variant v_arguments, bool fatal) {
  return t___call(v_name, !v_arguments.isNull() ? v_arguments : Variant(Array::Create()));
}
Variant c_SoapClient::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss2d5cec41, "__getlastrequest")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
        return (t___getlastrequest());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss6775c5a7, "__getlastrequestheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
        return (t___getlastrequestheaders());
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss377f1476, "__call")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
        return (t___call(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss63eef794, "__getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
        return (t___getfunctions());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss4ae2597c, "__getlastresponse")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
        return (t___getlastresponse());
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss68bc25e3, "__dorequest")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
        if (count <= 4) return (t___dorequest(a0, a1, a2, a3));
        else return (t___dorequest(a0, a1, a2, a3, a4));
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss30120c29, "__setcookie")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
        if (count <= 1) return (t___setcookie(a0));
        else return (t___setcookie(a0, a1));
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss4b959501, "__gettypes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
        return (t___gettypes());
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss2bf685d4, "__soapcall")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
        if (count <= 2) return (t___soapcall(a0, a1));
        else if (count == 3) return (t___soapcall(a0, a1, a2));
        else if (count == 4) return (t___soapcall(a0, a1, a2, a3));
        else return (t___soapcall(a0, a1, a2, a3, ref(a4)));
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss350e6cf4, "__getlastresponseheaders")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
        return (t___getlastresponseheaders());
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss69c97e19, "__setsoapheaders")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
        if (count <= 0) return (t___setsoapheaders());
        else return (t___setsoapheaders(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss425e765b, "__setlocation")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
        if (count <= 0) return (t___setlocation());
        else return (t___setlocation(a0));
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapClient::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapClient::ci___dorequest((void*)&c_SoapClient::i___dorequest, (void*)&c_SoapClient::ifa___dorequest, 5, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastrequest((void*)&c_SoapClient::i___getlastrequest, (void*)&c_SoapClient::ifa___getlastrequest, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setsoapheaders((void*)&c_SoapClient::i___setsoapheaders, (void*)&c_SoapClient::ifa___setsoapheaders, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setcookie((void*)&c_SoapClient::i___setcookie, (void*)&c_SoapClient::ifa___setcookie, 2, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___soapcall((void*)&c_SoapClient::i___soapcall, (void*)&c_SoapClient::ifa___soapcall, 5, 4, 0x0000000000000010LL);
CallInfo c_SoapClient::ci___destruct((void*)&c_SoapClient::i___destruct, (void*)&c_SoapClient::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___setlocation((void*)&c_SoapClient::i___setlocation, (void*)&c_SoapClient::ifa___setlocation, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastrequestheaders((void*)&c_SoapClient::i___getlastrequestheaders, (void*)&c_SoapClient::ifa___getlastrequestheaders, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___construct((void*)&c_SoapClient::i___construct, (void*)&c_SoapClient::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getfunctions((void*)&c_SoapClient::i___getfunctions, (void*)&c_SoapClient::ifa___getfunctions, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastresponseheaders((void*)&c_SoapClient::i___getlastresponseheaders, (void*)&c_SoapClient::ifa___getlastresponseheaders, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___getlastresponse((void*)&c_SoapClient::i___getlastresponse, (void*)&c_SoapClient::ifa___getlastresponse, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___gettypes((void*)&c_SoapClient::i___gettypes, (void*)&c_SoapClient::ifa___gettypes, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapClient::ci___call((void*)&c_SoapClient::i___call, (void*)&c_SoapClient::ifa___call, 2, 4, 0x0000000000000000LL);
Variant c_SoapClient::i___dorequest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 4) return (self->t___dorequest(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___dorequest(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_SoapClient::i___getlastrequest(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
  return (self->t___getlastrequest());
}
Variant c_SoapClient::i___setsoapheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___setsoapheaders());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___setsoapheaders(arg0));
  }
}
Variant c_SoapClient::i___setcookie(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___setcookie(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___setcookie(arg0, arg1));
  }
}
Variant c_SoapClient::i___soapcall(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___soapcall(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___soapcall(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___soapcall(arg0, arg1, arg2, arg3));
    CVarRef arg4(ref(ad->getValueRef(pos = ad->iter_advance(pos))));
    return (self->t___soapcall(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_SoapClient::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapClient::i___setlocation(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___setlocation());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___setlocation(arg0));
  }
}
Variant c_SoapClient::i___getlastrequestheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
  return (self->t___getlastrequestheaders());
}
Variant c_SoapClient::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapClient::i___getfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
  return (self->t___getfunctions());
}
Variant c_SoapClient::i___getlastresponseheaders(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
  return (self->t___getlastresponseheaders());
}
Variant c_SoapClient::i___getlastresponse(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
  return (self->t___getlastresponse());
}
Variant c_SoapClient::i___gettypes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
  return (self->t___gettypes());
}
Variant c_SoapClient::i___call(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___call(arg0, arg1));
  }
}
Variant c_SoapClient::ifa___dorequest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 4 || count > 5) return throw_wrong_arguments("__dorequest", count, 4, 5, 1);
  if (count <= 4) return (self->t___dorequest(a0, a1, a2, a3));
  return (self->t___dorequest(a0, a1, a2, a3, a4));
}
Variant c_SoapClient::ifa___getlastrequest(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequest", 0, 1);
  return (self->t___getlastrequest());
}
Variant c_SoapClient::ifa___setsoapheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setsoapheaders", 1, 1);
  if (count <= 0) return (self->t___setsoapheaders());
  return (self->t___setsoapheaders(a0));
}
Variant c_SoapClient::ifa___setcookie(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__setcookie", count, 1, 2, 1);
  if (count <= 1) return (self->t___setcookie(a0));
  return (self->t___setcookie(a0, a1));
}
Variant c_SoapClient::ifa___soapcall(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("__soapcall", count, 2, 5, 1);
  if (count <= 2) return (self->t___soapcall(a0, a1));
  if (count == 3) return (self->t___soapcall(a0, a1, a2));
  if (count == 4) return (self->t___soapcall(a0, a1, a2, a3));
  return (self->t___soapcall(a0, a1, a2, a3, ref(a4)));
}
Variant c_SoapClient::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapClient::ifa___setlocation(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("__setlocation", 1, 1);
  if (count <= 0) return (self->t___setlocation());
  return (self->t___setlocation(a0));
}
Variant c_SoapClient::ifa___getlastrequestheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastrequestheaders", 0, 1);
  return (self->t___getlastrequestheaders());
}
Variant c_SoapClient::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_SoapClient::ifa___getfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getfunctions", 0, 1);
  return (self->t___getfunctions());
}
Variant c_SoapClient::ifa___getlastresponseheaders(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponseheaders", 0, 1);
  return (self->t___getlastresponseheaders());
}
Variant c_SoapClient::ifa___getlastresponse(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__getlastresponse", 0, 1);
  return (self->t___getlastresponse());
}
Variant c_SoapClient::ifa___gettypes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__gettypes", 0, 1);
  return (self->t___gettypes());
}
Variant c_SoapClient::ifa___call(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapClient *self = NULL;
  p_SoapClient pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapClient*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__call", count, 2, 2, 1);
  return (self->t___call(a0, a1));
}
bool c_SoapClient::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 4:
      HASH_GUARD_LITSTR(0x5C5C1E24A140F6E4LL, NAMSTR(s_sys_ss2d5cec41, "__getlastrequest")) {
        mcp.ci = &c_SoapClient::ci___getlastrequest;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x3648EE7D3B37DE8CLL, NAMSTR(s_sys_ss6775c5a7, "__getlastrequestheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastrequestheaders;
        return true;
      }
      HASH_GUARD_LITSTR(0x5D73364F53CEEB6CLL, NAMSTR(s_sys_ss377f1476, "__call")) {
        mcp.ci = &c_SoapClient::ci___call;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x1365B3105FC59871LL, NAMSTR(s_sys_ss63eef794, "__getfunctions")) {
        mcp.ci = &c_SoapClient::ci___getfunctions;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapClient::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x3CA9145031035A54LL, NAMSTR(s_sys_ss4ae2597c, "__getlastresponse")) {
        mcp.ci = &c_SoapClient::ci___getlastresponse;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x19A26CEC7E8AAEF5LL, NAMSTR(s_sys_ss68bc25e3, "__dorequest")) {
        mcp.ci = &c_SoapClient::ci___dorequest;
        return true;
      }
      HASH_GUARD_LITSTR(0x52C6ABACCBFD0C75LL, NAMSTR(s_sys_ss30120c29, "__setcookie")) {
        mcp.ci = &c_SoapClient::ci___setcookie;
        return true;
      }
      HASH_GUARD_LITSTR(0x628D398E7604B9D5LL, NAMSTR(s_sys_ss4b959501, "__gettypes")) {
        mcp.ci = &c_SoapClient::ci___gettypes;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x4A2F89F662050D99LL, NAMSTR(s_sys_ss2bf685d4, "__soapcall")) {
        mcp.ci = &c_SoapClient::ci___soapcall;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x0C94657A58A82CFALL, NAMSTR(s_sys_ss350e6cf4, "__getlastresponseheaders")) {
        mcp.ci = &c_SoapClient::ci___getlastresponseheaders;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x14842228D5E335BBLL, NAMSTR(s_sys_ss69c97e19, "__setsoapheaders")) {
        mcp.ci = &c_SoapClient::ci___setsoapheaders;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x232D13904DBC36FFLL, NAMSTR(s_sys_ss425e765b, "__setlocation")) {
        mcp.ci = &c_SoapClient::ci___setlocation;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapClient::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapClient::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapClient *c_SoapClient::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapClient::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapClient::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapClient::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapClient::ci___construct;
  mcp.obj = this;
}
void c_SoapClient::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapClient = {
  c_SoapClient::os_getInit,
  c_SoapClient::os_get,
  c_SoapClient::os_lval,
  c_SoapClient::os_invoke,
  c_SoapClient::os_constant,
  c_SoapClient::os_get_call_info
};
Object co_SoapParam(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapParam)())->dynCreate(params, init));
}
Object coo_SoapParam() {
  Object r(NEW(c_SoapParam)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
Variant c_SoapParam::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
Variant c_SoapParam::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
Variant &c_SoapParam::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
void c_SoapParam::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
void c_SoapParam::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
Variant * c_SoapParam::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
Variant * c_SoapParam::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
Variant * c_SoapParam::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapParam
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
Variant c_SoapParam::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapParam
IMPLEMENT_CLASS(SoapParam)
void c_SoapParam::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapParam::cloneImpl() {
  c_SoapParam *obj = NEW(c_SoapParam)();
  cloneSet(obj);
  return obj;
}
void c_SoapParam::cloneSet(c_SoapParam *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapParam::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
        return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapParam::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapParam::ci___destruct((void*)&c_SoapParam::i___destruct, (void*)&c_SoapParam::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapParam::ci___construct((void*)&c_SoapParam::i___construct, (void*)&c_SoapParam::ifa___construct, 2, 4, 0x0000000000000000LL);
Variant c_SoapParam::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapParam::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapParam::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapParam::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapParam *self = NULL;
  p_SoapParam pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapParam*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__construct", count, 2, 2, 1);
  return (self->t___construct(a0, a1), null);
}
bool c_SoapParam::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapParam::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapParam::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapParam::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapParam *c_SoapParam::create(Variant a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapParam::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    }
  }
  return this;
}
void c_SoapParam::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  }
}
void c_SoapParam::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapParam::ci___construct;
  mcp.obj = this;
}
void c_SoapParam::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 2) throw_wrong_arguments("__construct", count, 2, 2, 1);
  (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapParam = {
  c_SoapParam::os_getInit,
  c_SoapParam::os_get,
  c_SoapParam::os_lval,
  c_SoapParam::os_invoke,
  c_SoapParam::os_constant,
  c_SoapParam::os_get_call_info
};
Object co_DateTime(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DateTime)())->dynCreate(params, init));
}
Object coo_DateTime() {
  Object r(NEW(c_DateTime)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
Variant c_DateTime::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
Variant c_DateTime::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
Variant &c_DateTime::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
void c_DateTime::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
void c_DateTime::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DateTime
Variant * c_DateTime::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
Variant * c_DateTime::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
Variant * c_DateTime::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DateTime
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
Variant c_DateTime::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 31) {
    case 4:
      HASH_RETURN(0x65F665B8975D4C44LL, q_DateTime_RSS, "RSS");
      break;
    case 5:
      HASH_RETURN(0x4C70260A54584B05LL, q_DateTime_ATOM, "ATOM");
      break;
    case 9:
      HASH_RETURN(0x0D93F5DDBEAD7BC9LL, q_DateTime_ISO8601, "ISO8601");
      break;
    case 10:
      HASH_RETURN(0x2E8A54E476F8FF8ALL, q_DateTime_RFC850, "RFC850");
      break;
    case 12:
      HASH_RETURN(0x2183317DB64F7D2CLL, q_DateTime_COOKIE, "COOKIE");
      HASH_RETURN(0x51E9E1D29858652CLL, q_DateTime_RFC1036, "RFC1036");
      HASH_RETURN(0x2035891FE861602CLL, q_DateTime_RFC3339, "RFC3339");
      break;
    case 23:
      HASH_RETURN(0x1CC8F0E77D83F017LL, q_DateTime_RFC2822, "RFC2822");
      break;
    case 27:
      HASH_RETURN(0x64B53064426F891BLL, q_DateTime_RFC822, "RFC822");
      HASH_RETURN(0x0D99FD60C002B3DBLL, q_DateTime_W3C, "W3C");
      break;
    case 30:
      HASH_RETURN(0x325DE23E7968F7FELL, q_DateTime_RFC1123, "RFC1123");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DateTime
IMPLEMENT_CLASS(DateTime)
void c_DateTime::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DateTime::cloneImpl() {
  c_DateTime *obj = NEW(c_DateTime)();
  cloneSet(obj);
  return obj;
}
void c_DateTime::cloneSet(c_DateTime *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DateTime::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss70529da2, "modify")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
        return (t_modify(a0));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss658c946d, "setDate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
        return (t_setdate(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss71028683, "getOffset")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
        return (t_getoffset());
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss424e8241, "getTimezone")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
        return (t_gettimezone());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss7358e00d, "setISODate")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
        if (count <= 2) return (t_setisodate(a0, a1));
        else return (t_setisodate(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss61782b95, "setTime")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
        if (count <= 2) return (t_settime(a0, a1));
        else return (t_settime(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss53950219, "setTimezone")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
        return (t_settimezone(a0));
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss19281e76, "format")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
        return (t_format(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DateTime::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DateTime::ci_format((void*)&c_DateTime::i_format, (void*)&c_DateTime::ifa_format, 1, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_setdate((void*)&c_DateTime::i_setdate, (void*)&c_DateTime::ifa_setdate, 3, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci___destruct((void*)&c_DateTime::i___destruct, (void*)&c_DateTime::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_getoffset((void*)&c_DateTime::i_getoffset, (void*)&c_DateTime::ifa_getoffset, 0, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_settime((void*)&c_DateTime::i_settime, (void*)&c_DateTime::ifa_settime, 3, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci___construct((void*)&c_DateTime::i___construct, (void*)&c_DateTime::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_gettimezone((void*)&c_DateTime::i_gettimezone, (void*)&c_DateTime::ifa_gettimezone, 0, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_setisodate((void*)&c_DateTime::i_setisodate, (void*)&c_DateTime::ifa_setisodate, 3, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_settimezone((void*)&c_DateTime::i_settimezone, (void*)&c_DateTime::ifa_settimezone, 1, 4, 0x0000000000000000LL);
CallInfo c_DateTime::ci_modify((void*)&c_DateTime::i_modify, (void*)&c_DateTime::ifa_modify, 1, 4, 0x0000000000000000LL);
Variant c_DateTime::i_format(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_format(arg0));
  }
}
Variant c_DateTime::i_setdate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setdate(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTime::i_getoffset(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
  return (self->t_getoffset());
}
Variant c_DateTime::i_settime(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_settime(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_settime(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DateTime::i_gettimezone(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
  return (self->t_gettimezone());
}
Variant c_DateTime::i_setisodate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_setisodate(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setisodate(arg0, arg1, arg2));
  }
}
Variant c_DateTime::i_settimezone(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_settimezone(arg0));
  }
}
Variant c_DateTime::i_modify(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_modify(arg0));
  }
}
Variant c_DateTime::ifa_format(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("format", count, 1, 1, 1);
  return (self->t_format(a0));
}
Variant c_DateTime::ifa_setdate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setdate", count, 3, 3, 1);
  return (self->t_setdate(a0, a1, a2));
}
Variant c_DateTime::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DateTime::ifa_getoffset(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getoffset", 0, 1);
  return (self->t_getoffset());
}
Variant c_DateTime::ifa_settime(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("settime", count, 2, 3, 1);
  if (count <= 2) return (self->t_settime(a0, a1));
  return (self->t_settime(a0, a1, a2));
}
Variant c_DateTime::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DateTime::ifa_gettimezone(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("gettimezone", 0, 1);
  return (self->t_gettimezone());
}
Variant c_DateTime::ifa_setisodate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("setisodate", count, 2, 3, 1);
  if (count <= 2) return (self->t_setisodate(a0, a1));
  return (self->t_setisodate(a0, a1, a2));
}
Variant c_DateTime::ifa_settimezone(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("settimezone", count, 1, 1, 1);
  return (self->t_settimezone(a0));
}
Variant c_DateTime::ifa_modify(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DateTime *self = NULL;
  p_DateTime pobj;
  if (mcp.obj) {
    self = static_cast<c_DateTime*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("modify", count, 1, 1, 1);
  return (self->t_modify(a0));
}
bool c_DateTime::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 7:
      HASH_GUARD_LITSTR(0x65A9B2950F080587LL, NAMSTR(s_sys_ss70529da2, "modify")) {
        mcp.ci = &c_DateTime::ci_modify;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x67314943DC9D120BLL, NAMSTR(s_sys_ss658c946d, "setDate")) {
        mcp.ci = &c_DateTime::ci_setdate;
        return true;
      }
      HASH_GUARD_LITSTR(0x68DB66F60B55BD0BLL, NAMSTR(s_sys_ss71028683, "getOffset")) {
        mcp.ci = &c_DateTime::ci_getoffset;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x688601F33BE7716CLL, NAMSTR(s_sys_ss424e8241, "getTimezone")) {
        mcp.ci = &c_DateTime::ci_gettimezone;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DateTime::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x16D6DBFD6EE55A74LL, NAMSTR(s_sys_ss7358e00d, "setISODate")) {
        mcp.ci = &c_DateTime::ci_setisodate;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x07CB96AB34F4C258LL, NAMSTR(s_sys_ss61782b95, "setTime")) {
        mcp.ci = &c_DateTime::ci_settime;
        return true;
      }
      HASH_GUARD_LITSTR(0x3B576E558B957CB8LL, NAMSTR(s_sys_ss53950219, "setTimezone")) {
        mcp.ci = &c_DateTime::ci_settimezone;
        return true;
      }
      break;
    case 27:
      HASH_GUARD_LITSTR(0x1B6DDAF6AAF8CA9BLL, NAMSTR(s_sys_ss19281e76, "format")) {
        mcp.ci = &c_DateTime::ci_format;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DateTime::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DateTime::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DateTime *c_DateTime::create(String a0, Object a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DateTime::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DateTime::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DateTime::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DateTime::ci___construct;
  mcp.obj = this;
}
void c_DateTime::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DateTime = {
  c_DateTime::os_getInit,
  c_DateTime::os_get,
  c_DateTime::os_lval,
  c_DateTime::os_invoke,
  c_DateTime::os_constant,
  c_DateTime::os_get_call_info
};
Object co_Collator(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_Collator)())->dynCreate(params, init));
}
Object coo_Collator() {
  Object r(NEW(c_Collator)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
Variant c_Collator::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
Variant c_Collator::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
Variant &c_Collator::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
void c_Collator::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
void c_Collator::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_Collator
Variant * c_Collator::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
Variant * c_Collator::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
Variant * c_Collator::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_Collator
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
Variant c_Collator::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_RETURN(0x44D1DA387595A403LL, q_Collator_SORT_REGULAR, "SORT_REGULAR");
      HASH_RETURN(0x243ECA9F2933DFC3LL, q_Collator_ON, "ON");
      break;
    case 4:
      HASH_RETURN(0x2FC0EE2E1B088E44LL, q_Collator_NUMERIC_COLLATION, "NUMERIC_COLLATION");
      break;
    case 7:
      HASH_RETURN(0x11D151DDDD2A4107LL, q_Collator_HIRAGANA_QUATERNARY_MODE, "HIRAGANA_QUATERNARY_MODE");
      break;
    case 12:
      HASH_RETURN(0x12C49411F55E648CLL, q_Collator_QUATERNARY, "QUATERNARY");
      break;
    case 20:
      HASH_RETURN(0x6A7AD33CDF49E8D4LL, q_Collator_SORT_NUMERIC, "SORT_NUMERIC");
      HASH_RETURN(0x342F3FCC372ABD54LL, q_Collator_NON_IGNORABLE, "NON_IGNORABLE");
      break;
    case 21:
      HASH_RETURN(0x43A7AE36C693E955LL, q_Collator_DEFAULT_VALUE, "DEFAULT_VALUE");
      break;
    case 24:
      HASH_RETURN(0x6DED35804EDAD218LL, q_Collator_CASE_LEVEL, "CASE_LEVEL");
      HASH_RETURN(0x0AE48A6C6BE5D798LL, q_Collator_LOWER_FIRST, "LOWER_FIRST");
      break;
    case 27:
      HASH_RETURN(0x2C6A6D2A478AF4DBLL, q_Collator_UPPER_FIRST, "UPPER_FIRST");
      break;
    case 29:
      HASH_RETURN(0x58342E71EC59E4DDLL, q_Collator_IDENTICAL, "IDENTICAL");
      break;
    case 32:
      HASH_RETURN(0x092DDC88428C3A20LL, q_Collator_PRIMARY, "PRIMARY");
      break;
    case 33:
      HASH_RETURN(0x713FE3D58B4C7661LL, q_Collator_FRENCH_COLLATION, "FRENCH_COLLATION");
      HASH_RETURN(0x25FE54F210EC5FE1LL, q_Collator_SECONDARY, "SECONDARY");
      HASH_RETURN(0x6E252898020550A1LL, q_Collator_TERTIARY, "TERTIARY");
      break;
    case 35:
      HASH_RETURN(0x2C984380FDBF8563LL, q_Collator_STRENGTH, "STRENGTH");
      break;
    case 39:
      HASH_RETURN(0x7306AAA31A7C8BE7LL, q_Collator_DEFAULT_STRENGTH, "DEFAULT_STRENGTH");
      break;
    case 45:
      HASH_RETURN(0x304F6E12C5B7486DLL, q_Collator_CASE_FIRST, "CASE_FIRST");
      break;
    case 52:
      HASH_RETURN(0x395D56BB0A8525F4LL, q_Collator_NORMALIZATION_MODE, "NORMALIZATION_MODE");
      break;
    case 53:
      HASH_RETURN(0x595FDD99C9EFE835LL, q_Collator_ALTERNATE_HANDLING, "ALTERNATE_HANDLING");
      break;
    case 60:
      HASH_RETURN(0x334AAA38C97C62FCLL, q_Collator_SORT_STRING, "SORT_STRING");
      HASH_RETURN(0x0039CBFC3620143CLL, q_Collator_SHIFTED, "SHIFTED");
      break;
    case 61:
      HASH_RETURN(0x136402C9E51A75FDLL, q_Collator_OFF, "OFF");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_Collator
IMPLEMENT_CLASS(Collator)
void c_Collator::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_Collator::cloneImpl() {
  c_Collator *obj = NEW(c_Collator)();
  cloneSet(obj);
  return obj;
}
void c_Collator::cloneSet(c_Collator *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_Collator::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss269cdcbb, "geterrorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
        return (t_geterrorcode());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss7a6049f4, "getlocale")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
        if (count <= 0) return (t_getlocale());
        else return (t_getlocale(a0));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss7416f7f1, "sort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
        if (count <= 1) return (t_sort(ref(a0)));
        else return (t_sort(ref(a0), a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss61f821f0, "sortwithsortkeys")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
        return (t_sortwithsortkeys(ref(a0)));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss3763e869, "asort")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = ref((*it)->refval(env));
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
        if (count <= 1) return (t_asort(ref(a0)));
        else return (t_asort(ref(a0), a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss343a37dc, "geterrormessage")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
        return (t_geterrormessage());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss7c760c1c, "compare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
        return (t_compare(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss52e73952, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(o_getClassName(), a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss2cb2e0eb, "setstrength")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
        return (t_setstrength(a0));
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss795eabe2, "getstrength")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
        return (t_getstrength());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_Collator::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss52e73952, "create")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
        return (ti_create(c, a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_Collator::ci_getattribute((void*)&c_Collator::i_getattribute, (void*)&c_Collator::ifa_getattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_sortwithsortkeys((void*)&c_Collator::i_sortwithsortkeys, (void*)&c_Collator::ifa_sortwithsortkeys, 1, 4, 0x0000000000000001LL);
CallInfo c_Collator::ci___destruct((void*)&c_Collator::i___destruct, (void*)&c_Collator::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci___construct((void*)&c_Collator::i___construct, (void*)&c_Collator::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_sort((void*)&c_Collator::i_sort, (void*)&c_Collator::ifa_sort, 2, 4, 0x0000000000000001LL);
CallInfo c_Collator::ci_geterrorcode((void*)&c_Collator::i_geterrorcode, (void*)&c_Collator::ifa_geterrorcode, 0, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_getstrength((void*)&c_Collator::i_getstrength, (void*)&c_Collator::ifa_getstrength, 0, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_asort((void*)&c_Collator::i_asort, (void*)&c_Collator::ifa_asort, 2, 4, 0x0000000000000001LL);
CallInfo c_Collator::ci_setstrength((void*)&c_Collator::i_setstrength, (void*)&c_Collator::ifa_setstrength, 1, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_create((void*)&c_Collator::i_create, (void*)&c_Collator::ifa_create, 1, 12, 0x0000000000000000LL);
CallInfo c_Collator::ci_setattribute((void*)&c_Collator::i_setattribute, (void*)&c_Collator::ifa_setattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_getlocale((void*)&c_Collator::i_getlocale, (void*)&c_Collator::ifa_getlocale, 1, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_geterrormessage((void*)&c_Collator::i_geterrormessage, (void*)&c_Collator::ifa_geterrormessage, 0, 4, 0x0000000000000000LL);
CallInfo c_Collator::ci_compare((void*)&c_Collator::i_compare, (void*)&c_Collator::ifa_compare, 2, 4, 0x0000000000000000LL);
Variant c_Collator::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_Collator::i_sortwithsortkeys(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    return (self->t_sortwithsortkeys(arg0));
  }
}
Variant c_Collator::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Collator::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_Collator::i_sort(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (self->t_sort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_sort(arg0, arg1));
  }
}
Variant c_Collator::i_geterrorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
  return (self->t_geterrorcode());
}
Variant c_Collator::i_getstrength(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
  return (self->t_getstrength());
}
Variant c_Collator::i_asort(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
  const_cast<Array&>(params).escalate(true);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0(ref(ad->getValueRef(pos)));
    if (count <= 1) return (self->t_asort(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_asort(arg0, arg1));
  }
}
Variant c_Collator::i_setstrength(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setstrength(arg0));
  }
}
Variant c_Collator::i_create(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (c_Collator::ti_create(c, arg0));
  }
}
Variant c_Collator::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_Collator::i_getlocale(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_getlocale());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getlocale(arg0));
  }
}
Variant c_Collator::i_geterrormessage(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
  return (self->t_geterrormessage());
}
Variant c_Collator::i_compare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_compare(arg0, arg1));
  }
}
Variant c_Collator::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_Collator::ifa_sortwithsortkeys(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("sortwithsortkeys", count, 1, 1, 1);
  return (self->t_sortwithsortkeys(ref(a0)));
}
Variant c_Collator::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_Collator::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_Collator::ifa_sort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("sort", count, 1, 2, 1);
  if (count <= 1) return (self->t_sort(ref(a0)));
  return (self->t_sort(ref(a0), a1));
}
Variant c_Collator::ifa_geterrorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrorcode", 0, 1);
  return (self->t_geterrorcode());
}
Variant c_Collator::ifa_getstrength(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getstrength", 0, 1);
  return (self->t_getstrength());
}
Variant c_Collator::ifa_asort(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("asort", count, 1, 2, 1);
  if (count <= 1) return (self->t_asort(ref(a0)));
  return (self->t_asort(ref(a0), a1));
}
Variant c_Collator::ifa_setstrength(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setstrength", count, 1, 1, 1);
  return (self->t_setstrength(a0));
}
Variant c_Collator::ifa_create(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count != 1) return throw_wrong_arguments("create", count, 1, 1, 1);
  return (c_Collator::ti_create(c, a0));
}
Variant c_Collator::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_Collator::ifa_getlocale(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("getlocale", 1, 1);
  if (count <= 0) return (self->t_getlocale());
  return (self->t_getlocale(a0));
}
Variant c_Collator::ifa_geterrormessage(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrormessage", 0, 1);
  return (self->t_geterrormessage());
}
Variant c_Collator::ifa_compare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_Collator *self = NULL;
  p_Collator pobj;
  if (mcp.obj) {
    self = static_cast<c_Collator*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("compare", count, 2, 2, 1);
  return (self->t_compare(a0, a1));
}
bool c_Collator::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x43E057044D6296E0LL, NAMSTR(s_sys_ss269cdcbb, "geterrorcode")) {
        mcp.ci = &c_Collator::ci_geterrorcode;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x2C7E06EB2965CE02LL, NAMSTR(s_sys_ss7a6049f4, "getlocale")) {
        mcp.ci = &c_Collator::ci_getlocale;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        mcp.ci = &c_Collator::ci_getattribute;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1F4984938E1DBB2ALL, NAMSTR(s_sys_ss7416f7f1, "sort")) {
        mcp.ci = &c_Collator::ci_sort;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        mcp.ci = &c_Collator::ci_setattribute;
        return true;
      }
      break;
    case 11:
      HASH_GUARD_LITSTR(0x365C573D887803EBLL, NAMSTR(s_sys_ss61f821f0, "sortwithsortkeys")) {
        mcp.ci = &c_Collator::ci_sortwithsortkeys;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x790B7C44A3442BEELL, NAMSTR(s_sys_ss3763e869, "asort")) {
        mcp.ci = &c_Collator::ci_asort;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x3B4D97DC8C437CD1LL, NAMSTR(s_sys_ss343a37dc, "geterrormessage")) {
        mcp.ci = &c_Collator::ci_geterrormessage;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x1BF74792BDECF352LL, NAMSTR(s_sys_ss7c760c1c, "compare")) {
        mcp.ci = &c_Collator::ci_compare;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_Collator::ci___destruct;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x3A0A2C5D90518456LL, NAMSTR(s_sys_ss52e73952, "create")) {
        mcp.ci = &c_Collator::ci_create;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x0B7AA0ED4CBF9ED7LL, NAMSTR(s_sys_ss2cb2e0eb, "setstrength")) {
        mcp.ci = &c_Collator::ci_setstrength;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1C15B5A1A05B4C5ELL, NAMSTR(s_sys_ss795eabe2, "getstrength")) {
        mcp.ci = &c_Collator::ci_getstrength;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_Collator::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_Collator::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_Collator *c_Collator::create(String a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_Collator::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_Collator::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_Collator::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_Collator::ci___construct;
  mcp.obj = this;
}
void c_Collator::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_Collator = {
  c_Collator::os_getInit,
  c_Collator::os_get,
  c_Collator::os_lval,
  c_Collator::os_invoke,
  c_Collator::os_constant,
  c_Collator::os_get_call_info
};
Object co_PDO(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_PDO)())->dynCreate(params, init));
}
Object coo_PDO() {
  Object r(NEW(c_PDO)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
Variant c_PDO::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
Variant c_PDO::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
Variant &c_PDO::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
void c_PDO::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
void c_PDO::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PDO
Variant * c_PDO::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
Variant * c_PDO::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
Variant * c_PDO::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_PDO
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
Variant c_PDO::os_constant(const char *s) {
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 0:
      HASH_RETURN(0x1800ED92A8884D00LL, q_PDO_ATTR_CASE, "ATTR_CASE");
      break;
    case 2:
      HASH_RETURN(0x07BAFBAE5A431902LL, q_PDO_ATTR_STATEMENT_CLASS, "ATTR_STATEMENT_CLASS");
      break;
    case 4:
      HASH_RETURN(0x0229D662F91D9C04LL, q_PDO_ERRMODE_EXCEPTION, "ERRMODE_EXCEPTION");
      break;
    case 8:
      HASH_RETURN(0x3BE7A02FD980AA08LL, q_PDO_CASE_NATURAL, "CASE_NATURAL");
      break;
    case 13:
      HASH_RETURN(0x099B533427CCC20DLL, q_PDO_FETCH_OBJ, "FETCH_OBJ");
      break;
    case 17:
      HASH_RETURN(0x5FAD218776C6E511LL, q_PDO_FETCH_INTO, "FETCH_INTO");
      break;
    case 25:
      HASH_RETURN(0x78CB81320C710019LL, q_PDO_FETCH_BOUND, "FETCH_BOUND");
      break;
    case 27:
      HASH_RETURN(0x3158D52C3627FE1BLL, q_PDO_MYSQL_ATTR_INIT_COMMAND, "MYSQL_ATTR_INIT_COMMAND");
      break;
    case 28:
      HASH_RETURN(0x03CF598D3CCCD01CLL, q_PDO_ATTR_CLIENT_VERSION, "ATTR_CLIENT_VERSION");
      break;
    case 29:
      HASH_RETURN(0x2BE16C4111A7B41DLL, q_PDO_ATTR_FETCH_CATALOG_NAMES, "ATTR_FETCH_CATALOG_NAMES");
      break;
    case 30:
      HASH_RETURN(0x2A5BA04D0218F11ELL, q_PDO_CASE_LOWER, "CASE_LOWER");
      break;
    case 35:
      HASH_RETURN(0x16B15CF4B0DD7E23LL, q_PDO_FETCH_GROUP, "FETCH_GROUP");
      break;
    case 37:
      HASH_RETURN(0x37F650C462FB6A25LL, q_PDO_CASE_UPPER, "CASE_UPPER");
      break;
    case 42:
      HASH_RETURN(0x262D9BE84029992ALL, q_PDO_PARAM_EVT_FETCH_POST, "PARAM_EVT_FETCH_POST");
      break;
    case 51:
      HASH_RETURN(0x15D2BCCED7726933LL, q_PDO_ATTR_TIMEOUT, "ATTR_TIMEOUT");
      break;
    case 59:
      HASH_RETURN(0x01B17428BEE0243BLL, q_PDO_PARAM_EVT_EXEC_PRE, "PARAM_EVT_EXEC_PRE");
      break;
    case 60:
      HASH_RETURN(0x2739A1D49673D43CLL, q_PDO_ATTR_ERRMODE, "ATTR_ERRMODE");
      HASH_RETURN(0x6AC5C285F4DD863CLL, q_PDO_ATTR_DEFAULT_FETCH_MODE, "ATTR_DEFAULT_FETCH_MODE");
      break;
    case 61:
      HASH_RETURN(0x3E11051E4101D73DLL, q_PDO_ATTR_EMULATE_PREPARES, "ATTR_EMULATE_PREPARES");
      break;
    case 68:
      HASH_RETURN(0x2189354E22363544LL, q_PDO_ATTR_PREFETCH, "ATTR_PREFETCH");
      break;
    case 72:
      HASH_RETURN(0x428D5CA64BB99E48LL, q_PDO_FETCH_UNIQUE, "FETCH_UNIQUE");
      break;
    case 78:
      HASH_RETURN(0x39B4E90F36E93B4ELL, q_PDO_MYSQL_ATTR_READ_DEFAULT_GROUP, "MYSQL_ATTR_READ_DEFAULT_GROUP");
      break;
    case 82:
      HASH_RETURN(0x58A833E2336C6152LL, q_PDO_ATTR_SERVER_INFO, "ATTR_SERVER_INFO");
      break;
    case 86:
      HASH_RETURN(0x57B75F4773C81556LL, q_PDO_PARAM_EVT_NORMALIZE, "PARAM_EVT_NORMALIZE");
      break;
    case 91:
      HASH_RETURN(0x5495020CF262F15BLL, q_PDO_ATTR_CONNECTION_STATUS, "ATTR_CONNECTION_STATUS");
      HASH_RETURN(0x37888F551D85275BLL, q_PDO_ATTR_ORACLE_NULLS, "ATTR_ORACLE_NULLS");
      break;
    case 97:
      HASH_RETURN(0x416A0550A8F12E61LL, q_PDO_MYSQL_ATTR_FOUND_ROWS, "MYSQL_ATTR_FOUND_ROWS");
      break;
    case 101:
      HASH_RETURN(0x15A3522970275465LL, q_PDO_FETCH_ORI_NEXT, "FETCH_ORI_NEXT");
      break;
    case 104:
      HASH_RETURN(0x162EAA2134F1C068LL, q_PDO_ATTR_FETCH_TABLE_NAMES, "ATTR_FETCH_TABLE_NAMES");
      break;
    case 111:
      HASH_RETURN(0x350E9275757FD66FLL, q_PDO_FETCH_ORI_REL, "FETCH_ORI_REL");
      break;
    case 112:
      HASH_RETURN(0x6870D9DE66F43D70LL, q_PDO_FETCH_ASSOC, "FETCH_ASSOC");
      break;
    case 113:
      HASH_RETURN(0x713C8339790FC071LL, q_PDO_ATTR_CURSOR_NAME, "ATTR_CURSOR_NAME");
      break;
    case 116:
      HASH_RETURN(0x1FB97A35B6711374LL, q_PDO_ATTR_MAX_COLUMN_LEN, "ATTR_MAX_COLUMN_LEN");
      break;
    case 117:
      HASH_RETURN(0x0E51487F9370EE75LL, q_PDO_ATTR_AUTOCOMMIT, "ATTR_AUTOCOMMIT");
      break;
    case 121:
      HASH_RETURN(0x630122BA9EC73379LL, q_PDO_PARAM_NULL, "PARAM_NULL");
      HASH_RETURN(0x05B00276031D7D79LL, q_PDO_PARAM_EVT_ALLOC, "PARAM_EVT_ALLOC");
      break;
    case 125:
      HASH_RETURN(0x500C039681520C7DLL, q_PDO_PARAM_BOOL, "PARAM_BOOL");
      break;
    case 126:
      HASH_RETURN(0x5CF4F38A0D7D087ELL, q_PDO_NULL_NATURAL, "NULL_NATURAL");
      break;
    case 131:
      HASH_RETURN(0x3F414F2735132983LL, q_PDO_PARAM_INT, "PARAM_INT");
      break;
    case 132:
      HASH_RETURN(0x2011B5A528057784LL, q_PDO_FETCH_NUM, "FETCH_NUM");
      break;
    case 133:
      HASH_RETURN(0x5451E44C627DD885LL, q_PDO_FETCH_ORI_PRIOR, "FETCH_ORI_PRIOR");
      break;
    case 134:
      HASH_RETURN(0x1B8BA5EEAABCB786LL, q_PDO_PARAM_EVT_EXEC_POST, "PARAM_EVT_EXEC_POST");
      HASH_RETURN(0x1B51C692B91D7486LL, q_PDO_MYSQL_ATTR_USE_BUFFERED_QUERY, "MYSQL_ATTR_USE_BUFFERED_QUERY");
      break;
    case 136:
      HASH_RETURN(0x7E64209D5A925F88LL, q_PDO_PARAM_STR, "PARAM_STR");
      break;
    case 138:
      HASH_RETURN(0x45AB9806DE21EA8ALL, q_PDO_ATTR_CURSOR, "ATTR_CURSOR");
      break;
    case 141:
      HASH_RETURN(0x0EDB017494A81E8DLL, q_PDO_ATTR_DRIVER_NAME, "ATTR_DRIVER_NAME");
      break;
    case 142:
      HASH_RETURN(0x126B3038F3355A8ELL, q_PDO_FETCH_USE_DEFAULT, "FETCH_USE_DEFAULT");
      break;
    case 143:
      HASH_RETURN(0x1F200B094608BE8FLL, q_PDO_ATTR_SERVER_VERSION, "ATTR_SERVER_VERSION");
      HASH_RETURN(0x1175C5F56147488FLL, q_PDO_MYSQL_ATTR_DIRECT_QUERY, "MYSQL_ATTR_DIRECT_QUERY");
      break;
    case 150:
      HASH_RETURN(0x25BE9238386C2796LL, q_PDO_FETCH_PROPS_LATE, "FETCH_PROPS_LATE");
      break;
    case 153:
      HASH_RETURN(0x657BEA5F741C4999LL, q_PDO_FETCH_COLUMN, "FETCH_COLUMN");
      HASH_RETURN(0x18B801DE8D8C9099LL, q_PDO_FETCH_CLASSTYPE, "FETCH_CLASSTYPE");
      break;
    case 156:
      HASH_RETURN(0x1EC178DF86F4FD9CLL, q_PDO_FETCH_SERIALIZE, "FETCH_SERIALIZE");
      break;
    case 160:
      HASH_RETURN(0x052245CE02FBF4A0LL, q_PDO_MYSQL_ATTR_LOCAL_INFILE, "MYSQL_ATTR_LOCAL_INFILE");
      break;
    case 162:
      HASH_RETURN(0x28D5B850B76FEEA2LL, q_PDO_FETCH_BOTH, "FETCH_BOTH");
      HASH_RETURN(0x0D0BCCC6768A88A2LL, q_PDO_FETCH_KEY_PAIR, "FETCH_KEY_PAIR");
      break;
    case 164:
      HASH_RETURN(0x6851B7545234FCA4LL, q_PDO_PARAM_EVT_FETCH_PRE, "PARAM_EVT_FETCH_PRE");
      break;
    case 168:
      HASH_RETURN(0x167DD614E842FAA8LL, q_PDO_CURSOR_FWDONLY, "CURSOR_FWDONLY");
      break;
    case 169:
      HASH_RETURN(0x6AEB66DE7A454FA9LL, q_PDO_FETCH_ORI_FIRST, "FETCH_ORI_FIRST");
      break;
    case 170:
      HASH_RETURN(0x392400A66B305EAALL, q_PDO_CURSOR_SCROLL, "CURSOR_SCROLL");
      break;
    case 171:
      HASH_RETURN(0x2F6AE87AF5701AABLL, q_PDO_FETCH_ORI_LAST, "FETCH_ORI_LAST");
      break;
    case 180:
      HASH_RETURN(0x56D59339A0F5D8B4LL, q_PDO_ATTR_PERSISTENT, "ATTR_PERSISTENT");
      break;
    case 184:
      HASH_RETURN(0x08657D6005DD08B8LL, q_PDO_NULL_EMPTY_STRING, "NULL_EMPTY_STRING");
      break;
    case 197:
      HASH_RETURN(0x60CE39F6493319C5LL, q_PDO_ATTR_STRINGIFY_FETCHES, "ATTR_STRINGIFY_FETCHES");
      break;
    case 198:
      HASH_RETURN(0x61BD1667BB46C9C6LL, q_PDO_MYSQL_ATTR_READ_DEFAULT_FILE, "MYSQL_ATTR_READ_DEFAULT_FILE");
      break;
    case 200:
      HASH_RETURN(0x30D00303975C98C8LL, q_PDO_FETCH_FUNC, "FETCH_FUNC");
      HASH_RETURN(0x47D4494BE4FA26C8LL, q_PDO_FETCH_ORI_ABS, "FETCH_ORI_ABS");
      break;
    case 202:
      HASH_RETURN(0x29B68A596E0615CALL, q_PDO_NULL_TO_STRING, "NULL_TO_STRING");
      break;
    case 203:
      HASH_RETURN(0x73FAA1AA068D19CBLL, q_PDO_MYSQL_ATTR_MAX_BUFFER_SIZE, "MYSQL_ATTR_MAX_BUFFER_SIZE");
      break;
    case 208:
      HASH_RETURN(0x439351C7C64634D0LL, q_PDO_FETCH_CLASS, "FETCH_CLASS");
      break;
    case 209:
      HASH_RETURN(0x5C75BB222F23C4D1LL, q_PDO_FETCH_LAZY, "FETCH_LAZY");
      break;
    case 211:
      HASH_RETURN(0x57F9152D7EC3A5D3LL, q_PDO_MYSQL_ATTR_COMPRESS, "MYSQL_ATTR_COMPRESS");
      break;
    case 220:
      HASH_RETURN(0x4D1DDF7F772C54DCLL, q_PDO_ERRMODE_WARNING, "ERRMODE_WARNING");
      break;
    case 235:
      HASH_RETURN(0x2E4175EAAB1F75EBLL, q_PDO_ERRMODE_SILENT, "ERRMODE_SILENT");
      break;
    case 245:
      HASH_RETURN(0x16017F3F58821EF5LL, q_PDO_ERR_NONE, "ERR_NONE");
      break;
    case 246:
      HASH_RETURN(0x674F9B0D2030C3F6LL, q_PDO_PARAM_LOB, "PARAM_LOB");
      break;
    case 247:
      HASH_RETURN(0x16EC9F213D7F57F7LL, q_PDO_FETCH_NAMED, "FETCH_NAMED");
      break;
    case 248:
      HASH_RETURN(0x6C0021FD5D20A1F8LL, q_PDO_PARAM_INPUT_OUTPUT, "PARAM_INPUT_OUTPUT");
      break;
    case 251:
      HASH_RETURN(0x13EC16B8F7B7B1FBLL, q_PDO_MYSQL_ATTR_IGNORE_SPACE, "MYSQL_ATTR_IGNORE_SPACE");
      break;
    case 253:
      HASH_RETURN(0x51938FCA0AE827FDLL, q_PDO_PARAM_STMT, "PARAM_STMT");
      break;
    case 254:
      HASH_RETURN(0x56335EC3392D8EFELL, q_PDO_PARAM_EVT_FREE, "PARAM_EVT_FREE");
      break;
    default:
      break;
  }
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_PDO
IMPLEMENT_CLASS(PDO)
void c_PDO::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_PDO::cloneImpl() {
  c_PDO *obj = NEW(c_PDO)();
  cloneSet(obj);
  return obj;
}
void c_PDO::cloneSet(c_PDO *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_PDO::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss31a11388, "errorcode")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
        return (t_errorcode());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss17f0e883, "exec")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
        return (t_exec(a0));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss717a7024, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(o_getClassName()));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss0bb83e44, "lastinsertid")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
        if (count <= 0) return (t_lastinsertid());
        else return (t_lastinsertid(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss0723515e, "__wakeup")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
        return (t___wakeup());
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss07706afb, "errorinfo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
        return (t_errorinfo());
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else return (t___construct(a0, a1, a2, a3), null);
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss580793a6, "commit")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("commit", 0, 1);
        return (t_commit());
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss0c905545, "__sleep")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
        return (t___sleep());
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss3d6f0745, "quote")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
        if (count <= 1) return (t_quote(a0));
        else return (t_quote(a0, a1));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss48724660, "prepare")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
        if (count <= 1) return (t_prepare(a0));
        else return (t_prepare(a0, a1));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss4e21b0f1, "rollback")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
        return (t_rollback());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
        return (t_query(a0));
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss1a3870d9, "begintransaction")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
        return (t_begintransaction());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_PDO::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 1) {
    case 0:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss717a7024, "getavailabledrivers")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
        return (ti_getavailabledrivers(c));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_PDO::ci_errorcode((void*)&c_PDO::i_errorcode, (void*)&c_PDO::ifa_errorcode, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_getattribute((void*)&c_PDO::i_getattribute, (void*)&c_PDO::ifa_getattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_exec((void*)&c_PDO::i_exec, (void*)&c_PDO::ifa_exec, 1, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_lastinsertid((void*)&c_PDO::i_lastinsertid, (void*)&c_PDO::ifa_lastinsertid, 1, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci___destruct((void*)&c_PDO::i___destruct, (void*)&c_PDO::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci___wakeup((void*)&c_PDO::i___wakeup, (void*)&c_PDO::ifa___wakeup, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci___construct((void*)&c_PDO::i___construct, (void*)&c_PDO::ifa___construct, 4, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_query((void*)&c_PDO::i_query, (void*)&c_PDO::ifa_query, 1, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_rollback((void*)&c_PDO::i_rollback, (void*)&c_PDO::ifa_rollback, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_commit((void*)&c_PDO::i_commit, (void*)&c_PDO::ifa_commit, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_getavailabledrivers((void*)&c_PDO::i_getavailabledrivers, (void*)&c_PDO::ifa_getavailabledrivers, 0, 12, 0x0000000000000000LL);
CallInfo c_PDO::ci_quote((void*)&c_PDO::i_quote, (void*)&c_PDO::ifa_quote, 2, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_setattribute((void*)&c_PDO::i_setattribute, (void*)&c_PDO::ifa_setattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_begintransaction((void*)&c_PDO::i_begintransaction, (void*)&c_PDO::ifa_begintransaction, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_prepare((void*)&c_PDO::i_prepare, (void*)&c_PDO::ifa_prepare, 2, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci_errorinfo((void*)&c_PDO::i_errorinfo, (void*)&c_PDO::ifa_errorinfo, 0, 4, 0x0000000000000000LL);
CallInfo c_PDO::ci___sleep((void*)&c_PDO::i___sleep, (void*)&c_PDO::ifa___sleep, 0, 4, 0x0000000000000000LL);
Variant c_PDO::i_errorcode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDO::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_PDO::i_exec(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_exec(arg0));
  }
}
Variant c_PDO::i_lastinsertid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_lastinsertid());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lastinsertid(arg0));
  }
}
Variant c_PDO::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDO::i___wakeup(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDO::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3), null);
  }
}
Variant c_PDO::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_query(arg0));
  }
}
Variant c_PDO::i_rollback(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
  return (self->t_rollback());
}
Variant c_PDO::i_commit(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("commit", 0, 1);
  return (self->t_commit());
}
Variant c_PDO::i_getavailabledrivers(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
  return (c_PDO::ti_getavailabledrivers(c));
}
Variant c_PDO::i_quote(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_quote(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_quote(arg0, arg1));
  }
}
Variant c_PDO::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_PDO::i_begintransaction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
  return (self->t_begintransaction());
}
Variant c_PDO::i_prepare(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_prepare(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_prepare(arg0, arg1));
  }
}
Variant c_PDO::i_errorinfo(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDO::i___sleep(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
Variant c_PDO::ifa_errorcode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorcode", 0, 1);
  return (self->t_errorcode());
}
Variant c_PDO::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_PDO::ifa_exec(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("exec", count, 1, 1, 1);
  return (self->t_exec(a0));
}
Variant c_PDO::ifa_lastinsertid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("lastinsertid", 1, 1);
  if (count <= 0) return (self->t_lastinsertid());
  return (self->t_lastinsertid(a0));
}
Variant c_PDO::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_PDO::ifa___wakeup(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__wakeup", 0, 1);
  return (self->t___wakeup());
}
Variant c_PDO::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("__construct", count, 1, 4, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  return (self->t___construct(a0, a1, a2, a3), null);
}
Variant c_PDO::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("query", count, 1, 1, 1);
  return (self->t_query(a0));
}
Variant c_PDO::ifa_rollback(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("rollback", 0, 1);
  return (self->t_rollback());
}
Variant c_PDO::ifa_commit(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("commit", 0, 1);
  return (self->t_commit());
}
Variant c_PDO::ifa_getavailabledrivers(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  CStrRef c(mcp.rootObj.is(KindOfObject) ? mcp.rootObj.getObjectData()->o_getClassName() : mcp.rootObj.toString());
  if (count > 0) return throw_toomany_arguments("getavailabledrivers", 0, 1);
  return (c_PDO::ti_getavailabledrivers(c));
}
Variant c_PDO::ifa_quote(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("quote", count, 1, 2, 1);
  if (count <= 1) return (self->t_quote(a0));
  return (self->t_quote(a0, a1));
}
Variant c_PDO::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_PDO::ifa_begintransaction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("begintransaction", 0, 1);
  return (self->t_begintransaction());
}
Variant c_PDO::ifa_prepare(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("prepare", count, 1, 2, 1);
  if (count <= 1) return (self->t_prepare(a0));
  return (self->t_prepare(a0, a1));
}
Variant c_PDO::ifa_errorinfo(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("errorinfo", 0, 1);
  return (self->t_errorinfo());
}
Variant c_PDO::ifa___sleep(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_PDO *self = NULL;
  p_PDO pobj;
  if (mcp.obj) {
    self = static_cast<c_PDO*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__sleep", 0, 1);
  return (self->t___sleep());
}
bool c_PDO::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 7:
      HASH_GUARD_LITSTR(0x6D0664CC2372F2C7LL, NAMSTR(s_sys_ss31a11388, "errorcode")) {
        mcp.ci = &c_PDO::ci_errorcode;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss1b71aee5, "setattribute")) {
        mcp.ci = &c_PDO::ci_setattribute;
        return true;
      }
      break;
    case 12:
      HASH_GUARD_LITSTR(0x4F1D1ED7B087208CLL, NAMSTR(s_sys_ss17f0e883, "exec")) {
        mcp.ci = &c_PDO::ci_exec;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x7FF4D594AC38340ELL, NAMSTR(s_sys_ss717a7024, "getavailabledrivers")) {
        mcp.ci = &c_PDO::ci_getavailabledrivers;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x25466EABBA2D7C12LL, NAMSTR(s_sys_ss0bb83e44, "lastinsertid")) {
        mcp.ci = &c_PDO::ci_lastinsertid;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x4389F50CAA085CDCLL, NAMSTR(s_sys_ss0723515e, "__wakeup")) {
        mcp.ci = &c_PDO::ci___wakeup;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x1DDD412E7F04605ELL, NAMSTR(s_sys_ss07706afb, "errorinfo")) {
        mcp.ci = &c_PDO::ci_errorinfo;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_PDO::ci___construct;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x24D23BE465E3F324LL, NAMSTR(s_sys_ss580793a6, "commit")) {
        mcp.ci = &c_PDO::ci_commit;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss740bb93c, "getattribute")) {
        mcp.ci = &c_PDO::ci_getattribute;
        return true;
      }
      break;
    case 45:
      HASH_GUARD_LITSTR(0x61D1244DDADBC02DLL, NAMSTR(s_sys_ss0c905545, "__sleep")) {
        mcp.ci = &c_PDO::ci___sleep;
        return true;
      }
      break;
    case 46:
      HASH_GUARD_LITSTR(0x1740B14E849464EELL, NAMSTR(s_sys_ss3d6f0745, "quote")) {
        mcp.ci = &c_PDO::ci_quote;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x540020AE4BA591AFLL, NAMSTR(s_sys_ss48724660, "prepare")) {
        mcp.ci = &c_PDO::ci_prepare;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_PDO::ci___destruct;
        return true;
      }
      break;
    case 54:
      HASH_GUARD_LITSTR(0x374B46BC6D79EC36LL, NAMSTR(s_sys_ss4e21b0f1, "rollback")) {
        mcp.ci = &c_PDO::ci_rollback;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        mcp.ci = &c_PDO::ci_query;
        return true;
      }
      break;
    case 59:
      HASH_GUARD_LITSTR(0x0DE392135C33E23BLL, NAMSTR(s_sys_ss1a3870d9, "begintransaction")) {
        mcp.ci = &c_PDO::ci_begintransaction;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_PDO::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_PDO *c_PDO::create(String a0, String a1, String a2, Array a3) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3);
  return this;
}
ObjectData *c_PDO::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3));
    } while (false);
  }
  return this;
}
void c_PDO::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3));
  } while (false);
}
void c_PDO::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_PDO::ci___construct;
  mcp.obj = this;
}
void c_PDO::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 4) throw_wrong_arguments("__construct", count, 1, 4, 1);
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else (t___construct(a0, a1, a2, a3), null);
}
struct ObjectStaticCallbacks cw_PDO = {
  c_PDO::os_getInit,
  c_PDO::os_get,
  c_PDO::os_lval,
  c_PDO::os_invoke,
  c_PDO::os_constant,
  c_PDO::os_get_call_info
};
Object co_ImageSprite(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_ImageSprite)())->dynCreate(params, init));
}
Object coo_ImageSprite() {
  Object r(NEW(c_ImageSprite)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
Variant c_ImageSprite::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
Variant c_ImageSprite::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
Variant &c_ImageSprite::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
void c_ImageSprite::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
void c_ImageSprite::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
Variant * c_ImageSprite::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
Variant * c_ImageSprite::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
Variant * c_ImageSprite::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_ImageSprite
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
Variant c_ImageSprite::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_ImageSprite
IMPLEMENT_CLASS(ImageSprite)
void c_ImageSprite::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_ImageSprite::cloneImpl() {
  c_ImageSprite *obj = NEW(c_ImageSprite)();
  cloneSet(obj);
  return obj;
}
void c_ImageSprite::cloneSet(c_ImageSprite *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_ImageSprite::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss7ef23ee0, "getErrors")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
        return (t_geterrors());
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss0801e92d, "loadDims")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
        if (count <= 0) return (t_loaddims());
        else return (t_loaddims(a0));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss7d4c47c4, "clear")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clear", 1, 1);
        if (count <= 0) return (t_clear());
        else return (t_clear(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss1d93a968, "addFile")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
        if (count <= 1) return (t_addfile(a0));
        else return (t_addfile(a0, a1));
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss07cc46bd, "loadImages")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
        if (count <= 0) return (t_loadimages());
        else return (t_loadimages(a0));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss1acbf5cf, "mapping")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
        return (t_mapping());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss1be35cfc, "addString")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
        if (count <= 2) return (t_addstring(a0, a1));
        else return (t_addstring(a0, a1, a2));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss672a5730, "css")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
        if (count <= 1) return (t_css(a0));
        else if (count == 2) return (t_css(a0, a1));
        else if (count == 3) return (t_css(a0, a1, a2));
        else return (t_css(a0, a1, a2, a3));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss044c14ae, "addUrl")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
        if (count <= 1) return (t_addurl(a0));
        else if (count == 2) return (t_addurl(a0, a1));
        else return (t_addurl(a0, a1, a2));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss7a5dbb24, "output")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("output", 3, 1);
        if (count <= 0) return (t_output());
        else if (count == 1) return (t_output(a0));
        else if (count == 2) return (t_output(a0, a1));
        else return (t_output(a0, a1, a2));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_ImageSprite::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_ImageSprite::ci_addstring((void*)&c_ImageSprite::i_addstring, (void*)&c_ImageSprite::ifa_addstring, 3, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_loaddims((void*)&c_ImageSprite::i_loaddims, (void*)&c_ImageSprite::ifa_loaddims, 1, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci___destruct((void*)&c_ImageSprite::i___destruct, (void*)&c_ImageSprite::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_mapping((void*)&c_ImageSprite::i_mapping, (void*)&c_ImageSprite::ifa_mapping, 0, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci___construct((void*)&c_ImageSprite::i___construct, (void*)&c_ImageSprite::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_css((void*)&c_ImageSprite::i_css, (void*)&c_ImageSprite::ifa_css, 4, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_output((void*)&c_ImageSprite::i_output, (void*)&c_ImageSprite::ifa_output, 3, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_loadimages((void*)&c_ImageSprite::i_loadimages, (void*)&c_ImageSprite::ifa_loadimages, 1, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_clear((void*)&c_ImageSprite::i_clear, (void*)&c_ImageSprite::ifa_clear, 1, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_geterrors((void*)&c_ImageSprite::i_geterrors, (void*)&c_ImageSprite::ifa_geterrors, 0, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_addurl((void*)&c_ImageSprite::i_addurl, (void*)&c_ImageSprite::ifa_addurl, 3, 4, 0x0000000000000000LL);
CallInfo c_ImageSprite::ci_addfile((void*)&c_ImageSprite::i_addfile, (void*)&c_ImageSprite::ifa_addfile, 2, 4, 0x0000000000000000LL);
Variant c_ImageSprite::i_addstring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_addstring(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addstring(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_loaddims(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_loaddims());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loaddims(arg0));
  }
}
Variant c_ImageSprite::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_ImageSprite::i_mapping(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
  return (self->t_mapping());
}
Variant c_ImageSprite::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_ImageSprite::i_css(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_css(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_css(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_css(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_css(arg0, arg1, arg2, arg3));
  }
}
Variant c_ImageSprite::i_output(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("output", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_output());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_output(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_output(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_output(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_loadimages(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_loadimages());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadimages(arg0));
  }
}
Variant c_ImageSprite::i_clear(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clear", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_clear());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_clear(arg0));
  }
}
Variant c_ImageSprite::i_geterrors(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
  return (self->t_geterrors());
}
Variant c_ImageSprite::i_addurl(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addurl(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_addurl(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addurl(arg0, arg1, arg2));
  }
}
Variant c_ImageSprite::i_addfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_addfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_addfile(arg0, arg1));
  }
}
Variant c_ImageSprite::ifa_addstring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("addstring", count, 2, 3, 1);
  if (count <= 2) return (self->t_addstring(a0, a1));
  return (self->t_addstring(a0, a1, a2));
}
Variant c_ImageSprite::ifa_loaddims(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loaddims", 1, 1);
  if (count <= 0) return (self->t_loaddims());
  return (self->t_loaddims(a0));
}
Variant c_ImageSprite::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_ImageSprite::ifa_mapping(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("mapping", 0, 1);
  return (self->t_mapping());
}
Variant c_ImageSprite::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_ImageSprite::ifa_css(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("css", count, 1, 4, 1);
  if (count <= 1) return (self->t_css(a0));
  if (count == 2) return (self->t_css(a0, a1));
  if (count == 3) return (self->t_css(a0, a1, a2));
  return (self->t_css(a0, a1, a2, a3));
}
Variant c_ImageSprite::ifa_output(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("output", 3, 1);
  if (count <= 0) return (self->t_output());
  if (count == 1) return (self->t_output(a0));
  if (count == 2) return (self->t_output(a0, a1));
  return (self->t_output(a0, a1, a2));
}
Variant c_ImageSprite::ifa_loadimages(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("loadimages", 1, 1);
  if (count <= 0) return (self->t_loadimages());
  return (self->t_loadimages(a0));
}
Variant c_ImageSprite::ifa_clear(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clear", 1, 1);
  if (count <= 0) return (self->t_clear());
  return (self->t_clear(a0));
}
Variant c_ImageSprite::ifa_geterrors(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("geterrors", 0, 1);
  return (self->t_geterrors());
}
Variant c_ImageSprite::ifa_addurl(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("addurl", count, 1, 3, 1);
  if (count <= 1) return (self->t_addurl(a0));
  if (count == 2) return (self->t_addurl(a0, a1));
  return (self->t_addurl(a0, a1, a2));
}
Variant c_ImageSprite::ifa_addfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_ImageSprite *self = NULL;
  p_ImageSprite pobj;
  if (mcp.obj) {
    self = static_cast<c_ImageSprite*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("addfile", count, 1, 2, 1);
  if (count <= 1) return (self->t_addfile(a0));
  return (self->t_addfile(a0, a1));
}
bool c_ImageSprite::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 0:
      HASH_GUARD_LITSTR(0x05D2634BA4310200LL, NAMSTR(s_sys_ss7ef23ee0, "getErrors")) {
        mcp.ci = &c_ImageSprite::ci_geterrors;
        return true;
      }
      break;
    case 2:
      HASH_GUARD_LITSTR(0x6A37A496C57D57A2LL, NAMSTR(s_sys_ss0801e92d, "loadDims")) {
        mcp.ci = &c_ImageSprite::ci_loaddims;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x31DA235C5A226667LL, NAMSTR(s_sys_ss7d4c47c4, "clear")) {
        mcp.ci = &c_ImageSprite::ci_clear;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x13A96E5A21D1906FLL, NAMSTR(s_sys_ss1d93a968, "addFile")) {
        mcp.ci = &c_ImageSprite::ci_addfile;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_ImageSprite::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x305D94BB2EC0B554LL, NAMSTR(s_sys_ss07cc46bd, "loadImages")) {
        mcp.ci = &c_ImageSprite::ci_loadimages;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x4D8226FDFA2CA297LL, NAMSTR(s_sys_ss1acbf5cf, "mapping")) {
        mcp.ci = &c_ImageSprite::ci_mapping;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x386BF72B932D233ALL, NAMSTR(s_sys_ss1be35cfc, "addString")) {
        mcp.ci = &c_ImageSprite::ci_addstring;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x63388F643871547CLL, NAMSTR(s_sys_ss672a5730, "css")) {
        mcp.ci = &c_ImageSprite::ci_css;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x79CFC8610DC84A7DLL, NAMSTR(s_sys_ss044c14ae, "addUrl")) {
        mcp.ci = &c_ImageSprite::ci_addurl;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_ImageSprite::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x07B89E83B77C677FLL, NAMSTR(s_sys_ss7a5dbb24, "output")) {
        mcp.ci = &c_ImageSprite::ci_output;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_ImageSprite::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_ImageSprite *c_ImageSprite::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_ImageSprite::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_ImageSprite::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_ImageSprite::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_ImageSprite::ci___construct;
  mcp.obj = this;
}
void c_ImageSprite::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_ImageSprite = {
  c_ImageSprite::os_getInit,
  c_ImageSprite::os_get,
  c_ImageSprite::os_lval,
  c_ImageSprite::os_invoke,
  c_ImageSprite::os_constant,
  c_ImageSprite::os_get_call_info
};
Object co_DOMEntity(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMEntity)())->dynCreate(params, init));
}
Object coo_DOMEntity() {
  Object r(NEW(c_DOMEntity)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
Variant c_DOMEntity::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
Variant c_DOMEntity::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
Variant &c_DOMEntity::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
void c_DOMEntity::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
void c_DOMEntity::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
Variant * c_DOMEntity::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
Variant * c_DOMEntity::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
Variant * c_DOMEntity::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMEntity
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
Variant c_DOMEntity::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMEntity
IMPLEMENT_CLASS(DOMEntity)
void c_DOMEntity::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMEntity::cloneImpl() {
  c_DOMEntity *obj = NEW(c_DOMEntity)();
  cloneSet(obj);
  return obj;
}
void c_DOMEntity::cloneSet(c_DOMEntity *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMEntity::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMEntity::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMEntity::ci___destruct((void*)&c_DOMEntity::i___destruct, (void*)&c_DOMEntity::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___set((void*)&c_DOMEntity::i___set, (void*)&c_DOMEntity::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___construct((void*)&c_DOMEntity::i___construct, (void*)&c_DOMEntity::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMEntity::ci___get((void*)&c_DOMEntity::i___get, (void*)&c_DOMEntity::ifa___get, 1, 4, 0x0000000000000000LL);
Variant c_DOMEntity::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntity::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMEntity::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMEntity::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMEntity::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMEntity::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMEntity::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMEntity::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMEntity *self = NULL;
  p_DOMEntity pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMEntity*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
bool c_DOMEntity::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMEntity::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMEntity::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMEntity::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMEntity::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMEntity::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMEntity *c_DOMEntity::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMEntity::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMEntity::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMEntity::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMEntity::ci___construct;
  mcp.obj = this;
}
void c_DOMEntity::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMEntity = {
  c_DOMEntity::os_getInit,
  c_DOMEntity::os_get,
  c_DOMEntity::os_lval,
  c_DOMEntity::os_invoke,
  c_DOMEntity::os_constant,
  c_DOMEntity::os_get_call_info
};
Object co_XMLWriter(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_XMLWriter)())->dynCreate(params, init));
}
Object coo_XMLWriter() {
  Object r(NEW(c_XMLWriter)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
Variant c_XMLWriter::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
Variant c_XMLWriter::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
Variant &c_XMLWriter::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
void c_XMLWriter::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
void c_XMLWriter::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
Variant * c_XMLWriter::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
Variant * c_XMLWriter::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
Variant * c_XMLWriter::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_XMLWriter
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
Variant c_XMLWriter::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_XMLWriter
IMPLEMENT_CLASS(XMLWriter)
void c_XMLWriter::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_XMLWriter::cloneImpl() {
  c_XMLWriter *obj = NEW(c_XMLWriter)();
  cloneSet(obj);
  return obj;
}
void c_XMLWriter::cloneSet(c_XMLWriter *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_XMLWriter::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss27a7fe99, "writeCData")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
        return (t_writecdata(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss2559ca9a, "startDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
        if (count <= 1) return (t_startdtd(a0));
        else if (count == 2) return (t_startdtd(a0, a1));
        else return (t_startdtd(a0, a1, a2));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6cdf7ec6, "writeDTD")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
        if (count <= 1) return (t_writedtd(a0));
        else if (count == 2) return (t_writedtd(a0, a1));
        else if (count == 3) return (t_writedtd(a0, a1, a2));
        else return (t_writedtd(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss210f927a, "openMemory")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
        return (t_openmemory());
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss72e840b6, "endCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
        return (t_endcdata());
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss0e5b3f43, "writeComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
        return (t_writecomment(a0));
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss5ee96b8f, "startAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
        return (t_startattribute(a0));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss33896428, "writeElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
        if (count <= 1) return (t_writeelement(a0));
        else return (t_writeelement(a0, a1));
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss4dd3a743, "text")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
        return (t_text(a0));
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss7239f6f3, "startCData")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
        return (t_startcdata());
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss225c5a00, "endPI")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
        return (t_endpi());
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss73e73811, "writeDTDAttlist")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
        return (t_writedtdattlist(a0, a1));
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss61185a01, "setIndentString")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
        return (t_setindentstring(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6b750a79, "endElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
        return (t_endelement());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss1d41740f, "endComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
        return (t_endcomment());
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss11ccda13, "writeRaw")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
        return (t_writeraw(a0));
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss55bd51a4, "startDocument")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
        if (count <= 0) return (t_startdocument());
        else if (count == 1) return (t_startdocument(a0));
        else if (count == 2) return (t_startdocument(a0, a1));
        else return (t_startdocument(a0, a1, a2));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss78542bc8, "outputMemory")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
        if (count <= 0) return (t_outputmemory());
        else return (t_outputmemory(a0));
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss4e8fec21, "openURI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
        return (t_openuri(a0));
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss3bc7ae68, "endDTD")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
        return (t_enddtd());
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss2d431bd1, "writeDTDEntity")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
        if (count <= 2) return (t_writedtdentity(a0, a1));
        else if (count == 3) return (t_writedtdentity(a0, a1, a2));
        else if (count == 4) return (t_writedtdentity(a0, a1, a2, a3));
        else if (count == 5) return (t_writedtdentity(a0, a1, a2, a3, a4));
        else return (t_writedtdentity(a0, a1, a2, a3, a4, a5));
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss6d15497b, "endDTDElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
        return (t_enddtdelement());
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss770c7dcd, "writeAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
        return (t_writeattribute(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss5943b0ab, "endAttribute")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
        return (t_endattribute());
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss42fc2063, "startAttributens")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
        return (t_startattributens(a0, a1, a2));
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss540d86c3, "writeDTDElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
        return (t_writedtdelement(a0, a1));
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss5ec345b7, "writeAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
        return (t_writeattributens(a0, a1, a2, a3));
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss0ad7057a, "endDTDEntity")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
        return (t_enddtdentity());
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss7a0832b7, "writePI")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
        return (t_writepi(a0, a1));
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss470cc511, "writeElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
        if (count <= 3) return (t_writeelementns(a0, a1, a2));
        else return (t_writeelementns(a0, a1, a2, a3));
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss525fabde, "startPI")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
        return (t_startpi(a0));
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss2fb43add, "endDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
        return (t_enddocument());
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss35f0e00c, "startDTDEntity")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
        return (t_startdtdentity(a0, a1));
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss52cc26aa, "startElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
        return (t_startelement(a0));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss3d0277bb, "setIndent")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
        return (t_setindent(a0));
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss5ea3f5ac, "startElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
        return (t_startelementns(a0, a1, a2));
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss3d09e8a5, "startDTDAttlist")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
        return (t_startdtdattlist(a0));
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss75ec94fd, "endDTDAttlist")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
        return (t_enddtdattlist());
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss01b8f0d7, "startDTDElement")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
        return (t_startdtdelement(a0));
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("flush", 1, 1);
        if (count <= 0) return (t_flush());
        else return (t_flush(a0));
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss17c3d085, "fullEndElement")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
        return (t_fullendelement());
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss5cea87cb, "startComment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
        return (t_startcomment());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_XMLWriter::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_XMLWriter::ci_writeelementns((void*)&c_XMLWriter::i_writeelementns, (void*)&c_XMLWriter::ifa_writeelementns, 4, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_outputmemory((void*)&c_XMLWriter::i_outputmemory, (void*)&c_XMLWriter::ifa_outputmemory, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdattlist((void*)&c_XMLWriter::i_enddtdattlist, (void*)&c_XMLWriter::ifa_enddtdattlist, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_fullendelement((void*)&c_XMLWriter::i_fullendelement, (void*)&c_XMLWriter::ifa_fullendelement, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdocument((void*)&c_XMLWriter::i_startdocument, (void*)&c_XMLWriter::ifa_startdocument, 3, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdentity((void*)&c_XMLWriter::i_startdtdentity, (void*)&c_XMLWriter::ifa_startdtdentity, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endcdata((void*)&c_XMLWriter::i_endcdata, (void*)&c_XMLWriter::ifa_endcdata, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writecomment((void*)&c_XMLWriter::i_writecomment, (void*)&c_XMLWriter::ifa_writecomment, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeattribute((void*)&c_XMLWriter::i_writeattribute, (void*)&c_XMLWriter::ifa_writeattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endcomment((void*)&c_XMLWriter::i_endcomment, (void*)&c_XMLWriter::ifa_endcomment, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci___destruct((void*)&c_XMLWriter::i___destruct, (void*)&c_XMLWriter::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtd((void*)&c_XMLWriter::i_writedtd, (void*)&c_XMLWriter::ifa_writedtd, 4, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci___construct((void*)&c_XMLWriter::i___construct, (void*)&c_XMLWriter::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdentity((void*)&c_XMLWriter::i_enddtdentity, (void*)&c_XMLWriter::ifa_enddtdentity, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startattributens((void*)&c_XMLWriter::i_startattributens, (void*)&c_XMLWriter::ifa_startattributens, 3, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startelement((void*)&c_XMLWriter::i_startelement, (void*)&c_XMLWriter::ifa_startelement, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startelementns((void*)&c_XMLWriter::i_startelementns, (void*)&c_XMLWriter::ifa_startelementns, 3, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdelement((void*)&c_XMLWriter::i_startdtdelement, (void*)&c_XMLWriter::ifa_startdtdelement, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddocument((void*)&c_XMLWriter::i_enddocument, (void*)&c_XMLWriter::ifa_enddocument, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writecdata((void*)&c_XMLWriter::i_writecdata, (void*)&c_XMLWriter::ifa_writecdata, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdelement((void*)&c_XMLWriter::i_writedtdelement, (void*)&c_XMLWriter::ifa_writedtdelement, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeattributens((void*)&c_XMLWriter::i_writeattributens, (void*)&c_XMLWriter::ifa_writeattributens, 4, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writepi((void*)&c_XMLWriter::i_writepi, (void*)&c_XMLWriter::ifa_writepi, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_setindentstring((void*)&c_XMLWriter::i_setindentstring, (void*)&c_XMLWriter::ifa_setindentstring, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startattribute((void*)&c_XMLWriter::i_startattribute, (void*)&c_XMLWriter::ifa_startattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeelement((void*)&c_XMLWriter::i_writeelement, (void*)&c_XMLWriter::ifa_writeelement, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endelement((void*)&c_XMLWriter::i_endelement, (void*)&c_XMLWriter::ifa_endelement, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writeraw((void*)&c_XMLWriter::i_writeraw, (void*)&c_XMLWriter::ifa_writeraw, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdentity((void*)&c_XMLWriter::i_writedtdentity, (void*)&c_XMLWriter::ifa_writedtdentity, 6, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endpi((void*)&c_XMLWriter::i_endpi, (void*)&c_XMLWriter::ifa_endpi, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtd((void*)&c_XMLWriter::i_startdtd, (void*)&c_XMLWriter::ifa_startdtd, 3, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_setindent((void*)&c_XMLWriter::i_setindent, (void*)&c_XMLWriter::ifa_setindent, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtdelement((void*)&c_XMLWriter::i_enddtdelement, (void*)&c_XMLWriter::ifa_enddtdelement, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startdtdattlist((void*)&c_XMLWriter::i_startdtdattlist, (void*)&c_XMLWriter::ifa_startdtdattlist, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startcdata((void*)&c_XMLWriter::i_startcdata, (void*)&c_XMLWriter::ifa_startcdata, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_writedtdattlist((void*)&c_XMLWriter::i_writedtdattlist, (void*)&c_XMLWriter::ifa_writedtdattlist, 2, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_enddtd((void*)&c_XMLWriter::i_enddtd, (void*)&c_XMLWriter::ifa_enddtd, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_openuri((void*)&c_XMLWriter::i_openuri, (void*)&c_XMLWriter::ifa_openuri, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_openmemory((void*)&c_XMLWriter::i_openmemory, (void*)&c_XMLWriter::ifa_openmemory, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_endattribute((void*)&c_XMLWriter::i_endattribute, (void*)&c_XMLWriter::ifa_endattribute, 0, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startpi((void*)&c_XMLWriter::i_startpi, (void*)&c_XMLWriter::ifa_startpi, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_text((void*)&c_XMLWriter::i_text, (void*)&c_XMLWriter::ifa_text, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_flush((void*)&c_XMLWriter::i_flush, (void*)&c_XMLWriter::ifa_flush, 1, 4, 0x0000000000000000LL);
CallInfo c_XMLWriter::ci_startcomment((void*)&c_XMLWriter::i_startcomment, (void*)&c_XMLWriter::ifa_startcomment, 0, 4, 0x0000000000000000LL);
Variant c_XMLWriter::i_writeelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 3) return (self->t_writeelementns(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeelementns(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i_outputmemory(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_outputmemory());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_outputmemory(arg0));
  }
}
Variant c_XMLWriter::i_enddtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
  return (self->t_enddtdattlist());
}
Variant c_XMLWriter::i_fullendelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
  return (self->t_fullendelement());
}
Variant c_XMLWriter::i_startdocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_startdocument());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_startdocument(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_startdocument(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdocument(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startdtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdtdentity(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endcdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
  return (self->t_endcdata());
}
Variant c_XMLWriter::i_writecomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writecomment(arg0));
  }
}
Variant c_XMLWriter::i_writeattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeattribute(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
  return (self->t_endcomment());
}
Variant c_XMLWriter::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_XMLWriter::i_writedtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_writedtd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_writedtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_writedtd(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtd(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_XMLWriter::i_enddtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
  return (self->t_enddtdentity());
}
Variant c_XMLWriter::i_startattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startattributens(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startelement(arg0));
  }
}
Variant c_XMLWriter::i_startelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startelementns(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_startdtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startdtdelement(arg0));
  }
}
Variant c_XMLWriter::i_enddocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
  return (self->t_enddocument());
}
Variant c_XMLWriter::i_writecdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writecdata(arg0));
  }
}
Variant c_XMLWriter::i_writedtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdelement(arg0, arg1));
  }
}
Variant c_XMLWriter::i_writeattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeattributens(arg0, arg1, arg2, arg3));
  }
}
Variant c_XMLWriter::i_writepi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writepi(arg0, arg1));
  }
}
Variant c_XMLWriter::i_setindentstring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setindentstring(arg0));
  }
}
Variant c_XMLWriter::i_startattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startattribute(arg0));
  }
}
Variant c_XMLWriter::i_writeelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_writeelement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writeelement(arg0, arg1));
  }
}
Variant c_XMLWriter::i_endelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
  return (self->t_endelement());
}
Variant c_XMLWriter::i_writeraw(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_writeraw(arg0));
  }
}
Variant c_XMLWriter::i_writedtdentity(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_writedtdentity(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_writedtdentity(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_writedtdentity(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t_writedtdentity(arg0, arg1, arg2, arg3, arg4));
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdentity(arg0, arg1, arg2, arg3, arg4, arg5));
  }
}
Variant c_XMLWriter::i_endpi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
  return (self->t_endpi());
}
Variant c_XMLWriter::i_startdtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_startdtd(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_startdtd(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_startdtd(arg0, arg1, arg2));
  }
}
Variant c_XMLWriter::i_setindent(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setindent(arg0));
  }
}
Variant c_XMLWriter::i_enddtdelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
  return (self->t_enddtdelement());
}
Variant c_XMLWriter::i_startdtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startdtdattlist(arg0));
  }
}
Variant c_XMLWriter::i_startcdata(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
  return (self->t_startcdata());
}
Variant c_XMLWriter::i_writedtdattlist(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_writedtdattlist(arg0, arg1));
  }
}
Variant c_XMLWriter::i_enddtd(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
  return (self->t_enddtd());
}
Variant c_XMLWriter::i_openuri(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_openuri(arg0));
  }
}
Variant c_XMLWriter::i_openmemory(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
  return (self->t_openmemory());
}
Variant c_XMLWriter::i_endattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
  return (self->t_endattribute());
}
Variant c_XMLWriter::i_startpi(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_startpi(arg0));
  }
}
Variant c_XMLWriter::i_text(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_text(arg0));
  }
}
Variant c_XMLWriter::i_flush(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_flush());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_flush(arg0));
  }
}
Variant c_XMLWriter::i_startcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
  return (self->t_startcomment());
}
Variant c_XMLWriter::ifa_writeelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 3 || count > 4) return throw_wrong_arguments("writeelementns", count, 3, 4, 1);
  if (count <= 3) return (self->t_writeelementns(a0, a1, a2));
  return (self->t_writeelementns(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa_outputmemory(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("outputmemory", 1, 1);
  if (count <= 0) return (self->t_outputmemory());
  return (self->t_outputmemory(a0));
}
Variant c_XMLWriter::ifa_enddtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdattlist", 0, 1);
  return (self->t_enddtdattlist());
}
Variant c_XMLWriter::ifa_fullendelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("fullendelement", 0, 1);
  return (self->t_fullendelement());
}
Variant c_XMLWriter::ifa_startdocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 3) return throw_toomany_arguments("startdocument", 3, 1);
  if (count <= 0) return (self->t_startdocument());
  if (count == 1) return (self->t_startdocument(a0));
  if (count == 2) return (self->t_startdocument(a0, a1));
  return (self->t_startdocument(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startdtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("startdtdentity", count, 2, 2, 1);
  return (self->t_startdtdentity(a0, a1));
}
Variant c_XMLWriter::ifa_endcdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcdata", 0, 1);
  return (self->t_endcdata());
}
Variant c_XMLWriter::ifa_writecomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecomment", count, 1, 1, 1);
  return (self->t_writecomment(a0));
}
Variant c_XMLWriter::ifa_writeattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writeattribute", count, 2, 2, 1);
  return (self->t_writeattribute(a0, a1));
}
Variant c_XMLWriter::ifa_endcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endcomment", 0, 1);
  return (self->t_endcomment());
}
Variant c_XMLWriter::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_XMLWriter::ifa_writedtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 4) return throw_wrong_arguments("writedtd", count, 1, 4, 1);
  if (count <= 1) return (self->t_writedtd(a0));
  if (count == 2) return (self->t_writedtd(a0, a1));
  if (count == 3) return (self->t_writedtd(a0, a1, a2));
  return (self->t_writedtd(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_XMLWriter::ifa_enddtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdentity", 0, 1);
  return (self->t_enddtdentity());
}
Variant c_XMLWriter::ifa_startattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startattributens", count, 3, 3, 1);
  return (self->t_startattributens(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startelement", count, 1, 1, 1);
  return (self->t_startelement(a0));
}
Variant c_XMLWriter::ifa_startelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("startelementns", count, 3, 3, 1);
  return (self->t_startelementns(a0, a1, a2));
}
Variant c_XMLWriter::ifa_startdtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdelement", count, 1, 1, 1);
  return (self->t_startdtdelement(a0));
}
Variant c_XMLWriter::ifa_enddocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddocument", 0, 1);
  return (self->t_enddocument());
}
Variant c_XMLWriter::ifa_writecdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writecdata", count, 1, 1, 1);
  return (self->t_writecdata(a0));
}
Variant c_XMLWriter::ifa_writedtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdelement", count, 2, 2, 1);
  return (self->t_writedtdelement(a0, a1));
}
Variant c_XMLWriter::ifa_writeattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 4) return throw_wrong_arguments("writeattributens", count, 4, 4, 1);
  return (self->t_writeattributens(a0, a1, a2, a3));
}
Variant c_XMLWriter::ifa_writepi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writepi", count, 2, 2, 1);
  return (self->t_writepi(a0, a1));
}
Variant c_XMLWriter::ifa_setindentstring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindentstring", count, 1, 1, 1);
  return (self->t_setindentstring(a0));
}
Variant c_XMLWriter::ifa_startattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startattribute", count, 1, 1, 1);
  return (self->t_startattribute(a0));
}
Variant c_XMLWriter::ifa_writeelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("writeelement", count, 1, 2, 1);
  if (count <= 1) return (self->t_writeelement(a0));
  return (self->t_writeelement(a0, a1));
}
Variant c_XMLWriter::ifa_endelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endelement", 0, 1);
  return (self->t_endelement());
}
Variant c_XMLWriter::ifa_writeraw(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("writeraw", count, 1, 1, 1);
  return (self->t_writeraw(a0));
}
Variant c_XMLWriter::ifa_writedtdentity(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("writedtdentity", count, 2, 6, 1);
  if (count <= 2) return (self->t_writedtdentity(a0, a1));
  if (count == 3) return (self->t_writedtdentity(a0, a1, a2));
  if (count == 4) return (self->t_writedtdentity(a0, a1, a2, a3));
  if (count == 5) return (self->t_writedtdentity(a0, a1, a2, a3, a4));
  return (self->t_writedtdentity(a0, a1, a2, a3, a4, a5));
}
Variant c_XMLWriter::ifa_endpi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endpi", 0, 1);
  return (self->t_endpi());
}
Variant c_XMLWriter::ifa_startdtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("startdtd", count, 1, 3, 1);
  if (count <= 1) return (self->t_startdtd(a0));
  if (count == 2) return (self->t_startdtd(a0, a1));
  return (self->t_startdtd(a0, a1, a2));
}
Variant c_XMLWriter::ifa_setindent(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setindent", count, 1, 1, 1);
  return (self->t_setindent(a0));
}
Variant c_XMLWriter::ifa_enddtdelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtdelement", 0, 1);
  return (self->t_enddtdelement());
}
Variant c_XMLWriter::ifa_startdtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startdtdattlist", count, 1, 1, 1);
  return (self->t_startdtdattlist(a0));
}
Variant c_XMLWriter::ifa_startcdata(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcdata", 0, 1);
  return (self->t_startcdata());
}
Variant c_XMLWriter::ifa_writedtdattlist(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("writedtdattlist", count, 2, 2, 1);
  return (self->t_writedtdattlist(a0, a1));
}
Variant c_XMLWriter::ifa_enddtd(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("enddtd", 0, 1);
  return (self->t_enddtd());
}
Variant c_XMLWriter::ifa_openuri(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("openuri", count, 1, 1, 1);
  return (self->t_openuri(a0));
}
Variant c_XMLWriter::ifa_openmemory(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("openmemory", 0, 1);
  return (self->t_openmemory());
}
Variant c_XMLWriter::ifa_endattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("endattribute", 0, 1);
  return (self->t_endattribute());
}
Variant c_XMLWriter::ifa_startpi(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("startpi", count, 1, 1, 1);
  return (self->t_startpi(a0));
}
Variant c_XMLWriter::ifa_text(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("text", count, 1, 1, 1);
  return (self->t_text(a0));
}
Variant c_XMLWriter::ifa_flush(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("flush", 1, 1);
  if (count <= 0) return (self->t_flush());
  return (self->t_flush(a0));
}
Variant c_XMLWriter::ifa_startcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_XMLWriter *self = NULL;
  p_XMLWriter pobj;
  if (mcp.obj) {
    self = static_cast<c_XMLWriter*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("startcomment", 0, 1);
  return (self->t_startcomment());
}
bool c_XMLWriter::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 2:
      HASH_GUARD_LITSTR(0x1EBCBEA66B6B0982LL, NAMSTR(s_sys_ss27a7fe99, "writeCData")) {
        mcp.ci = &c_XMLWriter::ci_writecdata;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x55E29E84E96ACF83LL, NAMSTR(s_sys_ss2559ca9a, "startDTD")) {
        mcp.ci = &c_XMLWriter::ci_startdtd;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x7C1FF8A79BAB3608LL, NAMSTR(s_sys_ss6cdf7ec6, "writeDTD")) {
        mcp.ci = &c_XMLWriter::ci_writedtd;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x119CC9E7C3E7EF0ELL, NAMSTR(s_sys_ss210f927a, "openMemory")) {
        mcp.ci = &c_XMLWriter::ci_openmemory;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x0A7FE14C41766610LL, NAMSTR(s_sys_ss72e840b6, "endCData")) {
        mcp.ci = &c_XMLWriter::ci_endcdata;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x75F8C992981A4093LL, NAMSTR(s_sys_ss0e5b3f43, "writeComment")) {
        mcp.ci = &c_XMLWriter::ci_writecomment;
        return true;
      }
      HASH_GUARD_LITSTR(0x5A7AE5A26994FF13LL, NAMSTR(s_sys_ss5ee96b8f, "startAttribute")) {
        mcp.ci = &c_XMLWriter::ci_startattribute;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x337EFFF3783B919CLL, NAMSTR(s_sys_ss33896428, "writeElement")) {
        mcp.ci = &c_XMLWriter::ci_writeelement;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x4D26D167066BB11DLL, NAMSTR(s_sys_ss4dd3a743, "text")) {
        mcp.ci = &c_XMLWriter::ci_text;
        return true;
      }
      break;
    case 32:
      HASH_GUARD_LITSTR(0x7DF0368A44C01B20LL, NAMSTR(s_sys_ss7239f6f3, "startCData")) {
        mcp.ci = &c_XMLWriter::ci_startcdata;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x5D49A460168D5C21LL, NAMSTR(s_sys_ss225c5a00, "endPI")) {
        mcp.ci = &c_XMLWriter::ci_endpi;
        return true;
      }
      break;
    case 41:
      HASH_GUARD_LITSTR(0x1D81ABDC9890C5A9LL, NAMSTR(s_sys_ss73e73811, "writeDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_writedtdattlist;
        return true;
      }
      break;
    case 43:
      HASH_GUARD_LITSTR(0x0DEAF425F1AD73ABLL, NAMSTR(s_sys_ss61185a01, "setIndentString")) {
        mcp.ci = &c_XMLWriter::ci_setindentstring;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x78A7A5D96EF2F4AFLL, NAMSTR(s_sys_ss6b750a79, "endElement")) {
        mcp.ci = &c_XMLWriter::ci_endelement;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x75B357D89DDE6EB5LL, NAMSTR(s_sys_ss1d41740f, "endComment")) {
        mcp.ci = &c_XMLWriter::ci_endcomment;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x4B0F1F6361A59C37LL, NAMSTR(s_sys_ss11ccda13, "writeRaw")) {
        mcp.ci = &c_XMLWriter::ci_writeraw;
        return true;
      }
      break;
    case 56:
      HASH_GUARD_LITSTR(0x7FC89CF1AFFB1E38LL, NAMSTR(s_sys_ss55bd51a4, "startDocument")) {
        mcp.ci = &c_XMLWriter::ci_startdocument;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x0D155D1E5C6641BALL, NAMSTR(s_sys_ss78542bc8, "outputMemory")) {
        mcp.ci = &c_XMLWriter::ci_outputmemory;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x1FBE635680ADB7BELL, NAMSTR(s_sys_ss4e8fec21, "openURI")) {
        mcp.ci = &c_XMLWriter::ci_openuri;
        return true;
      }
      break;
    case 68:
      HASH_GUARD_LITSTR(0x275896BFD7A77144LL, NAMSTR(s_sys_ss3bc7ae68, "endDTD")) {
        mcp.ci = &c_XMLWriter::ci_enddtd;
        return true;
      }
      break;
    case 70:
      HASH_GUARD_LITSTR(0x5D4650E5C0DAEE46LL, NAMSTR(s_sys_ss2d431bd1, "writeDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_writedtdentity;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x017687FD7029CCC7LL, NAMSTR(s_sys_ss6d15497b, "endDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_enddtdelement;
        return true;
      }
      break;
    case 75:
      HASH_GUARD_LITSTR(0x3954A2C0306CCCCBLL, NAMSTR(s_sys_ss770c7dcd, "writeAttribute")) {
        mcp.ci = &c_XMLWriter::ci_writeattribute;
        return true;
      }
      HASH_GUARD_LITSTR(0x7C43ECE80FF886CBLL, NAMSTR(s_sys_ss5943b0ab, "endAttribute")) {
        mcp.ci = &c_XMLWriter::ci_endattribute;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x4F1D890D5B36D24DLL, NAMSTR(s_sys_ss42fc2063, "startAttributens")) {
        mcp.ci = &c_XMLWriter::ci_startattributens;
        return true;
      }
      break;
    case 82:
      HASH_GUARD_LITSTR(0x1357CA1E92397452LL, NAMSTR(s_sys_ss540d86c3, "writeDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_writedtdelement;
        return true;
      }
      break;
    case 84:
      HASH_GUARD_LITSTR(0x154AE94AEFAC7C54LL, NAMSTR(s_sys_ss5ec345b7, "writeAttributeNS")) {
        mcp.ci = &c_XMLWriter::ci_writeattributens;
        return true;
      }
      break;
    case 86:
      HASH_GUARD_LITSTR(0x4520735705A382D6LL, NAMSTR(s_sys_ss0ad7057a, "endDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_enddtdentity;
        return true;
      }
      HASH_GUARD_LITSTR(0x37D51A94C6EE8F56LL, NAMSTR(s_sys_ss7a0832b7, "writePI")) {
        mcp.ci = &c_XMLWriter::ci_writepi;
        return true;
      }
      break;
    case 88:
      HASH_GUARD_LITSTR(0x24A376E9310BF058LL, NAMSTR(s_sys_ss470cc511, "writeElementNS")) {
        mcp.ci = &c_XMLWriter::ci_writeelementns;
        return true;
      }
      break;
    case 89:
      HASH_GUARD_LITSTR(0x390B6C01AE7C4159LL, NAMSTR(s_sys_ss525fabde, "startPI")) {
        mcp.ci = &c_XMLWriter::ci_startpi;
        return true;
      }
      break;
    case 92:
      HASH_GUARD_LITSTR(0x0DC5AC1E0A2F63DCLL, NAMSTR(s_sys_ss2fb43add, "endDocument")) {
        mcp.ci = &c_XMLWriter::ci_enddocument;
        return true;
      }
      break;
    case 93:
      HASH_GUARD_LITSTR(0x75A033B824EA1ADDLL, NAMSTR(s_sys_ss35f0e00c, "startDTDEntity")) {
        mcp.ci = &c_XMLWriter::ci_startdtdentity;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_XMLWriter::ci___construct;
        return true;
      }
      break;
    case 98:
      HASH_GUARD_LITSTR(0x55BFFBE5717EFD62LL, NAMSTR(s_sys_ss52cc26aa, "startElement")) {
        mcp.ci = &c_XMLWriter::ci_startelement;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x349B7446B5EE65E5LL, NAMSTR(s_sys_ss3d0277bb, "setIndent")) {
        mcp.ci = &c_XMLWriter::ci_setindent;
        return true;
      }
      break;
    case 105:
      HASH_GUARD_LITSTR(0x608A2D39DE12E169LL, NAMSTR(s_sys_ss5ea3f5ac, "startElementNS")) {
        mcp.ci = &c_XMLWriter::ci_startelementns;
        return true;
      }
      break;
    case 112:
      HASH_GUARD_LITSTR(0x0CBB10FA542B7D70LL, NAMSTR(s_sys_ss3d09e8a5, "startDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_startdtdattlist;
        return true;
      }
      break;
    case 113:
      HASH_GUARD_LITSTR(0x496175DBD52E1771LL, NAMSTR(s_sys_ss75ec94fd, "endDTDAttlist")) {
        mcp.ci = &c_XMLWriter::ci_enddtdattlist;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_XMLWriter::ci___destruct;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x451436438EBA2AF8LL, NAMSTR(s_sys_ss01b8f0d7, "startDTDElement")) {
        mcp.ci = &c_XMLWriter::ci_startdtdelement;
        return true;
      }
      break;
    case 122:
      HASH_GUARD_LITSTR(0x6A3D9F8EDB005E7ALL, NAMSTR(s_sys_ss56c1ddfb, "flush")) {
        mcp.ci = &c_XMLWriter::ci_flush;
        return true;
      }
      break;
    case 126:
      HASH_GUARD_LITSTR(0x3174CCE00BFB9FFELL, NAMSTR(s_sys_ss17c3d085, "fullEndElement")) {
        mcp.ci = &c_XMLWriter::ci_fullendelement;
        return true;
      }
      break;
    case 127:
      HASH_GUARD_LITSTR(0x6A8CC27A7F0466FFLL, NAMSTR(s_sys_ss5cea87cb, "startComment")) {
        mcp.ci = &c_XMLWriter::ci_startcomment;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_XMLWriter::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_XMLWriter *c_XMLWriter::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_XMLWriter::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_XMLWriter::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_XMLWriter::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_XMLWriter::ci___construct;
  mcp.obj = this;
}
void c_XMLWriter::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_XMLWriter = {
  c_XMLWriter::os_getInit,
  c_XMLWriter::os_get,
  c_XMLWriter::os_lval,
  c_XMLWriter::os_invoke,
  c_XMLWriter::os_constant,
  c_XMLWriter::os_get_call_info
};
Object co_DOMException(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMException)())->dynCreate(params, init));
}
Object coo_DOMException() {
  Object r(NEW(c_DOMException)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
Variant c_DOMException::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
Variant c_DOMException::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
Variant &c_DOMException::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
void c_DOMException::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
void c_DOMException::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMException
Variant * c_DOMException::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
Variant * c_DOMException::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
Variant * c_DOMException::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMException
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
Variant c_DOMException::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMException
IMPLEMENT_CLASS(DOMException)
void c_DOMException::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMException::cloneImpl() {
  c_DOMException *obj = NEW(c_DOMException)();
  cloneSet(obj);
  return obj;
}
void c_DOMException::cloneSet(c_DOMException *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_DOMException::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMException::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMException::ci___destruct((void*)&c_DOMException::i___destruct, (void*)&c_DOMException::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMException::ci___construct((void*)&c_DOMException::i___construct, (void*)&c_DOMException::ifa___construct, 2, 4, 0x0000000000000000LL);
Variant c_DOMException::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMException::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMException::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMException::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMException *self = NULL;
  p_DOMException pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMException*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
bool c_DOMException::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMException::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMException::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_DOMException::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMException *c_DOMException::create(String a0, int64 a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMException::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMException::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMException::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMException::ci___construct;
  mcp.obj = this;
}
void c_DOMException::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMException = {
  c_DOMException::os_getInit,
  c_DOMException::os_get,
  c_DOMException::os_lval,
  c_DOMException::os_invoke,
  c_DOMException::os_constant,
  c_DOMException::os_get_call_info
};
Object co_DOMXPath(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMXPath)())->dynCreate(params, init));
}
Object coo_DOMXPath() {
  Object r(NEW(c_DOMXPath)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
Variant c_DOMXPath::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
Variant c_DOMXPath::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
Variant &c_DOMXPath::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
void c_DOMXPath::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
void c_DOMXPath::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
Variant * c_DOMXPath::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
Variant * c_DOMXPath::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
Variant * c_DOMXPath::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMXPath
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
Variant c_DOMXPath::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMXPath
IMPLEMENT_CLASS(DOMXPath)
void c_DOMXPath::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMXPath::cloneImpl() {
  c_DOMXPath *obj = NEW(c_DOMXPath)();
  cloneSet(obj);
  return obj;
}
void c_DOMXPath::cloneSet(c_DOMXPath *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMXPath::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss53c4a65d, "registerPHPFunctions")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
        if (count <= 0) return (t_registerphpfunctions());
        else return (t_registerphpfunctions(a0));
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
        if (count <= 1) return (t_query(a0));
        else return (t_query(a0, a1));
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss6159a18c, "registerNamespace")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
        return (t_registernamespace(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
        return (t___construct(a0), null);
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss0bbd95ea, "evaluate")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
        if (count <= 1) return (t_evaluate(a0));
        else return (t_evaluate(a0, a1));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMXPath::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMXPath::ci___destruct((void*)&c_DOMXPath::i___destruct, (void*)&c_DOMXPath::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___set((void*)&c_DOMXPath::i___set, (void*)&c_DOMXPath::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___construct((void*)&c_DOMXPath::i___construct, (void*)&c_DOMXPath::ifa___construct, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_query((void*)&c_DOMXPath::i_query, (void*)&c_DOMXPath::ifa_query, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_evaluate((void*)&c_DOMXPath::i_evaluate, (void*)&c_DOMXPath::ifa_evaluate, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_registerphpfunctions((void*)&c_DOMXPath::i_registerphpfunctions, (void*)&c_DOMXPath::ifa_registerphpfunctions, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci___get((void*)&c_DOMXPath::i___get, (void*)&c_DOMXPath::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMXPath::ci_registernamespace((void*)&c_DOMXPath::i_registernamespace, (void*)&c_DOMXPath::ifa_registernamespace, 2, 4, 0x0000000000000000LL);
Variant c_DOMXPath::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMXPath::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMXPath::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___construct(arg0), null);
  }
}
Variant c_DOMXPath::i_query(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_query(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_query(arg0, arg1));
  }
}
Variant c_DOMXPath::i_evaluate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_evaluate(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_evaluate(arg0, arg1));
  }
}
Variant c_DOMXPath::i_registerphpfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_registerphpfunctions());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_registerphpfunctions(arg0));
  }
}
Variant c_DOMXPath::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMXPath::i_registernamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registernamespace(arg0, arg1));
  }
}
Variant c_DOMXPath::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMXPath::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMXPath::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__construct", count, 1, 1, 1);
  return (self->t___construct(a0), null);
}
Variant c_DOMXPath::ifa_query(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("query", count, 1, 2, 1);
  if (count <= 1) return (self->t_query(a0));
  return (self->t_query(a0, a1));
}
Variant c_DOMXPath::ifa_evaluate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("evaluate", count, 1, 2, 1);
  if (count <= 1) return (self->t_evaluate(a0));
  return (self->t_evaluate(a0, a1));
}
Variant c_DOMXPath::ifa_registerphpfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("registerphpfunctions", 1, 1);
  if (count <= 0) return (self->t_registerphpfunctions());
  return (self->t_registerphpfunctions(a0));
}
Variant c_DOMXPath::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMXPath::ifa_registernamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMXPath *self = NULL;
  p_DOMXPath pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMXPath*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernamespace", count, 2, 2, 1);
  return (self->t_registernamespace(a0, a1));
}
bool c_DOMXPath::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 15) {
    case 2:
      HASH_GUARD_LITSTR(0x144FADF6B374AB82LL, NAMSTR(s_sys_ss53c4a65d, "registerPHPFunctions")) {
        mcp.ci = &c_DOMXPath::ci_registerphpfunctions;
        return true;
      }
      break;
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMXPath::ci___destruct;
        return true;
      }
      break;
    case 5:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMXPath::ci___set;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x356758D4414DA377LL, NAMSTR(s_sys_ss1c0ab7fa, "query")) {
        mcp.ci = &c_DOMXPath::ci_query;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x47ACFB6D8681B0E8LL, NAMSTR(s_sys_ss6159a18c, "registerNamespace")) {
        mcp.ci = &c_DOMXPath::ci_registernamespace;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMXPath::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x2443593B6F3C912FLL, NAMSTR(s_sys_ss0bbd95ea, "evaluate")) {
        mcp.ci = &c_DOMXPath::ci_evaluate;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMXPath::ci___get;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMXPath::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMXPath *c_DOMXPath::create(Variant a0) {
  CountableHelper h(this);
  init();
  t___construct(a0);
  return this;
}
ObjectData *c_DOMXPath::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
    {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      (t___construct(arg0));
    }
  }
  return this;
}
void c_DOMXPath::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 2);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    (t___construct(arg0));
  }
}
void c_DOMXPath::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMXPath::ci___construct;
  mcp.obj = this;
}
void c_DOMXPath::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count != 1) throw_wrong_arguments("__construct", count, 1, 1, 1);
  (t___construct(a0), null);
}
struct ObjectStaticCallbacks cw_DOMXPath = {
  c_DOMXPath::os_getInit,
  c_DOMXPath::os_get,
  c_DOMXPath::os_lval,
  c_DOMXPath::os_invoke,
  c_DOMXPath::os_constant,
  c_DOMXPath::os_get_call_info
};
Object co_SoapServer(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapServer)())->dynCreate(params, init));
}
Object coo_SoapServer() {
  Object r(NEW(c_SoapServer)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
Variant c_SoapServer::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
Variant c_SoapServer::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
Variant &c_SoapServer::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
void c_SoapServer::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
void c_SoapServer::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
Variant * c_SoapServer::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
Variant * c_SoapServer::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
Variant * c_SoapServer::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapServer
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
Variant c_SoapServer::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapServer
IMPLEMENT_CLASS(SoapServer)
void c_SoapServer::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapServer::cloneImpl() {
  c_SoapServer *obj = NEW(c_SoapServer)();
  cloneSet(obj);
  return obj;
}
void c_SoapServer::cloneSet(c_SoapServer *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_SoapServer::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss238e31cb, "fault")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
        if (count <= 2) return (t_fault(a0, a1), null);
        else if (count == 3) return (t_fault(a0, a1, a2), null);
        else if (count == 4) return (t_fault(a0, a1, a2, a3), null);
        else return (t_fault(a0, a1, a2, a3, a4), null);
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss7257a6f2, "setpersistence")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
        return (t_setpersistence(a0), null);
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss6fc6c6bf, "getfunctions")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
        return (t_getfunctions());
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss46eeef5c, "handle")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("handle", 1, 1);
        if (count <= 0) return (t_handle(), null);
        else return (t_handle(a0), null);
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss47724c46, "setclass")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        Array vargs;
        for (; it != params.end(); ++it) {
          vargs.append((*it)->eval(env));
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
        if (count <= 1) return (t_setclass(count, a0), null);
        return (t_setclass(count, a0,vargs), null);
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss42a11cef, "setobject")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
        return (t_setobject(a0), null);
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss5eba20da, "addsoapheader")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
        return (t_addsoapheader(a0), null);
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss508b1d41, "addfunction")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
        return (t_addfunction(a0), null);
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
        if (count <= 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapServer::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapServer::ci_addfunction((void*)&c_SoapServer::i_addfunction, (void*)&c_SoapServer::ifa_addfunction, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci___destruct((void*)&c_SoapServer::i___destruct, (void*)&c_SoapServer::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci___construct((void*)&c_SoapServer::i___construct, (void*)&c_SoapServer::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_getfunctions((void*)&c_SoapServer::i_getfunctions, (void*)&c_SoapServer::ifa_getfunctions, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_addsoapheader((void*)&c_SoapServer::i_addsoapheader, (void*)&c_SoapServer::ifa_addsoapheader, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setpersistence((void*)&c_SoapServer::i_setpersistence, (void*)&c_SoapServer::ifa_setpersistence, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_handle((void*)&c_SoapServer::i_handle, (void*)&c_SoapServer::ifa_handle, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setobject((void*)&c_SoapServer::i_setobject, (void*)&c_SoapServer::ifa_setobject, 1, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_fault((void*)&c_SoapServer::i_fault, (void*)&c_SoapServer::ifa_fault, 5, 4, 0x0000000000000000LL);
CallInfo c_SoapServer::ci_setclass((void*)&c_SoapServer::i_setclass, (void*)&c_SoapServer::ifa_setclass, 1, 5, 0x0000000000000000LL);
Variant c_SoapServer::i_addfunction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addfunction(arg0), null);
  }
}
Variant c_SoapServer::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapServer::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_SoapServer::i_getfunctions(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
  return (self->t_getfunctions());
}
Variant c_SoapServer::i_addsoapheader(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_addsoapheader(arg0), null);
  }
}
Variant c_SoapServer::i_setpersistence(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setpersistence(arg0), null);
  }
}
Variant c_SoapServer::i_handle(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("handle", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_handle(), null);
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_handle(arg0), null);
  }
}
Variant c_SoapServer::i_setobject(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setobject(arg0), null);
  }
}
Variant c_SoapServer::i_fault(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_fault(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_fault(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_fault(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_fault(arg0, arg1, arg2, arg3, arg4), null);
  }
}
Variant c_SoapServer::i_setclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_setclass(count, arg0), null);
    return (self->t_setclass(count,arg0, params.slice(1, count - 1, false)), null);
  }
}
Variant c_SoapServer::ifa_addfunction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addfunction", count, 1, 1, 1);
  return (self->t_addfunction(a0), null);
}
Variant c_SoapServer::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapServer::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_SoapServer::ifa_getfunctions(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getfunctions", 0, 1);
  return (self->t_getfunctions());
}
Variant c_SoapServer::ifa_addsoapheader(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("addsoapheader", count, 1, 1, 1);
  return (self->t_addsoapheader(a0), null);
}
Variant c_SoapServer::ifa_setpersistence(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setpersistence", count, 1, 1, 1);
  return (self->t_setpersistence(a0), null);
}
Variant c_SoapServer::ifa_handle(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("handle", 1, 1);
  if (count <= 0) return (self->t_handle(), null);
  return (self->t_handle(a0), null);
}
Variant c_SoapServer::ifa_setobject(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setobject", count, 1, 1, 1);
  return (self->t_setobject(a0), null);
}
Variant c_SoapServer::ifa_fault(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 5) return throw_wrong_arguments("fault", count, 2, 5, 1);
  if (count <= 2) return (self->t_fault(a0, a1), null);
  if (count == 3) return (self->t_fault(a0, a1, a2), null);
  if (count == 4) return (self->t_fault(a0, a1, a2, a3), null);
  return (self->t_fault(a0, a1, a2, a3, a4), null);
}
Variant c_SoapServer::ifa_setclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapServer *self = NULL;
  p_SoapServer pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapServer*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1) return throw_missing_arguments("setclass", count+1, 1);
  if (count <= 1) return (self->t_setclass(count, a0), null);
  Array params;
  if (count >= 2) params.append(a1);
  if (count >= 3) params.append(a2);
  if (count >= 4) params.append(a3);
  if (count >= 5) params.append(a4);
  if (count >= 6) params.append(a5);
  return (self->t_setclass(count,a0, params), null);
}
bool c_SoapServer::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 31) {
    case 3:
      HASH_GUARD_LITSTR(0x758A4E04590FE203LL, NAMSTR(s_sys_ss238e31cb, "fault")) {
        mcp.ci = &c_SoapServer::ci_fault;
        return true;
      }
      break;
    case 8:
      HASH_GUARD_LITSTR(0x5E77DD94E0A69328LL, NAMSTR(s_sys_ss7257a6f2, "setpersistence")) {
        mcp.ci = &c_SoapServer::ci_setpersistence;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x652BDFA6E22F17AFLL, NAMSTR(s_sys_ss6fc6c6bf, "getfunctions")) {
        mcp.ci = &c_SoapServer::ci_getfunctions;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x5C4CA333F4541532LL, NAMSTR(s_sys_ss46eeef5c, "handle")) {
        mcp.ci = &c_SoapServer::ci_handle;
        return true;
      }
      break;
    case 19:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapServer::ci___destruct;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x597B151CC4F70834LL, NAMSTR(s_sys_ss47724c46, "setclass")) {
        mcp.ci = &c_SoapServer::ci_setclass;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x559622F84FE626B9LL, NAMSTR(s_sys_ss42a11cef, "setobject")) {
        mcp.ci = &c_SoapServer::ci_setobject;
        return true;
      }
      break;
    case 30:
      HASH_GUARD_LITSTR(0x278B0E6CCA74963ELL, NAMSTR(s_sys_ss5eba20da, "addsoapheader")) {
        mcp.ci = &c_SoapServer::ci_addsoapheader;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x48B5852A397D2D9FLL, NAMSTR(s_sys_ss508b1d41, "addfunction")) {
        mcp.ci = &c_SoapServer::ci_addfunction;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapServer::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_SoapServer::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapServer *c_SoapServer::create(Variant a0, Array a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_SoapServer::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_SoapServer::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_SoapServer::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapServer::ci___construct;
  mcp.obj = this;
}
void c_SoapServer::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 2) throw_wrong_arguments("__construct", count, 1, 2, 1);
  if (count <= 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_SoapServer = {
  c_SoapServer::os_getInit,
  c_SoapServer::os_get,
  c_SoapServer::os_lval,
  c_SoapServer::os_invoke,
  c_SoapServer::os_constant,
  c_SoapServer::os_get_call_info
};
Object co_DOMNode(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMNode)())->dynCreate(params, init));
}
Object coo_DOMNode() {
  Object r(NEW(c_DOMNode)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
Variant c_DOMNode::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
Variant c_DOMNode::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
Variant &c_DOMNode::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
void c_DOMNode::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
void c_DOMNode::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
Variant * c_DOMNode::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
Variant * c_DOMNode::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
Variant * c_DOMNode::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMNode
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
Variant c_DOMNode::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMNode
IMPLEMENT_CLASS(DOMNode)
void c_DOMNode::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMNode::cloneImpl() {
  c_DOMNode *obj = NEW(c_DOMNode)();
  cloneSet(obj);
  return obj;
}
void c_DOMNode::cloneSet(c_DOMNode *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_DOMNode::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss2c8e4dfb, "getNodePath")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
        return (t_getnodepath());
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss6412883b, "c14n")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
        if (count <= 0) return (t_c14n());
        else if (count == 1) return (t_c14n(a0));
        else if (count == 2) return (t_c14n(a0, a1));
        else if (count == 3) return (t_c14n(a0, a1, a2));
        else return (t_c14n(a0, a1, a2, a3));
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss11fcf5b7, "replaceChild")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
        return (t_replacechild(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss0e0c542f, "appendChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
        return (t_appendchild(a0));
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss34dcd74e, "cloneNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
        if (count <= 0) return (t_clonenode());
        else return (t_clonenode(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss52fe5cd5, "getLineNo")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
        return (t_getlineno());
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss679e8b98, "normalize")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
        return (t_normalize(), null);
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss6e9f1eba, "lookupNamespaceUri")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
        return (t_lookupnamespaceuri(a0));
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss13622d08, "removeChild")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
        return (t_removechild(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss135b2bb6, "lookupPrefix")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
        return (t_lookupprefix(a0));
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss750a46b0, "isDefaultNamespace")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
        return (t_isdefaultnamespace(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss4431a364, "isSameNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
        return (t_issamenode(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss344c5db6, "hasAttributes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
        return (t_hasattributes());
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss31ec77af, "insertBefore")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
        if (count <= 1) return (t_insertbefore(a0));
        else return (t_insertbefore(a0, a1));
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss717b8b62, "c14nfile")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
        if (count <= 1) return (t_c14nfile(a0));
        else if (count == 2) return (t_c14nfile(a0, a1));
        else if (count == 3) return (t_c14nfile(a0, a1, a2));
        else if (count == 4) return (t_c14nfile(a0, a1, a2, a3));
        else return (t_c14nfile(a0, a1, a2, a3, a4));
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss44a1dc88, "isSupported")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
        return (t_issupported(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss14eade34, "hasChildNodes")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
        return (t_haschildnodes());
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMNode::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMNode::ci_getlineno((void*)&c_DOMNode::i_getlineno, (void*)&c_DOMNode::ifa_getlineno, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_insertbefore((void*)&c_DOMNode::i_insertbefore, (void*)&c_DOMNode::ifa_insertbefore, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_isdefaultnamespace((void*)&c_DOMNode::i_isdefaultnamespace, (void*)&c_DOMNode::ifa_isdefaultnamespace, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_lookupnamespaceuri((void*)&c_DOMNode::i_lookupnamespaceuri, (void*)&c_DOMNode::ifa_lookupnamespaceuri, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_appendchild((void*)&c_DOMNode::i_appendchild, (void*)&c_DOMNode::ifa_appendchild, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___destruct((void*)&c_DOMNode::i___destruct, (void*)&c_DOMNode::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___set((void*)&c_DOMNode::i___set, (void*)&c_DOMNode::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_clonenode((void*)&c_DOMNode::i_clonenode, (void*)&c_DOMNode::ifa_clonenode, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___construct((void*)&c_DOMNode::i___construct, (void*)&c_DOMNode::ifa___construct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_replacechild((void*)&c_DOMNode::i_replacechild, (void*)&c_DOMNode::ifa_replacechild, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_c14n((void*)&c_DOMNode::i_c14n, (void*)&c_DOMNode::ifa_c14n, 4, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_hasattributes((void*)&c_DOMNode::i_hasattributes, (void*)&c_DOMNode::ifa_hasattributes, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_lookupprefix((void*)&c_DOMNode::i_lookupprefix, (void*)&c_DOMNode::ifa_lookupprefix, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_normalize((void*)&c_DOMNode::i_normalize, (void*)&c_DOMNode::ifa_normalize, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_getnodepath((void*)&c_DOMNode::i_getnodepath, (void*)&c_DOMNode::ifa_getnodepath, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_c14nfile((void*)&c_DOMNode::i_c14nfile, (void*)&c_DOMNode::ifa_c14nfile, 5, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_issamenode((void*)&c_DOMNode::i_issamenode, (void*)&c_DOMNode::ifa_issamenode, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_removechild((void*)&c_DOMNode::i_removechild, (void*)&c_DOMNode::ifa_removechild, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci___get((void*)&c_DOMNode::i___get, (void*)&c_DOMNode::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_issupported((void*)&c_DOMNode::i_issupported, (void*)&c_DOMNode::ifa_issupported, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMNode::ci_haschildnodes((void*)&c_DOMNode::i_haschildnodes, (void*)&c_DOMNode::ifa_haschildnodes, 0, 4, 0x0000000000000000LL);
Variant c_DOMNode::i_getlineno(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
  return (self->t_getlineno());
}
Variant c_DOMNode::i_insertbefore(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_insertbefore(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_insertbefore(arg0, arg1));
  }
}
Variant c_DOMNode::i_isdefaultnamespace(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_isdefaultnamespace(arg0));
  }
}
Variant c_DOMNode::i_lookupnamespaceuri(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lookupnamespaceuri(arg0));
  }
}
Variant c_DOMNode::i_appendchild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_appendchild(arg0));
  }
}
Variant c_DOMNode::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNode::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMNode::i_clonenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_clonenode());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_clonenode(arg0));
  }
}
Variant c_DOMNode::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNode::i_replacechild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_replacechild(arg0, arg1));
  }
}
Variant c_DOMNode::i_c14n(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_c14n());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_c14n(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_c14n(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_c14n(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_c14n(arg0, arg1, arg2, arg3));
  }
}
Variant c_DOMNode::i_hasattributes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
  return (self->t_hasattributes());
}
Variant c_DOMNode::i_lookupprefix(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_lookupprefix(arg0));
  }
}
Variant c_DOMNode::i_normalize(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
  return (self->t_normalize(), null);
}
Variant c_DOMNode::i_getnodepath(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
  return (self->t_getnodepath());
}
Variant c_DOMNode::i_c14nfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_c14nfile(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t_c14nfile(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t_c14nfile(arg0, arg1, arg2));
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t_c14nfile(arg0, arg1, arg2, arg3));
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_c14nfile(arg0, arg1, arg2, arg3, arg4));
  }
}
Variant c_DOMNode::i_issamenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_issamenode(arg0));
  }
}
Variant c_DOMNode::i_removechild(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removechild(arg0));
  }
}
Variant c_DOMNode::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMNode::i_issupported(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_issupported(arg0, arg1));
  }
}
Variant c_DOMNode::i_haschildnodes(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
  return (self->t_haschildnodes());
}
Variant c_DOMNode::ifa_getlineno(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getlineno", 0, 1);
  return (self->t_getlineno());
}
Variant c_DOMNode::ifa_insertbefore(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("insertbefore", count, 1, 2, 1);
  if (count <= 1) return (self->t_insertbefore(a0));
  return (self->t_insertbefore(a0, a1));
}
Variant c_DOMNode::ifa_isdefaultnamespace(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("isdefaultnamespace", count, 1, 1, 1);
  return (self->t_isdefaultnamespace(a0));
}
Variant c_DOMNode::ifa_lookupnamespaceuri(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupnamespaceuri", count, 1, 1, 1);
  return (self->t_lookupnamespaceuri(a0));
}
Variant c_DOMNode::ifa_appendchild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("appendchild", count, 1, 1, 1);
  return (self->t_appendchild(a0));
}
Variant c_DOMNode::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMNode::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMNode::ifa_clonenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("clonenode", 1, 1);
  if (count <= 0) return (self->t_clonenode());
  return (self->t_clonenode(a0));
}
Variant c_DOMNode::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_DOMNode::ifa_replacechild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("replacechild", count, 2, 2, 1);
  return (self->t_replacechild(a0, a1));
}
Variant c_DOMNode::ifa_c14n(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 4) return throw_toomany_arguments("c14n", 4, 1);
  if (count <= 0) return (self->t_c14n());
  if (count == 1) return (self->t_c14n(a0));
  if (count == 2) return (self->t_c14n(a0, a1));
  if (count == 3) return (self->t_c14n(a0, a1, a2));
  return (self->t_c14n(a0, a1, a2, a3));
}
Variant c_DOMNode::ifa_hasattributes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("hasattributes", 0, 1);
  return (self->t_hasattributes());
}
Variant c_DOMNode::ifa_lookupprefix(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("lookupprefix", count, 1, 1, 1);
  return (self->t_lookupprefix(a0));
}
Variant c_DOMNode::ifa_normalize(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalize", 0, 1);
  return (self->t_normalize(), null);
}
Variant c_DOMNode::ifa_getnodepath(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("getnodepath", 0, 1);
  return (self->t_getnodepath());
}
Variant c_DOMNode::ifa_c14nfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 5) return throw_wrong_arguments("c14nfile", count, 1, 5, 1);
  if (count <= 1) return (self->t_c14nfile(a0));
  if (count == 2) return (self->t_c14nfile(a0, a1));
  if (count == 3) return (self->t_c14nfile(a0, a1, a2));
  if (count == 4) return (self->t_c14nfile(a0, a1, a2, a3));
  return (self->t_c14nfile(a0, a1, a2, a3, a4));
}
Variant c_DOMNode::ifa_issamenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("issamenode", count, 1, 1, 1);
  return (self->t_issamenode(a0));
}
Variant c_DOMNode::ifa_removechild(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removechild", count, 1, 1, 1);
  return (self->t_removechild(a0));
}
Variant c_DOMNode::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMNode::ifa_issupported(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("issupported", count, 2, 2, 1);
  return (self->t_issupported(a0, a1));
}
Variant c_DOMNode::ifa_haschildnodes(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMNode *self = NULL;
  p_DOMNode pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMNode*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("haschildnodes", 0, 1);
  return (self->t_haschildnodes());
}
bool c_DOMNode::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 3:
      HASH_GUARD_LITSTR(0x69797649716AE343LL, NAMSTR(s_sys_ss2c8e4dfb, "getNodePath")) {
        mcp.ci = &c_DOMNode::ci_getnodepath;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x77570221C582ED8ALL, NAMSTR(s_sys_ss6412883b, "c14n")) {
        mcp.ci = &c_DOMNode::ci_c14n;
        return true;
      }
      break;
    case 14:
      HASH_GUARD_LITSTR(0x1C51CE3C2356D08ELL, NAMSTR(s_sys_ss11fcf5b7, "replaceChild")) {
        mcp.ci = &c_DOMNode::ci_replacechild;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x0B44A59A023E75CFLL, NAMSTR(s_sys_ss0e0c542f, "appendChild")) {
        mcp.ci = &c_DOMNode::ci_appendchild;
        return true;
      }
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMNode::ci___get;
        return true;
      }
      break;
    case 18:
      HASH_GUARD_LITSTR(0x4F615934A04E3092LL, NAMSTR(s_sys_ss34dcd74e, "cloneNode")) {
        mcp.ci = &c_DOMNode::ci_clonenode;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMNode::ci___set;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x58F8D846AF9E5D18LL, NAMSTR(s_sys_ss52fe5cd5, "getLineNo")) {
        mcp.ci = &c_DOMNode::ci_getlineno;
        return true;
      }
      break;
    case 26:
      HASH_GUARD_LITSTR(0x11A2D4B742CB6C5ALL, NAMSTR(s_sys_ss679e8b98, "normalize")) {
        mcp.ci = &c_DOMNode::ci_normalize;
        return true;
      }
      break;
    case 29:
      HASH_GUARD_LITSTR(0x28D1E151A83B8F5DLL, NAMSTR(s_sys_ss6e9f1eba, "lookupNamespaceUri")) {
        mcp.ci = &c_DOMNode::ci_lookupnamespaceuri;
        return true;
      }
      HASH_GUARD_LITSTR(0x72044C28B65364DDLL, NAMSTR(s_sys_ss13622d08, "removeChild")) {
        mcp.ci = &c_DOMNode::ci_removechild;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMNode::ci___construct;
        return true;
      }
      break;
    case 33:
      HASH_GUARD_LITSTR(0x599DE23996CB7D61LL, NAMSTR(s_sys_ss135b2bb6, "lookupPrefix")) {
        mcp.ci = &c_DOMNode::ci_lookupprefix;
        return true;
      }
      break;
    case 36:
      HASH_GUARD_LITSTR(0x643EFC8E9378F664LL, NAMSTR(s_sys_ss750a46b0, "isDefaultNamespace")) {
        mcp.ci = &c_DOMNode::ci_isdefaultnamespace;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x102549E9CA2EC6EFLL, NAMSTR(s_sys_ss4431a364, "isSameNode")) {
        mcp.ci = &c_DOMNode::ci_issamenode;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x3CFA6EECF6F5AEB1LL, NAMSTR(s_sys_ss344c5db6, "hasAttributes")) {
        mcp.ci = &c_DOMNode::ci_hasattributes;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x076FF0CF9185C433LL, NAMSTR(s_sys_ss31ec77af, "insertBefore")) {
        mcp.ci = &c_DOMNode::ci_insertbefore;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMNode::ci___destruct;
        return true;
      }
      break;
    case 53:
      HASH_GUARD_LITSTR(0x1D1768A6CF365A75LL, NAMSTR(s_sys_ss717b8b62, "c14nfile")) {
        mcp.ci = &c_DOMNode::ci_c14nfile;
        return true;
      }
      break;
    case 58:
      HASH_GUARD_LITSTR(0x279AA1B214B7677ALL, NAMSTR(s_sys_ss44a1dc88, "isSupported")) {
        mcp.ci = &c_DOMNode::ci_issupported;
        return true;
      }
      HASH_GUARD_LITSTR(0x5F63574EA50595FALL, NAMSTR(s_sys_ss14eade34, "hasChildNodes")) {
        mcp.ci = &c_DOMNode::ci_haschildnodes;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_DOMNode::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMNode *c_DOMNode::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_DOMNode::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_DOMNode::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_DOMNode::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMNode::ci___construct;
  mcp.obj = this;
}
void c_DOMNode::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_DOMNode = {
  c_DOMNode::os_getInit,
  c_DOMNode::os_get,
  c_DOMNode::os_lval,
  c_DOMNode::os_invoke,
  c_DOMNode::os_constant,
  c_DOMNode::os_get_call_info
};
Object co_DOMDocument(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMDocument)())->dynCreate(params, init));
}
Object coo_DOMDocument() {
  Object r(NEW(c_DOMDocument)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
Variant c_DOMDocument::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
Variant c_DOMDocument::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
Variant &c_DOMDocument::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
void c_DOMDocument::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
void c_DOMDocument::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
Variant * c_DOMDocument::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
Variant * c_DOMDocument::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
Variant * c_DOMDocument::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMDocument
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
Variant c_DOMDocument::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMDocument
IMPLEMENT_CLASS(DOMDocument)
void c_DOMDocument::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMDocument::cloneImpl() {
  c_DOMDocument *obj = NEW(c_DOMDocument)();
  cloneSet(obj);
  return obj;
}
void c_DOMDocument::cloneSet(c_DOMDocument *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMDocument::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss3727867b, "getElementById")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
        return (t_getelementbyid(a0));
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss11e815e7, "xinclude")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
        if (count <= 0) return (t_xinclude());
        else return (t_xinclude(a0));
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss4d3aaeee, "createCDATASection")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
        return (t_createcdatasection(a0));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss6863d210, "schemaValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
        return (t_schemavalidatesource(a0));
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss71377747, "save")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
        if (count <= 1) return (t_save(a0));
        else return (t_save(a0, a1));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss7aa4dd63, "createAttributens")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
        return (t_createattributens(a0, a1));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss587edbef, "relaxNGValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
        return (t_relaxngvalidate(a0));
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss274b0685, "loadHTML")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
        return (t_loadhtml(a0));
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss608280fa, "createElement")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
        if (count <= 1) return (t_createelement(a0));
        else return (t_createelement(a0, a1));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss3b7c2fd5, "relaxNGValidateSource")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
        return (t_relaxngvalidatesource(a0));
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss331d21f7, "createAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
        return (t_createattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss2ec5d965, "importNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
        if (count <= 1) return (t_importnode(a0));
        else return (t_importnode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss0fb4316d, "loadHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
        return (t_loadhtmlfile(a0));
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss6a2e848f, "loadXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
        if (count <= 1) return (t_loadxml(a0));
        else return (t_loadxml(a0, a1));
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss6d67e79b, "createEntityReference")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
        return (t_createentityreference(a0));
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss4805e14f, "validate")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("validate", 0, 1);
        return (t_validate());
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss15cc67bc, "createComment")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
        return (t_createcomment(a0));
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss46e9d423, "schemaValidate")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
        return (t_schemavalidate(a0));
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss2b6d2a95, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss49400bc1, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss427e7c24, "saveHTMLFile")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
        return (t_savehtmlfile(a0));
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss690e46e7, "saveHTML")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
        return (t_savehtml());
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
        if (count <= 0) return (t___construct(), null);
        else if (count == 1) return (t___construct(a0), null);
        else return (t___construct(a0, a1), null);
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss5853bc97, "load")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
        if (count <= 1) return (t_load(a0));
        else return (t_load(a0, a1));
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss6f5ad507, "saveXML")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
        if (count <= 0) return (t_savexml());
        else if (count == 1) return (t_savexml(a0));
        else return (t_savexml(a0, a1));
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss5d0c7971, "normalizeDocument")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
        return (t_normalizedocument(), null);
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss3983a61c, "createElementNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
        if (count <= 2) return (t_createelementns(a0, a1));
        else return (t_createelementns(a0, a1, a2));
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss73b46b63, "createProcessingInstruction")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
        if (count <= 1) return (t_createprocessinginstruction(a0));
        else return (t_createprocessinginstruction(a0, a1));
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss0915cca1, "registerNodeClass")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
        return (t_registernodeclass(a0, a1));
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss212dc503, "createDocumentFragment")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
        return (t_createdocumentfragment());
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss3bb8fb3e, "createTextNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
        return (t_createtextnode(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMDocument::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMDocument::ci_getelementsbytagname((void*)&c_DOMDocument::i_getelementsbytagname, (void*)&c_DOMDocument::ifa_getelementsbytagname, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createcdatasection((void*)&c_DOMDocument::i_createcdatasection, (void*)&c_DOMDocument::ifa_createcdatasection, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_validate((void*)&c_DOMDocument::i_validate, (void*)&c_DOMDocument::ifa_validate, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_getelementsbytagnamens((void*)&c_DOMDocument::i_getelementsbytagnamens, (void*)&c_DOMDocument::ifa_getelementsbytagnamens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_schemavalidatesource((void*)&c_DOMDocument::i_schemavalidatesource, (void*)&c_DOMDocument::ifa_schemavalidatesource, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_relaxngvalidate((void*)&c_DOMDocument::i_relaxngvalidate, (void*)&c_DOMDocument::ifa_relaxngvalidate, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadhtml((void*)&c_DOMDocument::i_loadhtml, (void*)&c_DOMDocument::ifa_loadhtml, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createentityreference((void*)&c_DOMDocument::i_createentityreference, (void*)&c_DOMDocument::ifa_createentityreference, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_schemavalidate((void*)&c_DOMDocument::i_schemavalidate, (void*)&c_DOMDocument::ifa_schemavalidate, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___destruct((void*)&c_DOMDocument::i___destruct, (void*)&c_DOMDocument::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___set((void*)&c_DOMDocument::i___set, (void*)&c_DOMDocument::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savexml((void*)&c_DOMDocument::i_savexml, (void*)&c_DOMDocument::ifa_savexml, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createprocessinginstruction((void*)&c_DOMDocument::i_createprocessinginstruction, (void*)&c_DOMDocument::ifa_createprocessinginstruction, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___construct((void*)&c_DOMDocument::i___construct, (void*)&c_DOMDocument::ifa___construct, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_registernodeclass((void*)&c_DOMDocument::i_registernodeclass, (void*)&c_DOMDocument::ifa_registernodeclass, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_load((void*)&c_DOMDocument::i_load, (void*)&c_DOMDocument::ifa_load, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createattributens((void*)&c_DOMDocument::i_createattributens, (void*)&c_DOMDocument::ifa_createattributens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createelement((void*)&c_DOMDocument::i_createelement, (void*)&c_DOMDocument::ifa_createelement, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createelementns((void*)&c_DOMDocument::i_createelementns, (void*)&c_DOMDocument::ifa_createelementns, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_importnode((void*)&c_DOMDocument::i_importnode, (void*)&c_DOMDocument::ifa_importnode, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_relaxngvalidatesource((void*)&c_DOMDocument::i_relaxngvalidatesource, (void*)&c_DOMDocument::ifa_relaxngvalidatesource, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createtextnode((void*)&c_DOMDocument::i_createtextnode, (void*)&c_DOMDocument::ifa_createtextnode, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savehtml((void*)&c_DOMDocument::i_savehtml, (void*)&c_DOMDocument::ifa_savehtml, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadxml((void*)&c_DOMDocument::i_loadxml, (void*)&c_DOMDocument::ifa_loadxml, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_save((void*)&c_DOMDocument::i_save, (void*)&c_DOMDocument::ifa_save, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createattribute((void*)&c_DOMDocument::i_createattribute, (void*)&c_DOMDocument::ifa_createattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_xinclude((void*)&c_DOMDocument::i_xinclude, (void*)&c_DOMDocument::ifa_xinclude, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci___get((void*)&c_DOMDocument::i___get, (void*)&c_DOMDocument::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_loadhtmlfile((void*)&c_DOMDocument::i_loadhtmlfile, (void*)&c_DOMDocument::ifa_loadhtmlfile, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_savehtmlfile((void*)&c_DOMDocument::i_savehtmlfile, (void*)&c_DOMDocument::ifa_savehtmlfile, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_getelementbyid((void*)&c_DOMDocument::i_getelementbyid, (void*)&c_DOMDocument::ifa_getelementbyid, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createcomment((void*)&c_DOMDocument::i_createcomment, (void*)&c_DOMDocument::ifa_createcomment, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_normalizedocument((void*)&c_DOMDocument::i_normalizedocument, (void*)&c_DOMDocument::ifa_normalizedocument, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMDocument::ci_createdocumentfragment((void*)&c_DOMDocument::i_createdocumentfragment, (void*)&c_DOMDocument::ifa_createdocumentfragment, 0, 4, 0x0000000000000000LL);
Variant c_DOMDocument::i_getelementsbytagname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementsbytagname(arg0));
  }
}
Variant c_DOMDocument::i_createcdatasection(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createcdatasection(arg0));
  }
}
Variant c_DOMDocument::i_validate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("validate", 0, 1);
  return (self->t_validate());
}
Variant c_DOMDocument::i_getelementsbytagnamens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getelementsbytagnamens(arg0, arg1));
  }
}
Variant c_DOMDocument::i_schemavalidatesource(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_schemavalidatesource(arg0));
  }
}
Variant c_DOMDocument::i_relaxngvalidate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_relaxngvalidate(arg0));
  }
}
Variant c_DOMDocument::i_loadhtml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadhtml(arg0));
  }
}
Variant c_DOMDocument::i_createentityreference(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createentityreference(arg0));
  }
}
Variant c_DOMDocument::i_schemavalidate(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_schemavalidate(arg0));
  }
}
Variant c_DOMDocument::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocument::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMDocument::i_savexml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_savexml());
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t_savexml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_savexml(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createprocessinginstruction(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_createprocessinginstruction(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createprocessinginstruction(arg0, arg1));
  }
}
Variant c_DOMDocument::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t___construct(), null);
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1), null);
  }
}
Variant c_DOMDocument::i_registernodeclass(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_registernodeclass(arg0, arg1));
  }
}
Variant c_DOMDocument::i_load(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_load(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_load(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createattributens(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createelement(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_createelement(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createelement(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createelementns(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t_createelementns(arg0, arg1));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_createelementns(arg0, arg1, arg2));
  }
}
Variant c_DOMDocument::i_importnode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_importnode(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_importnode(arg0, arg1));
  }
}
Variant c_DOMDocument::i_relaxngvalidatesource(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_relaxngvalidatesource(arg0));
  }
}
Variant c_DOMDocument::i_createtextnode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createtextnode(arg0));
  }
}
Variant c_DOMDocument::i_savehtml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
  return (self->t_savehtml());
}
Variant c_DOMDocument::i_loadxml(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_loadxml(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_loadxml(arg0, arg1));
  }
}
Variant c_DOMDocument::i_save(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t_save(arg0));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_save(arg0, arg1));
  }
}
Variant c_DOMDocument::i_createattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createattribute(arg0));
  }
}
Variant c_DOMDocument::i_xinclude(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) return (self->t_xinclude());
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_xinclude(arg0));
  }
}
Variant c_DOMDocument::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMDocument::i_loadhtmlfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_loadhtmlfile(arg0));
  }
}
Variant c_DOMDocument::i_savehtmlfile(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_savehtmlfile(arg0));
  }
}
Variant c_DOMDocument::i_getelementbyid(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementbyid(arg0));
  }
}
Variant c_DOMDocument::i_createcomment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_createcomment(arg0));
  }
}
Variant c_DOMDocument::i_normalizedocument(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
  return (self->t_normalizedocument(), null);
}
Variant c_DOMDocument::i_createdocumentfragment(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
  return (self->t_createdocumentfragment());
}
Variant c_DOMDocument::ifa_getelementsbytagname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  return (self->t_getelementsbytagname(a0));
}
Variant c_DOMDocument::ifa_createcdatasection(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcdatasection", count, 1, 1, 1);
  return (self->t_createcdatasection(a0));
}
Variant c_DOMDocument::ifa_validate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("validate", 0, 1);
  return (self->t_validate());
}
Variant c_DOMDocument::ifa_getelementsbytagnamens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  return (self->t_getelementsbytagnamens(a0, a1));
}
Variant c_DOMDocument::ifa_schemavalidatesource(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidatesource", count, 1, 1, 1);
  return (self->t_schemavalidatesource(a0));
}
Variant c_DOMDocument::ifa_relaxngvalidate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidate", count, 1, 1, 1);
  return (self->t_relaxngvalidate(a0));
}
Variant c_DOMDocument::ifa_loadhtml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtml", count, 1, 1, 1);
  return (self->t_loadhtml(a0));
}
Variant c_DOMDocument::ifa_createentityreference(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createentityreference", count, 1, 1, 1);
  return (self->t_createentityreference(a0));
}
Variant c_DOMDocument::ifa_schemavalidate(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("schemavalidate", count, 1, 1, 1);
  return (self->t_schemavalidate(a0));
}
Variant c_DOMDocument::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMDocument::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMDocument::ifa_savexml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("savexml", 2, 1);
  if (count <= 0) return (self->t_savexml());
  if (count == 1) return (self->t_savexml(a0));
  return (self->t_savexml(a0, a1));
}
Variant c_DOMDocument::ifa_createprocessinginstruction(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createprocessinginstruction", count, 1, 2, 1);
  if (count <= 1) return (self->t_createprocessinginstruction(a0));
  return (self->t_createprocessinginstruction(a0, a1));
}
Variant c_DOMDocument::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 2) return throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) return (self->t___construct(), null);
  if (count == 1) return (self->t___construct(a0), null);
  return (self->t___construct(a0, a1), null);
}
Variant c_DOMDocument::ifa_registernodeclass(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("registernodeclass", count, 2, 2, 1);
  return (self->t_registernodeclass(a0, a1));
}
Variant c_DOMDocument::ifa_load(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("load", count, 1, 2, 1);
  if (count <= 1) return (self->t_load(a0));
  return (self->t_load(a0, a1));
}
Variant c_DOMDocument::ifa_createattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("createattributens", count, 2, 2, 1);
  return (self->t_createattributens(a0, a1));
}
Variant c_DOMDocument::ifa_createelement(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("createelement", count, 1, 2, 1);
  if (count <= 1) return (self->t_createelement(a0));
  return (self->t_createelement(a0, a1));
}
Variant c_DOMDocument::ifa_createelementns(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 3) return throw_wrong_arguments("createelementns", count, 2, 3, 1);
  if (count <= 2) return (self->t_createelementns(a0, a1));
  return (self->t_createelementns(a0, a1, a2));
}
Variant c_DOMDocument::ifa_importnode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("importnode", count, 1, 2, 1);
  if (count <= 1) return (self->t_importnode(a0));
  return (self->t_importnode(a0, a1));
}
Variant c_DOMDocument::ifa_relaxngvalidatesource(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("relaxngvalidatesource", count, 1, 1, 1);
  return (self->t_relaxngvalidatesource(a0));
}
Variant c_DOMDocument::ifa_createtextnode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createtextnode", count, 1, 1, 1);
  return (self->t_createtextnode(a0));
}
Variant c_DOMDocument::ifa_savehtml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("savehtml", 0, 1);
  return (self->t_savehtml());
}
Variant c_DOMDocument::ifa_loadxml(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("loadxml", count, 1, 2, 1);
  if (count <= 1) return (self->t_loadxml(a0));
  return (self->t_loadxml(a0, a1));
}
Variant c_DOMDocument::ifa_save(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 2) return throw_wrong_arguments("save", count, 1, 2, 1);
  if (count <= 1) return (self->t_save(a0));
  return (self->t_save(a0, a1));
}
Variant c_DOMDocument::ifa_createattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createattribute", count, 1, 1, 1);
  return (self->t_createattribute(a0));
}
Variant c_DOMDocument::ifa_xinclude(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 1) return throw_toomany_arguments("xinclude", 1, 1);
  if (count <= 0) return (self->t_xinclude());
  return (self->t_xinclude(a0));
}
Variant c_DOMDocument::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMDocument::ifa_loadhtmlfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("loadhtmlfile", count, 1, 1, 1);
  return (self->t_loadhtmlfile(a0));
}
Variant c_DOMDocument::ifa_savehtmlfile(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("savehtmlfile", count, 1, 1, 1);
  return (self->t_savehtmlfile(a0));
}
Variant c_DOMDocument::ifa_getelementbyid(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementbyid", count, 1, 1, 1);
  return (self->t_getelementbyid(a0));
}
Variant c_DOMDocument::ifa_createcomment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("createcomment", count, 1, 1, 1);
  return (self->t_createcomment(a0));
}
Variant c_DOMDocument::ifa_normalizedocument(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("normalizedocument", 0, 1);
  return (self->t_normalizedocument(), null);
}
Variant c_DOMDocument::ifa_createdocumentfragment(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMDocument *self = NULL;
  p_DOMDocument pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMDocument*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("createdocumentfragment", 0, 1);
  return (self->t_createdocumentfragment());
}
bool c_DOMDocument::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 127) {
    case 5:
      HASH_GUARD_LITSTR(0x515FE7746601E385LL, NAMSTR(s_sys_ss3727867b, "getElementById")) {
        mcp.ci = &c_DOMDocument::ci_getelementbyid;
        return true;
      }
      break;
    case 10:
      HASH_GUARD_LITSTR(0x142A28F8CE4A4E8ALL, NAMSTR(s_sys_ss11e815e7, "xinclude")) {
        mcp.ci = &c_DOMDocument::ci_xinclude;
        return true;
      }
      break;
    case 13:
      HASH_GUARD_LITSTR(0x0D128C363EBF7F0DLL, NAMSTR(s_sys_ss4d3aaeee, "createCDATASection")) {
        mcp.ci = &c_DOMDocument::ci_createcdatasection;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMDocument::ci___get;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x69C6F7D584EC5011LL, NAMSTR(s_sys_ss6863d210, "schemaValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidatesource;
        return true;
      }
      break;
    case 20:
      HASH_GUARD_LITSTR(0x04F8F7CEA46D0514LL, NAMSTR(s_sys_ss71377747, "save")) {
        mcp.ci = &c_DOMDocument::ci_save;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMDocument::ci___set;
        return true;
      }
      HASH_GUARD_LITSTR(0x2FC58024A75AEB15LL, NAMSTR(s_sys_ss7aa4dd63, "createAttributens")) {
        mcp.ci = &c_DOMDocument::ci_createattributens;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x1A78385D7CD10A1CLL, NAMSTR(s_sys_ss587edbef, "relaxNGValidate")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidate;
        return true;
      }
      break;
    case 34:
      HASH_GUARD_LITSTR(0x1B0F4D437C8404A2LL, NAMSTR(s_sys_ss274b0685, "loadHTML")) {
        mcp.ci = &c_DOMDocument::ci_loadhtml;
        return true;
      }
      HASH_GUARD_LITSTR(0x4C40B0F935B39FA2LL, NAMSTR(s_sys_ss608280fa, "createElement")) {
        mcp.ci = &c_DOMDocument::ci_createelement;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x1304C35F6E006FACLL, NAMSTR(s_sys_ss3b7c2fd5, "relaxNGValidateSource")) {
        mcp.ci = &c_DOMDocument::ci_relaxngvalidatesource;
        return true;
      }
      HASH_GUARD_LITSTR(0x2BFDE9CF0FE9A82CLL, NAMSTR(s_sys_ss331d21f7, "createAttribute")) {
        mcp.ci = &c_DOMDocument::ci_createattribute;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x4A6C6D9AB88CD42FLL, NAMSTR(s_sys_ss2ec5d965, "importNode")) {
        mcp.ci = &c_DOMDocument::ci_importnode;
        return true;
      }
      HASH_GUARD_LITSTR(0x5FE94CA513F14AAFLL, NAMSTR(s_sys_ss0fb4316d, "loadHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_loadhtmlfile;
        return true;
      }
      break;
    case 49:
      HASH_GUARD_LITSTR(0x20E2B2FD2B7AE431LL, NAMSTR(s_sys_ss6a2e848f, "loadXML")) {
        mcp.ci = &c_DOMDocument::ci_loadxml;
        return true;
      }
      break;
    case 50:
      HASH_GUARD_LITSTR(0x7A9C4709CAD09832LL, NAMSTR(s_sys_ss6d67e79b, "createEntityReference")) {
        mcp.ci = &c_DOMDocument::ci_createentityreference;
        return true;
      }
      break;
    case 55:
      HASH_GUARD_LITSTR(0x1CA408E02262F737LL, NAMSTR(s_sys_ss4805e14f, "validate")) {
        mcp.ci = &c_DOMDocument::ci_validate;
        return true;
      }
      break;
    case 71:
      HASH_GUARD_LITSTR(0x29C79E90C6FCC0C7LL, NAMSTR(s_sys_ss15cc67bc, "createComment")) {
        mcp.ci = &c_DOMDocument::ci_createcomment;
        return true;
      }
      break;
    case 72:
      HASH_GUARD_LITSTR(0x7EB8C68BABDC5648LL, NAMSTR(s_sys_ss46e9d423, "schemaValidate")) {
        mcp.ci = &c_DOMDocument::ci_schemavalidate;
        return true;
      }
      break;
    case 74:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss2b6d2a95, "getElementsByTagName")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagname;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss49400bc1, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMDocument::ci_getelementsbytagnamens;
        return true;
      }
      break;
    case 77:
      HASH_GUARD_LITSTR(0x35C0FF513ED3054DLL, NAMSTR(s_sys_ss427e7c24, "saveHTMLFile")) {
        mcp.ci = &c_DOMDocument::ci_savehtmlfile;
        return true;
      }
      break;
    case 83:
      HASH_GUARD_LITSTR(0x21F3F1C9058310D3LL, NAMSTR(s_sys_ss690e46e7, "saveHTML")) {
        mcp.ci = &c_DOMDocument::ci_savehtml;
        return true;
      }
      break;
    case 95:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMDocument::ci___construct;
        return true;
      }
      HASH_GUARD_LITSTR(0x79B7A5774A0943DFLL, NAMSTR(s_sys_ss5853bc97, "load")) {
        mcp.ci = &c_DOMDocument::ci_load;
        return true;
      }
      break;
    case 101:
      HASH_GUARD_LITSTR(0x26D66F56DDDC32E5LL, NAMSTR(s_sys_ss6f5ad507, "saveXML")) {
        mcp.ci = &c_DOMDocument::ci_savexml;
        return true;
      }
      break;
    case 106:
      HASH_GUARD_LITSTR(0x0AC931EAB2FE3D6ALL, NAMSTR(s_sys_ss5d0c7971, "normalizeDocument")) {
        mcp.ci = &c_DOMDocument::ci_normalizedocument;
        return true;
      }
      break;
    case 107:
      HASH_GUARD_LITSTR(0x05EA36F416B7EBEBLL, NAMSTR(s_sys_ss3983a61c, "createElementNS")) {
        mcp.ci = &c_DOMDocument::ci_createelementns;
        return true;
      }
      break;
    case 109:
      HASH_GUARD_LITSTR(0x2A99431FC6E7BA6DLL, NAMSTR(s_sys_ss73b46b63, "createProcessingInstruction")) {
        mcp.ci = &c_DOMDocument::ci_createprocessinginstruction;
        return true;
      }
      break;
    case 115:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMDocument::ci___destruct;
        return true;
      }
      break;
    case 117:
      HASH_GUARD_LITSTR(0x615771958E1EB375LL, NAMSTR(s_sys_ss0915cca1, "registerNodeClass")) {
        mcp.ci = &c_DOMDocument::ci_registernodeclass;
        return true;
      }
      break;
    case 120:
      HASH_GUARD_LITSTR(0x44FD8C24F4EA46F8LL, NAMSTR(s_sys_ss212dc503, "createDocumentFragment")) {
        mcp.ci = &c_DOMDocument::ci_createdocumentfragment;
        return true;
      }
      break;
    case 123:
      HASH_GUARD_LITSTR(0x6056A5BB9855D7FBLL, NAMSTR(s_sys_ss3bb8fb3e, "createTextNode")) {
        mcp.ci = &c_DOMDocument::ci_createtextnode;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMDocument::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMDocument *c_DOMDocument::create(String a0, String a1) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1);
  return this;
}
ObjectData *c_DOMDocument::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 2) throw_toomany_arguments("__construct", 2, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      if (count <= 0) {
        (t___construct());
        break;
      }
      CVarRef arg0((ad->getValue(pos)));
      if (count == 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1));
    } while (false);
  }
  return this;
}
void c_DOMDocument::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    if (count <= 0) {
      (t___construct());
      break;
    }
    CVarRef arg0((ad->getValue(pos)));
    if (count == 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1));
  } while (false);
}
void c_DOMDocument::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMDocument::ci___construct;
  mcp.obj = this;
}
void c_DOMDocument::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 2) throw_toomany_arguments("__construct", 2, 1);
  if (count <= 0) (t___construct(), null);
  else if (count == 1) (t___construct(a0), null);
  else (t___construct(a0, a1), null);
}
struct ObjectStaticCallbacks cw_DOMDocument = {
  c_DOMDocument::os_getInit,
  c_DOMDocument::os_get,
  c_DOMDocument::os_lval,
  c_DOMDocument::os_invoke,
  c_DOMDocument::os_constant,
  c_DOMDocument::os_get_call_info
};
Object co_LibXMLError(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_LibXMLError)())->dynCreate(params, init));
}
Object coo_LibXMLError() {
  Object r(NEW(c_LibXMLError)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
Variant c_LibXMLError::os_getInit(CStrRef s) {
  return c_ObjectData::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
Variant c_LibXMLError::os_get(CStrRef s) {
  return c_ObjectData::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
Variant &c_LibXMLError::os_lval(CStrRef s) {
  return c_ObjectData::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
void c_LibXMLError::o_getArray(Array &props) const {
  c_ObjectData::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
void c_LibXMLError::o_setArray(CArrRef props) {
  c_ObjectData::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
Variant * c_LibXMLError::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
Variant * c_LibXMLError::o_realPropPublic(CStrRef s, int flags) const {
  return c_ObjectData::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
Variant * c_LibXMLError::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_LibXMLError
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
Variant c_LibXMLError::os_constant(const char *s) {
  return c_ObjectData::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_LibXMLError
IMPLEMENT_CLASS(LibXMLError)
void c_LibXMLError::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_LibXMLError::cloneImpl() {
  c_LibXMLError *obj = NEW(c_LibXMLError)();
  cloneSet(obj);
  return obj;
}
void c_LibXMLError::cloneSet(c_LibXMLError *clone) {
  ObjectData::cloneSet(clone);
}
Variant c_LibXMLError::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
        return (t___construct(), null);
      }
      break;
    default:
      break;
  }
  return c_ObjectData::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_LibXMLError::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_ObjectData::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_LibXMLError::ci___destruct((void*)&c_LibXMLError::i___destruct, (void*)&c_LibXMLError::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_LibXMLError::ci___construct((void*)&c_LibXMLError::i___construct, (void*)&c_LibXMLError::ifa___construct, 0, 4, 0x0000000000000000LL);
Variant c_LibXMLError::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_LibXMLError::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
Variant c_LibXMLError::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_LibXMLError::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_LibXMLError *self = NULL;
  p_LibXMLError pobj;
  if (mcp.obj) {
    self = static_cast<c_LibXMLError*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__construct", 0, 1);
  return (self->t___construct(), null);
}
bool c_LibXMLError::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 3) {
    case 3:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_LibXMLError::ci___destruct;
        return true;
      }
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_LibXMLError::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_ObjectData::os_get_call_info(mcp, hash);
}
bool c_LibXMLError::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_LibXMLError *c_LibXMLError::create() {
  CountableHelper h(this);
  init();
  t___construct();
  return this;
}
ObjectData *c_LibXMLError::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count > 0) throw_toomany_arguments("__construct", 0, 2);
    (t___construct());
  }
  return this;
}
void c_LibXMLError::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 2);
  (t___construct());
}
void c_LibXMLError::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_LibXMLError::ci___construct;
  mcp.obj = this;
}
void c_LibXMLError::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count > 0) throw_toomany_arguments("__construct", 0, 1);
  (t___construct(), null);
}
struct ObjectStaticCallbacks cw_LibXMLError = {
  c_LibXMLError::os_getInit,
  c_LibXMLError::os_get,
  c_LibXMLError::os_lval,
  c_LibXMLError::os_invoke,
  c_LibXMLError::os_constant,
  c_LibXMLError::os_get_call_info
};
Object co_SoapFault(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_SoapFault)())->dynCreate(params, init));
}
Object coo_SoapFault() {
  Object r(NEW(c_SoapFault)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
Variant c_SoapFault::os_getInit(CStrRef s) {
  return c_Exception::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
Variant c_SoapFault::os_get(CStrRef s) {
  return c_Exception::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
Variant &c_SoapFault::os_lval(CStrRef s) {
  return c_Exception::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
void c_SoapFault::o_getArray(Array &props) const {
  c_Exception::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
void c_SoapFault::o_setArray(CArrRef props) {
  c_Exception::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
Variant * c_SoapFault::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
Variant * c_SoapFault::o_realPropPublic(CStrRef s, int flags) const {
  return c_Exception::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
Variant * c_SoapFault::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_SoapFault
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
Variant c_SoapFault::os_constant(const char *s) {
  return c_Exception::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_SoapFault
IMPLEMENT_CLASS(SoapFault)
void c_SoapFault::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_SoapFault::cloneImpl() {
  c_SoapFault *obj = NEW(c_SoapFault)();
  cloneSet(obj);
  return obj;
}
void c_SoapFault::cloneSet(c_SoapFault *clone) {
  c_Exception::cloneSet(clone);
}
Variant c_SoapFault::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss5dc1dc95, "__tostring")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
        return (t___tostring());
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        Variant a3;
        Variant a4;
        Variant a5;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a3 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a4 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a5 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
        if (count <= 2) return (t___construct(a0, a1), null);
        else if (count == 3) return (t___construct(a0, a1, a2), null);
        else if (count == 4) return (t___construct(a0, a1, a2, a3), null);
        else if (count == 5) return (t___construct(a0, a1, a2, a3, a4), null);
        else return (t___construct(a0, a1, a2, a3, a4, a5), null);
      }
      break;
    default:
      break;
  }
  return c_Exception::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_SoapFault::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_Exception::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_SoapFault::ci___tostring((void*)&c_SoapFault::i___tostring, (void*)&c_SoapFault::ifa___tostring, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapFault::ci___destruct((void*)&c_SoapFault::i___destruct, (void*)&c_SoapFault::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_SoapFault::ci___construct((void*)&c_SoapFault::i___construct, (void*)&c_SoapFault::ifa___construct, 6, 4, 0x0000000000000000LL);
Variant c_SoapFault::i___tostring(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SoapFault::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapFault::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) return (self->t___construct(arg0, arg1, arg2), null);
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) return (self->t___construct(arg0, arg1, arg2, arg3), null);
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) return (self->t___construct(arg0, arg1, arg2, arg3, arg4), null);
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2, arg3, arg4, arg5), null);
  }
}
Variant c_SoapFault::ifa___tostring(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__tostring", 0, 1);
  return (self->t___tostring());
}
Variant c_SoapFault::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_SoapFault::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_SoapFault *self = NULL;
  p_SoapFault pobj;
  if (mcp.obj) {
    self = static_cast<c_SoapFault*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 2 || count > 6) return throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) return (self->t___construct(a0, a1), null);
  if (count == 3) return (self->t___construct(a0, a1, a2), null);
  if (count == 4) return (self->t___construct(a0, a1, a2, a3), null);
  if (count == 5) return (self->t___construct(a0, a1, a2, a3, a4), null);
  return (self->t___construct(a0, a1, a2, a3, a4, a5), null);
}
bool c_SoapFault::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 7) {
    case 3:
      HASH_GUARD_LITSTR(0x642C2D2994B34A13LL, NAMSTR(s_sys_ss5dc1dc95, "__tostring")) {
        mcp.ci = &c_SoapFault::ci___tostring;
        return true;
      }
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_SoapFault::ci___destruct;
        return true;
      }
      break;
    case 7:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_SoapFault::ci___construct;
        return true;
      }
      break;
    default:
      break;
  }
  return c_Exception::os_get_call_info(mcp, hash);
}
bool c_SoapFault::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_SoapFault *c_SoapFault::create(Variant a0, String a1, String a2, Variant a3, String a4, Variant a5) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2, a3, a4, a5);
  return this;
}
ObjectData *c_SoapFault::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count <= 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 3) {
        (t___construct(arg0, arg1, arg2));
        break;
      }
      CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 4) {
        (t___construct(arg0, arg1, arg2, arg3));
        break;
      }
      CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 5) {
        (t___construct(arg0, arg1, arg2, arg3, arg4));
        break;
      }
      CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
    } while (false);
  }
  return this;
}
void c_SoapFault::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count <= 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 3) {
      (t___construct(arg0, arg1, arg2));
      break;
    }
    CVarRef arg3((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 4) {
      (t___construct(arg0, arg1, arg2, arg3));
      break;
    }
    CVarRef arg4((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 5) {
      (t___construct(arg0, arg1, arg2, arg3, arg4));
      break;
    }
    CVarRef arg5((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2, arg3, arg4, arg5));
  } while (false);
}
void c_SoapFault::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_SoapFault::ci___construct;
  mcp.obj = this;
}
void c_SoapFault::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  Variant a3;
  Variant a4;
  Variant a5;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a3 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a4 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a5 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 2 || count > 6) throw_wrong_arguments("__construct", count, 2, 6, 1);
  if (count <= 2) (t___construct(a0, a1), null);
  else if (count == 3) (t___construct(a0, a1, a2), null);
  else if (count == 4) (t___construct(a0, a1, a2, a3), null);
  else if (count == 5) (t___construct(a0, a1, a2, a3, a4), null);
  else (t___construct(a0, a1, a2, a3, a4, a5), null);
}
struct ObjectStaticCallbacks cw_SoapFault = {
  c_SoapFault::os_getInit,
  c_SoapFault::os_get,
  c_SoapFault::os_lval,
  c_SoapFault::os_invoke,
  c_SoapFault::os_constant,
  c_SoapFault::os_get_call_info
};
Object co_DOMElement(CArrRef params, bool init /* = true */) {
  return Object((NEW(c_DOMElement)())->dynCreate(params, init));
}
Object coo_DOMElement() {
  Object r(NEW(c_DOMElement)());
  r->init();
  return r;
}
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
Variant c_DOMElement::os_getInit(CStrRef s) {
  return c_DOMNode::os_getInit(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GETINIT_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
Variant c_DOMElement::os_get(CStrRef s) {
  return c_DOMNode::os_get(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_GET_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
Variant &c_DOMElement::os_lval(CStrRef s) {
  return c_DOMNode::os_lval(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_STATIC_LVAL_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
void c_DOMElement::o_getArray(Array &props) const {
  c_DOMNode::o_getArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_GETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
void c_DOMElement::o_setArray(CArrRef props) {
  c_DOMNode::o_setArray(props);
}
#endif // OMIT_JUMP_TABLE_CLASS_SETARRAY_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
Variant * c_DOMElement::o_realProp(CStrRef prop, int flags, CStrRef context) const {
  return o_realPropPublic(prop, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
Variant * c_DOMElement::o_realPropPublic(CStrRef s, int flags) const {
  return c_DOMNode::o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PUBLIC_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
Variant * c_DOMElement::o_realPropPrivate(CStrRef s, int flags) const {
  return o_realPropPublic(s, flags);
}
#endif // OMIT_JUMP_TABLE_CLASS_realProp_PRIVATE_DOMElement
#ifndef OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
Variant c_DOMElement::os_constant(const char *s) {
  return c_DOMNode::os_constant(s);
}
#endif // OMIT_JUMP_TABLE_CLASS_CONSTANT_DOMElement
IMPLEMENT_CLASS(DOMElement)
void c_DOMElement::destruct() {
  if (!inCtorDtor()) {
    incRefCount();
    try {
      t___destruct();
    } catch (...) { handle_destructor_exception();}
  }
}
ObjectData *c_DOMElement::cloneImpl() {
  c_DOMElement *obj = NEW(c_DOMElement)();
  cloneSet(obj);
  return obj;
}
void c_DOMElement::cloneSet(c_DOMElement *clone) {
  c_DOMNode::cloneSet(clone);
}
Variant c_DOMElement::o_invoke_from_eval(const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  if (hash < 0) hash = hash_string(s);
  switch (hash & 63) {
    case 10:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss2b6d2a95, "getElementsByTagName")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
        return (t_getelementsbytagname(a0));
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss49400bc1, "getElementsByTagNameNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
        return (t_getelementsbytagnamens(a0, a1));
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss58a78f5c, "setIDAttributeNode")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
        return (t_setidattributenode(a0, a1));
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss625d0a69, "setAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
        return (t_setattribute(a0, a1));
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
        return (t___get(a0));
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss3fca29c8, "removeAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
        return (t_removeattributens(a0, a1));
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss0bfd696f, "setIDAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
        return (t_setidattributens(a0, a1, a2));
      }
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss34df4c9f, "setAttributeNodeNS")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
        return (t_setattributenodens(a0));
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
        return (t___set(a0, a1));
      }
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss1303cc56, "hasAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
        return (t_hasattributens(a0, a1));
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss102b70c6, "setIDAttribute")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
        return (t_setidattribute(a0, a1));
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss3d2102a4, "setAttributeNS")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
        return (t_setattributens(a0, a1, a2));
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss2aa43f67, "getAttributeNodeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
        return (t_getattributenodens(a0, a1));
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss29474452, "getAttributeNS")) {
        Variant a0;
        Variant a1;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
        return (t_getattributens(a0, a1));
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss28e44b58, "setAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
        return (t_setattributenode(a0));
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        Variant a0;
        Variant a1;
        Variant a2;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a1 = (*it)->eval(env);
          it++;
          if (it == params.end()) break;
          a2 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
        if (count <= 1) return (t___construct(a0), null);
        else if (count == 2) return (t___construct(a0, a1), null);
        else return (t___construct(a0, a1, a2), null);
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss0a49a8a1, "getAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
        return (t_getattribute(a0));
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss7e98a0fb, "removeAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
        return (t_removeattributenode(a0));
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss28995563, "hasAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
        return (t_hasattribute(a0));
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss5ef57bc3, "removeAttribute")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
        return (t_removeattribute(a0));
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
        return (t___destruct());
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss0b3b5e04, "getAttributeNode")) {
        Variant a0;
        const std::vector<Eval::ExpressionPtr> &params = caller->params();
        std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
        do {
          if (it == params.end()) break;
          a0 = (*it)->eval(env);
          it++;
        } while(false);
        for (; it != params.end(); ++it) {
          (*it)->eval(env);
        }
        int count __attribute__((__unused__)) = params.size();
        if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
        return (t_getattributenode(a0));
      }
      break;
    default:
      break;
  }
  return c_DOMNode::o_invoke_from_eval(s, env, caller, hash, fatal);
}
Variant c_DOMElement::os_invoke_from_eval(const char *c, const char *s, Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller, int64 hash, bool fatal) {
  return c_DOMNode::os_invoke_from_eval(c, s, env, caller, hash, fatal);
}
CallInfo c_DOMElement::ci_getelementsbytagname((void*)&c_DOMElement::i_getelementsbytagname, (void*)&c_DOMElement::ifa_getelementsbytagname, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattributens((void*)&c_DOMElement::i_setidattributens, (void*)&c_DOMElement::ifa_setidattributens, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattribute((void*)&c_DOMElement::i_getattribute, (void*)&c_DOMElement::ifa_getattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getelementsbytagnamens((void*)&c_DOMElement::i_getelementsbytagnamens, (void*)&c_DOMElement::ifa_getelementsbytagnamens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributenodens((void*)&c_DOMElement::i_getattributenodens, (void*)&c_DOMElement::ifa_getattributenodens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___destruct((void*)&c_DOMElement::i___destruct, (void*)&c_DOMElement::ifa___destruct, 0, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___set((void*)&c_DOMElement::i___set, (void*)&c_DOMElement::ifa___set, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___construct((void*)&c_DOMElement::i___construct, (void*)&c_DOMElement::ifa___construct, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_hasattribute((void*)&c_DOMElement::i_hasattribute, (void*)&c_DOMElement::ifa_hasattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_hasattributens((void*)&c_DOMElement::i_hasattributens, (void*)&c_DOMElement::ifa_hasattributens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributenodens((void*)&c_DOMElement::i_setattributenodens, (void*)&c_DOMElement::ifa_setattributenodens, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributens((void*)&c_DOMElement::i_setattributens, (void*)&c_DOMElement::ifa_setattributens, 3, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributens((void*)&c_DOMElement::i_getattributens, (void*)&c_DOMElement::ifa_getattributens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattributens((void*)&c_DOMElement::i_removeattributens, (void*)&c_DOMElement::ifa_removeattributens, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_getattributenode((void*)&c_DOMElement::i_getattributenode, (void*)&c_DOMElement::ifa_getattributenode, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattribute((void*)&c_DOMElement::i_setidattribute, (void*)&c_DOMElement::ifa_setidattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setidattributenode((void*)&c_DOMElement::i_setidattributenode, (void*)&c_DOMElement::ifa_setidattributenode, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattribute((void*)&c_DOMElement::i_setattribute, (void*)&c_DOMElement::ifa_setattribute, 2, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattributenode((void*)&c_DOMElement::i_removeattributenode, (void*)&c_DOMElement::ifa_removeattributenode, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci___get((void*)&c_DOMElement::i___get, (void*)&c_DOMElement::ifa___get, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_removeattribute((void*)&c_DOMElement::i_removeattribute, (void*)&c_DOMElement::ifa_removeattribute, 1, 4, 0x0000000000000000LL);
CallInfo c_DOMElement::ci_setattributenode((void*)&c_DOMElement::i_setattributenode, (void*)&c_DOMElement::ifa_setattributenode, 1, 4, 0x0000000000000000LL);
Variant c_DOMElement::i_getelementsbytagname(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getelementsbytagname(arg0));
  }
}
Variant c_DOMElement::i_setidattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattributens(arg0, arg1, arg2));
  }
}
Variant c_DOMElement::i_getattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattribute(arg0));
  }
}
Variant c_DOMElement::i_getelementsbytagnamens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getelementsbytagnamens(arg0, arg1));
  }
}
Variant c_DOMElement::i_getattributenodens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getattributenodens(arg0, arg1));
  }
}
Variant c_DOMElement::i___destruct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMElement::i___set(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___set(arg0, arg1));
  }
}
Variant c_DOMElement::i___construct(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) return (self->t___construct(arg0), null);
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) return (self->t___construct(arg0, arg1), null);
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t___construct(arg0, arg1, arg2), null);
  }
}
Variant c_DOMElement::i_hasattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_hasattribute(arg0));
  }
}
Variant c_DOMElement::i_hasattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_hasattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_setattributenodens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setattributenodens(arg0));
  }
}
Variant c_DOMElement::i_setattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattributens(arg0, arg1, arg2));
  }
}
Variant c_DOMElement::i_getattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_getattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_removeattributens(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_removeattributens(arg0, arg1));
  }
}
Variant c_DOMElement::i_getattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_getattributenode(arg0));
  }
}
Variant c_DOMElement::i_setidattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattribute(arg0, arg1));
  }
}
Variant c_DOMElement::i_setidattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setidattributenode(arg0, arg1));
  }
}
Variant c_DOMElement::i_setattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    return (self->t_setattribute(arg0, arg1));
  }
}
Variant c_DOMElement::i_removeattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removeattributenode(arg0));
  }
}
Variant c_DOMElement::i___get(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t___get(arg0));
  }
}
Variant c_DOMElement::i_removeattribute(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_removeattribute(arg0));
  }
}
Variant c_DOMElement::i_setattributenode(MethodCallPackage &mcp, CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
  {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    return (self->t_setattributenode(arg0));
  }
}
Variant c_DOMElement::ifa_getelementsbytagname(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getelementsbytagname", count, 1, 1, 1);
  return (self->t_getelementsbytagname(a0));
}
Variant c_DOMElement::ifa_setidattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setidattributens", count, 3, 3, 1);
  return (self->t_setidattributens(a0, a1, a2));
}
Variant c_DOMElement::ifa_getattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattribute", count, 1, 1, 1);
  return (self->t_getattribute(a0));
}
Variant c_DOMElement::ifa_getelementsbytagnamens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getelementsbytagnamens", count, 2, 2, 1);
  return (self->t_getelementsbytagnamens(a0, a1));
}
Variant c_DOMElement::ifa_getattributenodens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributenodens", count, 2, 2, 1);
  return (self->t_getattributenodens(a0, a1));
}
Variant c_DOMElement::ifa___destruct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count > 0) return throw_toomany_arguments("__destruct", 0, 1);
  return (self->t___destruct());
}
Variant c_DOMElement::ifa___set(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("__set", count, 2, 2, 1);
  return (self->t___set(a0, a1));
}
Variant c_DOMElement::ifa___construct(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count < 1 || count > 3) return throw_wrong_arguments("__construct", count, 1, 3, 1);
  if (count <= 1) return (self->t___construct(a0), null);
  if (count == 2) return (self->t___construct(a0, a1), null);
  return (self->t___construct(a0, a1, a2), null);
}
Variant c_DOMElement::ifa_hasattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("hasattribute", count, 1, 1, 1);
  return (self->t_hasattribute(a0));
}
Variant c_DOMElement::ifa_hasattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("hasattributens", count, 2, 2, 1);
  return (self->t_hasattributens(a0, a1));
}
Variant c_DOMElement::ifa_setattributenodens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenodens", count, 1, 1, 1);
  return (self->t_setattributenodens(a0));
}
Variant c_DOMElement::ifa_setattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 3) return throw_wrong_arguments("setattributens", count, 3, 3, 1);
  return (self->t_setattributens(a0, a1, a2));
}
Variant c_DOMElement::ifa_getattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("getattributens", count, 2, 2, 1);
  return (self->t_getattributens(a0, a1));
}
Variant c_DOMElement::ifa_removeattributens(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("removeattributens", count, 2, 2, 1);
  return (self->t_removeattributens(a0, a1));
}
Variant c_DOMElement::ifa_getattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("getattributenode", count, 1, 1, 1);
  return (self->t_getattributenode(a0));
}
Variant c_DOMElement::ifa_setidattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattribute", count, 2, 2, 1);
  return (self->t_setidattribute(a0, a1));
}
Variant c_DOMElement::ifa_setidattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setidattributenode", count, 2, 2, 1);
  return (self->t_setidattributenode(a0, a1));
}
Variant c_DOMElement::ifa_setattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 2) return throw_wrong_arguments("setattribute", count, 2, 2, 1);
  return (self->t_setattribute(a0, a1));
}
Variant c_DOMElement::ifa_removeattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattributenode", count, 1, 1, 1);
  return (self->t_removeattributenode(a0));
}
Variant c_DOMElement::ifa___get(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("__get", count, 1, 1, 1);
  return (self->t___get(a0));
}
Variant c_DOMElement::ifa_removeattribute(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("removeattribute", count, 1, 1, 1);
  return (self->t_removeattribute(a0));
}
Variant c_DOMElement::ifa_setattributenode(MethodCallPackage &mcp, int count, INVOKE_FEW_ARGS_IMPL_ARGS) {
  c_DOMElement *self = NULL;
  p_DOMElement pobj;
  if (mcp.obj) {
    self = static_cast<c_DOMElement*>(mcp.obj);
  } else {
    self = createDummy(pobj);
  }
  if (count != 1) return throw_wrong_arguments("setattributenode", count, 1, 1, 1);
  return (self->t_setattributenode(a0));
}
bool c_DOMElement::os_get_call_info(MethodCallPackage &mcp, int64 hash) {
  CStrRef s __attribute__((__unused__)) (mcp.name);
  if (hash < 0) hash = s->hash();
  switch (hash & 63) {
    case 10:
      HASH_GUARD_LITSTR(0x3FFA3F55ECAB93CALL, NAMSTR(s_sys_ss2b6d2a95, "getElementsByTagName")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagname;
        return true;
      }
      HASH_GUARD_LITSTR(0x1A9CC561CA4817CALL, NAMSTR(s_sys_ss49400bc1, "getElementsByTagNameNS")) {
        mcp.ci = &c_DOMElement::ci_getelementsbytagnamens;
        return true;
      }
      HASH_GUARD_LITSTR(0x29D272CBBC0CDA4ALL, NAMSTR(s_sys_ss58a78f5c, "setIDAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setidattributenode;
        return true;
      }
      HASH_GUARD_LITSTR(0x1D5B8B8144F4AB8ALL, NAMSTR(s_sys_ss625d0a69, "setAttribute")) {
        mcp.ci = &c_DOMElement::ci_setattribute;
        return true;
      }
      break;
    case 15:
      HASH_GUARD_LITSTR(0x26B6E00C74FA338FLL, NAMSTR(s_sys_ss6415a5db, "__get")) {
        mcp.ci = &c_DOMElement::ci___get;
        return true;
      }
      break;
    case 16:
      HASH_GUARD_LITSTR(0x710986B01E1A0890LL, NAMSTR(s_sys_ss3fca29c8, "removeAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_removeattributens;
        return true;
      }
      break;
    case 17:
      HASH_GUARD_LITSTR(0x31426AC6A851EE11LL, NAMSTR(s_sys_ss0bfd696f, "setIDAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setidattributens;
        return true;
      }
      HASH_GUARD_LITSTR(0x482E3873306253D1LL, NAMSTR(s_sys_ss34df4c9f, "setAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributenodens;
        return true;
      }
      break;
    case 21:
      HASH_GUARD_LITSTR(0x52F3DAD783340395LL, NAMSTR(s_sys_ss17981e9a, "__set")) {
        mcp.ci = &c_DOMElement::ci___set;
        return true;
      }
      HASH_GUARD_LITSTR(0x5EF7C3A45311D955LL, NAMSTR(s_sys_ss1303cc56, "hasAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_hasattributens;
        return true;
      }
      break;
    case 22:
      HASH_GUARD_LITSTR(0x6F83EC29E110D616LL, NAMSTR(s_sys_ss102b70c6, "setIDAttribute")) {
        mcp.ci = &c_DOMElement::ci_setidattribute;
        return true;
      }
      break;
    case 23:
      HASH_GUARD_LITSTR(0x62A40E71FAF19157LL, NAMSTR(s_sys_ss3d2102a4, "setAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_setattributens;
        return true;
      }
      break;
    case 24:
      HASH_GUARD_LITSTR(0x640FA60DDC80EC18LL, NAMSTR(s_sys_ss2aa43f67, "getAttributeNodeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributenodens;
        return true;
      }
      break;
    case 25:
      HASH_GUARD_LITSTR(0x34E103E06D3F0899LL, NAMSTR(s_sys_ss29474452, "getAttributeNS")) {
        mcp.ci = &c_DOMElement::ci_getattributens;
        return true;
      }
      break;
    case 28:
      HASH_GUARD_LITSTR(0x606827EF5CF34C5CLL, NAMSTR(s_sys_ss28e44b58, "setAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_setattributenode;
        return true;
      }
      break;
    case 31:
      HASH_GUARD_LITSTR(0x0D31D0AC229C615FLL, NAMSTR(s_sys_ss5e478259, "__construct")) {
        mcp.ci = &c_DOMElement::ci___construct;
        return true;
      }
      break;
    case 40:
      HASH_GUARD_LITSTR(0x49F89C466612FC28LL, NAMSTR(s_sys_ss0a49a8a1, "getAttribute")) {
        mcp.ci = &c_DOMElement::ci_getattribute;
        return true;
      }
      break;
    case 42:
      HASH_GUARD_LITSTR(0x1BFDB4272EA150EALL, NAMSTR(s_sys_ss7e98a0fb, "removeAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_removeattributenode;
        return true;
      }
      break;
    case 44:
      HASH_GUARD_LITSTR(0x6471DF8BB944FFECLL, NAMSTR(s_sys_ss28995563, "hasAttribute")) {
        mcp.ci = &c_DOMElement::ci_hasattribute;
        return true;
      }
      break;
    case 47:
      HASH_GUARD_LITSTR(0x47B96C0FC62E1E2FLL, NAMSTR(s_sys_ss5ef57bc3, "removeAttribute")) {
        mcp.ci = &c_DOMElement::ci_removeattribute;
        return true;
      }
      break;
    case 51:
      HASH_GUARD_LITSTR(0x7F974836AACC1EF3LL, NAMSTR(s_sys_ss5a580b07, "__destruct")) {
        mcp.ci = &c_DOMElement::ci___destruct;
        return true;
      }
      break;
    case 62:
      HASH_GUARD_LITSTR(0x343DF562BB5AB1FELL, NAMSTR(s_sys_ss0b3b5e04, "getAttributeNode")) {
        mcp.ci = &c_DOMElement::ci_getattributenode;
        return true;
      }
      break;
    default:
      break;
  }
  return c_DOMNode::os_get_call_info(mcp, hash);
}
bool c_DOMElement::o_get_call_info(MethodCallPackage &mcp, int64 hash) {
  mcp.obj = this;
  return os_get_call_info(mcp, hash);
}
c_DOMElement *c_DOMElement::create(String a0, String a1, String a2) {
  CountableHelper h(this);
  init();
  t___construct(a0, a1, a2);
  return this;
}
ObjectData *c_DOMElement::dynCreate(CArrRef params, bool construct /* = true */) {
  init();
  if (construct) {
    CountableHelper h(this);
    int count __attribute__((__unused__)) = params.size();
    if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
    do {
      ArrayData *ad(params.get());
      ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
      CVarRef arg0((ad->getValue(pos)));
      if (count <= 1) {
        (t___construct(arg0));
        break;
      }
      CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
      if (count == 2) {
        (t___construct(arg0, arg1));
        break;
      }
      CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
      (t___construct(arg0, arg1, arg2));
    } while (false);
  }
  return this;
}
void c_DOMElement::dynConstruct(CArrRef params) {
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 2);
  do {
    ArrayData *ad(params.get());
    ssize_t pos = ad ? ad->iter_begin() : ArrayData::invalid_index;
    CVarRef arg0((ad->getValue(pos)));
    if (count <= 1) {
      (t___construct(arg0));
      break;
    }
    CVarRef arg1((ad->getValue(pos = ad->iter_advance(pos))));
    if (count == 2) {
      (t___construct(arg0, arg1));
      break;
    }
    CVarRef arg2((ad->getValue(pos = ad->iter_advance(pos))));
    (t___construct(arg0, arg1, arg2));
  } while (false);
}
void c_DOMElement::getConstructor(MethodCallPackage &mcp) {
  mcp.ci = &c_DOMElement::ci___construct;
  mcp.obj = this;
}
void c_DOMElement::dynConstructFromEval(Eval::VariableEnvironment &env, const Eval::FunctionCallExpression *caller) {
  Variant a0;
  Variant a1;
  Variant a2;
  const std::vector<Eval::ExpressionPtr> &params = caller->params();
  std::vector<Eval::ExpressionPtr>::const_iterator it = params.begin();
  do {
    if (it == params.end()) break;
    a0 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a1 = (*it)->eval(env);
    it++;
    if (it == params.end()) break;
    a2 = (*it)->eval(env);
    it++;
  } while(false);
  for (; it != params.end(); ++it) {
    (*it)->eval(env);
  }
  int count __attribute__((__unused__)) = params.size();
  if (count < 1 || count > 3) throw_wrong_arguments("__construct", count, 1, 3, 1);
  if (count <= 1) (t___construct(a0), null);
  else if (count == 2) (t___construct(a0, a1), null);
  else (t___construct(a0, a1, a2), null);
}
struct ObjectStaticCallbacks cw_DOMElement = {
  c_DOMElement::os_getInit,
  c_DOMElement::os_get,
  c_DOMElement::os_lval,
  c_DOMElement::os_invoke,
  c_DOMElement::os_constant,
  c_DOMElement::os_get_call_info
};
Variant get_builtin_class_var_init(const char *s, const char *var) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_CLASS_VAR_INIT(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_CLASS_VAR_INIT(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_CLASS_VAR_INIT(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_CLASS_VAR_INIT(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_CLASS_VAR_INIT(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_CLASS_VAR_INIT(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_CLASS_VAR_INIT(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_CLASS_VAR_INIT(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_CLASS_VAR_INIT(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_CLASS_VAR_INIT(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_CLASS_VAR_INIT(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_CLASS_VAR_INIT(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_CLASS_VAR_INIT(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_CLASS_VAR_INIT(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_CLASS_VAR_INIT(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_CLASS_VAR_INIT(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_CLASS_VAR_INIT(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_CLASS_VAR_INIT(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_CLASS_VAR_INIT(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_CLASS_VAR_INIT(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_CLASS_VAR_INIT(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_CLASS_VAR_INIT(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_CLASS_VAR_INIT(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 74:
      HASH_GET_CLASS_VAR_INIT(0x72A49A22C192034ALL, Memcached);
      break;
    case 75:
      HASH_GET_CLASS_VAR_INIT(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_CLASS_VAR_INIT(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_CLASS_VAR_INIT(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_CLASS_VAR_INIT(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_CLASS_VAR_INIT(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_CLASS_VAR_INIT(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_CLASS_VAR_INIT(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_CLASS_VAR_INIT(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_CLASS_VAR_INIT(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_CLASS_VAR_INIT(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_CLASS_VAR_INIT(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_CLASS_VAR_INIT(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_CLASS_VAR_INIT(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_CLASS_VAR_INIT(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_CLASS_VAR_INIT(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_CLASS_VAR_INIT(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_CLASS_VAR_INIT(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_CLASS_VAR_INIT(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_CLASS_VAR_INIT(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_CLASS_VAR_INIT(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_CLASS_VAR_INIT(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_CLASS_VAR_INIT(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_CLASS_VAR_INIT(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_CLASS_VAR_INIT(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_CLASS_VAR_INIT(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_CLASS_VAR_INIT(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_CLASS_VAR_INIT(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_CLASS_VAR_INIT(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_CLASS_VAR_INIT(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_CLASS_VAR_INIT(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_CLASS_VAR_INIT(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_CLASS_VAR_INIT(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_CLASS_VAR_INIT(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_CLASS_VAR_INIT(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_CLASS_VAR_INIT(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_CLASS_VAR_INIT(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_CLASS_VAR_INIT(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_CLASS_VAR_INIT(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_CLASS_VAR_INIT(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_CLASS_VAR_INIT(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_CLASS_VAR_INIT(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_CLASS_VAR_INIT(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_CLASS_VAR_INIT(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_CLASS_VAR_INIT(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_CLASS_VAR_INIT(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_CLASS_VAR_INIT(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_CLASS_VAR_INIT(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_CLASS_VAR_INIT(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_CLASS_VAR_INIT(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_CLASS_VAR_INIT(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_CLASS_VAR_INIT(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_CLASS_VAR_INIT(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_CLASS_VAR_INIT(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_CLASS_VAR_INIT(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_CLASS_VAR_INIT(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_CLASS_VAR_INIT(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_CLASS_VAR_INIT(0x74419B70A46387FDLL, DOMImplementation);
      HASH_GET_CLASS_VAR_INIT(0x3D290BF933ED12FDLL, XhprofFrame);
      break;
    case 255:
      HASH_GET_CLASS_VAR_INIT(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
Object create_builtin_object_only(const char *s, ObjectData* root /* = NULL*/) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_CREATE_OBJECT_ONLY(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_CREATE_OBJECT_ONLY(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_CREATE_OBJECT_ONLY(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_CREATE_OBJECT_ONLY(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_CREATE_OBJECT_ONLY(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_CREATE_OBJECT_ONLY(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_CREATE_OBJECT_ONLY(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_CREATE_OBJECT_ONLY(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_CREATE_OBJECT_ONLY(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_CREATE_OBJECT_ONLY(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_CREATE_OBJECT_ONLY(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_CREATE_OBJECT_ONLY(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_CREATE_OBJECT_ONLY(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_CREATE_OBJECT_ONLY(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_CREATE_OBJECT_ONLY(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_CREATE_OBJECT_ONLY(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_CREATE_OBJECT_ONLY(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_CREATE_OBJECT_ONLY(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_CREATE_OBJECT_ONLY(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_CREATE_OBJECT_ONLY(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_CREATE_OBJECT_ONLY(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_CREATE_OBJECT_ONLY(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_CREATE_OBJECT_ONLY(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 74:
      HASH_CREATE_OBJECT_ONLY(0x72A49A22C192034ALL, Memcached);
      break;
    case 75:
      HASH_CREATE_OBJECT_ONLY(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_CREATE_OBJECT_ONLY(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_CREATE_OBJECT_ONLY(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_CREATE_OBJECT_ONLY(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_CREATE_OBJECT_ONLY(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_CREATE_OBJECT_ONLY(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_CREATE_OBJECT_ONLY(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_CREATE_OBJECT_ONLY(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_CREATE_OBJECT_ONLY(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_CREATE_OBJECT_ONLY(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_CREATE_OBJECT_ONLY(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_CREATE_OBJECT_ONLY(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_CREATE_OBJECT_ONLY(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_CREATE_OBJECT_ONLY(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_CREATE_OBJECT_ONLY(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_CREATE_OBJECT_ONLY(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_CREATE_OBJECT_ONLY(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_CREATE_OBJECT_ONLY(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_CREATE_OBJECT_ONLY(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_CREATE_OBJECT_ONLY(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_CREATE_OBJECT_ONLY(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_CREATE_OBJECT_ONLY(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_CREATE_OBJECT_ONLY(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_CREATE_OBJECT_ONLY(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_CREATE_OBJECT_ONLY(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_CREATE_OBJECT_ONLY(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_CREATE_OBJECT_ONLY(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_CREATE_OBJECT_ONLY(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_CREATE_OBJECT_ONLY(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_CREATE_OBJECT_ONLY(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_CREATE_OBJECT_ONLY(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_CREATE_OBJECT_ONLY(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_CREATE_OBJECT_ONLY(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_CREATE_OBJECT_ONLY(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_CREATE_OBJECT_ONLY(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_CREATE_OBJECT_ONLY(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_CREATE_OBJECT_ONLY(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_CREATE_OBJECT_ONLY(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_CREATE_OBJECT_ONLY(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_CREATE_OBJECT_ONLY(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_CREATE_OBJECT_ONLY(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_CREATE_OBJECT_ONLY(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_CREATE_OBJECT_ONLY(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_CREATE_OBJECT_ONLY(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_CREATE_OBJECT_ONLY(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_CREATE_OBJECT_ONLY(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_CREATE_OBJECT_ONLY(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_CREATE_OBJECT_ONLY(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_CREATE_OBJECT_ONLY(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_CREATE_OBJECT_ONLY(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_CREATE_OBJECT_ONLY(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_CREATE_OBJECT_ONLY(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_CREATE_OBJECT_ONLY(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_CREATE_OBJECT_ONLY(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_CREATE_OBJECT_ONLY(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_CREATE_OBJECT_ONLY(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_CREATE_OBJECT_ONLY(0x74419B70A46387FDLL, DOMImplementation);
      HASH_CREATE_OBJECT_ONLY(0x3D290BF933ED12FDLL, XhprofFrame);
      break;
    case 255:
      HASH_CREATE_OBJECT_ONLY(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return throw_missing_class(s);
}
bool get_call_info_static_method_builtin(MethodCallPackage &mcp) {
  StringData *s __attribute__((__unused__)) (mcp.rootObj.getStringData());
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = s->hash();
  switch (hash & 255) {
    case 8:
      HASH_CALL_INFO_STATIC_METHOD(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_CALL_INFO_STATIC_METHOD(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_CALL_INFO_STATIC_METHOD(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_CALL_INFO_STATIC_METHOD(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_CALL_INFO_STATIC_METHOD(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_CALL_INFO_STATIC_METHOD(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_CALL_INFO_STATIC_METHOD(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_CALL_INFO_STATIC_METHOD(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_CALL_INFO_STATIC_METHOD(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_CALL_INFO_STATIC_METHOD(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_CALL_INFO_STATIC_METHOD(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_CALL_INFO_STATIC_METHOD(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_CALL_INFO_STATIC_METHOD(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_CALL_INFO_STATIC_METHOD(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_CALL_INFO_STATIC_METHOD(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_CALL_INFO_STATIC_METHOD(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_CALL_INFO_STATIC_METHOD(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_CALL_INFO_STATIC_METHOD(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_CALL_INFO_STATIC_METHOD(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_CALL_INFO_STATIC_METHOD(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_CALL_INFO_STATIC_METHOD(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_CALL_INFO_STATIC_METHOD(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_CALL_INFO_STATIC_METHOD(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 74:
      HASH_CALL_INFO_STATIC_METHOD(0x72A49A22C192034ALL, Memcached);
      break;
    case 75:
      HASH_CALL_INFO_STATIC_METHOD(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_CALL_INFO_STATIC_METHOD(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_CALL_INFO_STATIC_METHOD(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_CALL_INFO_STATIC_METHOD(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_CALL_INFO_STATIC_METHOD(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_CALL_INFO_STATIC_METHOD(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_CALL_INFO_STATIC_METHOD(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_CALL_INFO_STATIC_METHOD(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_CALL_INFO_STATIC_METHOD(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_CALL_INFO_STATIC_METHOD(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_CALL_INFO_STATIC_METHOD(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_CALL_INFO_STATIC_METHOD(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_CALL_INFO_STATIC_METHOD(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_CALL_INFO_STATIC_METHOD(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_CALL_INFO_STATIC_METHOD(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_CALL_INFO_STATIC_METHOD(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_CALL_INFO_STATIC_METHOD(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_CALL_INFO_STATIC_METHOD(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_CALL_INFO_STATIC_METHOD(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_CALL_INFO_STATIC_METHOD(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_CALL_INFO_STATIC_METHOD(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_CALL_INFO_STATIC_METHOD(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_CALL_INFO_STATIC_METHOD(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_CALL_INFO_STATIC_METHOD(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_CALL_INFO_STATIC_METHOD(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_CALL_INFO_STATIC_METHOD(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_CALL_INFO_STATIC_METHOD(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_CALL_INFO_STATIC_METHOD(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_CALL_INFO_STATIC_METHOD(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_CALL_INFO_STATIC_METHOD(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_CALL_INFO_STATIC_METHOD(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_CALL_INFO_STATIC_METHOD(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_CALL_INFO_STATIC_METHOD(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_CALL_INFO_STATIC_METHOD(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_CALL_INFO_STATIC_METHOD(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_CALL_INFO_STATIC_METHOD(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_CALL_INFO_STATIC_METHOD(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_CALL_INFO_STATIC_METHOD(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_CALL_INFO_STATIC_METHOD(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_CALL_INFO_STATIC_METHOD(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_CALL_INFO_STATIC_METHOD(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_CALL_INFO_STATIC_METHOD(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_CALL_INFO_STATIC_METHOD(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_CALL_INFO_STATIC_METHOD(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_CALL_INFO_STATIC_METHOD(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_CALL_INFO_STATIC_METHOD(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_CALL_INFO_STATIC_METHOD(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_CALL_INFO_STATIC_METHOD(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_CALL_INFO_STATIC_METHOD(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_CALL_INFO_STATIC_METHOD(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_CALL_INFO_STATIC_METHOD(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_CALL_INFO_STATIC_METHOD(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_CALL_INFO_STATIC_METHOD(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_CALL_INFO_STATIC_METHOD(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_CALL_INFO_STATIC_METHOD(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_CALL_INFO_STATIC_METHOD(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_CALL_INFO_STATIC_METHOD(0x74419B70A46387FDLL, DOMImplementation);
      HASH_CALL_INFO_STATIC_METHOD(0x3D290BF933ED12FDLL, XhprofFrame);
      break;
    case 255:
      HASH_CALL_INFO_STATIC_METHOD(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return ObjectData::os_get_call_info(mcp);
}
bool get_call_info_static_method_with_index_builtin(MethodCallPackage &mcp, MethodIndex mi) {
  return get_call_info_static_method_builtin(mcp);
}
const ObjectStaticCallbacks * get_builtin_object_static_callbacks(const char *s) {
  DECLARE_SYSTEM_GLOBALS(g);
  int64 hash = hash_string(s);
  switch (hash & 255) {
    case 8:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4DA860E5647C3908LL, ImageSprite);
      break;
    case 9:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x21EF70351574EC09LL, ReflectionFunction);
      break;
    case 11:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4365BE9E5A85E60BLL, DOMNotation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x69EDCA1CC29CFE0BLL, ErrorException);
      break;
    case 18:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x78B42582709BAF12LL, DebuggerProxy);
      break;
    case 19:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A76B9AABB7CC713LL, SimpleXMLElement);
      break;
    case 21:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x32E5C767255D2515LL, SoapFault);
      break;
    case 26:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5CBA5B52C68B501ALL, DOMEntityReference);
      break;
    case 29:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x35A44A5E6AE2E71DLL, ReflectionClass);
      break;
    case 30:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3DB8FB455A602A1ELL, DateTime);
      break;
    case 43:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E66D362EAB5BF2BLL, SimpleXMLElementIterator);
      break;
    case 49:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A394042E7488231LL, FilterIterator);
      break;
    case 50:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x365899865E2EAA32LL, RecursiveIteratorIterator);
      break;
    case 53:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7909270014376235LL, SoapVar);
      break;
    case 55:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7FF7A8442616EF37LL, DOMNodeIterator);
      break;
    case 56:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x672AD818DDE95538LL, ReflectionException);
      break;
    case 61:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4C6991D3CF5CA03DLL, Collator);
      break;
    case 62:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x49FC1A1F7B878C3ELL, SoapServer);
      break;
    case 65:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x227C70ED5B143841LL, OutOfBoundsException);
      break;
    case 68:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4253D8488B734244LL, PDOStatement);
      break;
    case 70:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x196F76C9C527B946LL, DOMNamedNodeMap);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x66282FC8E4EF4E46LL, BadFunctionCallException);
      break;
    case 73:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5AA2EE582E0D3849LL, UnexpectedValueException);
      break;
    case 74:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x72A49A22C192034ALL, Memcached);
      break;
    case 75:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x4860DC2F9B0E6D4BLL, LogicException);
      break;
    case 77:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x164F490DAC49174DLL, DOMText);
      break;
    case 78:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x308D1D59986A3D4ELL, SoapHeader);
      break;
    case 79:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5BA243B9FBA7A64FLL, SplObjectStorage);
      break;
    case 80:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52EA111229F87A50LL, Normalizer);
      break;
    case 83:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x02239AA5D64B1453LL, DOMCharacterData);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6AF83706F76A9D53LL, RangeException);
      break;
    case 94:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7754323897E8A15ELL, DirectoryIterator);
      break;
    case 97:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70EBB2CC1FBF9761LL, DOMDocumentType);
      break;
    case 98:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70747A09B3523662LL, DOMNode);
      break;
    case 99:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D1235273F521A63LL, DebuggerClient);
      break;
    case 101:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2FF1EF6EBB3DA065LL, XMLWriter);
      break;
    case 104:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7E07B9C27FE59D68LL, DOMComment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x17A40D895C55D968LL, SoapParam);
      break;
    case 106:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6A5B99D5B1A4566ALL, DOMException);
      break;
    case 107:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3CAE91CFA2AAD16BLL, LengthException);
      break;
    case 115:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D5870E53BF89873LL, ArrayIterator);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0B61E0BFCFA06573LL, ReflectionExtension);
      break;
    case 117:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x085A4F6FD393D475LL, InvalidArgumentException);
      break;
    case 122:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x41A9F7D81254DD7ALL, ReflectionObject);
      break;
    case 125:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7AD161197633B87DLL, DOMDocumentFragment);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E899D2A2572EF7DLL, SQLite3Result);
      break;
    case 128:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x59B3EFD1CD987F80LL, DOMProcessingInstruction);
      break;
    case 130:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x33BD46E935281082LL, ReflectionFunctionAbstract);
      break;
    case 131:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x24DE53FD7D3E8383LL, DateTimeZone);
      break;
    case 132:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x70D4A29DE6A7BA84LL, DomainException);
      break;
    case 143:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x34C95AF311506C8FLL, Directory);
      break;
    case 144:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x06335FF83CDEA590LL, BadMethodCallException);
      break;
    case 147:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E7081C468A05993LL, ReflectionParameter);
      break;
    case 148:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6FFDF8DF15CABE94LL, DOMCDATASection);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6576EACCCE24D694LL, __PHP_Incomplete_Class);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x47D93E6F80B66A94LL, Exception);
      break;
    case 167:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x71089C29FE923FA7LL, SplFileInfo);
      break;
    case 168:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7D46DB2E09C6DBA8LL, DOMXPath);
      break;
    case 169:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1D35C3EFD00E11A9LL, SQLite3);
      break;
    case 170:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x67E31D42F2DFE4AALL, Locale);
      break;
    case 173:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0A34015F67C804ADLL, PDO);
      break;
    case 175:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E650138BA043AAFLL, DOMDocument);
      break;
    case 176:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x43BBC8F6F28E44B0LL, ReflectionMethod);
      break;
    case 177:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x6DD772FA3B20B8B1LL, DOMNodeList);
      break;
    case 189:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5D8785ACD19F77BDLL, PDOException);
      break;
    case 195:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x40B3C44077F5DDC3LL, DOMElement);
      break;
    case 200:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x2E363D51549781C8LL, AppendIterator);
      break;
    case 203:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x253AC17234FC8CCBLL, LibXMLError);
      break;
    case 208:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3C122DF8859C72D0LL, Memcache);
      break;
    case 210:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x52E5CC58B841AED2LL, SQLite3Stmt);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297ECCC7A259EDD2LL, SplFileObject);
      break;
    case 212:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x5E623FEAF7B068D4LL, UnderflowException);
      break;
    case 216:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x464D3427431A6ED8LL, RecursiveDirectoryIterator);
      break;
    case 217:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x0E4CCE95F6A727D9LL, OverflowException);
      break;
    case 218:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x7A52EBE538182BDALL, SoapClient);
      break;
    case 220:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x1078CB3118A8B3DCLL, RuntimeException);
      break;
    case 228:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x75AA2571BDB659E4LL, ReflectionProperty);
      break;
    case 244:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x297174231D4912F4LL, DOMAttr);
      break;
    case 247:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D69936178BA13F7LL, stdClass);
      break;
    case 252:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x622D4DF07E2A01FCLL, OutOfRangeException);
      break;
    case 253:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x74419B70A46387FDLL, DOMImplementation);
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x3D290BF933ED12FDLL, XhprofFrame);
      break;
    case 255:
      HASH_GET_OBJECT_STATIC_CALLBACKS(0x624835B2D74B86FFLL, DOMEntity);
      break;
    default:
      break;
  }
  return NULL;
}
Variant get_builtin_static_property(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_get(prop);
  }
  return null;
}
Variant *get_builtin_static_property_lv(const char *s, const char *prop) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return &cwo->os_lval(prop);
  }
  return NULL;
}
Variant get_builtin_class_constant(const char *s, const char *constant, bool fatal /* = true */) {
  {
    const ObjectStaticCallbacks * cwo = get_builtin_object_static_callbacks(s);
    if (cwo) return cwo->os_constant(constant);
  }
  if (fatal) {
    raise_error("Couldn't find constant %s::%s", s, constant);
  } else {
    raise_warning("Couldn't find constant %s::%s", s, constant);
  }
  return null;
}

///////////////////////////////////////////////////////////////////////////////
}
