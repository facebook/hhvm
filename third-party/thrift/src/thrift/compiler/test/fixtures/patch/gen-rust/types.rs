// @generated by Thrift for src/module.thrift
// This file is probably not the place you want to edit!

//! Thrift type definitions for `module`.

#![allow(clippy::redundant_closure)]


#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyData {
    pub data1: ::std::string::String,
    pub data2: ::std::primitive::i32,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum InnerUnion {
    innerOption(::std::vec::Vec<::std::primitive::u8>),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq, Debug)]
pub enum MyUnion {
    option1(::std::string::String),
    option2(::std::primitive::i32),
    option3(crate::types::InnerUnion),
    UnknownField(::std::primitive::i32),
}

#[derive(Clone, PartialEq)]
pub struct MyStruct {
    pub boolVal: ::std::primitive::bool,
    pub byteVal: ::std::primitive::i8,
    pub i16Val: ::std::primitive::i16,
    pub i32Val: ::std::primitive::i32,
    pub i64Val: ::std::primitive::i64,
    pub floatVal: ::std::primitive::f32,
    pub doubleVal: ::std::primitive::f64,
    pub stringVal: ::std::string::String,
    pub binaryVal: ::std::vec::Vec<::std::primitive::u8>,
    pub structVal: crate::types::MyData,
    pub optBoolVal: ::std::option::Option<::std::primitive::bool>,
    pub optByteVal: ::std::option::Option<::std::primitive::i8>,
    pub optI16Val: ::std::option::Option<::std::primitive::i16>,
    pub optI32Val: ::std::option::Option<::std::primitive::i32>,
    pub optI64Val: ::std::option::Option<::std::primitive::i64>,
    pub optFloatVal: ::std::option::Option<::std::primitive::f32>,
    pub optDoubleVal: ::std::option::Option<::std::primitive::f64>,
    pub optStringVal: ::std::option::Option<::std::string::String>,
    pub optBinaryVal: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
    pub optStructVal: ::std::option::Option<crate::types::MyData>,
    pub optListVal: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    pub optSetVal: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    pub optMapVal: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    pub unionVal: crate::types::MyUnion,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataFieldPatch {
    pub data1: patch::types::StringPatch,
    pub data2: patch::types::I32Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyDataPatch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyDataFieldPatch,
    #[doc = "Initlaize fields, using the given defaults. Applies third."]
    pub ensure: crate::types::MyData,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyDataFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyDataPatch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyDataPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::boxed::Box<crate::types::MyData>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyDataPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct InnerUnionFieldPatch {
    pub innerOption: patch::types::BinaryPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct InnerUnionPatch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: crate::types::InnerUnion,
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::InnerUnionFieldPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: crate::types::InnerUnion,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::InnerUnionFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalInnerUnionPatch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::InnerUnionPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::boxed::Box<crate::types::InnerUnion>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::InnerUnionPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyUnionFieldPatch {
    pub option1: patch::types::StringPatch,
    pub option2: patch::types::I32Patch,
    pub option3: crate::types::InnerUnionPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyUnionPatch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: crate::types::MyUnion,
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyUnionFieldPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: crate::types::MyUnion,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyUnionFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyUnionPatch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyUnionPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::boxed::Box<crate::types::MyUnion>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyUnionPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructFieldPatch {
    pub boolVal: patch::types::BoolPatch,
    pub byteVal: patch::types::BytePatch,
    pub i16Val: patch::types::I16Patch,
    pub i32Val: patch::types::I32Patch,
    pub i64Val: patch::types::I64Patch,
    pub floatVal: patch::types::FloatPatch,
    pub doubleVal: patch::types::DoublePatch,
    pub stringVal: patch::types::StringPatch,
    pub binaryVal: patch::types::BinaryPatch,
    pub structVal: crate::types::MyDataPatch,
    pub optBoolVal: patch::types::OptionalBoolPatch,
    pub optByteVal: patch::types::OptionalBytePatch,
    pub optI16Val: patch::types::OptionalI16Patch,
    pub optI32Val: patch::types::OptionalI32Patch,
    pub optI64Val: patch::types::OptionalI64Patch,
    pub optFloatVal: patch::types::OptionalFloatPatch,
    pub optDoubleVal: patch::types::OptionalDoublePatch,
    pub optStringVal: patch::types::OptionalStringPatch,
    pub optBinaryVal: patch::types::OptionalBinaryPatch,
    pub optStructVal: crate::types::OptionalMyDataPatch,
    pub optListVal: crate::types::OptionalMyStructField21Patch,
    pub optSetVal: crate::types::OptionalMyStructField22Patch,
    pub optMapVal: crate::types::OptionalMyStructField23Patch,
    pub unionVal: crate::types::MyUnionPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct MyStructField21Patch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Prepends to the front of a given list."]
    pub prepend: ::std::vec::Vec<::std::primitive::i16>,
    #[doc = "Appends to the back of a given list."]
    pub append: ::std::vec::Vec<::std::primitive::i16>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyStructField21Patch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyStructField21Patch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::vec::Vec<::std::primitive::i16>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyStructField21Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField22Patch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Removes entries, if present. Applies thrid."]
    pub remove: ::std::collections::BTreeSet<::std::string::String>,
    #[doc = "Adds entries, if not already present. Applies fourth."]
    pub add: ::std::collections::BTreeSet<::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyStructField22Patch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyStructField22Patch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::collections::BTreeSet<::std::string::String>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyStructField22Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructField23Patch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Add the given values, if the keys are not already present. Applies forth."]
    pub add: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    #[doc = "Adds or replaces the given key/value pairs. Applies fifth."]
    pub put: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyStructField23Patch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyStructField23Patch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyStructField23Patch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct MyStructPatch {
    #[doc = "Assigns a value. If set, all other operations are ignored."]
    pub assign: ::std::option::Option<::std::boxed::Box<crate::types::MyStruct>>,
    #[doc = "Clears a value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyStructFieldPatch,
    #[doc = "Initlaize fields, using the given defaults. Applies third."]
    pub ensure: crate::types::MyStruct,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyStructFieldPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[derive(Clone, PartialEq)]
pub struct OptionalMyStructPatch {
    #[doc = "Clears any set value. Applies first."]
    pub clear: ::std::primitive::bool,
    #[doc = "Patches any previously set values. Applies second."]
    pub patchPrior: crate::types::MyStructPatch,
    #[doc = "Assigns the value, if not already set to the same field. Applies third."]
    pub ensure: ::std::option::Option<::std::boxed::Box<crate::types::MyStruct>>,
    #[doc = "Patches any set value, including newly set values. Applies last."]
    pub patch: crate::types::MyStructPatch,
    // This field forces `..Default::default()` when instantiating this
    // struct, to make code future-proof against new fields added later to
    // the definition in Thrift. If you don't want this, add the annotation
    // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
    #[doc(hidden)]
    pub _dot_dot_Default_default: self::dot_dot::OtherFields,
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyData {
    fn default() -> Self {
        Self {
            data1: ::std::default::Default::default(),
            data2: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyData {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyData")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyData {}
unsafe impl ::std::marker::Sync for self::MyData {}

impl ::fbthrift::GetTType for self::MyData {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyData {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyData"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyData
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyData");
        p.write_field_begin("data1", ::fbthrift::TType::String, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::I32, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyData
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::I32, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::String, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_default(),
            data2: field_data2.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}



impl ::std::default::Default for InnerUnion {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for InnerUnion {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnion {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnion"
    }
}

impl<P> ::fbthrift::Serialize<P> for InnerUnion
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnion");
        match self {
            InnerUnion::innerOption(inner) => {
                p.write_field_begin("innerOption", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            InnerUnion::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for InnerUnion
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("innerOption", ::fbthrift::TType::String, 1),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::String, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(InnerUnion::innerOption(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "InnerUnion",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}


impl ::std::default::Default for MyUnion {
    fn default() -> Self {
        Self::UnknownField(-1)
    }
}

impl ::fbthrift::GetTType for MyUnion {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnion {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnion"
    }
}

impl<P> ::fbthrift::Serialize<P> for MyUnion
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnion");
        match self {
            MyUnion::option1(inner) => {
                p.write_field_begin("option1", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            MyUnion::option2(inner) => {
                p.write_field_begin("option2", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            MyUnion::option3(inner) => {
                p.write_field_begin("option3", ::fbthrift::TType::Struct, 3);
                ::fbthrift::Serialize::write(inner, p);
                p.write_field_end();
            }
            MyUnion::UnknownField(_) => {}
        }
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for MyUnion
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("option1", ::fbthrift::TType::String, 1),
            ::fbthrift::Field::new("option2", ::fbthrift::TType::I32, 2),
            ::fbthrift::Field::new("option3", ::fbthrift::TType::Struct, 3),
        ];
        let _ = p.read_struct_begin(|_| ())?;
        let mut once = false;
        let mut alt = ::std::option::Option::None;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32, once) {
                (::fbthrift::TType::Stop, _, _) => break,
                (::fbthrift::TType::String, 1, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(MyUnion::option1(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::I32, 2, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(MyUnion::option2(::fbthrift::Deserialize::read(p)?));
                }
                (::fbthrift::TType::Struct, 3, false) => {
                    once = true;
                    alt = ::std::option::Option::Some(MyUnion::option3(::fbthrift::Deserialize::read(p)?));
                }
                (fty, _, false) => p.skip(fty)?,
                (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                    format!(
                        "unwanted extra union {} field ty {:?} id {}",
                        "MyUnion",
                        badty,
                        badid,
                    ),
                ))),
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(alt.unwrap_or_default())
    }
}

#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStruct {
    fn default() -> Self {
        Self {
            boolVal: ::std::default::Default::default(),
            byteVal: ::std::default::Default::default(),
            i16Val: ::std::default::Default::default(),
            i32Val: ::std::default::Default::default(),
            i64Val: ::std::default::Default::default(),
            floatVal: ::std::default::Default::default(),
            doubleVal: ::std::default::Default::default(),
            stringVal: ::std::default::Default::default(),
            binaryVal: ::std::default::Default::default(),
            structVal: ::std::default::Default::default(),
            optBoolVal: ::std::option::Option::None,
            optByteVal: ::std::option::Option::None,
            optI16Val: ::std::option::Option::None,
            optI32Val: ::std::option::Option::None,
            optI64Val: ::std::option::Option::None,
            optFloatVal: ::std::option::Option::None,
            optDoubleVal: ::std::option::Option::None,
            optStringVal: ::std::option::Option::None,
            optBinaryVal: ::std::option::Option::None,
            optStructVal: ::std::option::Option::None,
            optListVal: ::std::option::Option::None,
            optSetVal: ::std::option::Option::None,
            optMapVal: ::std::option::Option::None,
            unionVal: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStruct {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStruct")
            .field("boolVal", &self.boolVal)
            .field("byteVal", &self.byteVal)
            .field("i16Val", &self.i16Val)
            .field("i32Val", &self.i32Val)
            .field("i64Val", &self.i64Val)
            .field("floatVal", &self.floatVal)
            .field("doubleVal", &self.doubleVal)
            .field("stringVal", &self.stringVal)
            .field("binaryVal", &self.binaryVal)
            .field("structVal", &self.structVal)
            .field("optBoolVal", &self.optBoolVal)
            .field("optByteVal", &self.optByteVal)
            .field("optI16Val", &self.optI16Val)
            .field("optI32Val", &self.optI32Val)
            .field("optI64Val", &self.optI64Val)
            .field("optFloatVal", &self.optFloatVal)
            .field("optDoubleVal", &self.optDoubleVal)
            .field("optStringVal", &self.optStringVal)
            .field("optBinaryVal", &self.optBinaryVal)
            .field("optStructVal", &self.optStructVal)
            .field("optListVal", &self.optListVal)
            .field("optSetVal", &self.optSetVal)
            .field("optMapVal", &self.optMapVal)
            .field("unionVal", &self.unionVal)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStruct {}
unsafe impl ::std::marker::Sync for self::MyStruct {}

impl ::fbthrift::GetTType for self::MyStruct {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStruct {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStruct"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStruct
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStruct");
        p.write_field_begin("boolVal", ::fbthrift::TType::Bool, 1);
        ::fbthrift::Serialize::write(&self.boolVal, p);
        p.write_field_end();
        p.write_field_begin("byteVal", ::fbthrift::TType::Byte, 2);
        ::fbthrift::Serialize::write(&self.byteVal, p);
        p.write_field_end();
        p.write_field_begin("i16Val", ::fbthrift::TType::I16, 3);
        ::fbthrift::Serialize::write(&self.i16Val, p);
        p.write_field_end();
        p.write_field_begin("i32Val", ::fbthrift::TType::I32, 4);
        ::fbthrift::Serialize::write(&self.i32Val, p);
        p.write_field_end();
        p.write_field_begin("i64Val", ::fbthrift::TType::I64, 5);
        ::fbthrift::Serialize::write(&self.i64Val, p);
        p.write_field_end();
        p.write_field_begin("floatVal", ::fbthrift::TType::Float, 6);
        ::fbthrift::Serialize::write(&self.floatVal, p);
        p.write_field_end();
        p.write_field_begin("doubleVal", ::fbthrift::TType::Double, 7);
        ::fbthrift::Serialize::write(&self.doubleVal, p);
        p.write_field_end();
        p.write_field_begin("stringVal", ::fbthrift::TType::String, 8);
        ::fbthrift::Serialize::write(&self.stringVal, p);
        p.write_field_end();
        p.write_field_begin("binaryVal", ::fbthrift::TType::String, 9);
        ::fbthrift::Serialize::write(&self.binaryVal, p);
        p.write_field_end();
        p.write_field_begin("structVal", ::fbthrift::TType::Struct, 10);
        ::fbthrift::Serialize::write(&self.structVal, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.optBoolVal {
            p.write_field_begin("optBoolVal", ::fbthrift::TType::Bool, 11);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optByteVal {
            p.write_field_begin("optByteVal", ::fbthrift::TType::Byte, 12);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI16Val {
            p.write_field_begin("optI16Val", ::fbthrift::TType::I16, 13);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI32Val {
            p.write_field_begin("optI32Val", ::fbthrift::TType::I32, 14);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optI64Val {
            p.write_field_begin("optI64Val", ::fbthrift::TType::I64, 15);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optFloatVal {
            p.write_field_begin("optFloatVal", ::fbthrift::TType::Float, 16);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optDoubleVal {
            p.write_field_begin("optDoubleVal", ::fbthrift::TType::Double, 17);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStringVal {
            p.write_field_begin("optStringVal", ::fbthrift::TType::String, 18);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optBinaryVal {
            p.write_field_begin("optBinaryVal", ::fbthrift::TType::String, 19);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optStructVal {
            p.write_field_begin("optStructVal", ::fbthrift::TType::Struct, 20);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optListVal {
            p.write_field_begin("optListVal", ::fbthrift::TType::List, 21);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optSetVal {
            p.write_field_begin("optSetVal", ::fbthrift::TType::Set, 22);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        if let ::std::option::Option::Some(some) = &self.optMapVal {
            p.write_field_begin("optMapVal", ::fbthrift::TType::Map, 23);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("unionVal", ::fbthrift::TType::Struct, 30);
        ::fbthrift::Serialize::write(&self.unionVal, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStruct
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("binaryVal", ::fbthrift::TType::String, 9),
            ::fbthrift::Field::new("boolVal", ::fbthrift::TType::Bool, 1),
            ::fbthrift::Field::new("byteVal", ::fbthrift::TType::Byte, 2),
            ::fbthrift::Field::new("doubleVal", ::fbthrift::TType::Double, 7),
            ::fbthrift::Field::new("floatVal", ::fbthrift::TType::Float, 6),
            ::fbthrift::Field::new("i16Val", ::fbthrift::TType::I16, 3),
            ::fbthrift::Field::new("i32Val", ::fbthrift::TType::I32, 4),
            ::fbthrift::Field::new("i64Val", ::fbthrift::TType::I64, 5),
            ::fbthrift::Field::new("optBinaryVal", ::fbthrift::TType::String, 19),
            ::fbthrift::Field::new("optBoolVal", ::fbthrift::TType::Bool, 11),
            ::fbthrift::Field::new("optByteVal", ::fbthrift::TType::Byte, 12),
            ::fbthrift::Field::new("optDoubleVal", ::fbthrift::TType::Double, 17),
            ::fbthrift::Field::new("optFloatVal", ::fbthrift::TType::Float, 16),
            ::fbthrift::Field::new("optI16Val", ::fbthrift::TType::I16, 13),
            ::fbthrift::Field::new("optI32Val", ::fbthrift::TType::I32, 14),
            ::fbthrift::Field::new("optI64Val", ::fbthrift::TType::I64, 15),
            ::fbthrift::Field::new("optListVal", ::fbthrift::TType::List, 21),
            ::fbthrift::Field::new("optMapVal", ::fbthrift::TType::Map, 23),
            ::fbthrift::Field::new("optSetVal", ::fbthrift::TType::Set, 22),
            ::fbthrift::Field::new("optStringVal", ::fbthrift::TType::String, 18),
            ::fbthrift::Field::new("optStructVal", ::fbthrift::TType::Struct, 20),
            ::fbthrift::Field::new("stringVal", ::fbthrift::TType::String, 8),
            ::fbthrift::Field::new("structVal", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("unionVal", ::fbthrift::TType::Struct, 30),
        ];
        let mut field_boolVal = ::std::option::Option::None;
        let mut field_byteVal = ::std::option::Option::None;
        let mut field_i16Val = ::std::option::Option::None;
        let mut field_i32Val = ::std::option::Option::None;
        let mut field_i64Val = ::std::option::Option::None;
        let mut field_floatVal = ::std::option::Option::None;
        let mut field_doubleVal = ::std::option::Option::None;
        let mut field_stringVal = ::std::option::Option::None;
        let mut field_binaryVal = ::std::option::Option::None;
        let mut field_structVal = ::std::option::Option::None;
        let mut field_optBoolVal = ::std::option::Option::None;
        let mut field_optByteVal = ::std::option::Option::None;
        let mut field_optI16Val = ::std::option::Option::None;
        let mut field_optI32Val = ::std::option::Option::None;
        let mut field_optI64Val = ::std::option::Option::None;
        let mut field_optFloatVal = ::std::option::Option::None;
        let mut field_optDoubleVal = ::std::option::Option::None;
        let mut field_optStringVal = ::std::option::Option::None;
        let mut field_optBinaryVal = ::std::option::Option::None;
        let mut field_optStructVal = ::std::option::Option::None;
        let mut field_optListVal = ::std::option::Option::None;
        let mut field_optSetVal = ::std::option::Option::None;
        let mut field_optMapVal = ::std::option::Option::None;
        let mut field_unionVal = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 1) => field_boolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 2) => field_byteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 3) => field_i16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 4) => field_i32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 5) => field_i64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, 6) => field_floatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 7) => field_doubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 8) => field_stringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 9) => field_binaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 10) => field_structVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 11) => field_optBoolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Byte, 12) => field_optByteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I16, 13) => field_optI16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I32, 14) => field_optI32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::I64, 15) => field_optI64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Float, 16) => field_optFloatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Double, 17) => field_optDoubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 18) => field_optStringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::String, 19) => field_optBinaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 20) => field_optStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 21) => field_optListVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 22) => field_optSetVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 23) => field_optMapVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 30) => field_unionVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            boolVal: field_boolVal.unwrap_or_default(),
            byteVal: field_byteVal.unwrap_or_default(),
            i16Val: field_i16Val.unwrap_or_default(),
            i32Val: field_i32Val.unwrap_or_default(),
            i64Val: field_i64Val.unwrap_or_default(),
            floatVal: field_floatVal.unwrap_or_default(),
            doubleVal: field_doubleVal.unwrap_or_default(),
            stringVal: field_stringVal.unwrap_or_default(),
            binaryVal: field_binaryVal.unwrap_or_default(),
            structVal: field_structVal.unwrap_or_default(),
            optBoolVal: field_optBoolVal,
            optByteVal: field_optByteVal,
            optI16Val: field_optI16Val,
            optI32Val: field_optI32Val,
            optI64Val: field_optI64Val,
            optFloatVal: field_optFloatVal,
            optDoubleVal: field_optDoubleVal,
            optStringVal: field_optStringVal,
            optBinaryVal: field_optBinaryVal,
            optStructVal: field_optStructVal,
            optListVal: field_optListVal,
            optSetVal: field_optSetVal,
            optMapVal: field_optMapVal,
            unionVal: field_unionVal.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataFieldPatch {
    fn default() -> Self {
        Self {
            data1: ::std::default::Default::default(),
            data2: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataFieldPatch")
            .field("data1", &self.data1)
            .field("data2", &self.data2)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyDataFieldPatch {}

impl ::fbthrift::GetTType for self::MyDataFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataFieldPatch");
        p.write_field_begin("data1", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.data1, p);
        p.write_field_end();
        p.write_field_begin("data2", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.data2, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("data1", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("data2", ::fbthrift::TType::Struct, 2),
        ];
        let mut field_data1 = ::std::option::Option::None;
        let mut field_data2 = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_data1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_data2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            data1: field_data1.unwrap_or_default(),
            data2: field_data2.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyDataPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyDataPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyDataPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyDataPatch {}
unsafe impl ::std::marker::Sync for self::MyDataPatch {}

impl ::fbthrift::GetTType for self::MyDataPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyDataPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyDataPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyDataPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyDataPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyDataPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyDataPatch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyDataPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyDataPatch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyDataPatch {}
unsafe impl ::std::marker::Sync for self::OptionalMyDataPatch {}

impl ::fbthrift::GetTType for self::OptionalMyDataPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyDataPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyDataPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyDataPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyDataPatch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyDataPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::InnerUnionFieldPatch {
    fn default() -> Self {
        Self {
            innerOption: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::InnerUnionFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("InnerUnionFieldPatch")
            .field("innerOption", &self.innerOption)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::InnerUnionFieldPatch {}
unsafe impl ::std::marker::Sync for self::InnerUnionFieldPatch {}

impl ::fbthrift::GetTType for self::InnerUnionFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnionFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnionFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::InnerUnionFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnionFieldPatch");
        p.write_field_begin("innerOption", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.innerOption, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::InnerUnionFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("innerOption", ::fbthrift::TType::Struct, 1),
        ];
        let mut field_innerOption = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_innerOption = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            innerOption: field_innerOption.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::InnerUnionPatch {
    fn default() -> Self {
        Self {
            assign: ::std::default::Default::default(),
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::InnerUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("InnerUnionPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::InnerUnionPatch {}
unsafe impl ::std::marker::Sync for self::InnerUnionPatch {}

impl ::fbthrift::GetTType for self::InnerUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::InnerUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/InnerUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::InnerUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("InnerUnionPatch");
        p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.assign, p);
        p.write_field_end();
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::InnerUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign.unwrap_or_default(),
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalInnerUnionPatch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalInnerUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalInnerUnionPatch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalInnerUnionPatch {}
unsafe impl ::std::marker::Sync for self::OptionalInnerUnionPatch {}

impl ::fbthrift::GetTType for self::OptionalInnerUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalInnerUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalInnerUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalInnerUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalInnerUnionPatch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalInnerUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyUnionFieldPatch {
    fn default() -> Self {
        Self {
            option1: ::std::default::Default::default(),
            option2: ::std::default::Default::default(),
            option3: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyUnionFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyUnionFieldPatch")
            .field("option1", &self.option1)
            .field("option2", &self.option2)
            .field("option3", &self.option3)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyUnionFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyUnionFieldPatch {}

impl ::fbthrift::GetTType for self::MyUnionFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnionFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnionFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyUnionFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnionFieldPatch");
        p.write_field_begin("option1", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.option1, p);
        p.write_field_end();
        p.write_field_begin("option2", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.option2, p);
        p.write_field_end();
        p.write_field_begin("option3", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.option3, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyUnionFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("option1", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("option2", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("option3", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_option1 = ::std::option::Option::None;
        let mut field_option2 = ::std::option::Option::None;
        let mut field_option3 = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_option1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_option2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_option3 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            option1: field_option1.unwrap_or_default(),
            option2: field_option2.unwrap_or_default(),
            option3: field_option3.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyUnionPatch {
    fn default() -> Self {
        Self {
            assign: ::std::default::Default::default(),
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyUnionPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyUnionPatch {}
unsafe impl ::std::marker::Sync for self::MyUnionPatch {}

impl ::fbthrift::GetTType for self::MyUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyUnionPatch");
        p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.assign, p);
        p.write_field_end();
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign.unwrap_or_default(),
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyUnionPatch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyUnionPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyUnionPatch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyUnionPatch {}
unsafe impl ::std::marker::Sync for self::OptionalMyUnionPatch {}

impl ::fbthrift::GetTType for self::OptionalMyUnionPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyUnionPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyUnionPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyUnionPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyUnionPatch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyUnionPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructFieldPatch {
    fn default() -> Self {
        Self {
            boolVal: ::std::default::Default::default(),
            byteVal: ::std::default::Default::default(),
            i16Val: ::std::default::Default::default(),
            i32Val: ::std::default::Default::default(),
            i64Val: ::std::default::Default::default(),
            floatVal: ::std::default::Default::default(),
            doubleVal: ::std::default::Default::default(),
            stringVal: ::std::default::Default::default(),
            binaryVal: ::std::default::Default::default(),
            structVal: ::std::default::Default::default(),
            optBoolVal: ::std::default::Default::default(),
            optByteVal: ::std::default::Default::default(),
            optI16Val: ::std::default::Default::default(),
            optI32Val: ::std::default::Default::default(),
            optI64Val: ::std::default::Default::default(),
            optFloatVal: ::std::default::Default::default(),
            optDoubleVal: ::std::default::Default::default(),
            optStringVal: ::std::default::Default::default(),
            optBinaryVal: ::std::default::Default::default(),
            optStructVal: ::std::default::Default::default(),
            optListVal: ::std::default::Default::default(),
            optSetVal: ::std::default::Default::default(),
            optMapVal: ::std::default::Default::default(),
            unionVal: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructFieldPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructFieldPatch")
            .field("boolVal", &self.boolVal)
            .field("byteVal", &self.byteVal)
            .field("i16Val", &self.i16Val)
            .field("i32Val", &self.i32Val)
            .field("i64Val", &self.i64Val)
            .field("floatVal", &self.floatVal)
            .field("doubleVal", &self.doubleVal)
            .field("stringVal", &self.stringVal)
            .field("binaryVal", &self.binaryVal)
            .field("structVal", &self.structVal)
            .field("optBoolVal", &self.optBoolVal)
            .field("optByteVal", &self.optByteVal)
            .field("optI16Val", &self.optI16Val)
            .field("optI32Val", &self.optI32Val)
            .field("optI64Val", &self.optI64Val)
            .field("optFloatVal", &self.optFloatVal)
            .field("optDoubleVal", &self.optDoubleVal)
            .field("optStringVal", &self.optStringVal)
            .field("optBinaryVal", &self.optBinaryVal)
            .field("optStructVal", &self.optStructVal)
            .field("optListVal", &self.optListVal)
            .field("optSetVal", &self.optSetVal)
            .field("optMapVal", &self.optMapVal)
            .field("unionVal", &self.unionVal)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructFieldPatch {}
unsafe impl ::std::marker::Sync for self::MyStructFieldPatch {}

impl ::fbthrift::GetTType for self::MyStructFieldPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructFieldPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructFieldPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructFieldPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructFieldPatch");
        p.write_field_begin("boolVal", ::fbthrift::TType::Struct, 1);
        ::fbthrift::Serialize::write(&self.boolVal, p);
        p.write_field_end();
        p.write_field_begin("byteVal", ::fbthrift::TType::Struct, 2);
        ::fbthrift::Serialize::write(&self.byteVal, p);
        p.write_field_end();
        p.write_field_begin("i16Val", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.i16Val, p);
        p.write_field_end();
        p.write_field_begin("i32Val", ::fbthrift::TType::Struct, 4);
        ::fbthrift::Serialize::write(&self.i32Val, p);
        p.write_field_end();
        p.write_field_begin("i64Val", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.i64Val, p);
        p.write_field_end();
        p.write_field_begin("floatVal", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.floatVal, p);
        p.write_field_end();
        p.write_field_begin("doubleVal", ::fbthrift::TType::Struct, 7);
        ::fbthrift::Serialize::write(&self.doubleVal, p);
        p.write_field_end();
        p.write_field_begin("stringVal", ::fbthrift::TType::Struct, 8);
        ::fbthrift::Serialize::write(&self.stringVal, p);
        p.write_field_end();
        p.write_field_begin("binaryVal", ::fbthrift::TType::Struct, 9);
        ::fbthrift::Serialize::write(&self.binaryVal, p);
        p.write_field_end();
        p.write_field_begin("structVal", ::fbthrift::TType::Struct, 10);
        ::fbthrift::Serialize::write(&self.structVal, p);
        p.write_field_end();
        p.write_field_begin("optBoolVal", ::fbthrift::TType::Struct, 11);
        ::fbthrift::Serialize::write(&self.optBoolVal, p);
        p.write_field_end();
        p.write_field_begin("optByteVal", ::fbthrift::TType::Struct, 12);
        ::fbthrift::Serialize::write(&self.optByteVal, p);
        p.write_field_end();
        p.write_field_begin("optI16Val", ::fbthrift::TType::Struct, 13);
        ::fbthrift::Serialize::write(&self.optI16Val, p);
        p.write_field_end();
        p.write_field_begin("optI32Val", ::fbthrift::TType::Struct, 14);
        ::fbthrift::Serialize::write(&self.optI32Val, p);
        p.write_field_end();
        p.write_field_begin("optI64Val", ::fbthrift::TType::Struct, 15);
        ::fbthrift::Serialize::write(&self.optI64Val, p);
        p.write_field_end();
        p.write_field_begin("optFloatVal", ::fbthrift::TType::Struct, 16);
        ::fbthrift::Serialize::write(&self.optFloatVal, p);
        p.write_field_end();
        p.write_field_begin("optDoubleVal", ::fbthrift::TType::Struct, 17);
        ::fbthrift::Serialize::write(&self.optDoubleVal, p);
        p.write_field_end();
        p.write_field_begin("optStringVal", ::fbthrift::TType::Struct, 18);
        ::fbthrift::Serialize::write(&self.optStringVal, p);
        p.write_field_end();
        p.write_field_begin("optBinaryVal", ::fbthrift::TType::Struct, 19);
        ::fbthrift::Serialize::write(&self.optBinaryVal, p);
        p.write_field_end();
        p.write_field_begin("optStructVal", ::fbthrift::TType::Struct, 20);
        ::fbthrift::Serialize::write(&self.optStructVal, p);
        p.write_field_end();
        p.write_field_begin("optListVal", ::fbthrift::TType::Struct, 21);
        ::fbthrift::Serialize::write(&self.optListVal, p);
        p.write_field_end();
        p.write_field_begin("optSetVal", ::fbthrift::TType::Struct, 22);
        ::fbthrift::Serialize::write(&self.optSetVal, p);
        p.write_field_end();
        p.write_field_begin("optMapVal", ::fbthrift::TType::Struct, 23);
        ::fbthrift::Serialize::write(&self.optMapVal, p);
        p.write_field_end();
        p.write_field_begin("unionVal", ::fbthrift::TType::Struct, 30);
        ::fbthrift::Serialize::write(&self.unionVal, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructFieldPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("binaryVal", ::fbthrift::TType::Struct, 9),
            ::fbthrift::Field::new("boolVal", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("byteVal", ::fbthrift::TType::Struct, 2),
            ::fbthrift::Field::new("doubleVal", ::fbthrift::TType::Struct, 7),
            ::fbthrift::Field::new("floatVal", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("i16Val", ::fbthrift::TType::Struct, 3),
            ::fbthrift::Field::new("i32Val", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("i64Val", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("optBinaryVal", ::fbthrift::TType::Struct, 19),
            ::fbthrift::Field::new("optBoolVal", ::fbthrift::TType::Struct, 11),
            ::fbthrift::Field::new("optByteVal", ::fbthrift::TType::Struct, 12),
            ::fbthrift::Field::new("optDoubleVal", ::fbthrift::TType::Struct, 17),
            ::fbthrift::Field::new("optFloatVal", ::fbthrift::TType::Struct, 16),
            ::fbthrift::Field::new("optI16Val", ::fbthrift::TType::Struct, 13),
            ::fbthrift::Field::new("optI32Val", ::fbthrift::TType::Struct, 14),
            ::fbthrift::Field::new("optI64Val", ::fbthrift::TType::Struct, 15),
            ::fbthrift::Field::new("optListVal", ::fbthrift::TType::Struct, 21),
            ::fbthrift::Field::new("optMapVal", ::fbthrift::TType::Struct, 23),
            ::fbthrift::Field::new("optSetVal", ::fbthrift::TType::Struct, 22),
            ::fbthrift::Field::new("optStringVal", ::fbthrift::TType::Struct, 18),
            ::fbthrift::Field::new("optStructVal", ::fbthrift::TType::Struct, 20),
            ::fbthrift::Field::new("stringVal", ::fbthrift::TType::Struct, 8),
            ::fbthrift::Field::new("structVal", ::fbthrift::TType::Struct, 10),
            ::fbthrift::Field::new("unionVal", ::fbthrift::TType::Struct, 30),
        ];
        let mut field_boolVal = ::std::option::Option::None;
        let mut field_byteVal = ::std::option::Option::None;
        let mut field_i16Val = ::std::option::Option::None;
        let mut field_i32Val = ::std::option::Option::None;
        let mut field_i64Val = ::std::option::Option::None;
        let mut field_floatVal = ::std::option::Option::None;
        let mut field_doubleVal = ::std::option::Option::None;
        let mut field_stringVal = ::std::option::Option::None;
        let mut field_binaryVal = ::std::option::Option::None;
        let mut field_structVal = ::std::option::Option::None;
        let mut field_optBoolVal = ::std::option::Option::None;
        let mut field_optByteVal = ::std::option::Option::None;
        let mut field_optI16Val = ::std::option::Option::None;
        let mut field_optI32Val = ::std::option::Option::None;
        let mut field_optI64Val = ::std::option::Option::None;
        let mut field_optFloatVal = ::std::option::Option::None;
        let mut field_optDoubleVal = ::std::option::Option::None;
        let mut field_optStringVal = ::std::option::Option::None;
        let mut field_optBinaryVal = ::std::option::Option::None;
        let mut field_optStructVal = ::std::option::Option::None;
        let mut field_optListVal = ::std::option::Option::None;
        let mut field_optSetVal = ::std::option::Option::None;
        let mut field_optMapVal = ::std::option::Option::None;
        let mut field_unionVal = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_boolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 2) => field_byteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_i16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_i32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_i64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_floatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 7) => field_doubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 8) => field_stringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 9) => field_binaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 10) => field_structVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 11) => field_optBoolVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 12) => field_optByteVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 13) => field_optI16Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 14) => field_optI32Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 15) => field_optI64Val = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 16) => field_optFloatVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 17) => field_optDoubleVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 18) => field_optStringVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 19) => field_optBinaryVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 20) => field_optStructVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 21) => field_optListVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 22) => field_optSetVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 23) => field_optMapVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 30) => field_unionVal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            boolVal: field_boolVal.unwrap_or_default(),
            byteVal: field_byteVal.unwrap_or_default(),
            i16Val: field_i16Val.unwrap_or_default(),
            i32Val: field_i32Val.unwrap_or_default(),
            i64Val: field_i64Val.unwrap_or_default(),
            floatVal: field_floatVal.unwrap_or_default(),
            doubleVal: field_doubleVal.unwrap_or_default(),
            stringVal: field_stringVal.unwrap_or_default(),
            binaryVal: field_binaryVal.unwrap_or_default(),
            structVal: field_structVal.unwrap_or_default(),
            optBoolVal: field_optBoolVal.unwrap_or_default(),
            optByteVal: field_optByteVal.unwrap_or_default(),
            optI16Val: field_optI16Val.unwrap_or_default(),
            optI32Val: field_optI32Val.unwrap_or_default(),
            optI64Val: field_optI64Val.unwrap_or_default(),
            optFloatVal: field_optFloatVal.unwrap_or_default(),
            optDoubleVal: field_optDoubleVal.unwrap_or_default(),
            optStringVal: field_optStringVal.unwrap_or_default(),
            optBinaryVal: field_optBinaryVal.unwrap_or_default(),
            optStructVal: field_optStructVal.unwrap_or_default(),
            optListVal: field_optListVal.unwrap_or_default(),
            optSetVal: field_optSetVal.unwrap_or_default(),
            optMapVal: field_optMapVal.unwrap_or_default(),
            unionVal: field_unionVal.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField21Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            prepend: ::std::default::Default::default(),
            append: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField21Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField21Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("prepend", &self.prepend)
            .field("append", &self.append)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField21Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField21Patch {}

impl ::fbthrift::GetTType for self::MyStructField21Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField21Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField21Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField21Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField21Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("prepend", ::fbthrift::TType::List, 8);
        ::fbthrift::Serialize::write(&self.prepend, p);
        p.write_field_end();
        p.write_field_begin("append", ::fbthrift::TType::List, 9);
        ::fbthrift::Serialize::write(&self.append, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField21Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("append", ::fbthrift::TType::List, 9),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::List, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("prepend", ::fbthrift::TType::List, 8),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_prepend = ::std::option::Option::None;
        let mut field_append = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::List, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 8) => field_prepend = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 9) => field_append = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            prepend: field_prepend.unwrap_or_default(),
            append: field_append.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyStructField21Patch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyStructField21Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyStructField21Patch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyStructField21Patch {}
unsafe impl ::std::marker::Sync for self::OptionalMyStructField21Patch {}

impl ::fbthrift::GetTType for self::OptionalMyStructField21Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyStructField21Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyStructField21Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyStructField21Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyStructField21Patch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyStructField21Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::List, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::List, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField22Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            remove: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField22Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField22Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("remove", &self.remove)
            .field("add", &self.add)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField22Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField22Patch {}

impl ::fbthrift::GetTType for self::MyStructField22Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField22Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField22Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField22Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField22Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Set, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("remove", ::fbthrift::TType::Set, 7);
        ::fbthrift::Serialize::write(&self.remove, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Set, 8);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField22Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Set, 8),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Set, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("remove", ::fbthrift::TType::Set, 7),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_remove = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Set, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 7) => field_remove = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 8) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            remove: field_remove.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyStructField22Patch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyStructField22Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyStructField22Patch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyStructField22Patch {}
unsafe impl ::std::marker::Sync for self::OptionalMyStructField22Patch {}

impl ::fbthrift::GetTType for self::OptionalMyStructField22Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyStructField22Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyStructField22Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyStructField22Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyStructField22Patch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Set, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyStructField22Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Set, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Set, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructField23Patch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            add: ::std::default::Default::default(),
            put: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructField23Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructField23Patch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("add", &self.add)
            .field("put", &self.put)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructField23Patch {}
unsafe impl ::std::marker::Sync for self::MyStructField23Patch {}

impl ::fbthrift::GetTType for self::MyStructField23Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructField23Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructField23Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructField23Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructField23Patch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("add", ::fbthrift::TType::Map, 5);
        ::fbthrift::Serialize::write(&self.add, p);
        p.write_field_end();
        p.write_field_begin("put", ::fbthrift::TType::Map, 9);
        ::fbthrift::Serialize::write(&self.put, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructField23Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("add", ::fbthrift::TType::Map, 5),
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Map, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("put", ::fbthrift::TType::Map, 9),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_add = ::std::option::Option::None;
        let mut field_put = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Map, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 5) => field_add = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 9) => field_put = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            add: field_add.unwrap_or_default(),
            put: field_put.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyStructField23Patch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyStructField23Patch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyStructField23Patch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyStructField23Patch {}
unsafe impl ::std::marker::Sync for self::OptionalMyStructField23Patch {}

impl ::fbthrift::GetTType for self::OptionalMyStructField23Patch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyStructField23Patch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyStructField23Patch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyStructField23Patch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyStructField23Patch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Map, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyStructField23Patch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Map, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Map, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::MyStructPatch {
    fn default() -> Self {
        Self {
            assign: ::std::option::Option::None,
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::default::Default::default(),
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::MyStructPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("MyStructPatch")
            .field("assign", &self.assign)
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::MyStructPatch {}
unsafe impl ::std::marker::Sync for self::MyStructPatch {}

impl ::fbthrift::GetTType for self::MyStructPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::MyStructPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/MyStructPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::MyStructPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("MyStructPatch");
        if let ::std::option::Option::Some(some) = &self.assign {
            p.write_field_begin("assign", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        p.write_field_begin("ensure", ::fbthrift::TType::Struct, 5);
        ::fbthrift::Serialize::write(&self.ensure, p);
        p.write_field_end();
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::MyStructPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("assign", ::fbthrift::TType::Struct, 1),
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 5),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_assign = ::std::option::Option::None;
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Struct, 1) => field_assign = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 5) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            assign: field_assign,
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure.unwrap_or_default(),
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


#[allow(clippy::derivable_impls)]
impl ::std::default::Default for self::OptionalMyStructPatch {
    fn default() -> Self {
        Self {
            clear: ::std::default::Default::default(),
            patchPrior: ::std::default::Default::default(),
            ensure: ::std::option::Option::None,
            patch: ::std::default::Default::default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        }
    }
}

impl ::std::fmt::Debug for self::OptionalMyStructPatch {
    fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        formatter
            .debug_struct("OptionalMyStructPatch")
            .field("clear", &self.clear)
            .field("patchPrior", &self.patchPrior)
            .field("ensure", &self.ensure)
            .field("patch", &self.patch)
            .finish()
    }
}

unsafe impl ::std::marker::Send for self::OptionalMyStructPatch {}
unsafe impl ::std::marker::Sync for self::OptionalMyStructPatch {}

impl ::fbthrift::GetTType for self::OptionalMyStructPatch {
    const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
}

impl ::fbthrift::GetUri for self::OptionalMyStructPatch {
    fn uri() -> &'static str {
        "test.dev/fixtures/patch/OptionalMyStructPatch"
    }
}

impl<P> ::fbthrift::Serialize<P> for self::OptionalMyStructPatch
where
    P: ::fbthrift::ProtocolWriter,
{
    fn write(&self, p: &mut P) {
        p.write_struct_begin("OptionalMyStructPatch");
        p.write_field_begin("clear", ::fbthrift::TType::Bool, 2);
        ::fbthrift::Serialize::write(&self.clear, p);
        p.write_field_end();
        p.write_field_begin("patchPrior", ::fbthrift::TType::Struct, 3);
        ::fbthrift::Serialize::write(&self.patchPrior, p);
        p.write_field_end();
        if let ::std::option::Option::Some(some) = &self.ensure {
            p.write_field_begin("ensure", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(some, p);
            p.write_field_end();
        }
        p.write_field_begin("patch", ::fbthrift::TType::Struct, 6);
        ::fbthrift::Serialize::write(&self.patch, p);
        p.write_field_end();
        p.write_field_stop();
        p.write_struct_end();
    }
}

impl<P> ::fbthrift::Deserialize<P> for self::OptionalMyStructPatch
where
    P: ::fbthrift::ProtocolReader,
{
    fn read(p: &mut P) -> ::anyhow::Result<Self> {
        static FIELDS: &[::fbthrift::Field] = &[
            ::fbthrift::Field::new("clear", ::fbthrift::TType::Bool, 2),
            ::fbthrift::Field::new("ensure", ::fbthrift::TType::Struct, 4),
            ::fbthrift::Field::new("patch", ::fbthrift::TType::Struct, 6),
            ::fbthrift::Field::new("patchPrior", ::fbthrift::TType::Struct, 3),
        ];
        let mut field_clear = ::std::option::Option::None;
        let mut field_patchPrior = ::std::option::Option::None;
        let mut field_ensure = ::std::option::Option::None;
        let mut field_patch = ::std::option::Option::None;
        let _ = p.read_struct_begin(|_| ())?;
        loop {
            let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
            match (fty, fid as ::std::primitive::i32) {
                (::fbthrift::TType::Stop, _) => break,
                (::fbthrift::TType::Bool, 2) => field_clear = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 3) => field_patchPrior = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 4) => field_ensure = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (::fbthrift::TType::Struct, 6) => field_patch = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                (fty, _) => p.skip(fty)?,
            }
            p.read_field_end()?;
        }
        p.read_struct_end()?;
        ::std::result::Result::Ok(Self {
            clear: field_clear.unwrap_or_default(),
            patchPrior: field_patchPrior.unwrap_or_default(),
            ensure: field_ensure,
            patch: field_patch.unwrap_or_default(),
            _dot_dot_Default_default: self::dot_dot::OtherFields(()),
        })
    }
}


mod dot_dot {
    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct OtherFields(pub(crate) ());

    #[allow(dead_code)] // if serde isn't being used
    pub(super) fn default_for_serde_deserialize() -> OtherFields {
        OtherFields(())
    }
}
