<?hh
/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

namespace thrift\op;

/**
 * The meaning of the patch op field ids, in all properly formulated patch
 * definitions.
 * 
 * Patch field ids are interpreted at runtime, as a dynamic patch protocol,
 * without any additional schema derived from IDL patch definitions.
 * 
 * Original thrift enum:-
 * PatchOp
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/PatchOp'))>>
enum PatchOp: int {
  /**
   * Set the value. Supersedes all other ops.
   */
  Assign = 1;
  /**
   * Set to the intrinsic default (which might be 'unset').
   */
  Clear = 2;
  /**
   * Apply a field/value-wise patch.
   */
  Patch = 3;
  /**
   * Set to the given default, if not already of the same type.
   * 
   * In a dynamic context this means the ids/values must match exactly:
   *     ensureUnion(Object ensureUnion, Object value) {
   *       if (ensureUnion.ids() != value.ids())
   *         value = ensureUnion;
   *     }
   */
  EnsureUnion = 4;
  /**
   *  * A pair-wise ensure operation.
   *  *
   *  * For maps this is an "add if key not present".
   *  *
   *  * For structs, this can be use to encodes the default state of the fields, based
   *  * on thier qualifier type:
   *  * - optional: absent
   *  * - terse: intrinsic default
   *  * - fill: custom default
   * *
   */
  EnsureStruct = 5;
  /**
   * Apply a field/value-wise patch after all other ops.
   */
  PatchAfter = 6;
  /**
   * Remove if present.
   * 
   * A key/value-based remove for set/list, 'saturating subtract' for
   * numeric/'counting' types, and 'remove by key' for maps.
   */
  Remove = 7;
  /**
   * Add/prepend a value,with the following semantics:
   * - Key/value-based 'add' for set;
   * - 'prepend' for list, string, or binary; and
   * - saturating 'add' for numeric/counting types.
   */
  Add = 8;
  /**
   * Put/append/invert a value, with the following semantics:
   * - Identical to 'add' for set;
   * - 'update or insert' for maps;
   * - 'append' for list, string or binary; and
   * - 'invert' for boolean.
   */
  Put = 9;
  Unspecified = 0;
}

class PatchOp_TEnumStaticMetadata implements \IThriftEnumStaticMetadata {
  public static function getEnumMetadata()[]: \tmeta_ThriftEnum {
    return \tmeta_ThriftEnum::fromShape(
      shape(
        "name" => "patch.PatchOp",
        "elements" => dict[
          1 => "Assign",
          2 => "Clear",
          3 => "Patch",
          4 => "EnsureUnion",
          5 => "EnsureStruct",
          6 => "PatchAfter",
          7 => "Remove",
          8 => "Add",
          9 => "Put",
          0 => "Unspecified",
        ],
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TEnumAnnotations {
    return shape(
      'enum' => dict[
        '\thrift\annotation\GenDefaultEnumValue' => \thrift\annotation\GenDefaultEnumValue::fromShape(
          shape(
          )
        ),
      ],
      'constants' => dict[
      ],
    );
  }
}

/**
 * An annotation that indicates a patch representation
 * should be generated for the associated definition.
 *
 * Original thrift struct:-
 * GeneratePatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/GeneratePatch'))>>
class GeneratePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
    ...
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'GeneratePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.GeneratePatch",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\Program' => \thrift\annotation\Program::fromShape(
          shape(
          )
        ),
        '\thrift\annotation\Structured' => \thrift\annotation\Structured::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * Original thrift struct:-
 * GenerateOptionalPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/GenerateOptionalPatch'))>>
class GenerateOptionalPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
  ];
  const dict<string, int> FIELDMAP = dict[
  ];

  const type TConstructorShape = shape(
  );

  const type TShape = shape(
    ...
  );
  const int STRUCTURAL_ID = 957977401221134810;

  public function __construct()[] {
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
    );
  }

  public function getName()[]: string {
    return 'GenerateOptionalPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.GenerateOptionalPatch",
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\Struct' => \thrift\annotation\Struct::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

  }

}

/**
 * A patch for a boolean value.
 *
 * Original thrift struct:-
 * BoolPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/BoolPatch'))>>
class BoolPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::BOOL,
    ),
    9 => shape(
      'var' => 'invert',
      'type' => \TType::BOOL,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'invert' => 9,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?bool,
    ?'invert' => ?bool,
  );

  const type TShape = shape(
    ?'assign' => ?bool,
    'invert' => bool,
    ...
  );
  const int STRUCTURAL_ID = 8755251121021042450;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: bool assign
   */
  public ?bool $assign;
  /**
   * If the bool value should be inverted.
   * 
   * Original thrift field:-
   * 9: bool invert
   */
  public bool $invert;

  public function __construct(?bool $assign = null, ?bool $invert = null)[] {
    $this->assign = $assign;
    $this->invert = $invert ?? false;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'invert'),
    );
  }

  public function getName()[]: string {
    return 'BoolPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BoolPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 9,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "invert",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::BoolPatchAdapter",
            "underlyingName" => "BoolPatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['invert'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'invert' => $this->invert,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['assign']);
    }
    if (idx($parsed, 'invert') !== null) {
      $this->invert = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['invert']);
    }
  }

}

/**
 * A patch for an 8-bit integer value.
 *
 * Original thrift struct:-
 * BytePatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/BytePatch'))>>
class BytePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::BYTE,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::BYTE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 2211838474069143581;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: byte assign
   */
  public ?int $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: byte add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'BytePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BytePatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "BytePatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['assign']);
      if ($_tmp0 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['add']);
      if ($_tmp1 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }
  }

}

/**
 * A patch for a 16-bit integer value.
 *
 * Original thrift struct:-
 * I16Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/I16Patch'))>>
class I16Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I16,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::I16,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 5266422431097931584;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: i16 assign
   */
  public ?int $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: i16 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I16Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I16Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "I16PatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['assign']);
      if ($_tmp0 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['add']);
      if ($_tmp1 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }
  }

}

/**
 * A patch for a 32-bit integer value.
 *
 * Original thrift struct:-
 * I32Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/I32Patch'))>>
class I32Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I32,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::I32,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 3653733632732906564;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: i32 assign
   */
  public ?int $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: i32 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I32Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I32Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "I32PatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $_tmp0 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['assign']);
      if ($_tmp0 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->assign = (int)$_tmp0;
      }
    }
    if (idx($parsed, 'add') !== null) {
      $_tmp1 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['add']);
      if ($_tmp1 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->add = (int)$_tmp1;
      }
    }
  }

}

/**
 * A patch for a 64-bit integer value.
 *
 * Original thrift struct:-
 * I64Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/I64Patch'))>>
class I64Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::I64,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::I64,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?int,
    ?'add' => ?int,
  );

  const type TShape = shape(
    ?'assign' => ?int,
    'add' => int,
    ...
  );
  const int STRUCTURAL_ID = 6370961107317493914;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: i64 assign
   */
  public ?int $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: i64 add
   */
  public int $add;

  public function __construct(?int $assign = null, ?int $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'I64Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.I64Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "I64PatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['assign']);
    }
    if (idx($parsed, 'add') !== null) {
      $this->add = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['add']);
    }
  }

}

/**
 * A patch for a 32-bit floating point value.
 *
 * Original thrift struct:-
 * FloatPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/FloatPatch'))>>
class FloatPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::FLOAT,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::FLOAT,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?float,
    ?'add' => ?float,
  );

  const type TShape = shape(
    ?'assign' => ?float,
    'add' => float,
    ...
  );
  const int STRUCTURAL_ID = 2446293251068622176;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: float assign
   */
  public ?float $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: float add
   */
  public float $add;

  public function __construct(?float $assign = null, ?float $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0.0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'FloatPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.FloatPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "FloatPatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['assign']);
    }
    if (idx($parsed, 'add') !== null) {
      $this->add = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['add']);
    }
  }

}

/**
 * A patch for an 64-bit floating point value.
 *
 * Original thrift struct:-
 * DoublePatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/DoublePatch'))>>
class DoublePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::DOUBLE,
    ),
    8 => shape(
      'var' => 'add',
      'type' => \TType::DOUBLE,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'add' => 8,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?float,
    ?'add' => ?float,
  );

  const type TShape = shape(
    ?'assign' => ?float,
    'add' => float,
    ...
  );
  const int STRUCTURAL_ID = 5398809695762940407;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: double assign
   */
  public ?float $assign;
  /**
   * Add to a given value.
   * 
   * Original thrift field:-
   * 8: double add
   */
  public float $add;

  public function __construct(?float $assign = null, ?float $add = null)[] {
    $this->assign = $assign;
    $this->add = $add ?? 0.0;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'add'),
    );
  }

  public function getName()[]: string {
    return 'DoublePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.DoublePatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "add",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
            "underlyingName" => "DoublePatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['add'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'add' => $this->add,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['assign']);
    }
    if (idx($parsed, 'add') !== null) {
      $this->add = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['add']);
    }
  }

}

/**
 * A patch for a string value.
 *
 * Original thrift struct:-
 * StringPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/StringPatch'))>>
class StringPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::STRING,
    ),
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    8 => shape(
      'var' => 'prepend',
      'type' => \TType::STRING,
    ),
    9 => shape(
      'var' => 'append',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
    'clear' => 2,
    'prepend' => 8,
    'append' => 9,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?string,
    ?'clear' => ?bool,
    ?'prepend' => ?string,
    ?'append' => ?string,
  );

  const type TShape = shape(
    ?'assign' => ?string,
    'clear' => bool,
    'prepend' => string,
    'append' => string,
    ...
  );
  const int STRUCTURAL_ID = 5212135444748250232;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: string assign
   */
  public ?string $assign;
  /**
   * Clear a given string.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Prepend to a given value.
   * 
   * Original thrift field:-
   * 8: string prepend
   */
  public string $prepend;
  /**
   * Append to a given value.
   * 
   * Original thrift field:-
   * 9: string append
   */
  public string $append;

  public function __construct(?string $assign = null, ?bool $clear = null, ?string $prepend = null, ?string $append = null)[] {
    $this->assign = $assign;
    $this->clear = $clear ?? false;
    $this->prepend = $prepend ?? '';
    $this->append = $append ?? '';
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'prepend'),
      Shapes::idx($shape, 'append'),
    );
  }

  public function getName()[]: string {
    return 'StringPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.StringPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 8,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "prepend",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 9,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "append",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::StringPatchAdapter",
            "underlyingName" => "StringPatchStruct",
            "extraNamespace" => "",
          )
        ),
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
      $shape['clear'],
      $shape['prepend'],
      $shape['append'],
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
      'clear' => $this->clear,
      'prepend' => $this->prepend,
      'append' => $this->append,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['assign']);
    }
    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'prepend') !== null) {
      $this->prepend = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['prepend']);
    }
    if (idx($parsed, 'append') !== null) {
      $this->append = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['append']);
    }
  }

}

/**
 * A patch for a binary value.
 *
 * Original thrift struct:-
 * BinaryPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/BinaryPatch'))>>
class BinaryPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    1 => shape(
      'var' => 'assign',
      'type' => \TType::STRING,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'assign' => 1,
  ];

  const type TConstructorShape = shape(
    ?'assign' => ?string,
  );

  const type TShape = shape(
    ?'assign' => ?string,
    ...
  );
  const int STRUCTURAL_ID = 6677740157096629654;
  /**
   * Assign to a given value.
   * 
   * If set, all other patch operations are ignored.
   * 
   * Original thrift field:-
   * 1: binary assign
   */
  public ?string $assign;

  public function __construct(?string $assign = null)[] {
    $this->assign = $assign;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
    );
  }

  public function getName()[]: string {
    return 'BinaryPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.BinaryPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 1,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "assign",
              "is_optional" => true,
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
          shape(
          )
        ),
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::AssignPatchAdapter",
            "underlyingName" => "BinaryPatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'assign'),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'assign' => $this->assign,
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'assign') !== null) {
      $this->assign = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['assign']);
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalBoolPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalBoolPatch'))>>
class OptionalBoolPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BoolPatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::BOOL,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BoolPatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\BoolPatch,
    ?'ensure' => ?bool,
    ?'patch' => ?\thrift\op\BoolPatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\BoolPatch::TShape,
    ?'ensure' => ?bool,
    ?'patch' => ?\thrift\op\BoolPatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 5970728508838259493;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.BoolPatch patchPrior
   */
  public ?\thrift\op\BoolPatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: bool ensure
   */
  public ?bool $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.BoolPatch patch
   */
  public ?\thrift\op\BoolPatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\BoolPatch $patchPrior = null, ?bool $ensure = null, ?\thrift\op\BoolPatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalBoolPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalBoolPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BoolPatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BoolPatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalBoolPatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::BoolPatchAdapter",
                "underlyingName" => "BoolPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::BoolPatchAdapter",
                "underlyingName" => "BoolPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\BoolPatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\BoolPatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BoolPatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\BoolPatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BoolPatch>($parsed['patch']));
      $_tmp3 = \thrift\op\BoolPatch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalBytePatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalBytePatch'))>>
class OptionalBytePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BytePatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::BYTE,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BytePatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\BytePatch,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\BytePatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\BytePatch::TShape,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\BytePatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 4178832588145864018;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.BytePatch patchPrior
   */
  public ?\thrift\op\BytePatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: byte ensure
   */
  public ?int $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.BytePatch patch
   */
  public ?\thrift\op\BytePatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\BytePatch $patchPrior = null, ?int $ensure = null, ?\thrift\op\BytePatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalBytePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalBytePatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BytePatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BYTE_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BytePatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalBytePatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "BytePatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "BytePatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\BytePatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\BytePatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BytePatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\BytePatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['ensure']);
      if ($_tmp2 > 0x7f) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->ensure = (int)$_tmp2;
      }
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp3 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BytePatch>($parsed['patch']));
      $_tmp4 = \thrift\op\BytePatch::withDefaultValues();
      $_tmp4->readFromJson($_tmp3);
      $this->patch = $_tmp4;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalI16Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalI16Patch'))>>
class OptionalI16Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I16Patch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::I16,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I16Patch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\I16Patch,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I16Patch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\I16Patch::TShape,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I16Patch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 619389808295037415;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.I16Patch patchPrior
   */
  public ?\thrift\op\I16Patch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: i16 ensure
   */
  public ?int $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.I16Patch patch
   */
  public ?\thrift\op\I16Patch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\I16Patch $patchPrior = null, ?int $ensure = null, ?\thrift\op\I16Patch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalI16Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalI16Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I16Patch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I16_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I16Patch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalI16PatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I16PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I16PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\I16Patch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\I16Patch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I16Patch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\I16Patch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['ensure']);
      if ($_tmp2 > 0x7fff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->ensure = (int)$_tmp2;
      }
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp3 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I16Patch>($parsed['patch']));
      $_tmp4 = \thrift\op\I16Patch::withDefaultValues();
      $_tmp4->readFromJson($_tmp3);
      $this->patch = $_tmp4;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalI32Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalI32Patch'))>>
class OptionalI32Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I32Patch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::I32,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I32Patch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\I32Patch,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I32Patch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\I32Patch::TShape,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I32Patch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 705741916380779985;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.I32Patch patchPrior
   */
  public ?\thrift\op\I32Patch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: i32 ensure
   */
  public ?int $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.I32Patch patch
   */
  public ?\thrift\op\I32Patch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\I32Patch $patchPrior = null, ?int $ensure = null, ?\thrift\op\I32Patch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalI32Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalI32Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I32Patch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I32_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I32Patch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalI32PatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I32PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I32PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\I32Patch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\I32Patch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I32Patch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\I32Patch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $_tmp2 = (int)HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['ensure']);
      if ($_tmp2 > 0x7fffffff) {
        throw new \TProtocolException("number exceeds limit in field");
      } else {
        $this->ensure = (int)$_tmp2;
      }
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp3 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I32Patch>($parsed['patch']));
      $_tmp4 = \thrift\op\I32Patch::withDefaultValues();
      $_tmp4->readFromJson($_tmp3);
      $this->patch = $_tmp4;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalI64Patch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalI64Patch'))>>
class OptionalI64Patch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I64Patch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::I64,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\I64Patch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\I64Patch,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I64Patch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\I64Patch::TShape,
    ?'ensure' => ?int,
    ?'patch' => ?\thrift\op\I64Patch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 8723392942656751661;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.I64Patch patchPrior
   */
  public ?\thrift\op\I64Patch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: i64 ensure
   */
  public ?int $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.I64Patch patch
   */
  public ?\thrift\op\I64Patch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\I64Patch $patchPrior = null, ?int $ensure = null, ?\thrift\op\I64Patch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalI64Patch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalI64Patch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I64Patch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_I64_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.I64Patch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalI64PatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I64PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "I64PatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\I64Patch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\I64Patch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I64Patch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\I64Patch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, int>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\I64Patch>($parsed['patch']));
      $_tmp3 = \thrift\op\I64Patch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalFloatPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalFloatPatch'))>>
class OptionalFloatPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\FloatPatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::FLOAT,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\FloatPatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\FloatPatch,
    ?'ensure' => ?float,
    ?'patch' => ?\thrift\op\FloatPatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\FloatPatch::TShape,
    ?'ensure' => ?float,
    ?'patch' => ?\thrift\op\FloatPatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 3190125567736108403;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.FloatPatch patchPrior
   */
  public ?\thrift\op\FloatPatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: float ensure
   */
  public ?float $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.FloatPatch patch
   */
  public ?\thrift\op\FloatPatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\FloatPatch $patchPrior = null, ?float $ensure = null, ?\thrift\op\FloatPatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalFloatPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalFloatPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.FloatPatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_FLOAT_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.FloatPatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalFloatPatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "FloatPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "FloatPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\FloatPatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\FloatPatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\FloatPatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\FloatPatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\FloatPatch>($parsed['patch']));
      $_tmp3 = \thrift\op\FloatPatch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalDoublePatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalDoublePatch'))>>
class OptionalDoublePatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\DoublePatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::DOUBLE,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\DoublePatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\DoublePatch,
    ?'ensure' => ?float,
    ?'patch' => ?\thrift\op\DoublePatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\DoublePatch::TShape,
    ?'ensure' => ?float,
    ?'patch' => ?\thrift\op\DoublePatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 559246202549086289;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.DoublePatch patchPrior
   */
  public ?\thrift\op\DoublePatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: double ensure
   */
  public ?float $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.DoublePatch patch
   */
  public ?\thrift\op\DoublePatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\DoublePatch $patchPrior = null, ?float $ensure = null, ?\thrift\op\DoublePatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalDoublePatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalDoublePatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.DoublePatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_DOUBLE_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.DoublePatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalDoublePatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "DoublePatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::NumberPatchAdapter",
                "underlyingName" => "DoublePatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\DoublePatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\DoublePatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\DoublePatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\DoublePatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, float>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\DoublePatch>($parsed['patch']));
      $_tmp3 = \thrift\op\DoublePatch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalStringPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalStringPatch'))>>
class OptionalStringPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\StringPatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::STRING,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\StringPatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\StringPatch,
    ?'ensure' => ?string,
    ?'patch' => ?\thrift\op\StringPatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\StringPatch::TShape,
    ?'ensure' => ?string,
    ?'patch' => ?\thrift\op\StringPatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 9145296182371217249;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.StringPatch patchPrior
   */
  public ?\thrift\op\StringPatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: string ensure
   */
  public ?string $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.StringPatch patch
   */
  public ?\thrift\op\StringPatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\StringPatch $patchPrior = null, ?string $ensure = null, ?\thrift\op\StringPatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalStringPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalStringPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.StringPatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_STRING_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.StringPatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalStringPatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::StringPatchAdapter",
                "underlyingName" => "StringPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::StringPatchAdapter",
                "underlyingName" => "StringPatchStruct",
                "extraNamespace" => "",
              )
            ),
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\StringPatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\StringPatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\StringPatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\StringPatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\StringPatch>($parsed['patch']));
      $_tmp3 = \thrift\op\StringPatch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

/**
 * Original thrift struct:-
 * OptionalBinaryPatch
 */
<<\ThriftTypeInfo(shape('uri' => 'facebook.com/thrift/op/OptionalBinaryPatch'))>>
class OptionalBinaryPatch implements \IThriftSyncStruct, \IThriftShapishSyncStruct {
  use \ThriftSerializationTrait;

  const dict<int, this::TFieldSpec> SPEC = dict[
    2 => shape(
      'var' => 'clear',
      'type' => \TType::BOOL,
    ),
    3 => shape(
      'var' => 'patchPrior',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BinaryPatch::class,
    ),
    4 => shape(
      'var' => 'ensure',
      'type' => \TType::STRING,
    ),
    6 => shape(
      'var' => 'patch',
      'type' => \TType::STRUCT,
      'class' => \thrift\op\BinaryPatch::class,
    ),
  ];
  const dict<string, int> FIELDMAP = dict[
    'clear' => 2,
    'patchPrior' => 3,
    'ensure' => 4,
    'patch' => 6,
  ];

  const type TConstructorShape = shape(
    ?'clear' => ?bool,
    ?'patchPrior' => ?\thrift\op\BinaryPatch,
    ?'ensure' => ?string,
    ?'patch' => ?\thrift\op\BinaryPatch,
  );

  const type TShape = shape(
    'clear' => bool,
    ?'patchPrior' => ?\thrift\op\BinaryPatch::TShape,
    ?'ensure' => ?string,
    ?'patch' => ?\thrift\op\BinaryPatch::TShape,
    ...
  );
  const int STRUCTURAL_ID = 2891389540098318350;
  /**
   * Clears any set value. Applies first.
   * 
   * Original thrift field:-
   * 2: bool clear
   */
  public bool $clear;
  /**
   * Patches any previously set values. Applies second.
   * 
   * Original thrift field:-
   * 3: struct patch.BinaryPatch patchPrior
   */
  public ?\thrift\op\BinaryPatch $patchPrior;
  /**
   * Assigns the value, if not already set to the same field. Applies third.
   * 
   * Original thrift field:-
   * 4: binary ensure
   */
  public ?string $ensure;
  /**
   * Patches any set value, including newly set values. Applies last.
   * 
   * Original thrift field:-
   * 6: struct patch.BinaryPatch patch
   */
  public ?\thrift\op\BinaryPatch $patch;

  public function __construct(?bool $clear = null, ?\thrift\op\BinaryPatch $patchPrior = null, ?string $ensure = null, ?\thrift\op\BinaryPatch $patch = null)[] {
    $this->clear = $clear ?? false;
    $this->patchPrior = $patchPrior;
    $this->ensure = $ensure;
    $this->patch = $patch;
  }

  public static function withDefaultValues()[]: this {
    return new static();
  }

  public static function fromShape(self::TConstructorShape $shape)[]: this {
    return new static(
      Shapes::idx($shape, 'clear'),
      Shapes::idx($shape, 'patchPrior'),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch'),
    );
  }

  public function getName()[]: string {
    return 'OptionalBinaryPatch';
  }

  public static function getStructMetadata()[]: \tmeta_ThriftStruct {
    return \tmeta_ThriftStruct::fromShape(
      shape(
        "name" => "patch.OptionalBinaryPatch",
        "fields" => vec[
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 2,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BOOL_TYPE,
                )
              ),
              "name" => "clear",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 3,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BinaryPatch",
                    )
                  ),
                )
              ),
              "name" => "patchPrior",
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 4,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_primitive" => \tmeta_ThriftPrimitiveType::THRIFT_BINARY_TYPE,
                )
              ),
              "name" => "ensure",
              "is_optional" => true,
            )
          ),
          \tmeta_ThriftField::fromShape(
            shape(
              "id" => 6,
              "type" => \tmeta_ThriftType::fromShape(
                shape(
                  "t_struct" => \tmeta_ThriftStructType::fromShape(
                    shape(
                      "name" => "patch.BinaryPatch",
                    )
                  ),
                )
              ),
              "name" => "patch",
            )
          ),
        ],
        "is_union" => false,
      )
    );
  }

  public static function getAllStructuredAnnotations()[write_props]: \TStructAnnotations {
    return shape(
      'struct' => dict[
        '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
          shape(
            "name" => "::apache::thrift::op::detail::OptionalPatchAdapter",
            "underlyingName" => "OptionalBinaryPatchStruct",
            "extraNamespace" => "",
          )
        ),
      ],
      'fields' => dict[
        'patchPrior' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::AssignPatchAdapter",
                "underlyingName" => "BinaryPatchStruct",
                "extraNamespace" => "",
              )
            ),
          ],
        ),
        'patch' => shape(
          'field' => dict[],
          'type' => dict[
            '\thrift\op\GenerateOptionalPatch' => \thrift\op\GenerateOptionalPatch::fromShape(
              shape(
              )
            ),
            '\thrift\annotation\cpp\Adapter' => \thrift\annotation\cpp\Adapter::fromShape(
              shape(
                "name" => "::apache::thrift::op::detail::AssignPatchAdapter",
                "underlyingName" => "BinaryPatchStruct",
                "extraNamespace" => "",
              )
            ),
          ],
        ),
      ],
    );
  }

  public static function __fromShape(self::TShape $shape)[]: this {
    return new static(
      $shape['clear'],
      Shapes::idx($shape, 'patchPrior') === null ? null : (\thrift\op\BinaryPatch::__fromShape($shape['patchPrior'])),
      Shapes::idx($shape, 'ensure'),
      Shapes::idx($shape, 'patch') === null ? null : (\thrift\op\BinaryPatch::__fromShape($shape['patch'])),
    );
  }

  public function __toShape()[]: self::TShape {
    return shape(
      'clear' => $this->clear,
      'patchPrior' => $this->patchPrior?->__toShape(),
      'ensure' => $this->ensure,
      'patch' => $this->patch?->__toShape(),
    );
  }
  public function getInstanceKey()[write_props]: string {
    return \TCompactSerializer::serialize($this);
  }

  public function readFromJson(string $jsonText): void {
    $parsed = json_decode($jsonText, true);

    if ($parsed === null || !($parsed is KeyedContainer<_, _>)) {
      throw new \TProtocolException("Cannot parse the given json string.");
    }

    if (idx($parsed, 'clear') !== null) {
      $this->clear = HH\FIXME\UNSAFE_CAST<mixed, bool>($parsed['clear']);
    }
    if (idx($parsed, 'patchPrior') !== null) {
      $_tmp0 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BinaryPatch>($parsed['patchPrior']));
      $_tmp1 = \thrift\op\BinaryPatch::withDefaultValues();
      $_tmp1->readFromJson($_tmp0);
      $this->patchPrior = $_tmp1;
    }
    if (idx($parsed, 'ensure') !== null) {
      $this->ensure = HH\FIXME\UNSAFE_CAST<mixed, string>($parsed['ensure']);
    }
    if (idx($parsed, 'patch') !== null) {
      $_tmp2 = \json_encode(HH\FIXME\UNSAFE_CAST<mixed, \thrift\op\BinaryPatch>($parsed['patch']));
      $_tmp3 = \thrift\op\BinaryPatch::withDefaultValues();
      $_tmp3->readFromJson($_tmp2);
      $this->patch = $_tmp3;
    }
  }

}

