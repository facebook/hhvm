/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/visitation/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.h"
#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_types.tcc"

#include <thrift/lib/cpp2/gen/module_types_cpp.h>

#include "thrift/compiler/test/fixtures/visitation/gen-cpp2/module_data.h"


namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::enum1 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum1>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum1>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum1>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::enum2 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum2>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum2>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum2>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::enum3 const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum3>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum3>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum3>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::enum_with_special_names const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::enum_with_special_names>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::enum_with_special_names>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}

}} // apache::thrift


namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::union1::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union1::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union1::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union1::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union1>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union1::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union1>::name;
}

void union1::__fbthrift_destruct() {
  switch(getType()) {
    case Type::__EMPTY__:
      break;
    case Type::ui:
      ::std::destroy_at(::std::addressof(value_.ui));
      break;
    case Type::ud:
      ::std::destroy_at(::std::addressof(value_.ud));
      break;
    case Type::us:
      ::std::destroy_at(::std::addressof(value_.us));
      break;
    case Type::ue:
      ::std::destroy_at(::std::addressof(value_.ue));
      break;
    default:
      assert(false);
      break;
  }
}

void union1::__fbthrift_clear() {
  __fbthrift_destruct();
  type_ = folly::to_underlying(Type::__EMPTY__);
}

  union1::~union1() {
    __fbthrift_destruct();
  }

bool union1::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}
  union1::union1(const union1& rhs)
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        return;
      case Type::ui:
        set_ui(rhs.value_.ui);
        break;
      case Type::ud:
        set_ud(rhs.value_.ud);
        break;
      case Type::us:
        set_us(rhs.value_.us);
        break;
      case Type::ue:
        set_ue(rhs.value_.ue);
        break;
      default:
        assert(false);
    }
  }

    union1&union1::operator=(const union1& rhs) {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        __fbthrift_clear();
        return *this;
      case Type::ui:
        set_ui(rhs.value_.ui);
        break;
      case Type::ud:
        set_ud(rhs.value_.ud);
        break;
      case Type::us:
        set_us(rhs.value_.us);
        break;
      case Type::ue:
        set_ue(rhs.value_.ue);
        break;
      default:
        __fbthrift_clear();
        assert(false);
    }
    return *this;
  }


bool union1::operator==(const union1& rhs) const {
  return ::apache::thrift::op::detail::UnionEquality{}(*this, rhs);
}

bool union1::operator<([[maybe_unused]] const union1& rhs) const {
  return ::apache::thrift::op::detail::UnionLessThan{}(*this, rhs);
}

void swap(union1& a, union1& b) {
  union1 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::union2::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union2::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union2::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union2>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union2::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union2>::name;
}

void union2::__fbthrift_destruct() {
  switch(getType()) {
    case Type::__EMPTY__:
      break;
    case Type::ui_2:
      ::std::destroy_at(::std::addressof(value_.ui_2));
      break;
    case Type::ud_2:
      ::std::destroy_at(::std::addressof(value_.ud_2));
      break;
    case Type::us_2:
      ::std::destroy_at(::std::addressof(value_.us_2));
      break;
    case Type::ue_2:
      ::std::destroy_at(::std::addressof(value_.ue_2));
      break;
    default:
      assert(false);
      break;
  }
}

void union2::__fbthrift_clear() {
  __fbthrift_destruct();
  type_ = folly::to_underlying(Type::__EMPTY__);
}

  union2::~union2() {
    __fbthrift_destruct();
  }

bool union2::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}
  union2::union2(const union2& rhs)
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        return;
      case Type::ui_2:
        set_ui_2(rhs.value_.ui_2);
        break;
      case Type::ud_2:
        set_ud_2(rhs.value_.ud_2);
        break;
      case Type::us_2:
        set_us_2(rhs.value_.us_2);
        break;
      case Type::ue_2:
        set_ue_2(rhs.value_.ue_2);
        break;
      default:
        assert(false);
    }
  }

    union2&union2::operator=(const union2& rhs) {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        __fbthrift_clear();
        return *this;
      case Type::ui_2:
        set_ui_2(rhs.value_.ui_2);
        break;
      case Type::ud_2:
        set_ud_2(rhs.value_.ud_2);
        break;
      case Type::us_2:
        set_us_2(rhs.value_.us_2);
        break;
      case Type::ue_2:
        set_ue_2(rhs.value_.ue_2);
        break;
      default:
        __fbthrift_clear();
        assert(false);
    }
    return *this;
  }


bool union2::operator==(const union2& rhs) const {
  return ::apache::thrift::op::detail::UnionEquality{}(*this, rhs);
}

bool union2::operator<([[maybe_unused]] const union2& rhs) const {
  return ::apache::thrift::op::detail::UnionLessThan{}(*this, rhs);
}

void swap(union2& a, union2& b) {
  union2 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::union3::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union3::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union3::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union3::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union3>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union3::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union3>::name;
}

void union3::__fbthrift_destruct() {
  switch(getType()) {
    case Type::__EMPTY__:
      break;
    case Type::ui_3:
      ::std::destroy_at(::std::addressof(value_.ui_3));
      break;
    case Type::ud_3:
      ::std::destroy_at(::std::addressof(value_.ud_3));
      break;
    case Type::us_3:
      ::std::destroy_at(::std::addressof(value_.us_3));
      break;
    case Type::ue_3:
      ::std::destroy_at(::std::addressof(value_.ue_3));
      break;
    default:
      assert(false);
      break;
  }
}

void union3::__fbthrift_clear() {
  __fbthrift_destruct();
  type_ = folly::to_underlying(Type::__EMPTY__);
}

  union3::~union3() {
    __fbthrift_destruct();
  }

bool union3::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}
  union3::union3(const union3& rhs)
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        return;
      case Type::ui_3:
        set_ui_3(rhs.value_.ui_3);
        break;
      case Type::ud_3:
        set_ud_3(rhs.value_.ud_3);
        break;
      case Type::us_3:
        set_us_3(rhs.value_.us_3);
        break;
      case Type::ue_3:
        set_ue_3(rhs.value_.ue_3);
        break;
      default:
        assert(false);
    }
  }

    union3&union3::operator=(const union3& rhs) {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        __fbthrift_clear();
        return *this;
      case Type::ui_3:
        set_ui_3(rhs.value_.ui_3);
        break;
      case Type::ud_3:
        set_ud_3(rhs.value_.ud_3);
        break;
      case Type::us_3:
        set_us_3(rhs.value_.us_3);
        break;
      case Type::ue_3:
        set_ue_3(rhs.value_.ue_3);
        break;
      default:
        __fbthrift_clear();
        assert(false);
    }
    return *this;
  }


bool union3::operator==(const union3& rhs) const {
  return ::apache::thrift::op::detail::UnionEquality{}(*this, rhs);
}

bool union3::operator<([[maybe_unused]] const union3& rhs) const {
  return ::apache::thrift::op::detail::UnionLessThan{}(*this, rhs);
}

void swap(union3& a, union3& b) {
  union3 temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structA::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structA>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structA::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structA>::name;
}

structA::structA(const structA&) = default;
structA& structA::operator=(const structA&) = default;
structA::structA() :
      __fbthrift_field_a() {
}


structA::~structA() {}

structA::structA([[maybe_unused]] structA&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __isset(other.__isset) {
}

structA& structA::operator=([[maybe_unused]] structA&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    __isset = other.__isset;
    return *this;
}


structA::structA(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void structA::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

void structA::__fbthrift_clear_terse_fields() {
}

bool structA::__fbthrift_is_empty() const {
  return false;
}

bool structA::operator==([[maybe_unused]] const structA& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool structA::operator<([[maybe_unused]] const structA& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] structA& a, [[maybe_unused]] structA& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__isset, b.__isset);
}

template void structA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::unionA>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::unionA>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::unionA::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::unionA::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::unionA::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece unionA::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<unionA>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece unionA::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<unionA>::name;
}

void unionA::__fbthrift_destruct() {
  switch(getType()) {
    case Type::__EMPTY__:
      break;
    case Type::i:
      ::std::destroy_at(::std::addressof(value_.i));
      break;
    case Type::d:
      ::std::destroy_at(::std::addressof(value_.d));
      break;
    case Type::s:
      ::std::destroy_at(::std::addressof(value_.s));
      break;
    case Type::e:
      ::std::destroy_at(::std::addressof(value_.e));
      break;
    case Type::a:
      ::std::destroy_at(::std::addressof(value_.a));
      break;
    default:
      assert(false);
      break;
  }
}

void unionA::__fbthrift_clear() {
  __fbthrift_destruct();
  type_ = folly::to_underlying(Type::__EMPTY__);
}

  unionA::~unionA() {
    __fbthrift_destruct();
  }

bool unionA::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}
  unionA::unionA(const unionA& rhs)
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        return;
      case Type::i:
        set_i(rhs.value_.i);
        break;
      case Type::d:
        set_d(rhs.value_.d);
        break;
      case Type::s:
        set_s(rhs.value_.s);
        break;
      case Type::e:
        set_e(rhs.value_.e);
        break;
      case Type::a:
        set_a(rhs.value_.a);
        break;
      default:
        assert(false);
    }
  }

    unionA&unionA::operator=(const unionA& rhs) {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        __fbthrift_clear();
        return *this;
      case Type::i:
        set_i(rhs.value_.i);
        break;
      case Type::d:
        set_d(rhs.value_.d);
        break;
      case Type::s:
        set_s(rhs.value_.s);
        break;
      case Type::e:
        set_e(rhs.value_.e);
        break;
      case Type::a:
        set_a(rhs.value_.a);
        break;
      default:
        __fbthrift_clear();
        assert(false);
    }
    return *this;
  }


bool unionA::operator==(const unionA& rhs) const {
  return ::apache::thrift::op::detail::UnionEquality{}(*this, rhs);
}

bool unionA::operator<([[maybe_unused]] const unionA& rhs) const {
  return ::apache::thrift::op::detail::UnionLessThan{}(*this, rhs);
}

void swap(unionA& a, unionA& b) {
  unionA temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void unionA::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void unionA::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t unionA::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t unionA::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t unionA::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        unionA,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structB>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structB>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structB::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structB>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structB::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structB>::name;
}


structB::structB(apache::thrift::FragileConstructor, double c__arg, bool d__arg) :
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_d(std::move(d__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void structB::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_c = double();
  this->__fbthrift_field_d = bool();
  __isset = {};
}

void structB::__fbthrift_clear_terse_fields() {
}

bool structB::__fbthrift_is_empty() const {
  return false;
}

bool structB::operator==([[maybe_unused]] const structB& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool structB::operator<([[maybe_unused]] const structB& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] structB& a, [[maybe_unused]] structB& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_d, b.__fbthrift_field_d);
  swap(a.__isset, b.__isset);
}

template void structB::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structB::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structB::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structB::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structB::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structB::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::structC>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::structC>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece structC::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<structC>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece structC::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<structC>::name;
}

structC::structC(const structC&) = default;
structC& structC::operator=(const structC&) = default;
structC::structC() :
      __fbthrift_field_a(),
      __fbthrift_field_c(),
      __fbthrift_field_d(),
      __fbthrift_field_e(),
      __fbthrift_field_f() {
}


structC::~structC() {}

structC::structC([[maybe_unused]] structC&& other) noexcept :
    __fbthrift_field_a(std::move(other.__fbthrift_field_a)),
    __fbthrift_field_b(std::move(other.__fbthrift_field_b)),
    __fbthrift_field_c(std::move(other.__fbthrift_field_c)),
    __fbthrift_field_d(std::move(other.__fbthrift_field_d)),
    __fbthrift_field_e(std::move(other.__fbthrift_field_e)),
    __fbthrift_field_f(std::move(other.__fbthrift_field_f)),
    __fbthrift_field_g(std::move(other.__fbthrift_field_g)),
    __fbthrift_field_h(std::move(other.__fbthrift_field_h)),
    __fbthrift_field_i(std::move(other.__fbthrift_field_i)),
    __fbthrift_field_j(std::move(other.__fbthrift_field_j)),
    __fbthrift_field_j1(std::move(other.__fbthrift_field_j1)),
    __fbthrift_field_j2(std::move(other.__fbthrift_field_j2)),
    __fbthrift_field_j3(std::move(other.__fbthrift_field_j3)),
    __fbthrift_field_k(std::move(other.__fbthrift_field_k)),
    __fbthrift_field_k1(std::move(other.__fbthrift_field_k1)),
    __fbthrift_field_k2(std::move(other.__fbthrift_field_k2)),
    __fbthrift_field_k3(std::move(other.__fbthrift_field_k3)),
    __fbthrift_field_l(std::move(other.__fbthrift_field_l)),
    __fbthrift_field_l1(std::move(other.__fbthrift_field_l1)),
    __fbthrift_field_l2(std::move(other.__fbthrift_field_l2)),
    __fbthrift_field_l3(std::move(other.__fbthrift_field_l3)),
    __fbthrift_field_m1(std::move(other.__fbthrift_field_m1)),
    __fbthrift_field_m2(std::move(other.__fbthrift_field_m2)),
    __fbthrift_field_m3(std::move(other.__fbthrift_field_m3)),
    __fbthrift_field_n1(std::move(other.__fbthrift_field_n1)),
    __fbthrift_field_n2(std::move(other.__fbthrift_field_n2)),
    __fbthrift_field_n3(std::move(other.__fbthrift_field_n3)),
    __fbthrift_field_o1(std::move(other.__fbthrift_field_o1)),
    __fbthrift_field_o2(std::move(other.__fbthrift_field_o2)),
    __fbthrift_field_o3(std::move(other.__fbthrift_field_o3)),
    __isset(other.__isset) {
}

structC& structC::operator=([[maybe_unused]] structC&& other) noexcept {
    this->__fbthrift_field_a = std::move(other.__fbthrift_field_a);
    this->__fbthrift_field_b = std::move(other.__fbthrift_field_b);
    this->__fbthrift_field_c = std::move(other.__fbthrift_field_c);
    this->__fbthrift_field_d = std::move(other.__fbthrift_field_d);
    this->__fbthrift_field_e = std::move(other.__fbthrift_field_e);
    this->__fbthrift_field_f = std::move(other.__fbthrift_field_f);
    this->__fbthrift_field_g = std::move(other.__fbthrift_field_g);
    this->__fbthrift_field_h = std::move(other.__fbthrift_field_h);
    this->__fbthrift_field_i = std::move(other.__fbthrift_field_i);
    this->__fbthrift_field_j = std::move(other.__fbthrift_field_j);
    this->__fbthrift_field_j1 = std::move(other.__fbthrift_field_j1);
    this->__fbthrift_field_j2 = std::move(other.__fbthrift_field_j2);
    this->__fbthrift_field_j3 = std::move(other.__fbthrift_field_j3);
    this->__fbthrift_field_k = std::move(other.__fbthrift_field_k);
    this->__fbthrift_field_k1 = std::move(other.__fbthrift_field_k1);
    this->__fbthrift_field_k2 = std::move(other.__fbthrift_field_k2);
    this->__fbthrift_field_k3 = std::move(other.__fbthrift_field_k3);
    this->__fbthrift_field_l = std::move(other.__fbthrift_field_l);
    this->__fbthrift_field_l1 = std::move(other.__fbthrift_field_l1);
    this->__fbthrift_field_l2 = std::move(other.__fbthrift_field_l2);
    this->__fbthrift_field_l3 = std::move(other.__fbthrift_field_l3);
    this->__fbthrift_field_m1 = std::move(other.__fbthrift_field_m1);
    this->__fbthrift_field_m2 = std::move(other.__fbthrift_field_m2);
    this->__fbthrift_field_m3 = std::move(other.__fbthrift_field_m3);
    this->__fbthrift_field_n1 = std::move(other.__fbthrift_field_n1);
    this->__fbthrift_field_n2 = std::move(other.__fbthrift_field_n2);
    this->__fbthrift_field_n3 = std::move(other.__fbthrift_field_n3);
    this->__fbthrift_field_o1 = std::move(other.__fbthrift_field_o1);
    this->__fbthrift_field_o2 = std::move(other.__fbthrift_field_o2);
    this->__fbthrift_field_o3 = std::move(other.__fbthrift_field_o3);
    __isset = other.__isset;
    return *this;
}


structC::structC(apache::thrift::FragileConstructor, ::std::int32_t a__arg, ::std::string b__arg, double c__arg, bool d__arg, ::test_cpp2::cpp_reflection::enum1 e__arg, ::test_cpp2::cpp_reflection::enum2 f__arg, ::test_cpp2::cpp_reflection::union1 g__arg, ::test_cpp2::cpp_reflection::unionA h__arg, ::test_cpp2::cpp_reflection::unionA i__arg, ::std::vector<::std::int32_t> j__arg, ::std::vector<::std::int32_t> j1__arg, ::std::vector<::test_cpp2::cpp_reflection::enum1> j2__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> j3__arg, ::std::set<::std::int32_t> k__arg, ::std::set<::std::int32_t> k1__arg, ::std::set<::test_cpp2::cpp_reflection::enum2> k2__arg, ::std::set<::test_cpp2::cpp_reflection::structB> k3__arg, ::std::map<::std::int32_t, ::std::int32_t> l__arg, ::std::map<::std::int32_t, ::std::int32_t> l1__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> l2__arg, ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> l3__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> m1__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> m2__arg, ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> m3__arg, ::std::map<::std::string, ::std::int32_t> n1__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> n2__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> n3__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> o1__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> o2__arg, ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> o3__arg) :
    __fbthrift_field_a(std::move(a__arg)),
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_d(std::move(d__arg)),
    __fbthrift_field_e(std::move(e__arg)),
    __fbthrift_field_f(std::move(f__arg)),
    __fbthrift_field_g(std::move(g__arg)),
    __fbthrift_field_h(std::move(h__arg)),
    __fbthrift_field_i(std::move(i__arg)),
    __fbthrift_field_j(std::move(j__arg)),
    __fbthrift_field_j1(std::move(j1__arg)),
    __fbthrift_field_j2(std::move(j2__arg)),
    __fbthrift_field_j3(std::move(j3__arg)),
    __fbthrift_field_k(std::move(k__arg)),
    __fbthrift_field_k1(std::move(k1__arg)),
    __fbthrift_field_k2(std::move(k2__arg)),
    __fbthrift_field_k3(std::move(k3__arg)),
    __fbthrift_field_l(std::move(l__arg)),
    __fbthrift_field_l1(std::move(l1__arg)),
    __fbthrift_field_l2(std::move(l2__arg)),
    __fbthrift_field_l3(std::move(l3__arg)),
    __fbthrift_field_m1(std::move(m1__arg)),
    __fbthrift_field_m2(std::move(m2__arg)),
    __fbthrift_field_m3(std::move(m3__arg)),
    __fbthrift_field_n1(std::move(n1__arg)),
    __fbthrift_field_n2(std::move(n2__arg)),
    __fbthrift_field_n3(std::move(n3__arg)),
    __fbthrift_field_o1(std::move(o1__arg)),
    __fbthrift_field_o2(std::move(o2__arg)),
    __fbthrift_field_o3(std::move(o3__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
  __isset.set(folly::index_constant<18>(), true);
  __isset.set(folly::index_constant<19>(), true);
  __isset.set(folly::index_constant<20>(), true);
  __isset.set(folly::index_constant<21>(), true);
  __isset.set(folly::index_constant<22>(), true);
  __isset.set(folly::index_constant<23>(), true);
  __isset.set(folly::index_constant<24>(), true);
  __isset.set(folly::index_constant<25>(), true);
  __isset.set(folly::index_constant<26>(), true);
  __isset.set(folly::index_constant<27>(), true);
  __isset.set(folly::index_constant<28>(), true);
  __isset.set(folly::index_constant<29>(), true);
}


void structC::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  this->__fbthrift_field_b = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_c = double();
  this->__fbthrift_field_d = bool();
  this->__fbthrift_field_e = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_f = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_g);
  ::apache::thrift::clear(this->__fbthrift_field_h);
  ::apache::thrift::clear(this->__fbthrift_field_i);
  this->__fbthrift_field_j.clear();
  this->__fbthrift_field_j1.clear();
  this->__fbthrift_field_j2.clear();
  this->__fbthrift_field_j3.clear();
  this->__fbthrift_field_k.clear();
  this->__fbthrift_field_k1.clear();
  this->__fbthrift_field_k2.clear();
  this->__fbthrift_field_k3.clear();
  this->__fbthrift_field_l.clear();
  this->__fbthrift_field_l1.clear();
  this->__fbthrift_field_l2.clear();
  this->__fbthrift_field_l3.clear();
  this->__fbthrift_field_m1.clear();
  this->__fbthrift_field_m2.clear();
  this->__fbthrift_field_m3.clear();
  this->__fbthrift_field_n1.clear();
  this->__fbthrift_field_n2.clear();
  this->__fbthrift_field_n3.clear();
  this->__fbthrift_field_o1.clear();
  this->__fbthrift_field_o2.clear();
  this->__fbthrift_field_o3.clear();
  __isset = {};
}

void structC::__fbthrift_clear_terse_fields() {
}

bool structC::__fbthrift_is_empty() const {
  return false;
}

bool structC::operator==([[maybe_unused]] const structC& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool structC::operator<([[maybe_unused]] const structC& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::union1& structC::get_g() const& {
  return __fbthrift_field_g;
}

::test_cpp2::cpp_reflection::union1 structC::get_g() && {
  return std::move(__fbthrift_field_g);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_h() const& {
  return __fbthrift_field_h;
}

::test_cpp2::cpp_reflection::unionA structC::get_h() && {
  return std::move(__fbthrift_field_h);
}

const ::test_cpp2::cpp_reflection::unionA& structC::get_i() const& {
  return __fbthrift_field_i;
}

::test_cpp2::cpp_reflection::unionA structC::get_i() && {
  return std::move(__fbthrift_field_i);
}

const ::std::vector<::std::int32_t>& structC::get_j() const& {
  return __fbthrift_field_j;
}

::std::vector<::std::int32_t> structC::get_j() && {
  return std::move(__fbthrift_field_j);
}

const ::std::vector<::std::int32_t>& structC::get_j1() const& {
  return __fbthrift_field_j1;
}

::std::vector<::std::int32_t> structC::get_j1() && {
  return std::move(__fbthrift_field_j1);
}

const ::std::vector<::test_cpp2::cpp_reflection::enum1>& structC::get_j2() const& {
  return __fbthrift_field_j2;
}

::std::vector<::test_cpp2::cpp_reflection::enum1> structC::get_j2() && {
  return std::move(__fbthrift_field_j2);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& structC::get_j3() const& {
  return __fbthrift_field_j3;
}

::std::vector<::test_cpp2::cpp_reflection::structA> structC::get_j3() && {
  return std::move(__fbthrift_field_j3);
}

const ::std::set<::std::int32_t>& structC::get_k() const& {
  return __fbthrift_field_k;
}

::std::set<::std::int32_t> structC::get_k() && {
  return std::move(__fbthrift_field_k);
}

const ::std::set<::std::int32_t>& structC::get_k1() const& {
  return __fbthrift_field_k1;
}

::std::set<::std::int32_t> structC::get_k1() && {
  return std::move(__fbthrift_field_k1);
}

const ::std::set<::test_cpp2::cpp_reflection::enum2>& structC::get_k2() const& {
  return __fbthrift_field_k2;
}

::std::set<::test_cpp2::cpp_reflection::enum2> structC::get_k2() && {
  return std::move(__fbthrift_field_k2);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& structC::get_k3() const& {
  return __fbthrift_field_k3;
}

::std::set<::test_cpp2::cpp_reflection::structB> structC::get_k3() && {
  return std::move(__fbthrift_field_k3);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l() const& {
  return __fbthrift_field_l;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l() && {
  return std::move(__fbthrift_field_l);
}

const ::std::map<::std::int32_t, ::std::int32_t>& structC::get_l1() const& {
  return __fbthrift_field_l1;
}

::std::map<::std::int32_t, ::std::int32_t> structC::get_l1() && {
  return std::move(__fbthrift_field_l1);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1>& structC::get_l2() const& {
  return __fbthrift_field_l2;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::enum1> structC::get_l2() && {
  return std::move(__fbthrift_field_l2);
}

const ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>& structC::get_l3() const& {
  return __fbthrift_field_l3;
}

::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB> structC::get_l3() && {
  return std::move(__fbthrift_field_l3);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t>& structC::get_m1() const& {
  return __fbthrift_field_m1;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::std::int32_t> structC::get_m1() && {
  return std::move(__fbthrift_field_m1);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2>& structC::get_m2() const& {
  return __fbthrift_field_m2;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::enum2> structC::get_m2() && {
  return std::move(__fbthrift_field_m2);
}

const ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>& structC::get_m3() const& {
  return __fbthrift_field_m3;
}

::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB> structC::get_m3() && {
  return std::move(__fbthrift_field_m3);
}

const ::std::map<::std::string, ::std::int32_t>& structC::get_n1() const& {
  return __fbthrift_field_n1;
}

::std::map<::std::string, ::std::int32_t> structC::get_n1() && {
  return std::move(__fbthrift_field_n1);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1>& structC::get_n2() const& {
  return __fbthrift_field_n2;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::enum1> structC::get_n2() && {
  return std::move(__fbthrift_field_n2);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& structC::get_n3() const& {
  return __fbthrift_field_n3;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> structC::get_n3() && {
  return std::move(__fbthrift_field_n3);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>& structC::get_o1() const& {
  return __fbthrift_field_o1;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t> structC::get_o1() && {
  return std::move(__fbthrift_field_o1);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>& structC::get_o2() const& {
  return __fbthrift_field_o2;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1> structC::get_o2() && {
  return std::move(__fbthrift_field_o2);
}

const ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>& structC::get_o3() const& {
  return __fbthrift_field_o3;
}

::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB> structC::get_o3() && {
  return std::move(__fbthrift_field_o3);
}


void swap([[maybe_unused]] structC& a, [[maybe_unused]] structC& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_d, b.__fbthrift_field_d);
  swap(a.__fbthrift_field_e, b.__fbthrift_field_e);
  swap(a.__fbthrift_field_f, b.__fbthrift_field_f);
  swap(a.__fbthrift_field_g, b.__fbthrift_field_g);
  swap(a.__fbthrift_field_h, b.__fbthrift_field_h);
  swap(a.__fbthrift_field_i, b.__fbthrift_field_i);
  swap(a.__fbthrift_field_j, b.__fbthrift_field_j);
  swap(a.__fbthrift_field_j1, b.__fbthrift_field_j1);
  swap(a.__fbthrift_field_j2, b.__fbthrift_field_j2);
  swap(a.__fbthrift_field_j3, b.__fbthrift_field_j3);
  swap(a.__fbthrift_field_k, b.__fbthrift_field_k);
  swap(a.__fbthrift_field_k1, b.__fbthrift_field_k1);
  swap(a.__fbthrift_field_k2, b.__fbthrift_field_k2);
  swap(a.__fbthrift_field_k3, b.__fbthrift_field_k3);
  swap(a.__fbthrift_field_l, b.__fbthrift_field_l);
  swap(a.__fbthrift_field_l1, b.__fbthrift_field_l1);
  swap(a.__fbthrift_field_l2, b.__fbthrift_field_l2);
  swap(a.__fbthrift_field_l3, b.__fbthrift_field_l3);
  swap(a.__fbthrift_field_m1, b.__fbthrift_field_m1);
  swap(a.__fbthrift_field_m2, b.__fbthrift_field_m2);
  swap(a.__fbthrift_field_m3, b.__fbthrift_field_m3);
  swap(a.__fbthrift_field_n1, b.__fbthrift_field_n1);
  swap(a.__fbthrift_field_n2, b.__fbthrift_field_n2);
  swap(a.__fbthrift_field_n3, b.__fbthrift_field_n3);
  swap(a.__fbthrift_field_o1, b.__fbthrift_field_o1);
  swap(a.__fbthrift_field_o2, b.__fbthrift_field_o2);
  swap(a.__fbthrift_field_o3, b.__fbthrift_field_o3);
  swap(a.__isset, b.__isset);
}

template void structC::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t structC::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void structC::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t structC::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t structC::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t structC::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::unionA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::integral, ::apache::thrift::type_class::structure>,
        ::std::map<::std::int32_t, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::enumeration, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::enum1, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::integral>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::std::int32_t>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::enumeration>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::enum1>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        structC,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::structure, ::apache::thrift::type_class::structure>,
        ::std::map<::test_cpp2::cpp_reflection::structA, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct1>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct1>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct1::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct1>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct1::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct1>::name;
}

struct1::struct1(const struct1&) = default;
struct1& struct1::operator=(const struct1&) = default;
struct1::struct1() :
      __fbthrift_field_field0(),
      __fbthrift_field_field2(),
      __fbthrift_field_field3() {
}


struct1::~struct1() {}

struct1::struct1([[maybe_unused]] struct1&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __fbthrift_field_field5(std::move(other.__fbthrift_field_field5)),
    __isset(other.__isset) {
}

struct1& struct1::operator=([[maybe_unused]] struct1&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    this->__fbthrift_field_field5 = std::move(other.__fbthrift_field_field5);
    __isset = other.__isset;
    return *this;
}


struct1::struct1(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::enum2 field3__arg, ::test_cpp2::cpp_reflection::union1 field4__arg, ::test_cpp2::cpp_reflection::union2 field5__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)),
    __fbthrift_field_field5(std::move(field5__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void struct1::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_field3 = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_field4);
  ::apache::thrift::clear(this->__fbthrift_field_field5);
  __isset = {};
}

void struct1::__fbthrift_clear_terse_fields() {
}

bool struct1::__fbthrift_is_empty() const {
  return false;
}

bool struct1::operator==([[maybe_unused]] const struct1& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct1::operator<([[maybe_unused]] const struct1& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::union1* struct1::get_field4() const& {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

::test_cpp2::cpp_reflection::union1* struct1::get_field4() & {
  return field4_ref().has_value() ? std::addressof(__fbthrift_field_field4) : nullptr;
}

const ::test_cpp2::cpp_reflection::union2& struct1::get_field5() const& {
  return __fbthrift_field_field5;
}

::test_cpp2::cpp_reflection::union2 struct1::get_field5() && {
  return std::move(__fbthrift_field_field5);
}


void swap([[maybe_unused]] struct1& a, [[maybe_unused]] struct1& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__fbthrift_field_field5, b.__fbthrift_field_field5);
  swap(a.__isset, b.__isset);
}

template void struct1::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct1::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct1::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct1::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct1::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct1,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct2>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct2>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct2::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct2>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct2::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct2>::name;
}

struct2::struct2(const struct2&) = default;
struct2& struct2::operator=(const struct2&) = default;
struct2::struct2() :
      __fbthrift_field_fieldA(),
      __fbthrift_field_fieldC(),
      __fbthrift_field_fieldD() {
}


struct2::~struct2() {}

struct2::struct2([[maybe_unused]] struct2&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __isset(other.__isset) {
}

struct2& struct2::operator=([[maybe_unused]] struct2&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    __isset = other.__isset;
    return *this;
}


struct2::struct2(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
}


void struct2::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA = ::std::int32_t();
  this->__fbthrift_field_fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_fieldC = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_fieldD = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_fieldE);
  ::apache::thrift::clear(this->__fbthrift_field_fieldF);
  ::apache::thrift::clear(this->__fbthrift_field_fieldG);
  __isset = {};
}

void struct2::__fbthrift_clear_terse_fields() {
}

bool struct2::__fbthrift_is_empty() const {
  return false;
}

bool struct2::operator==([[maybe_unused]] const struct2& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct2::operator<([[maybe_unused]] const struct2& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::union1& struct2::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

::test_cpp2::cpp_reflection::union1 struct2::get_fieldE() && {
  return std::move(__fbthrift_field_fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct2::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

::test_cpp2::cpp_reflection::union2 struct2::get_fieldF() && {
  return std::move(__fbthrift_field_fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct2::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct2::get_fieldG() && {
  return std::move(__fbthrift_field_fieldG);
}


void swap([[maybe_unused]] struct2& a, [[maybe_unused]] struct2& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__isset, b.__isset);
}

template void struct2::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct2::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct2::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct2::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct2::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct2,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct3>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct3>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct3::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct3>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct3::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct3>::name;
}

struct3::struct3(const struct3&) = default;
struct3& struct3::operator=(const struct3&) = default;
struct3::struct3() :
      __fbthrift_field_fieldA(),
      __fbthrift_field_fieldC(),
      __fbthrift_field_fieldD() {
}


struct3::~struct3() {}

struct3::struct3([[maybe_unused]] struct3&& other) noexcept :
    __fbthrift_field_fieldA(std::move(other.__fbthrift_field_fieldA)),
    __fbthrift_field_fieldB(std::move(other.__fbthrift_field_fieldB)),
    __fbthrift_field_fieldC(std::move(other.__fbthrift_field_fieldC)),
    __fbthrift_field_fieldD(std::move(other.__fbthrift_field_fieldD)),
    __fbthrift_field_fieldE(std::move(other.__fbthrift_field_fieldE)),
    __fbthrift_field_fieldF(std::move(other.__fbthrift_field_fieldF)),
    __fbthrift_field_fieldG(std::move(other.__fbthrift_field_fieldG)),
    __fbthrift_field_fieldH(std::move(other.__fbthrift_field_fieldH)),
    __fbthrift_field_fieldI(std::move(other.__fbthrift_field_fieldI)),
    __fbthrift_field_fieldJ(std::move(other.__fbthrift_field_fieldJ)),
    __fbthrift_field_fieldK(std::move(other.__fbthrift_field_fieldK)),
    __fbthrift_field_fieldL(std::move(other.__fbthrift_field_fieldL)),
    __fbthrift_field_fieldM(std::move(other.__fbthrift_field_fieldM)),
    __fbthrift_field_fieldN(std::move(other.__fbthrift_field_fieldN)),
    __fbthrift_field_fieldO(std::move(other.__fbthrift_field_fieldO)),
    __fbthrift_field_fieldP(std::move(other.__fbthrift_field_fieldP)),
    __fbthrift_field_fieldQ(std::move(other.__fbthrift_field_fieldQ)),
    __fbthrift_field_fieldR(std::move(other.__fbthrift_field_fieldR)),
    __isset(other.__isset) {
}

struct3& struct3::operator=([[maybe_unused]] struct3&& other) noexcept {
    this->__fbthrift_field_fieldA = std::move(other.__fbthrift_field_fieldA);
    this->__fbthrift_field_fieldB = std::move(other.__fbthrift_field_fieldB);
    this->__fbthrift_field_fieldC = std::move(other.__fbthrift_field_fieldC);
    this->__fbthrift_field_fieldD = std::move(other.__fbthrift_field_fieldD);
    this->__fbthrift_field_fieldE = std::move(other.__fbthrift_field_fieldE);
    this->__fbthrift_field_fieldF = std::move(other.__fbthrift_field_fieldF);
    this->__fbthrift_field_fieldG = std::move(other.__fbthrift_field_fieldG);
    this->__fbthrift_field_fieldH = std::move(other.__fbthrift_field_fieldH);
    this->__fbthrift_field_fieldI = std::move(other.__fbthrift_field_fieldI);
    this->__fbthrift_field_fieldJ = std::move(other.__fbthrift_field_fieldJ);
    this->__fbthrift_field_fieldK = std::move(other.__fbthrift_field_fieldK);
    this->__fbthrift_field_fieldL = std::move(other.__fbthrift_field_fieldL);
    this->__fbthrift_field_fieldM = std::move(other.__fbthrift_field_fieldM);
    this->__fbthrift_field_fieldN = std::move(other.__fbthrift_field_fieldN);
    this->__fbthrift_field_fieldO = std::move(other.__fbthrift_field_fieldO);
    this->__fbthrift_field_fieldP = std::move(other.__fbthrift_field_fieldP);
    this->__fbthrift_field_fieldQ = std::move(other.__fbthrift_field_fieldQ);
    this->__fbthrift_field_fieldR = std::move(other.__fbthrift_field_fieldR);
    __isset = other.__isset;
    return *this;
}


struct3::struct3(apache::thrift::FragileConstructor, ::std::int32_t fieldA__arg, ::std::string fieldB__arg, ::test_cpp2::cpp_reflection::enum1 fieldC__arg, ::test_cpp2::cpp_reflection::enum2 fieldD__arg, ::test_cpp2::cpp_reflection::union1 fieldE__arg, ::test_cpp2::cpp_reflection::union2 fieldF__arg, ::test_cpp2::cpp_reflection::struct1 fieldG__arg, ::test_cpp2::cpp_reflection::union2 fieldH__arg, ::std::vector<::std::int32_t> fieldI__arg, ::std::vector<::std::string> fieldJ__arg, ::std::vector<::std::string> fieldK__arg, ::std::vector<::test_cpp2::cpp_reflection::structA> fieldL__arg, ::std::set<::std::int32_t> fieldM__arg, ::std::set<::std::string> fieldN__arg, ::std::set<::std::string> fieldO__arg, ::std::set<::test_cpp2::cpp_reflection::structB> fieldP__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> fieldQ__arg, ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> fieldR__arg) :
    __fbthrift_field_fieldA(std::move(fieldA__arg)),
    __fbthrift_field_fieldB(std::move(fieldB__arg)),
    __fbthrift_field_fieldC(std::move(fieldC__arg)),
    __fbthrift_field_fieldD(std::move(fieldD__arg)),
    __fbthrift_field_fieldE(std::move(fieldE__arg)),
    __fbthrift_field_fieldF(std::move(fieldF__arg)),
    __fbthrift_field_fieldG(std::move(fieldG__arg)),
    __fbthrift_field_fieldH(std::move(fieldH__arg)),
    __fbthrift_field_fieldI(std::move(fieldI__arg)),
    __fbthrift_field_fieldJ(std::move(fieldJ__arg)),
    __fbthrift_field_fieldK(std::move(fieldK__arg)),
    __fbthrift_field_fieldL(std::move(fieldL__arg)),
    __fbthrift_field_fieldM(std::move(fieldM__arg)),
    __fbthrift_field_fieldN(std::move(fieldN__arg)),
    __fbthrift_field_fieldO(std::move(fieldO__arg)),
    __fbthrift_field_fieldP(std::move(fieldP__arg)),
    __fbthrift_field_fieldQ(std::move(fieldQ__arg)),
    __fbthrift_field_fieldR(std::move(fieldR__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
}


void struct3::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_fieldA = ::std::int32_t();
  this->__fbthrift_field_fieldB = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_fieldC = ::test_cpp2::cpp_reflection::enum1();
  this->__fbthrift_field_fieldD = ::test_cpp2::cpp_reflection::enum2();
  ::apache::thrift::clear(this->__fbthrift_field_fieldE);
  ::apache::thrift::clear(this->__fbthrift_field_fieldF);
  ::apache::thrift::clear(this->__fbthrift_field_fieldG);
  ::apache::thrift::clear(this->__fbthrift_field_fieldH);
  this->__fbthrift_field_fieldI.clear();
  this->__fbthrift_field_fieldJ.clear();
  this->__fbthrift_field_fieldK.clear();
  this->__fbthrift_field_fieldL.clear();
  this->__fbthrift_field_fieldM.clear();
  this->__fbthrift_field_fieldN.clear();
  this->__fbthrift_field_fieldO.clear();
  this->__fbthrift_field_fieldP.clear();
  this->__fbthrift_field_fieldQ.clear();
  this->__fbthrift_field_fieldR.clear();
  __isset = {};
}

void struct3::__fbthrift_clear_terse_fields() {
}

bool struct3::__fbthrift_is_empty() const {
  return false;
}

bool struct3::operator==([[maybe_unused]] const struct3& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct3::operator<([[maybe_unused]] const struct3& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::union1& struct3::get_fieldE() const& {
  return __fbthrift_field_fieldE;
}

::test_cpp2::cpp_reflection::union1 struct3::get_fieldE() && {
  return std::move(__fbthrift_field_fieldE);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldF() const& {
  return __fbthrift_field_fieldF;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldF() && {
  return std::move(__fbthrift_field_fieldF);
}

const ::test_cpp2::cpp_reflection::struct1& struct3::get_fieldG() const& {
  return __fbthrift_field_fieldG;
}

::test_cpp2::cpp_reflection::struct1 struct3::get_fieldG() && {
  return std::move(__fbthrift_field_fieldG);
}

const ::test_cpp2::cpp_reflection::union2& struct3::get_fieldH() const& {
  return __fbthrift_field_fieldH;
}

::test_cpp2::cpp_reflection::union2 struct3::get_fieldH() && {
  return std::move(__fbthrift_field_fieldH);
}

const ::std::vector<::std::int32_t>& struct3::get_fieldI() const& {
  return __fbthrift_field_fieldI;
}

::std::vector<::std::int32_t> struct3::get_fieldI() && {
  return std::move(__fbthrift_field_fieldI);
}

const ::std::vector<::std::string>& struct3::get_fieldJ() const& {
  return __fbthrift_field_fieldJ;
}

::std::vector<::std::string> struct3::get_fieldJ() && {
  return std::move(__fbthrift_field_fieldJ);
}

const ::std::vector<::std::string>& struct3::get_fieldK() const& {
  return __fbthrift_field_fieldK;
}

::std::vector<::std::string> struct3::get_fieldK() && {
  return std::move(__fbthrift_field_fieldK);
}

const ::std::vector<::test_cpp2::cpp_reflection::structA>& struct3::get_fieldL() const& {
  return __fbthrift_field_fieldL;
}

::std::vector<::test_cpp2::cpp_reflection::structA> struct3::get_fieldL() && {
  return std::move(__fbthrift_field_fieldL);
}

const ::std::set<::std::int32_t>& struct3::get_fieldM() const& {
  return __fbthrift_field_fieldM;
}

::std::set<::std::int32_t> struct3::get_fieldM() && {
  return std::move(__fbthrift_field_fieldM);
}

const ::std::set<::std::string>& struct3::get_fieldN() const& {
  return __fbthrift_field_fieldN;
}

::std::set<::std::string> struct3::get_fieldN() && {
  return std::move(__fbthrift_field_fieldN);
}

const ::std::set<::std::string>& struct3::get_fieldO() const& {
  return __fbthrift_field_fieldO;
}

::std::set<::std::string> struct3::get_fieldO() && {
  return std::move(__fbthrift_field_fieldO);
}

const ::std::set<::test_cpp2::cpp_reflection::structB>& struct3::get_fieldP() const& {
  return __fbthrift_field_fieldP;
}

::std::set<::test_cpp2::cpp_reflection::structB> struct3::get_fieldP() && {
  return std::move(__fbthrift_field_fieldP);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>& struct3::get_fieldQ() const& {
  return __fbthrift_field_fieldQ;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structA> struct3::get_fieldQ() && {
  return std::move(__fbthrift_field_fieldQ);
}

const ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>& struct3::get_fieldR() const& {
  return __fbthrift_field_fieldR;
}

::std::map<::std::string, ::test_cpp2::cpp_reflection::structB> struct3::get_fieldR() && {
  return std::move(__fbthrift_field_fieldR);
}


void swap([[maybe_unused]] struct3& a, [[maybe_unused]] struct3& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_fieldA, b.__fbthrift_field_fieldA);
  swap(a.__fbthrift_field_fieldB, b.__fbthrift_field_fieldB);
  swap(a.__fbthrift_field_fieldC, b.__fbthrift_field_fieldC);
  swap(a.__fbthrift_field_fieldD, b.__fbthrift_field_fieldD);
  swap(a.__fbthrift_field_fieldE, b.__fbthrift_field_fieldE);
  swap(a.__fbthrift_field_fieldF, b.__fbthrift_field_fieldF);
  swap(a.__fbthrift_field_fieldG, b.__fbthrift_field_fieldG);
  swap(a.__fbthrift_field_fieldH, b.__fbthrift_field_fieldH);
  swap(a.__fbthrift_field_fieldI, b.__fbthrift_field_fieldI);
  swap(a.__fbthrift_field_fieldJ, b.__fbthrift_field_fieldJ);
  swap(a.__fbthrift_field_fieldK, b.__fbthrift_field_fieldK);
  swap(a.__fbthrift_field_fieldL, b.__fbthrift_field_fieldL);
  swap(a.__fbthrift_field_fieldM, b.__fbthrift_field_fieldM);
  swap(a.__fbthrift_field_fieldN, b.__fbthrift_field_fieldN);
  swap(a.__fbthrift_field_fieldO, b.__fbthrift_field_fieldO);
  swap(a.__fbthrift_field_fieldP, b.__fbthrift_field_fieldP);
  swap(a.__fbthrift_field_fieldQ, b.__fbthrift_field_fieldQ);
  swap(a.__fbthrift_field_fieldR, b.__fbthrift_field_fieldR);
  swap(a.__isset, b.__isset);
}

template void struct3::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct3::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct3::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct3::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct3::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::struct1>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::variant,
        ::test_cpp2::cpp_reflection::union2>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::list<::apache::thrift::type_class::structure>,
        ::std::vector<::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::set<::apache::thrift::type_class::structure>,
        ::std::set<::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structA>>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct3,
        ::apache::thrift::type_class::map<::apache::thrift::type_class::string, ::apache::thrift::type_class::structure>,
        ::std::map<::std::string, ::test_cpp2::cpp_reflection::structB>>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct4>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct4>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct4::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct4>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct4::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct4>::name;
}

struct4::struct4(const struct4& srcObj) :
    __fbthrift_field_field0(srcObj.__fbthrift_field_field0),
    __fbthrift_field_field1(srcObj.__fbthrift_field_field1),
    __fbthrift_field_field2(srcObj.__fbthrift_field_field2),
    __fbthrift_field_field3(::apache::thrift::detail::st::copy_field<
          ::apache::thrift::type_class::structure>(srcObj.__fbthrift_field_field3)),
    __isset(srcObj.__isset) {
}

struct4& struct4::operator=(const struct4& other) {
  struct4 tmp(other);
  swap(*this, tmp);
  return *this;
}

struct4::struct4() :
      __fbthrift_field_field0(),
      __fbthrift_field_field2(),
      __fbthrift_field_field3(std::make_unique<::test_cpp2::cpp_reflection::structA>()) {
}


struct4::~struct4() {}

struct4::struct4([[maybe_unused]] struct4&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __isset(other.__isset) {
}

struct4& struct4::operator=([[maybe_unused]] struct4&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    __isset = other.__isset;
    return *this;
}


struct4::struct4(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::std::unique_ptr<::test_cpp2::cpp_reflection::structA> field3__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
}


void struct4::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  if (this->__fbthrift_field_field3) ::apache::thrift::clear(*this->__fbthrift_field_field3);
  __isset = {};
}

void struct4::__fbthrift_clear_terse_fields() {
}

bool struct4::__fbthrift_is_empty() const {
  return false;
}

bool struct4::operator==([[maybe_unused]] const struct4& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct4::operator<([[maybe_unused]] const struct4& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] struct4& a, [[maybe_unused]] struct4& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__isset, b.__isset);
}

template void struct4::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct4::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct4::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct4::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct4::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct4,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct5>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct5>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct5::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct5>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct5::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct5>::name;
}

struct5::struct5(const struct5&) = default;
struct5& struct5::operator=(const struct5&) = default;
struct5::struct5() :
      __fbthrift_field_field0(),
      __fbthrift_field_field2() {
}


struct5::~struct5() {}

struct5::struct5([[maybe_unused]] struct5&& other) noexcept :
    __fbthrift_field_field0(std::move(other.__fbthrift_field_field0)),
    __fbthrift_field_field1(std::move(other.__fbthrift_field_field1)),
    __fbthrift_field_field2(std::move(other.__fbthrift_field_field2)),
    __fbthrift_field_field3(std::move(other.__fbthrift_field_field3)),
    __fbthrift_field_field4(std::move(other.__fbthrift_field_field4)),
    __isset(other.__isset) {
}

struct5& struct5::operator=([[maybe_unused]] struct5&& other) noexcept {
    this->__fbthrift_field_field0 = std::move(other.__fbthrift_field_field0);
    this->__fbthrift_field_field1 = std::move(other.__fbthrift_field_field1);
    this->__fbthrift_field_field2 = std::move(other.__fbthrift_field_field2);
    this->__fbthrift_field_field3 = std::move(other.__fbthrift_field_field3);
    this->__fbthrift_field_field4 = std::move(other.__fbthrift_field_field4);
    __isset = other.__isset;
    return *this;
}


struct5::struct5(apache::thrift::FragileConstructor, ::std::int32_t field0__arg, ::std::string field1__arg, ::test_cpp2::cpp_reflection::enum1 field2__arg, ::test_cpp2::cpp_reflection::structA field3__arg, ::test_cpp2::cpp_reflection::structB field4__arg) :
    __fbthrift_field_field0(std::move(field0__arg)),
    __fbthrift_field_field1(std::move(field1__arg)),
    __fbthrift_field_field2(std::move(field2__arg)),
    __fbthrift_field_field3(std::move(field3__arg)),
    __fbthrift_field_field4(std::move(field4__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
}


void struct5::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_field0 = ::std::int32_t();
  this->__fbthrift_field_field1 = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  this->__fbthrift_field_field2 = ::test_cpp2::cpp_reflection::enum1();
  ::apache::thrift::clear(this->__fbthrift_field_field3);
  ::apache::thrift::clear(this->__fbthrift_field_field4);
  __isset = {};
}

void struct5::__fbthrift_clear_terse_fields() {
}

bool struct5::__fbthrift_is_empty() const {
  return false;
}

bool struct5::operator==([[maybe_unused]] const struct5& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct5::operator<([[maybe_unused]] const struct5& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::structA& struct5::get_field3() const& {
  return __fbthrift_field_field3;
}

::test_cpp2::cpp_reflection::structA struct5::get_field3() && {
  return std::move(__fbthrift_field_field3);
}

const ::test_cpp2::cpp_reflection::structB& struct5::get_field4() const& {
  return __fbthrift_field_field4;
}

::test_cpp2::cpp_reflection::structB struct5::get_field4() && {
  return std::move(__fbthrift_field_field4);
}


void swap([[maybe_unused]] struct5& a, [[maybe_unused]] struct5& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_field0, b.__fbthrift_field_field0);
  swap(a.__fbthrift_field_field1, b.__fbthrift_field_field1);
  swap(a.__fbthrift_field_field2, b.__fbthrift_field_field2);
  swap(a.__fbthrift_field_field3, b.__fbthrift_field_field3);
  swap(a.__fbthrift_field_field4, b.__fbthrift_field_field4);
  swap(a.__isset, b.__isset);
}

template void struct5::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct5::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct5::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct5::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct5::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structA>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        struct5,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::structB>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_binary>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_binary>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_binary::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_binary>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_binary::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_binary>::name;
}

struct_binary::struct_binary(const struct_binary&) = default;
struct_binary& struct_binary::operator=(const struct_binary&) = default;
struct_binary::struct_binary() {
}


struct_binary::~struct_binary() {}

struct_binary::struct_binary([[maybe_unused]] struct_binary&& other) noexcept :
    __fbthrift_field_bi(std::move(other.__fbthrift_field_bi)),
    __isset(other.__isset) {
}

struct_binary& struct_binary::operator=([[maybe_unused]] struct_binary&& other) noexcept {
    this->__fbthrift_field_bi = std::move(other.__fbthrift_field_bi);
    __isset = other.__isset;
    return *this;
}


struct_binary::struct_binary(apache::thrift::FragileConstructor, ::std::string bi__arg) :
    __fbthrift_field_bi(std::move(bi__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void struct_binary::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_bi = apache::thrift::StringTraits<std::string>::fromStringLiteral("");
  __isset = {};
}

void struct_binary::__fbthrift_clear_terse_fields() {
}

bool struct_binary::__fbthrift_is_empty() const {
  return false;
}

bool struct_binary::operator==([[maybe_unused]] const struct_binary& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct_binary::operator<([[maybe_unused]] const struct_binary& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] struct_binary& a, [[maybe_unused]] struct_binary& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_bi, b.__fbthrift_field_bi);
  swap(a.__isset, b.__isset);
}

template void struct_binary::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_binary::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_binary::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_binary::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_binary::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_A_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_A_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece dep_A_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<dep_A_struct>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece dep_A_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<dep_A_struct>::name;
}


dep_A_struct::dep_A_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_i_a(std::move(i_a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void dep_A_struct::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_b);
  ::apache::thrift::clear(this->__fbthrift_field_c);
  this->__fbthrift_field_i_a = ::std::int32_t();
  __isset = {};
}

void dep_A_struct::__fbthrift_clear_terse_fields() {
}

bool dep_A_struct::__fbthrift_is_empty() const {
  return false;
}

bool dep_A_struct::operator==([[maybe_unused]] const dep_A_struct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool dep_A_struct::operator<([[maybe_unused]] const dep_A_struct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_A_struct::get_b() const& {
  return __fbthrift_field_b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_A_struct::get_b() && {
  return std::move(__fbthrift_field_b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_A_struct::get_c() const& {
  return __fbthrift_field_c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_A_struct::get_c() && {
  return std::move(__fbthrift_field_c);
}


void swap([[maybe_unused]] dep_A_struct& a, [[maybe_unused]] dep_A_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_i_a, b.__fbthrift_field_i_a);
  swap(a.__isset, b.__isset);
}

template void dep_A_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_A_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_A_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_A_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_A_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_A_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::dep_B_struct>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::dep_B_struct>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece dep_B_struct::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<dep_B_struct>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece dep_B_struct::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<dep_B_struct>::name;
}


dep_B_struct::dep_B_struct(apache::thrift::FragileConstructor, ::test_cpp2::cpp_reflection::dep_B_struct b__arg, ::test_cpp2::cpp_reflection::dep_C_struct c__arg, ::std::int32_t i_a__arg) :
    __fbthrift_field_b(std::move(b__arg)),
    __fbthrift_field_c(std::move(c__arg)),
    __fbthrift_field_i_a(std::move(i_a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
}


void dep_B_struct::__fbthrift_clear() {
  // clear all fields
  ::apache::thrift::clear(this->__fbthrift_field_b);
  ::apache::thrift::clear(this->__fbthrift_field_c);
  this->__fbthrift_field_i_a = ::std::int32_t();
  __isset = {};
}

void dep_B_struct::__fbthrift_clear_terse_fields() {
}

bool dep_B_struct::__fbthrift_is_empty() const {
  return false;
}

bool dep_B_struct::operator==([[maybe_unused]] const dep_B_struct& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool dep_B_struct::operator<([[maybe_unused]] const dep_B_struct& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}

const ::test_cpp2::cpp_reflection::dep_B_struct& dep_B_struct::get_b() const& {
  return __fbthrift_field_b;
}

::test_cpp2::cpp_reflection::dep_B_struct dep_B_struct::get_b() && {
  return std::move(__fbthrift_field_b);
}

const ::test_cpp2::cpp_reflection::dep_C_struct& dep_B_struct::get_c() const& {
  return __fbthrift_field_c;
}

::test_cpp2::cpp_reflection::dep_C_struct dep_B_struct::get_c() && {
  return std::move(__fbthrift_field_c);
}


void swap([[maybe_unused]] dep_B_struct& a, [[maybe_unused]] dep_B_struct& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_b, b.__fbthrift_field_b);
  swap(a.__fbthrift_field_c, b.__fbthrift_field_c);
  swap(a.__fbthrift_field_i_a, b.__fbthrift_field_i_a);
  swap(a.__isset, b.__isset);
}

template void dep_B_struct::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void dep_B_struct::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t dep_B_struct::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t dep_B_struct::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t dep_B_struct::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;

static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_B_struct>,
    "inconsistent use of json option");
static_assert(
    ::apache::thrift::detail::st::gen_check_json<
        dep_B_struct,
        ::apache::thrift::type_class::structure,
        ::test_cpp2::cpp_reflection::dep_C_struct>,
    "inconsistent use of json option");

}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::annotated>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::annotated>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece annotated::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<annotated>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece annotated::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<annotated>::name;
}


annotated::annotated(apache::thrift::FragileConstructor, ::std::int32_t a__arg) :
    __fbthrift_field_a(std::move(a__arg)) {
  __isset.set(folly::index_constant<0>(), true);
}


void annotated::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_a = ::std::int32_t();
  __isset = {};
}

void annotated::__fbthrift_clear_terse_fields() {
}

bool annotated::__fbthrift_is_empty() const {
  return false;
}

bool annotated::operator==([[maybe_unused]] const annotated& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool annotated::operator<([[maybe_unused]] const annotated& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] annotated& a, [[maybe_unused]] annotated& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_a, b.__fbthrift_field_a);
  swap(a.__isset, b.__isset);
}

template void annotated::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void annotated::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t annotated::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t annotated::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t annotated::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::union_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::union_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace apache { namespace thrift {

folly::Range<::test_cpp2::cpp_reflection::union_with_special_names::Type const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::values);
folly::Range<folly::StringPiece const*> const TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names = folly::range(TEnumDataStorage<::test_cpp2::cpp_reflection::union_with_special_names::Type>::names);

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findName(type value, folly::StringPiece* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_name(value, out);
}

bool TEnumTraits<::test_cpp2::cpp_reflection::union_with_special_names::Type>::findValue(folly::StringPiece name, type* out) noexcept {
  return ::apache::thrift::detail::st::enum_find_value(name, out);
}
}} // apache::thrift
namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece union_with_special_names::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<union_with_special_names>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece union_with_special_names::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<union_with_special_names>::name;
}

void union_with_special_names::__fbthrift_destruct() {
  switch(getType()) {
    case Type::__EMPTY__:
      break;
    case Type::get:
      ::std::destroy_at(::std::addressof(value_.get));
      break;
    case Type::getter:
      ::std::destroy_at(::std::addressof(value_.getter));
      break;
    case Type::lists:
      ::std::destroy_at(::std::addressof(value_.lists));
      break;
    case Type::maps:
      ::std::destroy_at(::std::addressof(value_.maps));
      break;
    case Type::name:
      ::std::destroy_at(::std::addressof(value_.name));
      break;
    case Type::name_to_value:
      ::std::destroy_at(::std::addressof(value_.name_to_value));
      break;
    case Type::names:
      ::std::destroy_at(::std::addressof(value_.names));
      break;
    case Type::prefix_tree:
      ::std::destroy_at(::std::addressof(value_.prefix_tree));
      break;
    case Type::sets:
      ::std::destroy_at(::std::addressof(value_.sets));
      break;
    case Type::setter:
      ::std::destroy_at(::std::addressof(value_.setter));
      break;
    case Type::str:
      ::std::destroy_at(::std::addressof(value_.str));
      break;
    case Type::strings:
      ::std::destroy_at(::std::addressof(value_.strings));
      break;
    case Type::type:
      ::std::destroy_at(::std::addressof(value_.type));
      break;
    case Type::value:
      ::std::destroy_at(::std::addressof(value_.value));
      break;
    case Type::value_to_name:
      ::std::destroy_at(::std::addressof(value_.value_to_name));
      break;
    case Type::values:
      ::std::destroy_at(::std::addressof(value_.values));
      break;
    case Type::id:
      ::std::destroy_at(::std::addressof(value_.id));
      break;
    case Type::ids:
      ::std::destroy_at(::std::addressof(value_.ids));
      break;
    case Type::descriptor:
      ::std::destroy_at(::std::addressof(value_.descriptor));
      break;
    case Type::descriptors:
      ::std::destroy_at(::std::addressof(value_.descriptors));
      break;
    case Type::key:
      ::std::destroy_at(::std::addressof(value_.key));
      break;
    case Type::keys:
      ::std::destroy_at(::std::addressof(value_.keys));
      break;
    case Type::annotation:
      ::std::destroy_at(::std::addressof(value_.annotation));
      break;
    case Type::annotations:
      ::std::destroy_at(::std::addressof(value_.annotations));
      break;
    case Type::member:
      ::std::destroy_at(::std::addressof(value_.member));
      break;
    case Type::members:
      ::std::destroy_at(::std::addressof(value_.members));
      break;
    case Type::field:
      ::std::destroy_at(::std::addressof(value_.field));
      break;
    case Type::fields:
      ::std::destroy_at(::std::addressof(value_.fields));
      break;
    default:
      assert(false);
      break;
  }
}

void union_with_special_names::__fbthrift_clear() {
  __fbthrift_destruct();
  type_ = folly::to_underlying(Type::__EMPTY__);
}


bool union_with_special_names::__fbthrift_is_empty() const {
  return getType() == Type::__EMPTY__;
}
  union_with_special_names::union_with_special_names(const union_with_special_names& rhs)
      : type_(folly::to_underlying(Type::__EMPTY__)) {
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        return;
      case Type::get:
        set_get(rhs.value_.get);
        break;
      case Type::getter:
        set_getter(rhs.value_.getter);
        break;
      case Type::lists:
        set_lists(rhs.value_.lists);
        break;
      case Type::maps:
        set_maps(rhs.value_.maps);
        break;
      case Type::name:
        set_name(rhs.value_.name);
        break;
      case Type::name_to_value:
        set_name_to_value(rhs.value_.name_to_value);
        break;
      case Type::names:
        set_names(rhs.value_.names);
        break;
      case Type::prefix_tree:
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      case Type::sets:
        set_sets(rhs.value_.sets);
        break;
      case Type::setter:
        set_setter(rhs.value_.setter);
        break;
      case Type::str:
        set_str(rhs.value_.str);
        break;
      case Type::strings:
        set_strings(rhs.value_.strings);
        break;
      case Type::type:
        set_type(rhs.value_.type);
        break;
      case Type::value:
        set_value(rhs.value_.value);
        break;
      case Type::value_to_name:
        set_value_to_name(rhs.value_.value_to_name);
        break;
      case Type::values:
        set_values(rhs.value_.values);
        break;
      case Type::id:
        set_id(rhs.value_.id);
        break;
      case Type::ids:
        set_ids(rhs.value_.ids);
        break;
      case Type::descriptor:
        set_descriptor(rhs.value_.descriptor);
        break;
      case Type::descriptors:
        set_descriptors(rhs.value_.descriptors);
        break;
      case Type::key:
        set_key(rhs.value_.key);
        break;
      case Type::keys:
        set_keys(rhs.value_.keys);
        break;
      case Type::annotation:
        set_annotation(rhs.value_.annotation);
        break;
      case Type::annotations:
        set_annotations(rhs.value_.annotations);
        break;
      case Type::member:
        set_member(rhs.value_.member);
        break;
      case Type::members:
        set_members(rhs.value_.members);
        break;
      case Type::field:
        set_field(rhs.value_.field);
        break;
      case Type::fields:
        set_fields(rhs.value_.fields);
        break;
      default:
        assert(false);
    }
  }

    union_with_special_names&union_with_special_names::operator=(const union_with_special_names& rhs) {
    if (this == &rhs) { return *this; }
    switch (rhs.getType()) {
      case Type::__EMPTY__:
        __fbthrift_clear();
        return *this;
      case Type::get:
        set_get(rhs.value_.get);
        break;
      case Type::getter:
        set_getter(rhs.value_.getter);
        break;
      case Type::lists:
        set_lists(rhs.value_.lists);
        break;
      case Type::maps:
        set_maps(rhs.value_.maps);
        break;
      case Type::name:
        set_name(rhs.value_.name);
        break;
      case Type::name_to_value:
        set_name_to_value(rhs.value_.name_to_value);
        break;
      case Type::names:
        set_names(rhs.value_.names);
        break;
      case Type::prefix_tree:
        set_prefix_tree(rhs.value_.prefix_tree);
        break;
      case Type::sets:
        set_sets(rhs.value_.sets);
        break;
      case Type::setter:
        set_setter(rhs.value_.setter);
        break;
      case Type::str:
        set_str(rhs.value_.str);
        break;
      case Type::strings:
        set_strings(rhs.value_.strings);
        break;
      case Type::type:
        set_type(rhs.value_.type);
        break;
      case Type::value:
        set_value(rhs.value_.value);
        break;
      case Type::value_to_name:
        set_value_to_name(rhs.value_.value_to_name);
        break;
      case Type::values:
        set_values(rhs.value_.values);
        break;
      case Type::id:
        set_id(rhs.value_.id);
        break;
      case Type::ids:
        set_ids(rhs.value_.ids);
        break;
      case Type::descriptor:
        set_descriptor(rhs.value_.descriptor);
        break;
      case Type::descriptors:
        set_descriptors(rhs.value_.descriptors);
        break;
      case Type::key:
        set_key(rhs.value_.key);
        break;
      case Type::keys:
        set_keys(rhs.value_.keys);
        break;
      case Type::annotation:
        set_annotation(rhs.value_.annotation);
        break;
      case Type::annotations:
        set_annotations(rhs.value_.annotations);
        break;
      case Type::member:
        set_member(rhs.value_.member);
        break;
      case Type::members:
        set_members(rhs.value_.members);
        break;
      case Type::field:
        set_field(rhs.value_.field);
        break;
      case Type::fields:
        set_fields(rhs.value_.fields);
        break;
      default:
        __fbthrift_clear();
        assert(false);
    }
    return *this;
  }


bool union_with_special_names::operator==(const union_with_special_names& rhs) const {
  return ::apache::thrift::op::detail::UnionEquality{}(*this, rhs);
}

bool union_with_special_names::operator<([[maybe_unused]] const union_with_special_names& rhs) const {
  return ::apache::thrift::op::detail::UnionLessThan{}(*this, rhs);
}

void swap(union_with_special_names& a, union_with_special_names& b) {
  union_with_special_names temp(std::move(a));
  a = std::move(b);
  b = std::move(temp);
}

template void union_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void union_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t union_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t union_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t union_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_special_names>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_special_names>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_with_special_names::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_with_special_names>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_with_special_names::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_with_special_names>::name;
}


struct_with_special_names::struct_with_special_names(apache::thrift::FragileConstructor, ::std::int32_t get__arg, ::std::int32_t getter__arg, ::std::int32_t lists__arg, ::std::int32_t maps__arg, ::std::int32_t name__arg, ::std::int32_t name_to_value__arg, ::std::int32_t names__arg, ::std::int32_t prefix_tree__arg, ::std::int32_t sets__arg, ::std::int32_t setter__arg, ::std::int32_t str__arg, ::std::int32_t strings__arg, ::std::int32_t type__arg, ::std::int32_t value__arg, ::std::int32_t value_to_name__arg, ::std::int32_t values__arg, ::std::int32_t id__arg, ::std::int32_t ids__arg, ::std::int32_t descriptor__arg, ::std::int32_t descriptors__arg, ::std::int32_t key__arg, ::std::int32_t keys__arg, ::std::int32_t annotation__arg, ::std::int32_t annotations__arg, ::std::int32_t member__arg, ::std::int32_t members__arg, ::std::int32_t field__arg, ::std::int32_t fields__arg) :
    __fbthrift_field_get(std::move(get__arg)),
    __fbthrift_field_getter(std::move(getter__arg)),
    __fbthrift_field_lists(std::move(lists__arg)),
    __fbthrift_field_maps(std::move(maps__arg)),
    __fbthrift_field_name(std::move(name__arg)),
    __fbthrift_field_name_to_value(std::move(name_to_value__arg)),
    __fbthrift_field_names(std::move(names__arg)),
    __fbthrift_field_prefix_tree(std::move(prefix_tree__arg)),
    __fbthrift_field_sets(std::move(sets__arg)),
    __fbthrift_field_setter(std::move(setter__arg)),
    __fbthrift_field_str(std::move(str__arg)),
    __fbthrift_field_strings(std::move(strings__arg)),
    __fbthrift_field_type(std::move(type__arg)),
    __fbthrift_field_value(std::move(value__arg)),
    __fbthrift_field_value_to_name(std::move(value_to_name__arg)),
    __fbthrift_field_values(std::move(values__arg)),
    __fbthrift_field_id(std::move(id__arg)),
    __fbthrift_field_ids(std::move(ids__arg)),
    __fbthrift_field_descriptor(std::move(descriptor__arg)),
    __fbthrift_field_descriptors(std::move(descriptors__arg)),
    __fbthrift_field_key(std::move(key__arg)),
    __fbthrift_field_keys(std::move(keys__arg)),
    __fbthrift_field_annotation(std::move(annotation__arg)),
    __fbthrift_field_annotations(std::move(annotations__arg)),
    __fbthrift_field_member(std::move(member__arg)),
    __fbthrift_field_members(std::move(members__arg)),
    __fbthrift_field_field(std::move(field__arg)),
    __fbthrift_field_fields(std::move(fields__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
  __isset.set(folly::index_constant<5>(), true);
  __isset.set(folly::index_constant<6>(), true);
  __isset.set(folly::index_constant<7>(), true);
  __isset.set(folly::index_constant<8>(), true);
  __isset.set(folly::index_constant<9>(), true);
  __isset.set(folly::index_constant<10>(), true);
  __isset.set(folly::index_constant<11>(), true);
  __isset.set(folly::index_constant<12>(), true);
  __isset.set(folly::index_constant<13>(), true);
  __isset.set(folly::index_constant<14>(), true);
  __isset.set(folly::index_constant<15>(), true);
  __isset.set(folly::index_constant<16>(), true);
  __isset.set(folly::index_constant<17>(), true);
  __isset.set(folly::index_constant<18>(), true);
  __isset.set(folly::index_constant<19>(), true);
  __isset.set(folly::index_constant<20>(), true);
  __isset.set(folly::index_constant<21>(), true);
  __isset.set(folly::index_constant<22>(), true);
  __isset.set(folly::index_constant<23>(), true);
  __isset.set(folly::index_constant<24>(), true);
  __isset.set(folly::index_constant<25>(), true);
  __isset.set(folly::index_constant<26>(), true);
  __isset.set(folly::index_constant<27>(), true);
}


void struct_with_special_names::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_get = ::std::int32_t();
  this->__fbthrift_field_getter = ::std::int32_t();
  this->__fbthrift_field_lists = ::std::int32_t();
  this->__fbthrift_field_maps = ::std::int32_t();
  this->__fbthrift_field_name = ::std::int32_t();
  this->__fbthrift_field_name_to_value = ::std::int32_t();
  this->__fbthrift_field_names = ::std::int32_t();
  this->__fbthrift_field_prefix_tree = ::std::int32_t();
  this->__fbthrift_field_sets = ::std::int32_t();
  this->__fbthrift_field_setter = ::std::int32_t();
  this->__fbthrift_field_str = ::std::int32_t();
  this->__fbthrift_field_strings = ::std::int32_t();
  this->__fbthrift_field_type = ::std::int32_t();
  this->__fbthrift_field_value = ::std::int32_t();
  this->__fbthrift_field_value_to_name = ::std::int32_t();
  this->__fbthrift_field_values = ::std::int32_t();
  this->__fbthrift_field_id = ::std::int32_t();
  this->__fbthrift_field_ids = ::std::int32_t();
  this->__fbthrift_field_descriptor = ::std::int32_t();
  this->__fbthrift_field_descriptors = ::std::int32_t();
  this->__fbthrift_field_key = ::std::int32_t();
  this->__fbthrift_field_keys = ::std::int32_t();
  this->__fbthrift_field_annotation = ::std::int32_t();
  this->__fbthrift_field_annotations = ::std::int32_t();
  this->__fbthrift_field_member = ::std::int32_t();
  this->__fbthrift_field_members = ::std::int32_t();
  this->__fbthrift_field_field = ::std::int32_t();
  this->__fbthrift_field_fields = ::std::int32_t();
  __isset = {};
}

void struct_with_special_names::__fbthrift_clear_terse_fields() {
}

bool struct_with_special_names::__fbthrift_is_empty() const {
  return false;
}

bool struct_with_special_names::operator==([[maybe_unused]] const struct_with_special_names& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct_with_special_names::operator<([[maybe_unused]] const struct_with_special_names& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] struct_with_special_names& a, [[maybe_unused]] struct_with_special_names& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_get, b.__fbthrift_field_get);
  swap(a.__fbthrift_field_getter, b.__fbthrift_field_getter);
  swap(a.__fbthrift_field_lists, b.__fbthrift_field_lists);
  swap(a.__fbthrift_field_maps, b.__fbthrift_field_maps);
  swap(a.__fbthrift_field_name, b.__fbthrift_field_name);
  swap(a.__fbthrift_field_name_to_value, b.__fbthrift_field_name_to_value);
  swap(a.__fbthrift_field_names, b.__fbthrift_field_names);
  swap(a.__fbthrift_field_prefix_tree, b.__fbthrift_field_prefix_tree);
  swap(a.__fbthrift_field_sets, b.__fbthrift_field_sets);
  swap(a.__fbthrift_field_setter, b.__fbthrift_field_setter);
  swap(a.__fbthrift_field_str, b.__fbthrift_field_str);
  swap(a.__fbthrift_field_strings, b.__fbthrift_field_strings);
  swap(a.__fbthrift_field_type, b.__fbthrift_field_type);
  swap(a.__fbthrift_field_value, b.__fbthrift_field_value);
  swap(a.__fbthrift_field_value_to_name, b.__fbthrift_field_value_to_name);
  swap(a.__fbthrift_field_values, b.__fbthrift_field_values);
  swap(a.__fbthrift_field_id, b.__fbthrift_field_id);
  swap(a.__fbthrift_field_ids, b.__fbthrift_field_ids);
  swap(a.__fbthrift_field_descriptor, b.__fbthrift_field_descriptor);
  swap(a.__fbthrift_field_descriptors, b.__fbthrift_field_descriptors);
  swap(a.__fbthrift_field_key, b.__fbthrift_field_key);
  swap(a.__fbthrift_field_keys, b.__fbthrift_field_keys);
  swap(a.__fbthrift_field_annotation, b.__fbthrift_field_annotation);
  swap(a.__fbthrift_field_annotations, b.__fbthrift_field_annotations);
  swap(a.__fbthrift_field_member, b.__fbthrift_field_member);
  swap(a.__fbthrift_field_members, b.__fbthrift_field_members);
  swap(a.__fbthrift_field_field, b.__fbthrift_field_field);
  swap(a.__fbthrift_field_fields, b.__fbthrift_field_fields);
  swap(a.__isset, b.__isset);
}

template void struct_with_special_names::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_special_names::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_special_names::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_special_names::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_special_names::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace apache {
namespace thrift {
namespace detail {

void TccStructTraits<::test_cpp2::cpp_reflection::struct_with_indirections>::translateFieldName(
    folly::StringPiece _fname,
    int16_t& fid,
    apache::thrift::protocol::TType& _ftype) noexcept {
  using data = apache::thrift::TStructDataStorage<::test_cpp2::cpp_reflection::struct_with_indirections>;
  static const st::translate_field_name_table table{
      data::fields_size,
      data::fields_names.data(),
      data::fields_ids.data(),
      data::fields_types.data()};
  st::translate_field_name(_fname, fid, _ftype, table);
}

} // namespace detail
} // namespace thrift
} // namespace apache

namespace test_cpp2 { namespace cpp_reflection {

const folly::StringPiece struct_with_indirections::__fbthrift_get_field_name(::apache::thrift::FieldOrdinal ord) {
  if (ord == ::apache::thrift::FieldOrdinal{0}) { return {}; }
  return apache::thrift::TStructDataStorage<struct_with_indirections>::fields_names[folly::to_underlying(ord) - 1];
}
const folly::StringPiece struct_with_indirections::__fbthrift_get_class_name() {
  return apache::thrift::TStructDataStorage<struct_with_indirections>::name;
}

struct_with_indirections::struct_with_indirections(const struct_with_indirections&) = default;
struct_with_indirections& struct_with_indirections::operator=(const struct_with_indirections&) = default;
struct_with_indirections::struct_with_indirections() :
      __fbthrift_field_real(),
      __fbthrift_field_fake(),
      __fbthrift_field_number(),
      __fbthrift_field_result() {
}


struct_with_indirections::~struct_with_indirections() {}

struct_with_indirections::struct_with_indirections([[maybe_unused]] struct_with_indirections&& other) noexcept :
    __fbthrift_field_real(std::move(other.__fbthrift_field_real)),
    __fbthrift_field_fake(std::move(other.__fbthrift_field_fake)),
    __fbthrift_field_number(std::move(other.__fbthrift_field_number)),
    __fbthrift_field_result(std::move(other.__fbthrift_field_result)),
    __fbthrift_field_phrase(std::move(other.__fbthrift_field_phrase)),
    __isset(other.__isset) {
}

struct_with_indirections& struct_with_indirections::operator=([[maybe_unused]] struct_with_indirections&& other) noexcept {
    this->__fbthrift_field_real = std::move(other.__fbthrift_field_real);
    this->__fbthrift_field_fake = std::move(other.__fbthrift_field_fake);
    this->__fbthrift_field_number = std::move(other.__fbthrift_field_number);
    this->__fbthrift_field_result = std::move(other.__fbthrift_field_result);
    this->__fbthrift_field_phrase = std::move(other.__fbthrift_field_phrase);
    __isset = other.__isset;
    return *this;
}


struct_with_indirections::struct_with_indirections(apache::thrift::FragileConstructor, ::std::int32_t real__arg, ::test_cpp2::cpp_reflection::FakeI32 fake__arg, ::test_cpp2::cpp_reflection::HasANumber number__arg, ::test_cpp2::cpp_reflection::HasAResult result__arg, ::test_cpp2::cpp_reflection::HasAPhrase phrase__arg) :
    __fbthrift_field_real(std::move(real__arg)),
    __fbthrift_field_fake(std::move(fake__arg)),
    __fbthrift_field_number(std::move(number__arg)),
    __fbthrift_field_result(std::move(result__arg)),
    __fbthrift_field_phrase(std::move(phrase__arg)) {
  __isset.set(folly::index_constant<0>(), true);
  __isset.set(folly::index_constant<1>(), true);
  __isset.set(folly::index_constant<2>(), true);
  __isset.set(folly::index_constant<3>(), true);
  __isset.set(folly::index_constant<4>(), true);
}


void struct_with_indirections::__fbthrift_clear() {
  // clear all fields
  this->__fbthrift_field_real = ::std::int32_t();
  this->__fbthrift_field_fake = ::test_cpp2::cpp_reflection::FakeI32();
  ::apache::thrift::apply_indirection(this->__fbthrift_field_number) = 0;
  ::apache::thrift::apply_indirection(this->__fbthrift_field_result) = 0;
  ::apache::thrift::apply_indirection(this->__fbthrift_field_phrase) = apache::thrift::StringTraits<::folly::remove_cvref_t<::folly::invoke_result_t<::apache::thrift::detail::apply_indirection_fn, CppHasAPhrase const&>>>::fromStringLiteral("");
  __isset = {};
}

void struct_with_indirections::__fbthrift_clear_terse_fields() {
}

bool struct_with_indirections::__fbthrift_is_empty() const {
  return false;
}

bool struct_with_indirections::operator==([[maybe_unused]] const struct_with_indirections& rhs) const {
  return ::apache::thrift::op::detail::StructEquality{}(*this, rhs);
}

bool struct_with_indirections::operator<([[maybe_unused]] const struct_with_indirections& rhs) const {
  return ::apache::thrift::op::detail::StructLessThan{}(*this, rhs);
}


void swap([[maybe_unused]] struct_with_indirections& a, [[maybe_unused]] struct_with_indirections& b) {
  using ::std::swap;
  swap(a.__fbthrift_field_real, b.__fbthrift_field_real);
  swap(a.__fbthrift_field_fake, b.__fbthrift_field_fake);
  swap(a.__fbthrift_field_number, b.__fbthrift_field_number);
  swap(a.__fbthrift_field_result, b.__fbthrift_field_result);
  swap(a.__fbthrift_field_phrase, b.__fbthrift_field_phrase);
  swap(a.__isset, b.__isset);
}

template void struct_with_indirections::readNoXfer<>(apache::thrift::BinaryProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::BinaryProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::BinaryProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::BinaryProtocolWriter const*) const;
template void struct_with_indirections::readNoXfer<>(apache::thrift::CompactProtocolReader*);
template uint32_t struct_with_indirections::write<>(apache::thrift::CompactProtocolWriter*) const;
template uint32_t struct_with_indirections::serializedSize<>(apache::thrift::CompactProtocolWriter const*) const;
template uint32_t struct_with_indirections::serializedSizeZC<>(apache::thrift::CompactProtocolWriter const*) const;


}} // test_cpp2::cpp_reflection

namespace test_cpp2 { namespace cpp_reflection { namespace {
[[maybe_unused]] FOLLY_ERASE void validateAdapters() {
}
}}} // test_cpp2::cpp_reflection
namespace apache::thrift::detail::annotation {
}
