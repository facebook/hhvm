/**
 * Autogenerated by Thrift for thrift/compiler/test/fixtures/mcpp2-compare/src/module.thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated @nocommit
 */

#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/ReturnService.h"
#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/ReturnService.tcc"
#include "thrift/compiler/test/fixtures/mcpp2-compare/gen-cpp2/module_metadata.h"
#include <thrift/lib/cpp2/gen/service_cpp.h>

std::unique_ptr<apache::thrift::AsyncProcessor> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::getProcessor() {
  return std::make_unique<::some::valid::ns::ReturnServiceAsyncProcessor>(this);
}

apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::CreateMethodMetadataResult apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::createMethodMetadata() {
  return ::apache::thrift::detail::ap::createMethodMetadataMap<::some::valid::ns::ReturnServiceAsyncProcessor>(getServiceRequestInfoMap().value().get());
}


std::optional<std::reference_wrapper<apache::thrift::ServiceRequestInfoMap const>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::getServiceRequestInfoMap() const {
  return __fbthrift_serviceInfoHolder.requestInfoMap();
}

::some::valid::ns::ReturnServiceServiceInfoHolder apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::__fbthrift_serviceInfoHolder;


void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_noReturn(std::unique_ptr<apache::thrift::HandlerCallback<void>> callback) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("noReturn"));
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::boolReturn() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("boolReturn");
}

bool apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_boolReturn() {
  return boolReturn();
}

folly::SemiFuture<bool> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_boolReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_boolReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_boolReturn();
}

folly::Future<bool> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_boolReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_boolReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_boolReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_boolReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_boolReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<bool> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_boolReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_boolReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_boolReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_boolReturn(std::unique_ptr<apache::thrift::HandlerCallback<bool>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_boolReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_boolReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_boolReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_boolReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_boolReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_boolReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_boolReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_boolReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_boolReturn());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int16_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::i16Return() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("i16Return");
}

::std::int16_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_i16Return() {
  return i16Return();
}

folly::SemiFuture<::std::int16_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_i16Return() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_i16Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_i16Return();
}

folly::Future<::std::int16_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_i16Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_i16Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_i16Return(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i16Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_i16Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::std::int16_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i16Return(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_i16Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_i16Return();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_i16Return(std::unique_ptr<apache::thrift::HandlerCallback<::std::int16_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_i16Return.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i16Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i16Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i16Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_i16Return();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_i16Return();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i16Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_i16Return();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_i16Return());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int32_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::i32Return() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("i32Return");
}

::std::int32_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_i32Return() {
  return i32Return();
}

folly::SemiFuture<::std::int32_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_i32Return() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_i32Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_i32Return();
}

folly::Future<::std::int32_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_i32Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_i32Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_i32Return(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i32Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_i32Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::std::int32_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i32Return(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_i32Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_i32Return();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_i32Return(std::unique_ptr<apache::thrift::HandlerCallback<::std::int32_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_i32Return.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i32Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i32Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i32Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_i32Return();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_i32Return();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i32Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_i32Return();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_i32Return());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::i64Return() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("i64Return");
}

::std::int64_t apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_i64Return() {
  return i64Return();
}

folly::SemiFuture<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_i64Return() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_i64Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_i64Return();
}

folly::Future<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_i64Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_i64Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_i64Return(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i64Return() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_i64Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::std::int64_t> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_i64Return(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_i64Return.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_i64Return();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_i64Return(std::unique_ptr<apache::thrift::HandlerCallback<::std::int64_t>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_i64Return.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_i64Return.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_i64Return();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_i64Return();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_i64Return(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_i64Return();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_i64Return());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

float apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::floatReturn() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("floatReturn");
}

float apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_floatReturn() {
  return floatReturn();
}

folly::SemiFuture<float> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_floatReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_floatReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_floatReturn();
}

folly::Future<float> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_floatReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_floatReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_floatReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<float> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_floatReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_floatReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<float> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_floatReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_floatReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_floatReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_floatReturn(std::unique_ptr<apache::thrift::HandlerCallback<float>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_floatReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_floatReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_floatReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_floatReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_floatReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_floatReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_floatReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_floatReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_floatReturn());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

double apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::doubleReturn() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("doubleReturn");
}

double apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_doubleReturn() {
  return doubleReturn();
}

folly::SemiFuture<double> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_doubleReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_doubleReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_doubleReturn();
}

folly::Future<double> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_doubleReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_doubleReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_doubleReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<double> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_doubleReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_doubleReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<double> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_doubleReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_doubleReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_doubleReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_doubleReturn(std::unique_ptr<apache::thrift::HandlerCallback<double>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_doubleReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_doubleReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_doubleReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_doubleReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_doubleReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_doubleReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_doubleReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_doubleReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_doubleReturn());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_stringReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("stringReturn"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::binaryReturn(::std::string& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("binaryReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_binaryReturn(::std::string& _return) {
  return binaryReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_binaryReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_binaryReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::string>();
  sync_binaryReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_binaryReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_binaryReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_binaryReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_binaryReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_binaryReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::string>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_binaryReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_binaryReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_binaryReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_binaryReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::string>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_binaryReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_binaryReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_binaryReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_binaryReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_binaryReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_binaryReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_binaryReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_binaryReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::string _return;
        sync_binaryReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::mapReturn(::std::map<::std::string, ::std::int64_t>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("mapReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_mapReturn(::std::map<::std::string, ::std::int64_t>& _return) {
  return mapReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_mapReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_mapReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::map<::std::string, ::std::int64_t>>();
  sync_mapReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_mapReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_mapReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_mapReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_mapReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_mapReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_mapReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_mapReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_mapReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_mapReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::map<::std::string, ::std::int64_t>>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_mapReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_mapReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_mapReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_mapReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_mapReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_mapReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_mapReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_mapReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::map<::std::string, ::std::int64_t> _return;
        sync_mapReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

::some::valid::ns::simpleTypeDef apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::simpleTypedefReturn() {
  apache::thrift::detail::si::throw_app_exn_unimplemented("simpleTypedefReturn");
}

::some::valid::ns::simpleTypeDef apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_simpleTypedefReturn() {
  return simpleTypedefReturn();
}

folly::SemiFuture<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_simpleTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  return sync_simpleTypedefReturn();
}

folly::Future<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_simpleTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_simpleTypedefReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_simpleTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<::some::valid::ns::simpleTypeDef> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_simpleTypedefReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_simpleTypedefReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_simpleTypedefReturn(std::unique_ptr<apache::thrift::HandlerCallback<::some::valid::ns::simpleTypeDef>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_simpleTypedefReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_simpleTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_simpleTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_simpleTypedefReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_simpleTypedefReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_simpleTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_simpleTypedefReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        callback->result(sync_simpleTypedefReturn());
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::complexTypedefReturn(::some::valid::ns::complexStructTypeDef& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("complexTypedefReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_complexTypedefReturn(::some::valid::ns::complexStructTypeDef& _return) {
  return complexTypedefReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::some::valid::ns::complexStructTypeDef>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_complexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::some::valid::ns::complexStructTypeDef>();
  sync_complexTypedefReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::some::valid::ns::complexStructTypeDef>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_complexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_complexTypedefReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::some::valid::ns::complexStructTypeDef>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_complexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::some::valid::ns::complexStructTypeDef>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_complexTypedefReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_complexTypedefReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_complexTypedefReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::complexStructTypeDef>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_complexTypedefReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_complexTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_complexTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_complexTypedefReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_complexTypedefReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_complexTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_complexTypedefReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::some::valid::ns::complexStructTypeDef _return;
        sync_complexTypedefReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::list_mostComplexTypedefReturn(::std::vector<::some::valid::ns::mostComplexTypeDef>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_mostComplexTypedefReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_list_mostComplexTypedefReturn(::std::vector<::some::valid::ns::mostComplexTypeDef>& _return) {
  return list_mostComplexTypedefReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::std::vector<::some::valid::ns::mostComplexTypeDef>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_list_mostComplexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::some::valid::ns::mostComplexTypeDef>>();
  sync_list_mostComplexTypedefReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::some::valid::ns::mostComplexTypeDef>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_list_mostComplexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_mostComplexTypedefReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::mostComplexTypeDef>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_list_mostComplexTypedefReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::mostComplexTypeDef>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_list_mostComplexTypedefReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_list_mostComplexTypedefReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_list_mostComplexTypedefReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::mostComplexTypeDef>>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_list_mostComplexTypedefReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_mostComplexTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_mostComplexTypedefReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_mostComplexTypedefReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_mostComplexTypedefReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_mostComplexTypedefReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_list_mostComplexTypedefReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::some::valid::ns::mostComplexTypeDef> _return;
        sync_list_mostComplexTypedefReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_enumReturn(std::unique_ptr<apache::thrift::HandlerCallback<::some::valid::ns::MyEnumA>> callback) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("enumReturn"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_list_EnumReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::MyEnumA>>>> callback) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("list_EnumReturn"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::structReturn(::some::valid::ns::MyStruct& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("structReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_structReturn(::some::valid::ns::MyStruct& _return) {
  return structReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::some::valid::ns::MyStruct>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_structReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_structReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::some::valid::ns::MyStruct>();
  sync_structReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::some::valid::ns::MyStruct>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_structReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_structReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_structReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::some::valid::ns::MyStruct>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_structReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_structReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::some::valid::ns::MyStruct>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_structReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_structReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_structReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_structReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::MyStruct>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_structReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_structReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_structReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_structReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_structReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_structReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_structReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_structReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::some::valid::ns::MyStruct _return;
        sync_structReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::set_StructReturn(::std::set<::some::valid::ns::MyStruct>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("set_StructReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_set_StructReturn(::std::set<::some::valid::ns::MyStruct>& _return) {
  return set_StructReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_set_StructReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_set_StructReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::set<::some::valid::ns::MyStruct>>();
  sync_set_StructReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_set_StructReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_set_StructReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_set_StructReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_set_StructReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_set_StructReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_set_StructReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_set_StructReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_set_StructReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_set_StructReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::set<::some::valid::ns::MyStruct>>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_set_StructReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_set_StructReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_set_StructReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_set_StructReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_set_StructReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_set_StructReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_set_StructReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_set_StructReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::set<::some::valid::ns::MyStruct> _return;
        sync_set_StructReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_unionReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::ComplexUnion>>> callback) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("unionReturn"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::list_UnionReturn(::std::vector<::some::valid::ns::ComplexUnion>& /*_return*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("list_UnionReturn");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_list_UnionReturn(::std::vector<::some::valid::ns::ComplexUnion>& _return) {
  return list_UnionReturn(_return);
}

folly::SemiFuture<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_list_UnionReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::std::vector<::some::valid::ns::ComplexUnion>>();
  sync_list_UnionReturn(*ret);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_list_UnionReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_list_UnionReturn(), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_list_UnionReturn() {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<>());
}

folly::coro::Task<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_list_UnionReturn(apache::thrift::RequestParams /* params */) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_list_UnionReturn();
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_list_UnionReturn(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::std::vector<::some::valid::ns::ComplexUnion>>>> callback) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_list_UnionReturn.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_UnionReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_list_UnionReturn.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_list_UnionReturn();
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_list_UnionReturn();
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_list_UnionReturn(params);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_list_UnionReturn();
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::std::vector<::some::valid::ns::ComplexUnion> _return;
        sync_list_UnionReturn(_return);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie() = std::move(ex).restoreArgs<>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_eb_readDataEb(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::IOBuf>>> callback, ::std::int64_t /*size*/) {
  callback->exception(apache::thrift::detail::si::create_app_exn_unimplemented("readDataEb"));
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::readData(::some::valid::ns::IOBufPtr& /*_return*/, ::std::int64_t /*size*/) {
  apache::thrift::detail::si::throw_app_exn_unimplemented("readData");
}

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::sync_readData(::some::valid::ns::IOBufPtr& _return, ::std::int64_t p_size) {
  return readData(_return, p_size);
}

folly::SemiFuture<std::unique_ptr<::some::valid::ns::IOBufPtr>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::semifuture_readData(::std::int64_t p_size) {
  auto expected{apache::thrift::detail::si::InvocationType::SemiFuture};
  __fbthrift_invocation_readData.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Sync, std::memory_order_relaxed);
  auto ret = std::make_unique<::some::valid::ns::IOBufPtr>();
  sync_readData(*ret, p_size);
  return folly::makeSemiFuture(std::move(ret));
}

folly::Future<std::unique_ptr<::some::valid::ns::IOBufPtr>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::future_readData(::std::int64_t p_size) {
  auto expected{apache::thrift::detail::si::InvocationType::Future};
  __fbthrift_invocation_readData.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::SemiFuture, std::memory_order_relaxed);
  return apache::thrift::detail::si::future(semifuture_readData(p_size), getInternalKeepAlive());
}

#if FOLLY_HAS_COROUTINES
folly::coro::Task<std::unique_ptr<::some::valid::ns::IOBufPtr>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_readData(::std::int64_t p_size) {
  auto expected{apache::thrift::detail::si::InvocationType::Coro};
  __fbthrift_invocation_readData.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
  folly::throw_exception(apache::thrift::detail::si::UnimplementedCoroMethod::withCapturedArgs<::std::int64_t /*size*/>(p_size));
}

folly::coro::Task<std::unique_ptr<::some::valid::ns::IOBufPtr>> apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::co_readData(apache::thrift::RequestParams /* params */, ::std::int64_t p_size) {
  auto expected{apache::thrift::detail::si::InvocationType::CoroParam};
  __fbthrift_invocation_readData.compare_exchange_strong(expected, apache::thrift::detail::si::InvocationType::Coro, std::memory_order_relaxed);
  return co_readData(p_size);
}
#endif // FOLLY_HAS_COROUTINES

void apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>::async_tm_readData(std::unique_ptr<apache::thrift::HandlerCallback<std::unique_ptr<::some::valid::ns::IOBufPtr>>> callback, ::std::int64_t p_size) {
  // It's possible the coroutine versions will delegate to a future-based
  // version. If that happens, we need the RequestParams arguments to be
  // available to the future through the thread-local backchannel, so we create
  // a RAII object that sets up RequestParams and clears them on destruction.
  apache::thrift::detail::si::AsyncTmPrep asyncTmPrep(this, callback.get());
#if FOLLY_HAS_COROUTINES
determineInvocationType:
#endif // FOLLY_HAS_COROUTINES
  auto invocationType = __fbthrift_invocation_readData.load(std::memory_order_relaxed);
  try {
    switch (invocationType) {
      case apache::thrift::detail::si::InvocationType::AsyncTm:
      {
#if FOLLY_HAS_COROUTINES
        __fbthrift_invocation_readData.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::CoroParam, std::memory_order_relaxed);
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_readData(params, p_size);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
#else // FOLLY_HAS_COROUTINES
        __fbthrift_invocation_readData.compare_exchange_strong(invocationType, apache::thrift::detail::si::InvocationType::Future, std::memory_order_relaxed);
        FOLLY_FALLTHROUGH;
#endif // FOLLY_HAS_COROUTINES
      }
      case apache::thrift::detail::si::InvocationType::Future:
      {
        auto fut = future_readData(p_size);
        apache::thrift::detail::si::async_tm_future(std::move(callback), std::move(fut));
        return;
      }
      case apache::thrift::detail::si::InvocationType::SemiFuture:
      {
        auto fut = semifuture_readData(p_size);
        apache::thrift::detail::si::async_tm_semifuture(std::move(callback), std::move(fut));
        return;
      }
#if FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::CoroParam:
      {
        apache::thrift::RequestParams params{callback->getRequestContext(),
          callback->getThreadManager_deprecated(), callback->getEventBase(), callback->getHandlerExecutor()};
        auto task = co_readData(params, p_size);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
      case apache::thrift::detail::si::InvocationType::Coro:
      {
        auto task = co_readData(p_size);
        apache::thrift::detail::si::async_tm_coro(std::move(callback), std::move(task));
        return;
      }
#endif // FOLLY_HAS_COROUTINES
      case apache::thrift::detail::si::InvocationType::Sync:
      {
        ::some::valid::ns::IOBufPtr _return;
        sync_readData(_return, p_size);
        callback->result(_return);
        return;
      }
      default:
      {
        folly::assume_unreachable();
      }
    }
#if FOLLY_HAS_COROUTINES
  } catch (apache::thrift::detail::si::UnimplementedCoroMethod& ex) {
    std::tie(p_size) = std::move(ex).restoreArgs<::std::int64_t /*size*/>();
    goto determineInvocationType;
#endif // FOLLY_HAS_COROUTINES
  } catch (...) {
    callback->exception(std::current_exception());
  }
}


namespace some { namespace valid { namespace ns {

bool ReturnServiceSvNull::boolReturn() {
  return 0;
}

::std::int16_t ReturnServiceSvNull::i16Return() {
  return 0;
}

::std::int32_t ReturnServiceSvNull::i32Return() {
  return 0;
}

::std::int64_t ReturnServiceSvNull::i64Return() {
  return 0;
}

float ReturnServiceSvNull::floatReturn() {
  return 0;
}

double ReturnServiceSvNull::doubleReturn() {
  return 0;
}

void ReturnServiceSvNull::binaryReturn(::std::string& /*_return*/) {}

void ReturnServiceSvNull::mapReturn(::std::map<::std::string, ::std::int64_t>& /*_return*/) {}

::some::valid::ns::simpleTypeDef ReturnServiceSvNull::simpleTypedefReturn() {
  return 0;
}

void ReturnServiceSvNull::complexTypedefReturn(::some::valid::ns::complexStructTypeDef& /*_return*/) {}

void ReturnServiceSvNull::list_mostComplexTypedefReturn(::std::vector<::some::valid::ns::mostComplexTypeDef>& /*_return*/) {}

void ReturnServiceSvNull::structReturn(::some::valid::ns::MyStruct& /*_return*/) {}

void ReturnServiceSvNull::set_StructReturn(::std::set<::some::valid::ns::MyStruct>& /*_return*/) {}

void ReturnServiceSvNull::list_UnionReturn(::std::vector<::some::valid::ns::ComplexUnion>& /*_return*/) {}

void ReturnServiceSvNull::readData(::some::valid::ns::IOBufPtr& /*_return*/, ::std::int64_t /*size*/) {}


const char* ReturnServiceAsyncProcessor::getServiceName() {
  return "ReturnService";
}

void ReturnServiceAsyncProcessor::getServiceMetadata(apache::thrift::metadata::ThriftServiceMetadataResponse& response) {
  ::apache::thrift::detail::md::ServiceMetadata<::apache::thrift::ServiceHandler<::some::valid::ns::ReturnService>>::gen(response);
}

void ReturnServiceAsyncProcessor::processSerializedCompressedRequestWithMetadata(apache::thrift::ResponseChannelRequest::UniquePtr req, apache::thrift::SerializedCompressedRequest&& serializedRequest, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata, apache::thrift::protocol::PROTOCOL_TYPES protType, apache::thrift::Cpp2RequestContext* context, folly::EventBase* eb, apache::thrift::concurrency::ThreadManager* tm) {
  apache::thrift::detail::ap::process(this, iface_, std::move(req), std::move(serializedRequest), methodMetadata, protType, context, eb, tm);
}

void ReturnServiceAsyncProcessor::executeRequest(apache::thrift::ServerRequest&& request, const apache::thrift::AsyncProcessorFactory::MethodMetadata& methodMetadata) {
  apache::thrift::detail::ap::execute(this, std::move(request), apache::thrift::detail::ServerRequestHelper::protocol(request), methodMetadata);
}

const ReturnServiceAsyncProcessor::ProcessMap& ReturnServiceAsyncProcessor::getOwnProcessMap() {
  return kOwnProcessMap_;
}

const ReturnServiceAsyncProcessor::ProcessMap ReturnServiceAsyncProcessor::kOwnProcessMap_ {
  {"noReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_noReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_noReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_noReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_noReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"boolReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_boolReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_boolReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_boolReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_boolReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i16Return",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_i16Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_i16Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i16Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i16Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i32Return",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_i32Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_i32Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i32Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i32Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"i64Return",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_i64Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_i64Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i64Return<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_i64Return<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"floatReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_floatReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_floatReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_floatReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_floatReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"doubleReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_doubleReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_doubleReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_doubleReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_doubleReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"stringReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_stringReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_stringReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_stringReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_stringReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"binaryReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_binaryReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_binaryReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_binaryReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_binaryReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"mapReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_mapReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_mapReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_mapReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_mapReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"simpleTypedefReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_simpleTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_simpleTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_simpleTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_simpleTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"complexTypedefReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_complexTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_complexTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_complexTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_complexTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_mostComplexTypedefReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_list_mostComplexTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_list_mostComplexTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_mostComplexTypedefReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_mostComplexTypedefReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"enumReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_enumReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_enumReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_enumReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_enumReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_EnumReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_list_EnumReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_list_EnumReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_EnumReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_EnumReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"structReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_structReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_structReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_structReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_structReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"set_StructReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_set_StructReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_set_StructReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_set_StructReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_set_StructReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"unionReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_unionReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_unionReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_unionReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_unionReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"list_UnionReturn",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_list_UnionReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_list_UnionReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_UnionReturn<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_list_UnionReturn<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"readDataEb",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_readDataEb<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_readDataEb<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_readDataEb<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_readDataEb<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
  {"readData",
    {&ReturnServiceAsyncProcessor::setUpAndProcess_readData<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::setUpAndProcess_readData<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_readData<apache::thrift::CompactProtocolReader, apache::thrift::CompactProtocolWriter>,
     &ReturnServiceAsyncProcessor::executeRequest_readData<apache::thrift::BinaryProtocolReader, apache::thrift::BinaryProtocolWriter>}},
};

apache::thrift::ServiceRequestInfoMap const& ReturnServiceServiceInfoHolder::requestInfoMap() const {
  static folly::Indestructible<apache::thrift::ServiceRequestInfoMap> requestInfoMap{staticRequestInfoMap()};
  return *requestInfoMap;
}

apache::thrift::ServiceRequestInfoMap ReturnServiceServiceInfoHolder::staticRequestInfoMap() {
  apache::thrift::ServiceRequestInfoMap requestInfoMap = {
  {"noReturn",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.noReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"boolReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.boolReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"i16Return",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.i16Return",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"i32Return",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.i32Return",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"i64Return",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.i64Return",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"floatReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.floatReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"doubleReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.doubleReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"stringReturn",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.stringReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"binaryReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.binaryReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"mapReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.mapReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"simpleTypedefReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.simpleTypedefReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"complexTypedefReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.complexTypedefReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"list_mostComplexTypedefReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.list_mostComplexTypedefReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"enumReturn",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.enumReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"list_EnumReturn",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.list_EnumReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"structReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.structReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"set_StructReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.set_StructReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"unionReturn",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.unionReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"list_UnionReturn",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.list_UnionReturn",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"readDataEb",
    {true,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.readDataEb",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  {"readData",
    {false,
     apache::thrift::RpcKind::SINGLE_REQUEST_SINGLE_RESPONSE,
     "ReturnService.readData",
     std::nullopt,
     apache::thrift::concurrency::NORMAL}},
  };

  return requestInfoMap;
}
}}} // some::valid::ns
